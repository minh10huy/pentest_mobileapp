/*
 * Decompiled with CFR 0_132.
 */
package android.support.constraint.solver.widgets;

import android.support.constraint.solver.ArrayRow;
import android.support.constraint.solver.LinearSystem;
import android.support.constraint.solver.SolverVariable;
import android.support.constraint.solver.widgets.ConstraintAnchor;
import android.support.constraint.solver.widgets.ConstraintWidget;
import android.support.constraint.solver.widgets.ConstraintWidgetContainer;
import android.support.constraint.solver.widgets.Helper;
import android.support.constraint.solver.widgets.ResolutionAnchor;
import android.support.constraint.solver.widgets.ResolutionNode;
import java.util.ArrayList;

public class Barrier
extends Helper {
    public static final int BOTTOM = 3;
    public static final int LEFT = 0;
    public static final int RIGHT = 1;
    public static final int TOP = 2;
    private boolean mAllowsGoneWidget = true;
    private int mBarrierType = 0;
    private ArrayList<ResolutionAnchor> mNodes = new ArrayList(4);

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public void addToSolver(LinearSystem linearSystem) {
        boolean bl;
        ConstraintWidget constraintWidget;
        int n;
        block18 : {
            this.mListAnchors[0] = this.mLeft;
            this.mListAnchors[2] = this.mTop;
            this.mListAnchors[1] = this.mRight;
            this.mListAnchors[3] = this.mBottom;
            for (n = 0; n < this.mListAnchors.length; ++n) {
                this.mListAnchors[n].mSolverVariable = linearSystem.createObjectVariable(this.mListAnchors[n]);
            }
            if (this.mBarrierType < 0 || this.mBarrierType >= 4) return;
            {
                ConstraintAnchor constraintAnchor = this.mListAnchors[this.mBarrierType];
            }
            for (n = 0; n < this.mWidgetsCount; ++n) {
                constraintWidget = this.mWidgets[n];
                if (!this.mAllowsGoneWidget && !constraintWidget.allowedInBarrier() || (this.mBarrierType != 0 && this.mBarrierType != 1 || constraintWidget.getHorizontalDimensionBehaviour() != ConstraintWidget.DimensionBehaviour.MATCH_CONSTRAINT) && (this.mBarrierType != 2 && this.mBarrierType != 3 || constraintWidget.getVerticalDimensionBehaviour() != ConstraintWidget.DimensionBehaviour.MATCH_CONSTRAINT)) continue;
                bl = true;
                break block18;
            }
            bl = false;
        }
        if (this.mBarrierType != 0 && this.mBarrierType != 1 ? this.getParent().getVerticalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT : this.getParent().getHorizontalDimensionBehaviour() == ConstraintWidget.DimensionBehaviour.WRAP_CONTENT) {
            bl = false;
        }
        for (n = 0; n < this.mWidgetsCount; ++n) {
            SolverVariable solverVariable;
            constraintWidget = this.mWidgets[n];
            if (!this.mAllowsGoneWidget && !constraintWidget.allowedInBarrier()) continue;
            constraintWidget.mListAnchors[this.mBarrierType].mSolverVariable = solverVariable = linearSystem.createObjectVariable(constraintWidget.mListAnchors[this.mBarrierType]);
            if (this.mBarrierType != 0 && this.mBarrierType != 2) {
                linearSystem.addGreaterBarrier(constraintAnchor.mSolverVariable, solverVariable, bl);
                continue;
            }
            linearSystem.addLowerBarrier(constraintAnchor.mSolverVariable, solverVariable, bl);
        }
        if (this.mBarrierType == 0) {
            linearSystem.addEquality(this.mRight.mSolverVariable, this.mLeft.mSolverVariable, 0, 6);
            if (bl) return;
            {
                linearSystem.addEquality(this.mLeft.mSolverVariable, this.mParent.mRight.mSolverVariable, 0, 5);
                return;
            }
        } else if (this.mBarrierType == 1) {
            linearSystem.addEquality(this.mLeft.mSolverVariable, this.mRight.mSolverVariable, 0, 6);
            if (bl) return;
            {
                linearSystem.addEquality(this.mLeft.mSolverVariable, this.mParent.mLeft.mSolverVariable, 0, 5);
                return;
            }
        } else if (this.mBarrierType == 2) {
            linearSystem.addEquality(this.mBottom.mSolverVariable, this.mTop.mSolverVariable, 0, 6);
            if (bl) return;
            {
                linearSystem.addEquality(this.mTop.mSolverVariable, this.mParent.mBottom.mSolverVariable, 0, 5);
                return;
            }
        } else {
            if (this.mBarrierType != 3) return;
            {
                linearSystem.addEquality(this.mTop.mSolverVariable, this.mBottom.mSolverVariable, 0, 6);
                if (bl) return;
                {
                    linearSystem.addEquality(this.mTop.mSolverVariable, this.mParent.mTop.mSolverVariable, 0, 5);
                }
            }
        }
    }

    @Override
    public boolean allowedInBarrier() {
        return true;
    }

    @Override
    public void analyze(int n) {
        ResolutionAnchor resolutionAnchor;
        if (this.mParent == null) {
            return;
        }
        if (!((ConstraintWidgetContainer)this.mParent).optimizeFor(2)) {
            return;
        }
        switch (this.mBarrierType) {
            default: {
                return;
            }
            case 3: {
                resolutionAnchor = this.mBottom.getResolutionNode();
                break;
            }
            case 2: {
                resolutionAnchor = this.mTop.getResolutionNode();
                break;
            }
            case 1: {
                resolutionAnchor = this.mRight.getResolutionNode();
                break;
            }
            case 0: {
                resolutionAnchor = this.mLeft.getResolutionNode();
            }
        }
        resolutionAnchor.setType(5);
        if (this.mBarrierType != 0 && this.mBarrierType != 1) {
            this.mLeft.getResolutionNode().resolve(null, 0.0f);
            this.mRight.getResolutionNode().resolve(null, 0.0f);
        } else {
            this.mTop.getResolutionNode().resolve(null, 0.0f);
            this.mBottom.getResolutionNode().resolve(null, 0.0f);
        }
        this.mNodes.clear();
        for (n = 0; n < this.mWidgetsCount; ++n) {
            Object object = this.mWidgets[n];
            if (!this.mAllowsGoneWidget && !object.allowedInBarrier()) continue;
            switch (this.mBarrierType) {
                default: {
                    object = null;
                    break;
                }
                case 3: {
                    object = object.mBottom.getResolutionNode();
                    break;
                }
                case 2: {
                    object = object.mTop.getResolutionNode();
                    break;
                }
                case 1: {
                    object = object.mRight.getResolutionNode();
                    break;
                }
                case 0: {
                    object = object.mLeft.getResolutionNode();
                }
            }
            if (object == null) continue;
            this.mNodes.add((ResolutionAnchor)object);
            object.addDependent(resolutionAnchor);
        }
    }

    @Override
    public void resetResolutionNodes() {
        super.resetResolutionNodes();
        this.mNodes.clear();
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    @Override
    public void resolve() {
        block19 : {
            var3_1 = this.mBarrierType;
            var1_2 = Float.MAX_VALUE;
            switch (var3_1) {
                default: {
                    return;
                }
                case 3: {
                    var5_3 = this.mBottom.getResolutionNode();
                    ** GOTO lbl14
                }
                case 2: {
                    var5_3 = this.mTop.getResolutionNode();
                    break block19;
                }
                case 1: {
                    var5_3 = this.mRight.getResolutionNode();
lbl14: // 2 sources:
                    var1_2 = 0.0f;
                    break block19;
                }
                case 0: 
            }
            var5_3 = this.mLeft.getResolutionNode();
        }
        var4_4 = this.mNodes.size();
        var6_5 = null;
        var2_6 = var1_2;
        for (var3_1 = 0; var3_1 < var4_4; ++var3_1) {
            var7_7 = this.mNodes.get(var3_1);
            if (var7_7.state != 1) {
                return;
            }
            if (this.mBarrierType != 0 && this.mBarrierType != 2) {
                var1_2 = var2_6;
                if (var7_7.resolvedOffset > var2_6) {
                    var1_2 = var7_7.resolvedOffset;
                    var6_5 = var7_7.resolvedTarget;
                }
            } else {
                var1_2 = var2_6;
                if (var7_7.resolvedOffset < var2_6) {
                    var1_2 = var7_7.resolvedOffset;
                    var6_5 = var7_7.resolvedTarget;
                }
            }
            var2_6 = var1_2;
        }
        if (LinearSystem.getMetrics() != null) {
            var7_7 = LinearSystem.getMetrics();
            ++var7_7.barrierConnectionResolved;
        }
        var5_3.resolvedTarget = var6_5;
        var5_3.resolvedOffset = var2_6;
        var5_3.didResolve();
        switch (this.mBarrierType) {
            default: {
                return;
            }
            case 3: {
                this.mTop.getResolutionNode().resolve(var6_5, var2_6);
                return;
            }
            case 2: {
                this.mBottom.getResolutionNode().resolve(var6_5, var2_6);
                return;
            }
            case 1: {
                this.mLeft.getResolutionNode().resolve(var6_5, var2_6);
                return;
            }
            case 0: 
        }
        this.mRight.getResolutionNode().resolve(var6_5, var2_6);
    }

    public void setAllowsGoneWidget(boolean bl) {
        this.mAllowsGoneWidget = bl;
    }

    public void setBarrierType(int n) {
        this.mBarrierType = n;
    }
}

