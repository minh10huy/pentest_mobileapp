/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.content.Context
 *  android.content.SharedPreferences
 *  android.content.SharedPreferences$Editor
 *  android.os.Build
 *  android.os.Build$VERSION
 *  android.util.Log
 */
package android.support.multidex;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.support.multidex.ZipUtil;
import android.util.Log;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileFilter;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

final class MultiDexExtractor
implements Closeable {
    private static final int BUFFER_SIZE = 16384;
    private static final String DEX_PREFIX = "classes";
    static final String DEX_SUFFIX = ".dex";
    private static final String EXTRACTED_NAME_EXT = ".classes";
    static final String EXTRACTED_SUFFIX = ".zip";
    private static final String KEY_CRC = "crc";
    private static final String KEY_DEX_CRC = "dex.crc.";
    private static final String KEY_DEX_NUMBER = "dex.number";
    private static final String KEY_DEX_TIME = "dex.time.";
    private static final String KEY_TIME_STAMP = "timestamp";
    private static final String LOCK_FILENAME = "MultiDex.lock";
    private static final int MAX_EXTRACT_ATTEMPTS = 3;
    private static final long NO_VALUE = -1L;
    private static final String PREFS_FILE = "multidex.version";
    private static final String TAG = "MultiDex";
    private final FileLock cacheLock;
    private final File dexDir;
    private final FileChannel lockChannel;
    private final RandomAccessFile lockRaf;
    private final File sourceApk;
    private final long sourceCrc;

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    MultiDexExtractor(File file, File serializable) throws IOException {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("MultiDexExtractor(");
        stringBuilder.append(file.getPath());
        stringBuilder.append(", ");
        stringBuilder.append(serializable.getPath());
        stringBuilder.append(")");
        Log.i((String)TAG, (String)stringBuilder.toString());
        this.sourceApk = file;
        this.dexDir = serializable;
        this.sourceCrc = MultiDexExtractor.getZipCrc(file);
        file = new File((File)serializable, LOCK_FILENAME);
        this.lockRaf = new RandomAccessFile(file, "rw");
        this.lockChannel = this.lockRaf.getChannel();
        serializable = new StringBuilder();
        serializable.append("Blocking on lock ");
        serializable.append(file.getPath());
        Log.i((String)TAG, (String)serializable.toString());
        this.cacheLock = this.lockChannel.lock();
        try {
            serializable = new StringBuilder();
            serializable.append(file.getPath());
            serializable.append(" locked");
            Log.i((String)TAG, (String)serializable.toString());
            return;
            catch (IOException | Error | RuntimeException throwable) {
                MultiDexExtractor.closeQuietly(this.lockChannel);
                throw throwable;
            }
        }
        catch (IOException | Error | RuntimeException throwable2) {
            MultiDexExtractor.closeQuietly(this.lockRaf);
            throw throwable2;
        }
    }

    private void clearDexDir() {
        Object object = this.dexDir.listFiles(new FileFilter(){

            @Override
            public boolean accept(File file) {
                return file.getName().equals(MultiDexExtractor.LOCK_FILENAME) ^ true;
            }
        });
        if (object == null) {
            object = new StringBuilder();
            object.append("Failed to list secondary dex dir content (");
            object.append(this.dexDir.getPath());
            object.append(").");
            Log.w((String)TAG, (String)object.toString());
            return;
        }
        for (Object object2 : object) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Trying to delete old file ");
            stringBuilder.append(object2.getPath());
            stringBuilder.append(" of size ");
            stringBuilder.append(object2.length());
            Log.i((String)TAG, (String)stringBuilder.toString());
            if (!object2.delete()) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Failed to delete old file ");
                stringBuilder.append(object2.getPath());
                Log.w((String)TAG, (String)stringBuilder.toString());
                continue;
            }
            stringBuilder = new StringBuilder();
            stringBuilder.append("Deleted old file ");
            stringBuilder.append(object2.getPath());
            Log.i((String)TAG, (String)stringBuilder.toString());
        }
    }

    private static void closeQuietly(Closeable closeable) {
        try {
            closeable.close();
            return;
        }
        catch (IOException iOException) {
            Log.w((String)TAG, (String)"Failed to close resource", (Throwable)iOException);
            return;
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private static void extract(ZipFile closeable, ZipEntry object, File file, String object2) throws IOException, FileNotFoundException {
        closeable = closeable.getInputStream((ZipEntry)object);
        Object object3 = new StringBuilder();
        object3.append("tmp-");
        object3.append((String)object2);
        object2 = File.createTempFile(object3.toString(), EXTRACTED_SUFFIX, file.getParentFile());
        object3 = new StringBuilder();
        object3.append("Extracting ");
        object3.append(object2.getPath());
        Log.i((String)TAG, (String)object3.toString());
        object3 = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream((File)object2)));
        try {
            ZipEntry zipEntry = new ZipEntry("classes.dex");
            zipEntry.setTime(object.getTime());
            object3.putNextEntry(zipEntry);
            object = new byte[16384];
            int n = closeable.read((byte[])object);
            while (n != -1) {
                object3.write((byte[])object, 0, n);
                n = closeable.read((byte[])object);
            }
            object3.closeEntry();
        }
        catch (Throwable throwable) {
            try {
                object3.close();
                throw throwable;
            }
            catch (Throwable throwable2) {}
            throw throwable2;
        }
        try {
            object3.close();
            if (!object2.setReadOnly()) {
                object = new StringBuilder();
                object.append("Failed to mark readonly \"");
                object.append(object2.getAbsolutePath());
                object.append("\" (tmp of \"");
                object.append(file.getAbsolutePath());
                object.append("\")");
                throw new IOException(object.toString());
            }
            object = new StringBuilder();
            object.append("Renaming to ");
            object.append(file.getPath());
            Log.i((String)TAG, (String)object.toString());
            if (object2.renameTo(file)) return;
            object = new StringBuilder();
            object.append("Failed to rename \"");
            object.append(object2.getAbsolutePath());
            object.append("\" to \"");
            object.append(file.getAbsolutePath());
            object.append("\"");
            throw new IOException(object.toString());
        }
        finally {
            MultiDexExtractor.closeQuietly(closeable);
            object2.delete();
        }
    }

    private static SharedPreferences getMultiDexPreferences(Context context) {
        int n = Build.VERSION.SDK_INT < 11 ? 0 : 4;
        return context.getSharedPreferences(PREFS_FILE, n);
    }

    private static long getTimeStamp(File file) {
        long l;
        long l2 = l = file.lastModified();
        if (l == -1L) {
            l2 = l - 1L;
        }
        return l2;
    }

    private static long getZipCrc(File file) throws IOException {
        long l;
        long l2 = l = ZipUtil.getZipCrc(file);
        if (l == -1L) {
            l2 = l - 1L;
        }
        return l2;
    }

    private static boolean isModified(Context context, File serializable, long l, String string2) {
        context = MultiDexExtractor.getMultiDexPreferences(context);
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(string2);
        stringBuilder.append(KEY_TIME_STAMP);
        if (context.getLong(stringBuilder.toString(), -1L) == MultiDexExtractor.getTimeStamp((File)serializable)) {
            serializable = new StringBuilder();
            serializable.append(string2);
            serializable.append(KEY_CRC);
            if (context.getLong(serializable.toString(), -1L) == l) {
                return false;
            }
        }
        return true;
    }

    private List<ExtractedDex> loadExistingExtractions(Context object, String string2) throws IOException {
        Log.i((String)TAG, (String)"loading existing secondary dex files");
        CharSequence charSequence = new StringBuilder();
        charSequence.append(this.sourceApk.getName());
        charSequence.append(EXTRACTED_NAME_EXT);
        charSequence = charSequence.toString();
        object = MultiDexExtractor.getMultiDexPreferences((Context)object);
        Serializable serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append(KEY_DEX_NUMBER);
        int n = object.getInt(serializable.toString(), 1);
        serializable = new ArrayList(n - 1);
        for (int i = 2; i <= n; ++i) {
            Object object2 = new StringBuilder();
            object2.append((String)charSequence);
            object2.append(i);
            object2.append(EXTRACTED_SUFFIX);
            object2 = object2.toString();
            object2 = new ExtractedDex(this.dexDir, (String)object2);
            if (object2.isFile()) {
                object2.crc = MultiDexExtractor.getZipCrc((File)object2);
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append(KEY_DEX_CRC);
                stringBuilder.append(i);
                long l = object.getLong(stringBuilder.toString(), -1L);
                stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append(KEY_DEX_TIME);
                stringBuilder.append(i);
                long l2 = object.getLong(stringBuilder.toString(), -1L);
                long l3 = object2.lastModified();
                if (l2 == l3 && l == object2.crc) {
                    serializable.add(object2);
                    continue;
                }
                object = new StringBuilder();
                object.append("Invalid extracted dex: ");
                object.append(object2);
                object.append(" (key \"");
                object.append(string2);
                object.append("\"), expected modification time: ");
                object.append(l2);
                object.append(", modification time: ");
                object.append(l3);
                object.append(", expected crc: ");
                object.append(l);
                object.append(", file crc: ");
                object.append(object2.crc);
                throw new IOException(object.toString());
            }
            object = new StringBuilder();
            object.append("Missing extracted secondary dex file '");
            object.append(object2.getPath());
            object.append("'");
            throw new IOException(object.toString());
        }
        return serializable;
    }

    /*
     * Exception decompiling
     */
    private List<ExtractedDex> performExtractions() throws IOException {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [0[TRYBLOCK]], but top level block is 10[UNCONDITIONALDOLOOP]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    private static void putStoredApkInfo(Context context, String string2, long l, long l2, List<ExtractedDex> object) {
        context = MultiDexExtractor.getMultiDexPreferences(context).edit();
        Serializable serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append(KEY_TIME_STAMP);
        context.putLong(serializable.toString(), l);
        serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append(KEY_CRC);
        context.putLong(serializable.toString(), l2);
        serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append(KEY_DEX_NUMBER);
        context.putInt(serializable.toString(), object.size() + 1);
        object = object.iterator();
        int n = 2;
        while (object.hasNext()) {
            serializable = (ExtractedDex)object.next();
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(string2);
            stringBuilder.append(KEY_DEX_CRC);
            stringBuilder.append(n);
            context.putLong(stringBuilder.toString(), serializable.crc);
            stringBuilder = new StringBuilder();
            stringBuilder.append(string2);
            stringBuilder.append(KEY_DEX_TIME);
            stringBuilder.append(n);
            context.putLong(stringBuilder.toString(), serializable.lastModified());
            ++n;
        }
        context.commit();
    }

    @Override
    public void close() throws IOException {
        this.cacheLock.release();
        this.lockChannel.close();
        this.lockRaf.close();
    }

    List<? extends File> load(Context object, String charSequence, boolean bl) throws IOException {
        List<ExtractedDex> list = new StringBuilder();
        list.append("MultiDexExtractor.load(");
        list.append(this.sourceApk.getPath());
        list.append(", ");
        list.append(bl);
        list.append(", ");
        list.append((String)charSequence);
        list.append(")");
        Log.i((String)TAG, (String)list.toString());
        if (!this.cacheLock.isValid()) {
            throw new IllegalStateException("MultiDexExtractor was closed");
        }
        if (!bl && !MultiDexExtractor.isModified((Context)object, this.sourceApk, this.sourceCrc, (String)charSequence)) {
            try {
                list = this.loadExistingExtractions((Context)object, (String)charSequence);
                object = list;
            }
            catch (IOException iOException) {
                Log.w((String)TAG, (String)"Failed to reload existing extracted secondary dex files, falling back to fresh extraction", (Throwable)iOException);
                List<ExtractedDex> list2 = this.performExtractions();
                MultiDexExtractor.putStoredApkInfo((Context)object, (String)charSequence, MultiDexExtractor.getTimeStamp(this.sourceApk), this.sourceCrc, list2);
                object = list2;
            }
        } else {
            if (bl) {
                Log.i((String)TAG, (String)"Forced extraction must be performed.");
            } else {
                Log.i((String)TAG, (String)"Detected that extraction must be performed.");
            }
            list = this.performExtractions();
            MultiDexExtractor.putStoredApkInfo((Context)object, (String)charSequence, MultiDexExtractor.getTimeStamp(this.sourceApk), this.sourceCrc, list);
            object = list;
        }
        charSequence = new StringBuilder();
        charSequence.append("load found ");
        charSequence.append(object.size());
        charSequence.append(" secondary dex files");
        Log.i((String)TAG, (String)charSequence.toString());
        return object;
    }

    private static class ExtractedDex
    extends File {
        public long crc = -1L;

        public ExtractedDex(File file, String string2) {
            super(file, string2);
        }
    }

}

