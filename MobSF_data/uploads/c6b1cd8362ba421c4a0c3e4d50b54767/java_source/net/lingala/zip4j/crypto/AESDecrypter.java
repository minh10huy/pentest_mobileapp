/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.crypto;

import java.util.Arrays;
import net.lingala.zip4j.crypto.IDecrypter;
import net.lingala.zip4j.crypto.PBKDF2.MacBasedPRF;
import net.lingala.zip4j.crypto.PBKDF2.PBKDF2Engine;
import net.lingala.zip4j.crypto.PBKDF2.PBKDF2Parameters;
import net.lingala.zip4j.crypto.engine.AESEngine;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.model.AESExtraDataRecord;
import net.lingala.zip4j.model.LocalFileHeader;
import net.lingala.zip4j.util.Raw;

public class AESDecrypter
implements IDecrypter {
    private int KEY_LENGTH;
    private int MAC_LENGTH;
    private final int PASSWORD_VERIFIER_LENGTH = 2;
    private int SALT_LENGTH;
    private AESEngine aesEngine;
    private byte[] aesKey;
    private byte[] counterBlock;
    private byte[] derivedPasswordVerifier;
    private byte[] iv;
    private LocalFileHeader localFileHeader;
    private int loopCount = 0;
    private MacBasedPRF mac;
    private byte[] macKey;
    private int nonce = 1;
    private byte[] storedMac;

    public AESDecrypter(LocalFileHeader localFileHeader, byte[] arrby, byte[] arrby2) throws ZipException {
        if (localFileHeader == null) {
            throw new ZipException("one of the input parameters is null in AESDecryptor Constructor");
        }
        this.localFileHeader = localFileHeader;
        this.storedMac = null;
        this.iv = new byte[16];
        this.counterBlock = new byte[16];
        this.init(arrby, arrby2);
    }

    private byte[] deriveKey(byte[] arrby, char[] arrc) throws ZipException {
        try {
            arrby = new PBKDF2Engine(new PBKDF2Parameters("HmacSHA1", "ISO-8859-1", arrby, 1000)).deriveKey(arrc, this.KEY_LENGTH + this.MAC_LENGTH + 2);
            return arrby;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
    }

    private void init(byte[] object, byte[] arrby) throws ZipException {
        if (this.localFileHeader == null) {
            throw new ZipException("invalid file header in init method of AESDecryptor");
        }
        AESExtraDataRecord aESExtraDataRecord = this.localFileHeader.getAesExtraDataRecord();
        if (aESExtraDataRecord == null) {
            throw new ZipException("invalid aes extra data record - in init method of AESDecryptor");
        }
        switch (aESExtraDataRecord.getAesStrength()) {
            default: {
                object = new StringBuffer("invalid aes key strength for file: ");
                object.append(this.localFileHeader.getFileName());
                throw new ZipException(object.toString());
            }
            case 3: {
                this.KEY_LENGTH = 32;
                this.MAC_LENGTH = 32;
                this.SALT_LENGTH = 16;
                break;
            }
            case 2: {
                this.KEY_LENGTH = 24;
                this.MAC_LENGTH = 24;
                this.SALT_LENGTH = 12;
                break;
            }
            case 1: {
                this.KEY_LENGTH = 16;
                this.MAC_LENGTH = 16;
                this.SALT_LENGTH = 8;
            }
        }
        if (this.localFileHeader.getPassword() != null && this.localFileHeader.getPassword().length > 0) {
            if ((object = this.deriveKey((byte[])object, this.localFileHeader.getPassword())) != null && ((Object)object).length == this.KEY_LENGTH + this.MAC_LENGTH + 2) {
                this.aesKey = new byte[this.KEY_LENGTH];
                this.macKey = new byte[this.MAC_LENGTH];
                this.derivedPasswordVerifier = new byte[2];
                System.arraycopy(object, 0, this.aesKey, 0, this.KEY_LENGTH);
                System.arraycopy(object, this.KEY_LENGTH, this.macKey, 0, this.MAC_LENGTH);
                System.arraycopy(object, this.KEY_LENGTH + this.MAC_LENGTH, this.derivedPasswordVerifier, 0, 2);
                if (this.derivedPasswordVerifier == null) {
                    throw new ZipException("invalid derived password verifier for AES");
                }
                if (!Arrays.equals(arrby, this.derivedPasswordVerifier)) {
                    object = new StringBuffer("Wrong Password for file: ");
                    object.append(this.localFileHeader.getFileName());
                    throw new ZipException(object.toString(), 5);
                }
                this.aesEngine = new AESEngine(this.aesKey);
                this.mac = new MacBasedPRF("HmacSHA1");
                this.mac.init(this.macKey);
                return;
            }
            throw new ZipException("invalid derived key");
        }
        throw new ZipException("empty or null password provided for AES Decryptor");
    }

    @Override
    public int decryptData(byte[] arrby) throws ZipException {
        return this.decryptData(arrby, 0, arrby.length);
    }

    /*
     * Loose catch block
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public int decryptData(byte[] arrby, int n, int n2) throws ZipException {
        if (this.aesEngine == null) {
            throw new ZipException("AES not initialized properly");
        }
        int n3 = n;
        block5 : do {
            int n4;
            if (n3 >= (n4 = n + n2)) {
                return n2;
            }
            int n5 = n3 + 16;
            n4 = n5 <= n4 ? 16 : (n4 -= n3);
            this.loopCount = n4;
            this.mac.update(arrby, n3, this.loopCount);
            Raw.prepareBuffAESIVBytes(this.iv, this.nonce, 16);
            this.aesEngine.processBlock(this.iv, this.counterBlock);
            n4 = 0;
            do {
                block9 : {
                    if (n4 < this.loopCount) break block9;
                    ++this.nonce;
                    n3 = n5;
                    continue block5;
                }
                int n6 = n3 + n4;
                arrby[n6] = (byte)(arrby[n6] ^ this.counterBlock[n4]);
                ++n4;
            } while (true);
            break;
        } while (true);
        catch (Exception exception) {
            throw new ZipException(exception);
        }
        catch (ZipException zipException) {
            throw zipException;
        }
    }

    public byte[] getCalculatedAuthenticationBytes() {
        return this.mac.doFinal();
    }

    public int getPasswordVerifierLength() {
        return 2;
    }

    public int getSaltLength() {
        return this.SALT_LENGTH;
    }

    public byte[] getStoredMac() {
        return this.storedMac;
    }

    public void setStoredMac(byte[] arrby) {
        this.storedMac = arrby;
    }
}

