/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.crypto;

import net.lingala.zip4j.crypto.IDecrypter;
import net.lingala.zip4j.crypto.engine.ZipCryptoEngine;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.model.FileHeader;

public class StandardDecrypter
implements IDecrypter {
    private byte[] crc = new byte[4];
    private FileHeader fileHeader;
    private ZipCryptoEngine zipCryptoEngine;

    public StandardDecrypter(FileHeader fileHeader, byte[] arrby) throws ZipException {
        if (fileHeader == null) {
            throw new ZipException("one of more of the input parameters were null in StandardDecryptor");
        }
        this.fileHeader = fileHeader;
        this.zipCryptoEngine = new ZipCryptoEngine();
        this.init(arrby);
    }

    @Override
    public int decryptData(byte[] arrby) throws ZipException {
        return this.decryptData(arrby, 0, arrby.length);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    @Override
    public int decryptData(byte[] arrby, int n, int n2) throws ZipException {
        byte by2;
        byte by;
        ZipCryptoEngine zipCryptoEngine;
        if (n < 0) throw new ZipException("one of the input parameters were null in standard decrpyt data");
        if (n2 < 0) {
            throw new ZipException("one of the input parameters were null in standard decrpyt data");
        }
        int n3 = n;
        do {
            if (n3 >= n + n2) {
                return n2;
            }
            by2 = arrby[n3];
            by = this.zipCryptoEngine.decryptByte();
            zipCryptoEngine = this.zipCryptoEngine;
            break;
        } while (true);
        catch (Exception exception) {
            throw new ZipException(exception);
        }
        {
            byte by3 = (byte)((by2 & 255 ^ by) & 255);
            zipCryptoEngine.updateKeys(by3);
            arrby[n3] = by3;
            ++n3;
            continue;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public void init(byte[] arrby) throws ZipException {
        byte[] arrby2 = this.fileHeader.getCrcBuff();
        this.crc[3] = (byte)(arrby2[3] & 255);
        this.crc[2] = (byte)(arrby2[3] >> 8 & 255);
        this.crc[1] = (byte)(arrby2[3] >> 16 & 255);
        byte[] arrby3 = this.crc;
        byte by = (byte)(arrby2[3] >> 24 & 255);
        int n = 0;
        arrby3[0] = by;
        if (this.crc[2] > 0 || this.crc[1] > 0 || this.crc[0] > 0) throw new IllegalStateException("Invalid CRC in File Header");
        if (this.fileHeader.getPassword() == null || this.fileHeader.getPassword().length <= 0) throw new ZipException("Wrong password!", 5);
        this.zipCryptoEngine.initKeys(this.fileHeader.getPassword());
        byte by2 = arrby[0];
        while (n < 12) {
            int n2;
            try {
                this.zipCryptoEngine.updateKeys((byte)(this.zipCryptoEngine.decryptByte() ^ by2));
            }
            catch (Exception exception) {
                throw new ZipException(exception);
            }
            n = n2 = n + 1;
            if (n2 == 12) continue;
            by2 = arrby[n2];
            n = n2;
        }
    }
}

