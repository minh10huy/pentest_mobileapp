/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.crypto;

import java.util.Random;
import net.lingala.zip4j.crypto.IEncrypter;
import net.lingala.zip4j.crypto.engine.ZipCryptoEngine;
import net.lingala.zip4j.exception.ZipException;

public class StandardEncrypter
implements IEncrypter {
    private byte[] headerBytes;
    private ZipCryptoEngine zipCryptoEngine;

    public StandardEncrypter(char[] arrc, int n) throws ZipException {
        if (arrc != null && arrc.length > 0) {
            this.zipCryptoEngine = new ZipCryptoEngine();
            this.headerBytes = new byte[12];
            this.init(arrc, n);
            return;
        }
        throw new ZipException("input password is null or empty in standard encrpyter constructor");
    }

    private void init(char[] arrc, int n) throws ZipException {
        if (arrc != null && arrc.length > 0) {
            this.zipCryptoEngine.initKeys(arrc);
            this.headerBytes = this.generateRandomBytes(12);
            this.zipCryptoEngine.initKeys(arrc);
            this.headerBytes[11] = (byte)(n >>> 24);
            this.headerBytes[10] = (byte)(n >>> 16);
            if (this.headerBytes.length < 12) {
                throw new ZipException("invalid header bytes generated, cannot perform standard encryption");
            }
            this.encryptData(this.headerBytes);
            return;
        }
        throw new ZipException("input password is null or empty, cannot initialize standard encrypter");
    }

    protected byte encryptByte(byte by) {
        byte by2 = (byte)(this.zipCryptoEngine.decryptByte() & 255 ^ by);
        this.zipCryptoEngine.updateKeys(by);
        return by2;
    }

    @Override
    public int encryptData(byte[] arrby) throws ZipException {
        if (arrby == null) {
            throw new NullPointerException();
        }
        return this.encryptData(arrby, 0, arrby.length);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public int encryptData(byte[] arrby, int n, int n2) throws ZipException {
        if (n2 < 0) {
            throw new ZipException("invalid length specified to decrpyt data");
        }
        int n3 = n;
        while (n3 < n + n2) {
            try {
                arrby[n3] = this.encryptByte(arrby[n3]);
                ++n3;
                continue;
            }
            catch (Exception exception) {}
            throw new ZipException(exception);
        }
        return n2;
    }

    protected byte[] generateRandomBytes(int n) throws ZipException {
        if (n <= 0) {
            throw new ZipException("size is either 0 or less than 0, cannot generate header for standard encryptor");
        }
        byte[] arrby = new byte[n];
        Random random = new Random();
        n = 0;
        while (n < arrby.length) {
            arrby[n] = this.encryptByte((byte)random.nextInt(256));
            ++n;
        }
        return arrby;
    }

    public byte[] getHeaderBytes() {
        return this.headerBytes;
    }
}

