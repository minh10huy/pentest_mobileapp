/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.crypto;

import java.util.Random;
import net.lingala.zip4j.crypto.IEncrypter;
import net.lingala.zip4j.crypto.PBKDF2.MacBasedPRF;
import net.lingala.zip4j.crypto.PBKDF2.PBKDF2Engine;
import net.lingala.zip4j.crypto.PBKDF2.PBKDF2Parameters;
import net.lingala.zip4j.crypto.engine.AESEngine;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.util.Raw;

public class AESEncrpyter
implements IEncrypter {
    private int KEY_LENGTH;
    private int MAC_LENGTH;
    private final int PASSWORD_VERIFIER_LENGTH = 2;
    private int SALT_LENGTH;
    private AESEngine aesEngine;
    private byte[] aesKey;
    private byte[] counterBlock;
    private byte[] derivedPasswordVerifier;
    private boolean finished;
    private byte[] iv;
    private int keyStrength;
    private int loopCount = 0;
    private MacBasedPRF mac;
    private byte[] macKey;
    private int nonce = 1;
    private char[] password;
    private byte[] saltBytes;

    public AESEncrpyter(char[] arrc, int n) throws ZipException {
        if (arrc != null && arrc.length != 0) {
            if (n != 1 && n != 3) {
                throw new ZipException("Invalid key strength in AES encrypter constructor");
            }
            this.password = arrc;
            this.keyStrength = n;
            this.finished = false;
            this.counterBlock = new byte[16];
            this.iv = new byte[16];
            this.init();
            return;
        }
        throw new ZipException("input password is empty or null in AES encrypter constructor");
    }

    private byte[] deriveKey(byte[] arrby, char[] arrc) throws ZipException {
        try {
            arrby = new PBKDF2Engine(new PBKDF2Parameters("HmacSHA1", "ISO-8859-1", arrby, 1000)).deriveKey(arrc, this.KEY_LENGTH + this.MAC_LENGTH + 2);
            return arrby;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
    }

    private static byte[] generateSalt(int n) throws ZipException {
        if (n != 8 && n != 16) {
            throw new ZipException("invalid salt size, cannot generate salt");
        }
        int n2 = 0;
        int n3 = n == 8 ? 2 : 0;
        if (n == 16) {
            n3 = 4;
        }
        byte[] arrby = new byte[n];
        n = n2;
        while (n < n3) {
            n2 = new Random().nextInt();
            int n4 = n * 4;
            arrby[n4 + 0] = (byte)(n2 >> 24);
            arrby[n4 + 1] = (byte)(n2 >> 16);
            arrby[n4 + 2] = (byte)(n2 >> 8);
            arrby[n4 + 3] = (byte)n2;
            ++n;
        }
        return arrby;
    }

    private void init() throws ZipException {
        int n = this.keyStrength;
        if (n != 1) {
            if (n != 3) {
                throw new ZipException("invalid aes key strength, cannot determine key sizes");
            }
            this.KEY_LENGTH = 32;
            this.MAC_LENGTH = 32;
            this.SALT_LENGTH = 16;
        } else {
            this.KEY_LENGTH = 16;
            this.MAC_LENGTH = 16;
            this.SALT_LENGTH = 8;
        }
        this.saltBytes = AESEncrpyter.generateSalt(this.SALT_LENGTH);
        byte[] arrby = this.deriveKey(this.saltBytes, this.password);
        if (arrby != null && arrby.length == this.KEY_LENGTH + this.MAC_LENGTH + 2) {
            this.aesKey = new byte[this.KEY_LENGTH];
            this.macKey = new byte[this.MAC_LENGTH];
            this.derivedPasswordVerifier = new byte[2];
            System.arraycopy(arrby, 0, this.aesKey, 0, this.KEY_LENGTH);
            System.arraycopy(arrby, this.KEY_LENGTH, this.macKey, 0, this.MAC_LENGTH);
            System.arraycopy(arrby, this.KEY_LENGTH + this.MAC_LENGTH, this.derivedPasswordVerifier, 0, 2);
            this.aesEngine = new AESEngine(this.aesKey);
            this.mac = new MacBasedPRF("HmacSHA1");
            this.mac.init(this.macKey);
            return;
        }
        throw new ZipException("invalid key generated, cannot decrypt file");
    }

    @Override
    public int encryptData(byte[] arrby) throws ZipException {
        if (arrby == null) {
            throw new ZipException("input bytes are null, cannot perform AES encrpytion");
        }
        return this.encryptData(arrby, 0, arrby.length);
    }

    @Override
    public int encryptData(byte[] arrby, int n, int n2) throws ZipException {
        if (this.finished) {
            throw new ZipException("AES Encrypter is in finished state (A non 16 byte block has already been passed to encrypter)");
        }
        if (n2 % 16 != 0) {
            this.finished = true;
        }
        int n3 = n;
        int n4;
        block0 : while (n3 < (n4 = n + n2)) {
            int n5 = n3 + 16;
            n4 = n5 <= n4 ? 16 : (n4 -= n3);
            this.loopCount = n4;
            Raw.prepareBuffAESIVBytes(this.iv, this.nonce, 16);
            this.aesEngine.processBlock(this.iv, this.counterBlock);
            n4 = 0;
            do {
                if (n4 >= this.loopCount) {
                    this.mac.update(arrby, n3, this.loopCount);
                    ++this.nonce;
                    n3 = n5;
                    continue block0;
                }
                int n6 = n3 + n4;
                arrby[n6] = (byte)(arrby[n6] ^ this.counterBlock[n4]);
                ++n4;
            } while (true);
            break;
        }
        return n2;
    }

    public byte[] getDerivedPasswordVerifier() {
        return this.derivedPasswordVerifier;
    }

    public byte[] getFinalMac() {
        byte[] arrby = this.mac.doFinal();
        byte[] arrby2 = new byte[10];
        System.arraycopy(arrby, 0, arrby2, 0, 10);
        return arrby2;
    }

    public int getPasswordVeriifierLength() {
        return 2;
    }

    public byte[] getSaltBytes() {
        return this.saltBytes;
    }

    public int getSaltLength() {
        return this.SALT_LENGTH;
    }

    public void setDerivedPasswordVerifier(byte[] arrby) {
        this.derivedPasswordVerifier = arrby;
    }

    public void setSaltBytes(byte[] arrby) {
        this.saltBytes = arrby;
    }
}

