/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.util;

import java.io.DataInput;
import java.io.IOException;
import net.lingala.zip4j.exception.ZipException;

public class Raw {
    public static byte bitArrayToByte(int[] arrn) throws ZipException {
        if (arrn == null) {
            throw new ZipException("bit array is null, cannot calculate byte from bits");
        }
        if (arrn.length != 8) {
            throw new ZipException("invalid bit array length, cannot calculate byte");
        }
        if (!Raw.checkBits(arrn)) {
            throw new ZipException("invalid bits provided, bits contain other values than 0 or 1");
        }
        int n = 0;
        int n2 = 0;
        while (n < arrn.length) {
            n2 = (int)((double)n2 + Math.pow(2.0, n) * (double)arrn[n]);
            ++n;
        }
        return (byte)n2;
    }

    private static boolean checkBits(int[] arrn) {
        int n = 0;
        while (n < arrn.length) {
            if (arrn[n] != 0 && arrn[n] != 1) {
                return false;
            }
            ++n;
        }
        return true;
    }

    public static byte[] convertCharArrayToByteArray(char[] arrc) {
        if (arrc == null) {
            throw new NullPointerException();
        }
        byte[] arrby = new byte[arrc.length];
        int n = 0;
        while (n < arrc.length) {
            arrby[n] = (byte)arrc[n];
            ++n;
        }
        return arrby;
    }

    public static void prepareBuffAESIVBytes(byte[] arrby, int n, int n2) {
        arrby[0] = (byte)n;
        arrby[1] = (byte)(n >> 8);
        arrby[2] = (byte)(n >> 16);
        arrby[3] = (byte)(n >> 24);
        arrby[4] = 0;
        arrby[5] = 0;
        arrby[6] = 0;
        arrby[7] = 0;
        arrby[8] = 0;
        arrby[9] = 0;
        arrby[10] = 0;
        arrby[11] = 0;
        arrby[12] = 0;
        arrby[13] = 0;
        arrby[14] = 0;
        arrby[15] = 0;
    }

    public static int readIntLittleEndian(byte[] arrby, int n) {
        byte by = arrby[n];
        byte by2 = arrby[n + 1];
        byte by3 = arrby[n + 2];
        return ((arrby[n + 3] & 255) << 8 | by3 & 255) << 16 | (by & 255 | (by2 & 255) << 8);
    }

    public static int readLeInt(DataInput dataInput, byte[] arrby) throws ZipException {
        try {
            dataInput.readFully(arrby, 0, 4);
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
        byte by = arrby[0];
        byte by2 = arrby[1];
        byte by3 = arrby[2];
        return by & 255 | (by2 & 255) << 8 | ((arrby[3] & 255) << 8 | by3 & 255) << 16;
    }

    public static long readLongLittleEndian(byte[] arrby, int n) {
        return ((((((((long)(arrby[n + 7] & 255) | 0L) << 8 | (long)(arrby[n + 6] & 255)) << 8 | (long)(arrby[n + 5] & 255)) << 8 | (long)(arrby[n + 4] & 255)) << 8 | (long)(arrby[n + 3] & 255)) << 8 | (long)(arrby[n + 2] & 255)) << 8 | (long)(arrby[n + 1] & 255)) << 8 | (long)(arrby[n] & 255);
    }

    public static final short readShortBigEndian(byte[] arrby, int n) {
        short s = (short)((short)(arrby[n] & 255 | 0) << 8);
        return (short)(arrby[n + 1] & 255 | s);
    }

    public static int readShortLittleEndian(byte[] arrby, int n) {
        byte by = arrby[n];
        return (arrby[n + 1] & 255) << 8 | by & 255;
    }

    public static byte[] toByteArray(int n) {
        return new byte[]{(byte)n, (byte)(n >> 8), (byte)(n >> 16), (byte)(n >> 24)};
    }

    public static byte[] toByteArray(int n, int n2) {
        byte[] arrby = new byte[n2];
        byte[] arrby2 = Raw.toByteArray(n);
        for (n = 0; n < arrby2.length; ++n) {
            if (n >= n2) {
                return arrby;
            }
            arrby[n] = arrby2[n];
        }
        return arrby;
    }

    public static final void writeIntLittleEndian(byte[] arrby, int n, int n2) {
        arrby[n + 3] = (byte)(n2 >>> 24);
        arrby[n + 2] = (byte)(n2 >>> 16);
        arrby[n + 1] = (byte)(n2 >>> 8);
        arrby[n] = (byte)(n2 & 255);
    }

    public static void writeLongLittleEndian(byte[] arrby, int n, long l) {
        arrby[n + 7] = (byte)(l >>> 56);
        arrby[n + 6] = (byte)(l >>> 48);
        arrby[n + 5] = (byte)(l >>> 40);
        arrby[n + 4] = (byte)(l >>> 32);
        arrby[n + 3] = (byte)(l >>> 24);
        arrby[n + 2] = (byte)(l >>> 16);
        arrby[n + 1] = (byte)(l >>> 8);
        arrby[n] = (byte)(l & 255L);
    }

    public static final void writeShortLittleEndian(byte[] arrby, int n, short s) {
        arrby[n + 1] = (byte)(s >>> 8);
        arrby[n] = (byte)(s & 255);
    }
}

