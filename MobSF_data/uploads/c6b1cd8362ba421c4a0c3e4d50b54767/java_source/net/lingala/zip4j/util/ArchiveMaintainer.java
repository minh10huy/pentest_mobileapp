/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.util;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import net.lingala.zip4j.core.HeaderWriter;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.io.SplitOutputStream;
import net.lingala.zip4j.model.CentralDirectory;
import net.lingala.zip4j.model.EndCentralDirRecord;
import net.lingala.zip4j.model.FileHeader;
import net.lingala.zip4j.model.Zip64EndCentralDirLocator;
import net.lingala.zip4j.model.Zip64EndCentralDirRecord;
import net.lingala.zip4j.model.ZipModel;
import net.lingala.zip4j.progress.ProgressMonitor;
import net.lingala.zip4j.util.ArchiveMaintainer$1;
import net.lingala.zip4j.util.ArchiveMaintainer$2;
import net.lingala.zip4j.util.Raw;
import net.lingala.zip4j.util.Zip4jUtil;

public class ArchiveMaintainer {
    static /* synthetic */ void access$0(ArchiveMaintainer archiveMaintainer, ZipModel zipModel, File file, ProgressMonitor progressMonitor) throws ZipException {
        archiveMaintainer.initMergeSplitZipFile(zipModel, file, progressMonitor);
    }

    private long calculateTotalWorkForMergeOp(ZipModel zipModel) throws ZipException {
        if (zipModel.isSplitArchive()) {
            int n = zipModel.getEndCentralDirRecord().getNoOfThisDisk();
            String string2 = zipModel.getZipFile();
            long l = 0L;
            int n2 = 0;
            do {
                CharSequence charSequence;
                if (n2 > n) {
                    return l;
                }
                if (zipModel.getEndCentralDirRecord().getNoOfThisDisk() == 0) {
                    charSequence = zipModel.getZipFile();
                } else {
                    charSequence = new StringBuffer(String.valueOf(string2.substring(0, string2.lastIndexOf("."))));
                    charSequence.append(".z0");
                    charSequence.append(1);
                    charSequence = charSequence.toString();
                }
                long l2 = Zip4jUtil.getFileLengh(new File((String)charSequence));
                ++n2;
                l += l2;
            } while (true);
        }
        return 0L;
    }

    private long calculateTotalWorkForRemoveOp(ZipModel zipModel, FileHeader fileHeader) throws ZipException {
        return Zip4jUtil.getFileLengh(new File(zipModel.getZipFile())) - fileHeader.getCompressedSize();
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void copyFile(RandomAccessFile var1_1, OutputStream var2_4, long var3_5, long var5_6, ProgressMonitor var7_7) throws ZipException {
        if (var1_1 == null) throw new ZipException("input or output stream is null, cannot copy file");
        if (var2_4 == null) {
            throw new ZipException("input or output stream is null, cannot copy file");
        }
        var9_8 = 0L;
        if (var3_5 < 0L) {
            throw new ZipException("starting offset is negative, cannot copy file");
        }
        if (var5_6 < 0L) {
            throw new ZipException("end offset is negative, cannot copy file");
        }
        if (var3_5 > var5_6) {
            throw new ZipException("start offset is greater than end offset, cannot copy file");
        }
        if (var3_5 == var5_6) {
            return;
        }
        if (var7_7.isCancelAllTasks()) {
            var7_7.setResult(3);
            var7_7.setState(0);
            return;
        }
        try {
            var1_1.seek(var3_5);
            if ((var5_6 -= var3_5) < 4096L) {
                var11_9 = new byte[(int)var5_6];
                var3_5 = var9_8;
            } else {
                var11_9 = new byte[4096];
                var3_5 = var9_8;
            }
lbl25: // 3 sources:
            if ((var8_10 = var1_1.read(var11_9)) == -1) {
                return;
            }
            var2_4.write(var11_9, 0, var8_10);
            var9_8 = var8_10;
            var7_7.updateWorkCompleted(var9_8);
            if (var7_7.isCancelAllTasks()) {
                var7_7.setResult(3);
                return;
            }
        }
        catch (Exception var1_2) {
            throw new ZipException(var1_2);
        }
        catch (IOException var1_3) {
            throw new ZipException(var1_3);
        }
        if ((var3_5 += var9_8) == var5_6) {
            return;
        }
        var12_11 = var11_9;
        if (var3_5 + (long)var11_9.length > var5_6) {
            var12_11 = new byte[(int)(var5_6 - var3_5)];
        }
        var11_9 = var12_11;
        ** GOTO lbl25
    }

    private RandomAccessFile createFileHandler(ZipModel object, String string2) throws ZipException {
        if (object != null && Zip4jUtil.isStringNotNullAndNotEmpty(object.getZipFile())) {
            try {
                object = new RandomAccessFile(new File(object.getZipFile()), string2);
                return object;
            }
            catch (FileNotFoundException fileNotFoundException) {
                throw new ZipException(fileNotFoundException);
            }
        }
        throw new ZipException("input parameter is null in getFilePointer, cannot create file handler to remove file");
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private RandomAccessFile createSplitZipFileHandler(ZipModel object, int n) throws ZipException {
        if (object == null) {
            throw new ZipException("zip model is null, cannot create split file handler");
        }
        if (n < 0) {
            throw new ZipException("invlaid part number, cannot create split file handler");
        }
        try {
            Object object2 = object.getZipFile();
            if (n == object.getEndCentralDirRecord().getNoOfThisDisk()) {
                object = object.getZipFile();
            } else if (n >= 9) {
                object = new StringBuffer(String.valueOf(object2.substring(0, object2.lastIndexOf("."))));
                object.append(".z");
                object.append(n + 1);
                object = object.toString();
            } else {
                object = new StringBuffer(String.valueOf(object2.substring(0, object2.lastIndexOf("."))));
                object.append(".z0");
                object.append(n + 1);
                object = object.toString();
            }
            object2 = new File((String)object);
            if (Zip4jUtil.checkFileExists((File)object2)) return new RandomAccessFile((File)object2, "r");
            object2 = new StringBuffer("split file does not exist: ");
            object2.append((String)object);
            throw new ZipException(object2.toString());
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
        catch (FileNotFoundException fileNotFoundException) {
            throw new ZipException(fileNotFoundException);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void initMergeSplitZipFile(ZipModel var1_1, File var2_26, ProgressMonitor var3_29) throws ZipException {
        block52 : {
            block51 : {
                block50 : {
                    if (var1_1 == null) {
                        var1_1 = new ZipException("one of the input parameters is null, cannot merge split zip file");
                        var3_29.endProgressMonitorError((Throwable)var1_1);
                        throw var1_1;
                    }
                    if (!var1_1.isSplitArchive()) {
                        var1_1 = new ZipException("archive not a split zip file");
                        var3_29.endProgressMonitorError((Throwable)var1_1);
                        throw var1_1;
                    }
                    var19_30 = new ArrayList<Object>();
                    try {
                        var6_31 = var1_1.getEndCentralDirRecord().getNoOfThisDisk();
                        if (var6_31 <= 0) {
                            throw new ZipException("corrupt zip model, archive not a split zip file");
                        }
                        var2_26 = this.prepareOutputStreamForMerge((File)var2_26);
                        var14_32 = null;
                        var7_33 = false;
                        var8_34 = 0L;
                        var4_35 = 0;
                    }
                    catch (Throwable var1_16) {
                        var2_26 = var14_32 = null;
                        ** GOTO lbl180
                    }
                    catch (Exception var1_17) {
                        var2_26 = var14_32 = null;
                        break block50;
                    }
                    catch (IOException var1_25) {
                        var2_26 = var15_39 = null;
                        break block51;
                    }
                    do {
                        block56 : {
                            block55 : {
                                block59 : {
                                    block58 : {
                                        block57 : {
                                            block54 : {
                                                block53 : {
                                                    block63 : {
                                                        block62 : {
                                                            block61 : {
                                                                if (var4_35 <= var6_31) break block61;
                                                                var1_1 = (ZipModel)var1_1.clone();
                                                                var1_1.getEndCentralDirRecord().setOffsetOfStartOfCentralDir(var8_34);
                                                                this.updateSplitZipModel((ZipModel)var1_1, var19_30, var7_33);
                                                                new HeaderWriter().finalizeZipFileWithoutValidations((ZipModel)var1_1, (OutputStream)var2_26);
                                                                var3_29.endProgressMonitorSuccess();
                                                                ** if (var2_26 == null) goto lbl40
lbl-1000: // 1 sources:
                                                                {
                                                                    var2_26.close();
                                                                }
lbl40: // 2 sources:
                                                                ** GOTO lbl86
                                                            }
                                                            try {
                                                                var14_32 = var15_39 = this.createSplitZipFileHandler((ZipModel)var1_1, var4_35);
                                                            }
                                                            catch (Throwable var1_2) {
                                                                ** GOTO lbl180
                                                            }
                                                            catch (Exception var1_3) {
                                                                var15_39 = var14_32;
                                                                var14_32 = var1_3;
                                                                var1_1 = var15_39;
                                                                ** GOTO lbl170
                                                            }
                                                            catch (IOException var1_4) {
                                                                var15_39 = var14_32;
                                                                var14_32 = var1_4;
                                                                var1_5 = var15_39;
                                                                break block52;
                                                            }
                                                            var18_43 = new Long(var14_32.length());
                                                            if (var4_35 != 0) ** GOTO lbl92
                                                            var17_42 = var14_32;
                                                            var16_41 = var2_26;
                                                            if (var1_1.getCentralDirectory() == null) break block62;
                                                            var17_42 = var14_32;
                                                            var16_41 = var2_26;
                                                            if (var1_1.getCentralDirectory().getFileHeaders() == null) break block62;
                                                            var17_42 = var14_32;
                                                            var16_41 = var2_26;
                                                            if (var1_1.getCentralDirectory().getFileHeaders().size() <= 0) break block62;
                                                            var17_42 = var14_32;
                                                            var16_41 = var2_26;
                                                            var20_44 = new byte[4];
                                                            var17_42 = var14_32;
                                                            var16_41 = var2_26;
                                                            var14_32.seek(0L);
                                                            var17_42 = var14_32;
                                                            var16_41 = var2_26;
                                                            var14_32.read(var20_44);
                                                            var17_42 = var14_32;
                                                            var16_41 = var2_26;
                                                            if ((long)Raw.readIntLittleEndian(var20_44, 0) != 134695760L) break block62;
                                                            var5_36 = 4;
                                                            var7_33 = true;
                                                            break block63;
                                                            catch (IOException var1_19) {}
lbl86: // 2 sources:
                                                            if (var14_32 == null) return;
                                                            try {
                                                                var14_32.close();
                                                                return;
                                                            }
                                                            catch (IOException var1_20) {
                                                                return;
                                                            }
                                                        }
                                                        var5_36 = 0;
                                                    }
                                                    var16_41 = var18_43;
                                                    if (var4_35 != var6_31) break block53;
                                                    var17_42 = var14_32;
                                                    var16_41 = var2_26;
                                                    var18_43 = new Long(var1_1.getEndCentralDirRecord().getOffsetOfStartOfCentralDir());
                                                    var16_41 = var18_43;
                                                }
                                                var10_37 = var5_36;
                                                var12_38 = var16_41.longValue();
                                                this.copyFile((RandomAccessFile)var14_32, (OutputStream)var2_26, var10_37, var12_38, var3_29);
                                                var12_38 = var16_41.longValue();
                                                if (!var3_29.isCancelAllTasks()) break block54;
                                                var3_29.setResult(3);
                                                var3_29.setState(0);
                                                ** if (var2_26 == null) goto lbl-1000
lbl-1000: // 1 sources:
                                                {
                                                    var2_26.close();
                                                }
lbl-1000: // 2 sources:
                                                {
                                                    break block55;
                                                }
                                            }
                                            try {
                                                var19_30.add(var16_41);
                                                var14_32.close();
                                                break block56;
                                            }
                                            catch (Throwable var1_6) {
                                                break block57;
                                            }
                                            catch (Exception var1_7) {
                                                break block58;
                                            }
                                            catch (IOException var1_8) {
                                                break block59;
                                            }
                                            catch (Throwable var1_9) {
                                                // empty catch block
                                            }
                                        }
                                        var14_32 = var15_39;
                                        ** GOTO lbl180
                                        catch (Exception var1_11) {
                                            // empty catch block
                                        }
                                    }
                                    var14_32 = var1_1;
                                    var1_1 = var15_39;
                                    ** GOTO lbl170
                                    catch (IOException var1_12) {
                                        // empty catch block
                                    }
                                }
                                var14_32 = var1_5;
                                var1_5 = var15_39;
                                break block52;
                                catch (Throwable var1_13) {
                                    ** GOTO lbl180
                                }
                                catch (Exception var1_14) {
                                    break;
                                }
                                catch (IOException var1_15) {
                                    var15_39 = var14_32;
                                    break block51;
                                }
                                catch (IOException var1_21) {}
                            }
                            if (var14_32 == null) return;
                            try {
                                var14_32.close();
                                return;
                            }
                            catch (IOException var1_22) {
                                return;
                            }
                            catch (IOException var15_40) {}
                        }
                        ++var4_35;
                        var8_34 += var12_38 - var10_37;
                    } while (true);
                }
lbl166: // 2 sources:
                do {
                    var15_39 = var1_1;
                    var1_1 = var14_32;
                    var14_32 = var15_39;
lbl170: // 3 sources:
                    var17_42 = var1_1;
                    var16_41 = var2_26;
                    try {
                        var3_29.endProgressMonitorError((Throwable)var14_32);
                        var17_42 = var1_1;
                        var16_41 = var2_26;
                        throw new ZipException((Throwable)var14_32);
                    }
                    catch (Throwable var1_18) {
                        var14_32 = var17_42;
                        var2_26 = var16_41;
                    }
lbl180: // 5 sources:
                    if (var2_26 != null) {
                        try {
                            var2_26.close();
                        }
                        catch (IOException var2_27) {}
                    }
                    if (var14_32 == null) throw var1_10;
                    try {
                        var14_32.close();
                    }
                    catch (IOException var2_28) {
                        throw var1_10;
                    }
                    throw var1_10;
                    break;
                } while (true);
                catch (Exception var1_23) {
                    ** continue;
                }
                catch (IOException var1_24) {
                    var15_39 = var14_32;
                }
            }
            var14_32 = var1_5;
            var1_5 = var15_39;
        }
        var17_42 = var1_5;
        var16_41 = var2_26;
        var3_29.endProgressMonitorError((Throwable)var14_32);
        var17_42 = var1_5;
        var16_41 = var2_26;
        throw new ZipException((Throwable)var14_32);
    }

    private OutputStream prepareOutputStreamForMerge(File object) throws ZipException {
        if (object == null) {
            throw new ZipException("outFile is null, cannot create outputstream");
        }
        try {
            object = new FileOutputStream((File)object);
            return object;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
        catch (FileNotFoundException fileNotFoundException) {
            throw new ZipException(fileNotFoundException);
        }
    }

    private void restoreFileName(File file, String string2) throws ZipException {
        if (file.delete()) {
            if (!new File(string2).renameTo(file)) {
                throw new ZipException("cannot rename modified zip file");
            }
            return;
        }
        throw new ZipException("cannot delete old zip file");
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void updateSplitEndCentralDirectory(ZipModel var1_1) throws ZipException {
        if (var1_1 != null) ** GOTO lbl4
        try {
            throw new ZipException("zip model is null - cannot update end of central directory for split zip model");
lbl4: // 1 sources:
            if (var1_1.getCentralDirectory() == null) {
                throw new ZipException("corrupt zip model - getCentralDirectory, cannot update split zip model");
            }
            var1_1.getEndCentralDirRecord().setNoOfThisDisk(0);
            var1_1.getEndCentralDirRecord().setNoOfThisDiskStartOfCentralDir(0);
            var1_1.getEndCentralDirRecord().setTotNoOfEntriesInCentralDir(var1_1.getCentralDirectory().getFileHeaders().size());
            var1_1.getEndCentralDirRecord().setTotNoOfEntriesInCentralDirOnThisDisk(var1_1.getCentralDirectory().getFileHeaders().size());
            return;
        }
        catch (Exception var1_2) {
            throw new ZipException(var1_2);
        }
        catch (ZipException var1_3) {
            throw var1_3;
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void updateSplitFileHeader(ZipModel var1_1, ArrayList var2_4, boolean var3_5) throws ZipException {
        block8 : {
            try {
                if (var1_1.getCentralDirectory() == null) {
                    throw new ZipException("corrupt zip model - getCentralDirectory, cannot update split zip model");
                }
                var7_6 = var1_1.getCentralDirectory().getFileHeaders().size();
                var4_7 = var3_5 != false ? 4 : 0;
                var5_8 = 0;
                break block8;
lbl8: // 2 sources:
                if (var6_9 >= ((FileHeader)var1_1.getCentralDirectory().getFileHeaders().get(var5_8)).getDiskNumberStart()) {
                    ((FileHeader)var1_1.getCentralDirectory().getFileHeaders().get(var5_8)).setOffsetLocalHeader(((FileHeader)var1_1.getCentralDirectory().getFileHeaders().get(var5_8)).getOffsetLocalHeader() + var8_10 - (long)var4_7);
                    ((FileHeader)var1_1.getCentralDirectory().getFileHeaders().get(var5_8)).setDiskNumberStart(0);
                    ++var5_8;
                    break block8;
                }
                var10_11 = (Long)var2_4.get(var6_9);
                ++var6_9;
                var8_10 += var10_11;
                ** GOTO lbl8
            }
            catch (Exception var1_2) {
                throw new ZipException(var1_2);
            }
            catch (ZipException var1_3) {
                throw var1_3;
            }
        }
        if (var5_8 >= var7_6) {
            return;
        }
        var8_10 = 0L;
        var6_9 = 0;
        ** GOTO lbl8
    }

    private void updateSplitZip64EndCentralDirLocator(ZipModel zipModel, ArrayList arrayList) throws ZipException {
        if (zipModel == null) {
            throw new ZipException("zip model is null, cannot update split Zip64 end of central directory locator");
        }
        if (zipModel.getZip64EndCentralDirLocator() == null) {
            return;
        }
        Zip64EndCentralDirLocator zip64EndCentralDirLocator = zipModel.getZip64EndCentralDirLocator();
        int n = 0;
        zip64EndCentralDirLocator.setNoOfDiskStartOfZip64EndOfCentralDirRec(0);
        long l = 0L;
        do {
            if (n >= arrayList.size()) {
                zipModel.getZip64EndCentralDirLocator().setOffsetZip64EndOfCentralDirRec(zipModel.getZip64EndCentralDirLocator().getOffsetZip64EndOfCentralDirRec() + l);
                zipModel.getZip64EndCentralDirLocator().setTotNumberOfDiscs(1);
                return;
            }
            long l2 = (Long)arrayList.get(n);
            ++n;
            l += l2;
        } while (true);
    }

    private void updateSplitZip64EndCentralDirRec(ZipModel zipModel, ArrayList arrayList) throws ZipException {
        if (zipModel == null) {
            throw new ZipException("zip model is null, cannot update split Zip64 end of central directory record");
        }
        if (zipModel.getZip64EndCentralDirRecord() == null) {
            return;
        }
        Zip64EndCentralDirRecord zip64EndCentralDirRecord = zipModel.getZip64EndCentralDirRecord();
        int n = 0;
        zip64EndCentralDirRecord.setNoOfThisDisk(0);
        zipModel.getZip64EndCentralDirRecord().setNoOfThisDiskStartOfCentralDir(0);
        zipModel.getZip64EndCentralDirRecord().setTotNoOfEntriesInCentralDirOnThisDisk(zipModel.getEndCentralDirRecord().getTotNoOfEntriesInCentralDir());
        long l = 0L;
        do {
            if (n >= arrayList.size()) {
                zipModel.getZip64EndCentralDirRecord().setOffsetStartCenDirWRTStartDiskNo(zipModel.getZip64EndCentralDirRecord().getOffsetStartCenDirWRTStartDiskNo() + l);
                return;
            }
            long l2 = (Long)arrayList.get(n);
            ++n;
            l += l2;
        } while (true);
    }

    private void updateSplitZipModel(ZipModel zipModel, ArrayList arrayList, boolean bl) throws ZipException {
        if (zipModel == null) {
            throw new ZipException("zip model is null, cannot update split zip model");
        }
        zipModel.setSplitArchive(false);
        this.updateSplitFileHeader(zipModel, arrayList, bl);
        this.updateSplitEndCentralDirectory(zipModel);
        if (zipModel.isZip64Format()) {
            this.updateSplitZip64EndCentralDirLocator(zipModel, arrayList);
            this.updateSplitZip64EndCentralDirRec(zipModel, arrayList);
        }
    }

    public void initProgressMonitorForMergeOp(ZipModel zipModel, ProgressMonitor progressMonitor) throws ZipException {
        if (zipModel == null) {
            throw new ZipException("zip model is null, cannot calculate total work for merge op");
        }
        progressMonitor.setCurrentOperation(4);
        progressMonitor.setFileName(zipModel.getZipFile());
        progressMonitor.setTotalWork(this.calculateTotalWorkForMergeOp(zipModel));
        progressMonitor.setState(1);
    }

    public void initProgressMonitorForRemoveOp(ZipModel zipModel, FileHeader fileHeader, ProgressMonitor progressMonitor) throws ZipException {
        if (zipModel != null && fileHeader != null && progressMonitor != null) {
            progressMonitor.setCurrentOperation(2);
            progressMonitor.setFileName(fileHeader.getFileName());
            progressMonitor.setTotalWork(this.calculateTotalWorkForRemoveOp(zipModel, fileHeader));
            progressMonitor.setState(1);
            return;
        }
        throw new ZipException("one of the input parameters is null, cannot calculate total work");
    }

    /*
     * Exception decompiling
     */
    public HashMap initRemoveZipFile(ZipModel var1_1, FileHeader var2_60, ProgressMonitor var3_62) throws ZipException {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // java.lang.IllegalStateException: Backjump on non jumping statement [] lbl34 : TryStatement: try { 3[TRYBLOCK]

        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Cleaner$1.call(Cleaner.java:44)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Cleaner$1.call(Cleaner.java:22)
        // org.benf.cfr.reader.util.graph.GraphVisitorDFS.process(GraphVisitorDFS.java:67)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Cleaner.removeUnreachableCode(Cleaner.java:54)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.RemoveDeterministicJumps.apply(RemoveDeterministicJumps.java:35)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:497)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public void mergeSplitZipFiles(ZipModel zipModel, File file, ProgressMonitor progressMonitor, boolean bl) throws ZipException {
        if (bl) {
            new ArchiveMaintainer$2(this, "Zip4j", zipModel, file, progressMonitor).start();
            return;
        }
        this.initMergeSplitZipFile(zipModel, file, progressMonitor);
    }

    public HashMap removeZipFile(ZipModel cloneable, FileHeader fileHeader, ProgressMonitor progressMonitor, boolean bl) throws ZipException {
        if (bl) {
            new ArchiveMaintainer$1(this, "Zip4j", (ZipModel)cloneable, fileHeader, progressMonitor).start();
            return null;
        }
        cloneable = this.initRemoveZipFile((ZipModel)cloneable, fileHeader, progressMonitor);
        progressMonitor.endProgressMonitorSuccess();
        return cloneable;
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void setComment(ZipModel zipModel, String arrby) throws ZipException {
        void var1_7;
        Object arrby2;
        void var1_8;
        block22 : {
            Object object;
            int n;
            block21 : {
                if (arrby == null) {
                    throw new ZipException("comment is null, cannot update Zip file with comment");
                }
                if (zipModel == null) {
                    throw new ZipException("zipModel is null, cannot update Zip file with comment");
                }
                object = arrby.getBytes();
                n = arrby.length();
                arrby2 = arrby;
                if (Zip4jUtil.isSupportedCharset("windows-1254")) {
                    try {
                        arrby2 = new String(arrby.getBytes("windows-1254"), "windows-1254");
                        object = arrby2.getBytes("windows-1254");
                        n = arrby2.length();
                        arrby2 = arrby = arrby2;
                        break block21;
                    }
                    catch (UnsupportedEncodingException unsupportedEncodingException) {}
                    object = arrby.getBytes();
                    n = arrby.length();
                    arrby2 = arrby;
                }
            }
            if (n > 65535) {
                throw new ZipException("comment length exceeds maximum length");
            }
            zipModel.getEndCentralDirRecord().setComment((String)arrby2);
            zipModel.getEndCentralDirRecord().setCommentBytes((byte[])object);
            zipModel.getEndCentralDirRecord().setCommentLength(n);
            Object var6_17 = null;
            arrby2 = null;
            arrby = object = null;
            HeaderWriter headerWriter = new HeaderWriter();
            arrby = object;
            object = new SplitOutputStream(zipModel.getZipFile());
            if (zipModel.isZip64Format()) {
                object.seek(zipModel.getZip64EndCentralDirRecord().getOffsetStartCenDirWRTStartDiskNo());
            } else {
                object.seek(zipModel.getEndCentralDirRecord().getOffsetOfStartOfCentralDir());
            }
            headerWriter.finalizeZipFileWithoutValidations(zipModel, (OutputStream)object);
            if (object == null) return;
            try {
                object.close();
                return;
            }
            catch (IOException iOException) {
                return;
            }
            catch (Throwable throwable) {
                arrby = object;
                break block22;
            }
            catch (IOException iOException) {
                arrby = object;
                throw new ZipException((Throwable)((Object)zipModel));
            }
            catch (FileNotFoundException fileNotFoundException) {
                arrby = object;
                throw new ZipException((Throwable)var1_7);
            }
            catch (Throwable throwable) {
                break block22;
            }
            catch (IOException iOException) {
                arrby = var6_17;
            }
            {
                throw new ZipException((Throwable)((Object)zipModel));
            }
        }
        if (arrby == null) throw var1_8;
        try {
            arrby.close();
        }
        catch (IOException iOException) {
            throw var1_8;
        }
        throw var1_8;
        catch (FileNotFoundException fileNotFoundException) {
            arrby = arrby2;
            throw new ZipException((Throwable)var1_7);
        }
    }
}

