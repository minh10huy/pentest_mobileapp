/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.core;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import net.lingala.zip4j.core.HeaderReader;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.io.ZipInputStream;
import net.lingala.zip4j.model.CentralDirectory;
import net.lingala.zip4j.model.EndCentralDirRecord;
import net.lingala.zip4j.model.FileHeader;
import net.lingala.zip4j.model.UnzipParameters;
import net.lingala.zip4j.model.ZipModel;
import net.lingala.zip4j.model.ZipParameters;
import net.lingala.zip4j.progress.ProgressMonitor;
import net.lingala.zip4j.unzip.Unzip;
import net.lingala.zip4j.util.ArchiveMaintainer;
import net.lingala.zip4j.util.InternalZipConstants;
import net.lingala.zip4j.util.Zip4jUtil;
import net.lingala.zip4j.zip.ZipEngine;

public class ZipFile {
    private String file;
    private String fileNameCharset;
    private boolean isEncrypted;
    private int mode;
    private ProgressMonitor progressMonitor;
    private boolean runInThread;
    private ZipModel zipModel;

    public ZipFile(File file) throws ZipException {
        if (file == null) {
            throw new ZipException("Input zip file parameter is not null", 1);
        }
        this.file = file.getPath();
        this.mode = 2;
        this.progressMonitor = new ProgressMonitor();
        this.runInThread = false;
    }

    public ZipFile(String string2) throws ZipException {
        this(new File(string2));
    }

    private void addFolder(File file, ZipParameters zipParameters, boolean bl) throws ZipException {
        this.checkZipModel();
        if (this.zipModel == null) {
            throw new ZipException("internal error: zip model is null");
        }
        if (bl && this.zipModel.isSplitArchive()) {
            throw new ZipException("This is a split archive. Zip file format does not allow updating split/spanned files");
        }
        new ZipEngine(this.zipModel).addFolderToZip(file, zipParameters, this.progressMonitor, this.runInThread);
    }

    private void checkZipModel() throws ZipException {
        if (this.zipModel == null) {
            if (Zip4jUtil.checkFileExists(this.file)) {
                this.readZipInfo();
                return;
            }
            this.createNewZipModel();
        }
    }

    private void createNewZipModel() {
        this.zipModel = new ZipModel();
        this.zipModel.setZipFile(this.file);
        this.zipModel.setFileNameCharset(this.fileNameCharset);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void readZipInfo() throws ZipException {
        Object object;
        RandomAccessFile randomAccessFile;
        block17 : {
            block16 : {
                if (!Zip4jUtil.checkFileExists(this.file)) {
                    throw new ZipException("zip file does not exist");
                }
                if (!Zip4jUtil.checkFileReadAccess(this.file)) {
                    throw new ZipException("no read access for the input zip file");
                }
                if (this.mode != 2) {
                    throw new ZipException("Invalid mode");
                }
                randomAccessFile = new RandomAccessFile(new File(this.file), "r");
                object = randomAccessFile;
                if (this.zipModel == null) {
                    object = randomAccessFile;
                    this.zipModel = new HeaderReader(randomAccessFile).readAllHeaders(this.fileNameCharset);
                    object = randomAccessFile;
                    if (this.zipModel != null) {
                        object = randomAccessFile;
                        this.zipModel.setZipFile(this.file);
                    }
                }
                if (randomAccessFile == null) return;
                try {
                    randomAccessFile.close();
                    return;
                }
                catch (IOException iOException) {
                    return;
                }
                catch (FileNotFoundException fileNotFoundException) {
                    object = randomAccessFile;
                    break block16;
                }
                catch (Throwable throwable) {
                    randomAccessFile = null;
                    break block17;
                }
                catch (FileNotFoundException fileNotFoundException) {
                    object = null;
                }
            }
            try {
                void var3_8;
                throw new ZipException((Throwable)var3_8);
            }
            catch (Throwable throwable) {
                randomAccessFile = object;
                object = throwable;
            }
        }
        if (randomAccessFile == null) throw object;
        try {
            randomAccessFile.close();
        }
        catch (IOException iOException) {
            throw object;
        }
        throw object;
    }

    public void addFile(File file, ZipParameters zipParameters) throws ZipException {
        ArrayList<File> arrayList = new ArrayList<File>();
        arrayList.add(file);
        this.addFiles(arrayList, zipParameters);
    }

    public void addFiles(ArrayList arrayList, ZipParameters zipParameters) throws ZipException {
        this.checkZipModel();
        if (this.zipModel == null) {
            throw new ZipException("internal error: zip model is null");
        }
        if (arrayList == null) {
            throw new ZipException("input file ArrayList is null, cannot add files");
        }
        if (!Zip4jUtil.checkArrayListTypes(arrayList, 1)) {
            throw new ZipException("One or more elements in the input ArrayList is not of type File");
        }
        if (zipParameters == null) {
            throw new ZipException("input parameters are null, cannot add files to zip");
        }
        if (this.progressMonitor.getState() == 1) {
            throw new ZipException("invalid operation - Zip4j is in busy state");
        }
        if (Zip4jUtil.checkFileExists(this.file) && this.zipModel.isSplitArchive()) {
            throw new ZipException("Zip file already exists. Zip file format does not allow updating split/spanned files");
        }
        new ZipEngine(this.zipModel).addFiles(arrayList, zipParameters, this.progressMonitor, this.runInThread);
    }

    public void addFolder(File file, ZipParameters zipParameters) throws ZipException {
        if (file == null) {
            throw new ZipException("input path is null, cannot add folder to zip file");
        }
        if (zipParameters == null) {
            throw new ZipException("input parameters are null, cannot add folder to zip file");
        }
        this.addFolder(file, zipParameters, true);
    }

    public void addFolder(String string2, ZipParameters zipParameters) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("input path is null or empty, cannot add folder to zip file");
        }
        this.addFolder(new File(string2), zipParameters);
    }

    public void addStream(InputStream inputStream, ZipParameters zipParameters) throws ZipException {
        if (inputStream == null) {
            throw new ZipException("inputstream is null, cannot add file to zip");
        }
        if (zipParameters == null) {
            throw new ZipException("zip parameters are null");
        }
        this.setRunInThread(false);
        this.checkZipModel();
        if (this.zipModel == null) {
            throw new ZipException("internal error: zip model is null");
        }
        if (Zip4jUtil.checkFileExists(this.file) && this.zipModel.isSplitArchive()) {
            throw new ZipException("Zip file already exists. Zip file format does not allow updating split/spanned files");
        }
        new ZipEngine(this.zipModel).addStreamToZip(inputStream, zipParameters);
    }

    public void createZipFile(File file, ZipParameters zipParameters) throws ZipException {
        ArrayList<File> arrayList = new ArrayList<File>();
        arrayList.add(file);
        this.createZipFile(arrayList, zipParameters, false, -1L);
    }

    public void createZipFile(File file, ZipParameters zipParameters, boolean bl, long l) throws ZipException {
        ArrayList<File> arrayList = new ArrayList<File>();
        arrayList.add(file);
        this.createZipFile(arrayList, zipParameters, bl, l);
    }

    public void createZipFile(ArrayList arrayList, ZipParameters zipParameters) throws ZipException {
        this.createZipFile(arrayList, zipParameters, false, -1L);
    }

    public void createZipFile(ArrayList serializable, ZipParameters zipParameters, boolean bl, long l) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(this.file)) {
            throw new ZipException("zip file path is empty");
        }
        if (Zip4jUtil.checkFileExists(this.file)) {
            serializable = new StringBuffer("zip file: ");
            serializable.append(this.file);
            serializable.append(" already exists. To add files to existing zip file use addFile method");
            throw new ZipException(serializable.toString());
        }
        if (serializable == null) {
            throw new ZipException("input file ArrayList is null, cannot create zip file");
        }
        if (!Zip4jUtil.checkArrayListTypes((ArrayList)serializable, 1)) {
            throw new ZipException("One or more elements in the input ArrayList is not of type File");
        }
        this.createNewZipModel();
        this.zipModel.setSplitArchive(bl);
        this.zipModel.setSplitLength(l);
        this.addFiles((ArrayList)serializable, zipParameters);
    }

    public void createZipFileFromFolder(File serializable, ZipParameters zipParameters, boolean bl, long l) throws ZipException {
        if (serializable == null) {
            throw new ZipException("folderToAdd is null, cannot create zip file from folder");
        }
        if (zipParameters == null) {
            throw new ZipException("input parameters are null, cannot create zip file from folder");
        }
        if (Zip4jUtil.checkFileExists(this.file)) {
            serializable = new StringBuffer("zip file: ");
            serializable.append(this.file);
            serializable.append(" already exists. To add files to existing zip file use addFolder method");
            throw new ZipException(serializable.toString());
        }
        this.createNewZipModel();
        this.zipModel.setSplitArchive(bl);
        if (bl) {
            this.zipModel.setSplitLength(l);
        }
        this.addFolder((File)serializable, zipParameters, false);
    }

    public void createZipFileFromFolder(String string2, ZipParameters zipParameters, boolean bl, long l) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("folderToAdd is empty or null, cannot create Zip File from folder");
        }
        this.createZipFileFromFolder(new File(string2), zipParameters, bl, l);
    }

    public void extractAll(String string2) throws ZipException {
        this.extractAll(string2, null);
    }

    public void extractAll(String string2, UnzipParameters unzipParameters) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("output path is null or invalid");
        }
        if (!Zip4jUtil.checkOutputFolder(string2)) {
            throw new ZipException("invalid output path");
        }
        if (this.zipModel == null) {
            this.readZipInfo();
        }
        if (this.zipModel == null) {
            throw new ZipException("Internal error occurred when extracting zip file");
        }
        if (this.progressMonitor.getState() == 1) {
            throw new ZipException("invalid operation - Zip4j is in busy state");
        }
        new Unzip(this.zipModel).extractAll(unzipParameters, string2, this.progressMonitor, this.runInThread);
    }

    public void extractFile(String string2, String string3) throws ZipException {
        this.extractFile(string2, string3, null);
    }

    public void extractFile(String string2, String string3, UnzipParameters unzipParameters) throws ZipException {
        this.extractFile(string2, string3, unzipParameters, null);
    }

    public void extractFile(String object, String string2, UnzipParameters unzipParameters, String string3) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty((String)object)) {
            throw new ZipException("file to extract is null or empty, cannot extract file");
        }
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("destination string path is empty or null, cannot extract file");
        }
        this.readZipInfo();
        object = Zip4jUtil.getFileHeader(this.zipModel, (String)object);
        if (object == null) {
            throw new ZipException("file header not found for given file name, cannot extract file");
        }
        if (this.progressMonitor.getState() == 1) {
            throw new ZipException("invalid operation - Zip4j is in busy state");
        }
        object.extractFile(this.zipModel, string2, unzipParameters, string3, this.progressMonitor, this.runInThread);
    }

    public void extractFile(FileHeader fileHeader, String string2) throws ZipException {
        this.extractFile(fileHeader, string2, null);
    }

    public void extractFile(FileHeader fileHeader, String string2, UnzipParameters unzipParameters) throws ZipException {
        this.extractFile(fileHeader, string2, unzipParameters, null);
    }

    public void extractFile(FileHeader fileHeader, String string2, UnzipParameters unzipParameters, String string3) throws ZipException {
        if (fileHeader == null) {
            throw new ZipException("input file header is null, cannot extract file");
        }
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("destination path is empty or null, cannot extract file");
        }
        this.readZipInfo();
        if (this.progressMonitor.getState() == 1) {
            throw new ZipException("invalid operation - Zip4j is in busy state");
        }
        fileHeader.extractFile(this.zipModel, string2, unzipParameters, string3, this.progressMonitor, this.runInThread);
    }

    public String getComment() throws ZipException {
        return this.getComment(null);
    }

    public String getComment(String string2) throws ZipException {
        String string3 = string2;
        if (string2 == null) {
            string3 = Zip4jUtil.isSupportedCharset("windows-1254") ? "windows-1254" : InternalZipConstants.CHARSET_DEFAULT;
        }
        if (Zip4jUtil.checkFileExists(this.file)) {
            this.checkZipModel();
            if (this.zipModel == null) {
                throw new ZipException("zip model is null, cannot read comment");
            }
            if (this.zipModel.getEndCentralDirRecord() == null) {
                throw new ZipException("end of central directory record is null, cannot read comment");
            }
            if (this.zipModel.getEndCentralDirRecord().getCommentBytes() != null && this.zipModel.getEndCentralDirRecord().getCommentBytes().length > 0) {
                try {
                    string2 = new String(this.zipModel.getEndCentralDirRecord().getCommentBytes(), string3);
                    return string2;
                }
                catch (UnsupportedEncodingException unsupportedEncodingException) {
                    throw new ZipException(unsupportedEncodingException);
                }
            }
            return null;
        }
        throw new ZipException("zip file does not exist, cannot read comment");
    }

    public File getFile() {
        return new File(this.file);
    }

    public FileHeader getFileHeader(String string2) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("input file name is emtpy or null, cannot get FileHeader");
        }
        this.readZipInfo();
        if (this.zipModel != null && this.zipModel.getCentralDirectory() != null) {
            return Zip4jUtil.getFileHeader(this.zipModel, string2);
        }
        return null;
    }

    public List getFileHeaders() throws ZipException {
        this.readZipInfo();
        if (this.zipModel != null && this.zipModel.getCentralDirectory() != null) {
            return this.zipModel.getCentralDirectory().getFileHeaders();
        }
        return null;
    }

    public ZipInputStream getInputStream(FileHeader fileHeader) throws ZipException {
        if (fileHeader == null) {
            throw new ZipException("FileHeader is null, cannot get InputStream");
        }
        this.checkZipModel();
        if (this.zipModel == null) {
            throw new ZipException("zip model is null, cannot get inputstream");
        }
        return new Unzip(this.zipModel).getInputStream(fileHeader);
    }

    public ProgressMonitor getProgressMonitor() {
        return this.progressMonitor;
    }

    public ArrayList getSplitZipFiles() throws ZipException {
        this.checkZipModel();
        return Zip4jUtil.getSplitZipFiles(this.zipModel);
    }

    public boolean isEncrypted() throws ZipException {
        block6 : {
            if (this.zipModel == null) {
                this.readZipInfo();
                if (this.zipModel == null) {
                    throw new ZipException("Zip Model is null");
                }
            }
            if (this.zipModel.getCentralDirectory() == null || this.zipModel.getCentralDirectory().getFileHeaders() == null) break block6;
            ArrayList arrayList = this.zipModel.getCentralDirectory().getFileHeaders();
            int n = 0;
            do {
                block8 : {
                    block7 : {
                        if (n >= arrayList.size()) break block7;
                        FileHeader fileHeader = (FileHeader)arrayList.get(n);
                        if (fileHeader == null || !fileHeader.isEncrypted()) break block8;
                        this.isEncrypted = true;
                    }
                    return this.isEncrypted;
                }
                ++n;
            } while (true);
        }
        throw new ZipException("invalid zip file");
    }

    public boolean isRunInThread() {
        return this.runInThread;
    }

    public boolean isSplitArchive() throws ZipException {
        if (this.zipModel == null) {
            this.readZipInfo();
            if (this.zipModel == null) {
                throw new ZipException("Zip Model is null");
            }
        }
        return this.zipModel.isSplitArchive();
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public boolean isValidZipFile() {
        try {
            this.readZipInfo();
            return true;
        }
        catch (Exception exception) {
            return false;
        }
    }

    public void mergeSplitFiles(File file) throws ZipException {
        if (file == null) {
            throw new ZipException("outputZipFile is null, cannot merge split files");
        }
        if (file.exists()) {
            throw new ZipException("output Zip File already exists");
        }
        this.checkZipModel();
        if (this.zipModel == null) {
            throw new ZipException("zip model is null, corrupt zip file?");
        }
        ArchiveMaintainer archiveMaintainer = new ArchiveMaintainer();
        archiveMaintainer.initProgressMonitorForMergeOp(this.zipModel, this.progressMonitor);
        archiveMaintainer.mergeSplitZipFiles(this.zipModel, file, this.progressMonitor, this.runInThread);
    }

    public void removeFile(String string2) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("file name is empty or null, cannot remove file");
        }
        if (this.zipModel == null && Zip4jUtil.checkFileExists(this.file)) {
            this.readZipInfo();
        }
        if (this.zipModel.isSplitArchive()) {
            throw new ZipException("Zip file format does not allow updating split/spanned files");
        }
        Object object = Zip4jUtil.getFileHeader(this.zipModel, string2);
        if (object == null) {
            object = new StringBuffer("could not find file header for file: ");
            object.append(string2);
            throw new ZipException(object.toString());
        }
        this.removeFile((FileHeader)object);
    }

    public void removeFile(FileHeader fileHeader) throws ZipException {
        if (fileHeader == null) {
            throw new ZipException("file header is null, cannot remove file");
        }
        if (this.zipModel == null && Zip4jUtil.checkFileExists(this.file)) {
            this.readZipInfo();
        }
        if (this.zipModel.isSplitArchive()) {
            throw new ZipException("Zip file format does not allow updating split/spanned files");
        }
        ArchiveMaintainer archiveMaintainer = new ArchiveMaintainer();
        archiveMaintainer.initProgressMonitorForRemoveOp(this.zipModel, fileHeader, this.progressMonitor);
        archiveMaintainer.removeZipFile(this.zipModel, fileHeader, this.progressMonitor, this.runInThread);
    }

    public void setComment(String string2) throws ZipException {
        if (string2 == null) {
            throw new ZipException("input comment is null, cannot update zip file");
        }
        if (!Zip4jUtil.checkFileExists(this.file)) {
            throw new ZipException("zip file does not exist, cannot set comment for zip file");
        }
        this.readZipInfo();
        if (this.zipModel == null) {
            throw new ZipException("zipModel is null, cannot update zip file");
        }
        if (this.zipModel.getEndCentralDirRecord() == null) {
            throw new ZipException("end of central directory is null, cannot set comment");
        }
        new ArchiveMaintainer().setComment(this.zipModel, string2);
    }

    public void setFileNameCharset(String string2) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new ZipException("null or empty charset name");
        }
        if (!Zip4jUtil.isSupportedCharset(string2)) {
            StringBuffer stringBuffer = new StringBuffer("unsupported charset: ");
            stringBuffer.append(string2);
            throw new ZipException(stringBuffer.toString());
        }
        this.fileNameCharset = string2;
    }

    public void setPassword(String string2) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            throw new NullPointerException();
        }
        this.setPassword(string2.toCharArray());
    }

    public void setPassword(char[] arrc) throws ZipException {
        if (this.zipModel == null) {
            this.readZipInfo();
            if (this.zipModel == null) {
                throw new ZipException("Zip Model is null");
            }
        }
        if (this.zipModel.getCentralDirectory() != null && this.zipModel.getCentralDirectory().getFileHeaders() != null) {
            int n = 0;
            do {
                if (n >= this.zipModel.getCentralDirectory().getFileHeaders().size()) {
                    return;
                }
                if (this.zipModel.getCentralDirectory().getFileHeaders().get(n) != null && ((FileHeader)this.zipModel.getCentralDirectory().getFileHeaders().get(n)).isEncrypted()) {
                    ((FileHeader)this.zipModel.getCentralDirectory().getFileHeaders().get(n)).setPassword(arrc);
                }
                ++n;
            } while (true);
        }
        throw new ZipException("invalid zip file");
    }

    public void setRunInThread(boolean bl) {
        this.runInThread = bl;
    }
}

