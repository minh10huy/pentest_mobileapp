/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.core;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.io.SplitOutputStream;
import net.lingala.zip4j.model.AESExtraDataRecord;
import net.lingala.zip4j.model.CentralDirectory;
import net.lingala.zip4j.model.EndCentralDirRecord;
import net.lingala.zip4j.model.FileHeader;
import net.lingala.zip4j.model.LocalFileHeader;
import net.lingala.zip4j.model.Zip64EndCentralDirLocator;
import net.lingala.zip4j.model.Zip64EndCentralDirRecord;
import net.lingala.zip4j.model.ZipModel;
import net.lingala.zip4j.util.Raw;
import net.lingala.zip4j.util.Zip4jUtil;

public class HeaderWriter {
    private final int ZIP64_EXTRA_BUF = 50;

    private byte[] byteArrayListToByteArray(List list) throws ZipException {
        if (list == null) {
            throw new ZipException("input byte array list is null, cannot conver to byte array");
        }
        if (list.size() <= 0) {
            return null;
        }
        byte[] arrby = new byte[list.size()];
        int n = 0;
        while (n < list.size()) {
            arrby[n] = Byte.parseByte((String)list.get(n));
            ++n;
        }
        return arrby;
    }

    private void copyByteArrayToArrayList(byte[] arrby, List list) throws ZipException {
        if (list != null && arrby != null) {
            int n = 0;
            do {
                if (n >= arrby.length) {
                    return;
                }
                list.add(Byte.toString(arrby[n]));
                ++n;
            } while (true);
        }
        throw new ZipException("one of the input parameters is null, cannot copy byte array to array list");
    }

    private int countNumberOfFileHeaderEntriesOnDisk(ArrayList arrayList, int n) throws ZipException {
        if (arrayList == null) {
            throw new ZipException("file headers are null, cannot calculate number of entries on this disk");
        }
        int n2 = 0;
        int n3 = 0;
        while (n2 < arrayList.size()) {
            int n4 = n3;
            if (((FileHeader)arrayList.get(n2)).getDiskNumberStart() == n) {
                n4 = n3 + 1;
            }
            ++n2;
            n3 = n4;
        }
        return n3;
    }

    private void processHeaderData(ZipModel zipModel, OutputStream outputStream) throws ZipException {
        int n = 0;
        try {
            if (outputStream instanceof SplitOutputStream) {
                zipModel.getEndCentralDirRecord().setOffsetOfStartOfCentralDir(((SplitOutputStream)outputStream).getFilePointer());
                n = ((SplitOutputStream)outputStream).getCurrSplitFileCounter();
            }
            if (zipModel.isZip64Format()) {
                if (zipModel.getZip64EndCentralDirRecord() == null) {
                    zipModel.setZip64EndCentralDirRecord(new Zip64EndCentralDirRecord());
                }
                if (zipModel.getZip64EndCentralDirLocator() == null) {
                    zipModel.setZip64EndCentralDirLocator(new Zip64EndCentralDirLocator());
                }
                zipModel.getZip64EndCentralDirLocator().setNoOfDiskStartOfZip64EndOfCentralDirRec(n);
                zipModel.getZip64EndCentralDirLocator().setTotNumberOfDiscs(n + 1);
            }
            zipModel.getEndCentralDirRecord().setNoOfThisDisk(n);
            zipModel.getEndCentralDirRecord().setNoOfThisDiskStartOfCentralDir(n);
            return;
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void updateCompressedSizeInLocalFileHeader(SplitOutputStream splitOutputStream, LocalFileHeader localFileHeader, long l, long l2, byte[] arrby, boolean bl) throws ZipException {
        if (splitOutputStream == null) {
            throw new ZipException("invalid output stream, cannot update compressed size for local file header");
        }
        try {
            if (!localFileHeader.isWriteComprSizeInZip64ExtraRecord()) {
                splitOutputStream.seek(l + l2);
                splitOutputStream.write(arrby);
                return;
            }
            if (arrby.length != 8) {
                throw new ZipException("attempting to write a non 8-byte compressed size block for a zip64 file");
            }
            l = l + l2 + 4L + 4L + 2L + 2L + (long)localFileHeader.getFileNameLength() + 2L + 2L + 8L;
            if (l2 == 22L) {
                l += 8L;
            }
            splitOutputStream.seek(l);
            splitOutputStream.write(arrby);
            return;
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    private int writeCentralDirectory(ZipModel zipModel, OutputStream outputStream, List list) throws ZipException {
        if (zipModel != null && outputStream != null) {
            CentralDirectory centralDirectory = zipModel.getCentralDirectory();
            int n = 0;
            if (centralDirectory != null && zipModel.getCentralDirectory().getFileHeaders() != null) {
                if (zipModel.getCentralDirectory().getFileHeaders().size() <= 0) {
                    return 0;
                }
                int n2 = 0;
                do {
                    if (n >= zipModel.getCentralDirectory().getFileHeaders().size()) {
                        return n2;
                    }
                    n2 += this.writeFileHeader(zipModel, (FileHeader)zipModel.getCentralDirectory().getFileHeaders().get(n), outputStream, list);
                    ++n;
                } while (true);
            }
            return 0;
        }
        throw new ZipException("input parameters is null, cannot write central directory");
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void writeEndOfCentralDirectoryRecord(ZipModel zipModel, OutputStream arrby, int n, long l, List list) throws ZipException {
        if (zipModel == null) throw new ZipException("zip model or output stream is null, cannot write end of central directory record");
        if (arrby == null) {
            throw new ZipException("zip model or output stream is null, cannot write end of central directory record");
        }
        try {
            arrby = new byte[2];
            byte[] arrby2 = new byte[4];
            byte[] arrby3 = new byte[8];
            Raw.writeIntLittleEndian(arrby2, 0, (int)zipModel.getEndCentralDirRecord().getSignature());
            this.copyByteArrayToArrayList(arrby2, list);
            Raw.writeShortLittleEndian(arrby, 0, (short)zipModel.getEndCentralDirRecord().getNoOfThisDisk());
            this.copyByteArrayToArrayList(arrby, list);
            Raw.writeShortLittleEndian(arrby, 0, (short)zipModel.getEndCentralDirRecord().getNoOfThisDiskStartOfCentralDir());
            this.copyByteArrayToArrayList(arrby, list);
            if (zipModel.getCentralDirectory() == null) throw new ZipException("invalid central directory/file headers, cannot write end of central directory record");
            if (zipModel.getCentralDirectory().getFileHeaders() == null) {
                throw new ZipException("invalid central directory/file headers, cannot write end of central directory record");
            }
            int n2 = zipModel.getCentralDirectory().getFileHeaders().size();
            int n3 = zipModel.isSplitArchive() ? this.countNumberOfFileHeaderEntriesOnDisk(zipModel.getCentralDirectory().getFileHeaders(), zipModel.getEndCentralDirRecord().getNoOfThisDisk()) : n2;
            Raw.writeShortLittleEndian(arrby, 0, (short)n3);
            this.copyByteArrayToArrayList(arrby, list);
            Raw.writeShortLittleEndian(arrby, 0, (short)n2);
            this.copyByteArrayToArrayList(arrby, list);
            Raw.writeIntLittleEndian(arrby2, 0, n);
            this.copyByteArrayToArrayList(arrby2, list);
            if (l > 0xFFFFFFFFL) {
                Raw.writeLongLittleEndian(arrby3, 0, 0xFFFFFFFFL);
                System.arraycopy(arrby3, 0, arrby2, 0, 4);
                this.copyByteArrayToArrayList(arrby2, list);
            } else {
                Raw.writeLongLittleEndian(arrby3, 0, l);
                System.arraycopy(arrby3, 0, arrby2, 0, 4);
                this.copyByteArrayToArrayList(arrby2, list);
            }
            n = zipModel.getEndCentralDirRecord().getComment() != null ? zipModel.getEndCentralDirRecord().getCommentLength() : 0;
            Raw.writeShortLittleEndian(arrby, 0, (short)n);
            this.copyByteArrayToArrayList(arrby, list);
            if (n <= 0) return;
            this.copyByteArrayToArrayList(zipModel.getEndCentralDirRecord().getCommentBytes(), list);
            return;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private int writeFileHeader(ZipModel object, FileHeader fileHeader, OutputStream arrby, List list) throws ZipException {
        int n;
        int n2;
        block24 : {
            int n3;
            byte[] arrby2;
            boolean bl;
            boolean bl2;
            block25 : {
                byte[] arrby3;
                byte[] arrby4;
                byte[] arrby5;
                block23 : {
                    if (fileHeader == null) throw new ZipException("input parameters is null, cannot write local file header");
                    if (arrby == null) {
                        throw new ZipException("input parameters is null, cannot write local file header");
                    }
                    try {
                        arrby = new byte[2];
                        n = 4;
                        arrby5 = new byte[4];
                        arrby2 = new byte[8];
                        arrby4 = new byte[2];
                        arrby3 = new byte[4];
                        Raw.writeIntLittleEndian(arrby5, 0, fileHeader.getSignature());
                        this.copyByteArrayToArrayList(arrby5, list);
                        Raw.writeShortLittleEndian(arrby, 0, (short)fileHeader.getVersionMadeBy());
                        this.copyByteArrayToArrayList(arrby, list);
                        Raw.writeShortLittleEndian(arrby, 0, (short)fileHeader.getVersionNeededToExtract());
                        this.copyByteArrayToArrayList(arrby, list);
                        this.copyByteArrayToArrayList(fileHeader.getGeneralPurposeFlag(), list);
                        Raw.writeShortLittleEndian(arrby, 0, (short)fileHeader.getCompressionMethod());
                        this.copyByteArrayToArrayList(arrby, list);
                        Raw.writeIntLittleEndian(arrby5, 0, fileHeader.getLastModFileTime());
                        this.copyByteArrayToArrayList(arrby5, list);
                        Raw.writeIntLittleEndian(arrby5, 0, (int)fileHeader.getCrc32());
                        this.copyByteArrayToArrayList(arrby5, list);
                        if (fileHeader.getCompressedSize() < 0xFFFFFFFFL && fileHeader.getUncompressedSize() + 50L < 0xFFFFFFFFL) {
                            Raw.writeLongLittleEndian(arrby2, 0, fileHeader.getCompressedSize());
                            System.arraycopy(arrby2, 0, arrby5, 0, 4);
                            this.copyByteArrayToArrayList(arrby5, list);
                            Raw.writeLongLittleEndian(arrby2, 0, fileHeader.getUncompressedSize());
                            System.arraycopy(arrby2, 0, arrby5, 0, 4);
                            this.copyByteArrayToArrayList(arrby5, list);
                            bl2 = false;
                        } else {
                            Raw.writeLongLittleEndian(arrby2, 0, 0xFFFFFFFFL);
                            System.arraycopy(arrby2, 0, arrby5, 0, 4);
                            this.copyByteArrayToArrayList(arrby5, list);
                            this.copyByteArrayToArrayList(arrby5, list);
                            bl2 = true;
                        }
                        Raw.writeShortLittleEndian(arrby, 0, (short)fileHeader.getFileNameLength());
                        this.copyByteArrayToArrayList(arrby, list);
                        arrby5 = new byte[4];
                        if (fileHeader.getOffsetLocalHeader() > 0xFFFFFFFFL) {
                            Raw.writeLongLittleEndian(arrby2, 0, 0xFFFFFFFFL);
                            System.arraycopy(arrby2, 0, arrby5, 0, 4);
                            bl = true;
                        } else {
                            Raw.writeLongLittleEndian(arrby2, 0, fileHeader.getOffsetLocalHeader());
                            System.arraycopy(arrby2, 0, arrby5, 0, 4);
                            bl = false;
                        }
                        if (!bl2 && !bl) {
                            n = 0;
                        } else {
                            if (bl2) {
                                n = 20;
                            }
                            if (bl) {
                                n += 8;
                            }
                        }
                        n2 = n;
                        if (fileHeader.getAesExtraDataRecord() == null) break block23;
                    }
                    catch (Exception exception) {
                        throw new ZipException(exception);
                    }
                    n2 = n + 11;
                }
                Raw.writeShortLittleEndian(arrby, 0, (short)n2);
                this.copyByteArrayToArrayList(arrby, list);
                this.copyByteArrayToArrayList(arrby4, list);
                Raw.writeShortLittleEndian(arrby, 0, (short)fileHeader.getDiskNumberStart());
                this.copyByteArrayToArrayList(arrby, list);
                this.copyByteArrayToArrayList(arrby4, list);
                if (fileHeader.getExternalFileAttr() != null) {
                    this.copyByteArrayToArrayList(fileHeader.getExternalFileAttr(), list);
                } else {
                    this.copyByteArrayToArrayList(arrby3, list);
                }
                this.copyByteArrayToArrayList(arrby5, list);
                if (Zip4jUtil.isStringNotNullAndNotEmpty(object.getFileNameCharset())) {
                    arrby4 = fileHeader.getFileName().getBytes(object.getFileNameCharset());
                    this.copyByteArrayToArrayList(arrby4, list);
                    n2 = 46 + arrby4.length;
                } else {
                    this.copyByteArrayToArrayList(Zip4jUtil.convertCharset(fileHeader.getFileName()), list);
                    n2 = 46 + Zip4jUtil.getEncodedStringLength(fileHeader.getFileName());
                }
                if (!bl2) {
                    n = n2;
                    if (!bl) break block24;
                }
                object.setZip64Format(true);
                Raw.writeShortLittleEndian(arrby, 0, (short)1);
                this.copyByteArrayToArrayList(arrby, list);
                n = bl2 ? 16 : 0;
                n3 = n;
                if (!bl) break block25;
                n3 = n + 8;
            }
            Raw.writeShortLittleEndian(arrby, 0, (short)n3);
            this.copyByteArrayToArrayList(arrby, list);
            n2 = n = n2 + 2 + 2;
            if (bl2) {
                Raw.writeLongLittleEndian(arrby2, 0, fileHeader.getUncompressedSize());
                this.copyByteArrayToArrayList(arrby2, list);
                Raw.writeLongLittleEndian(arrby2, 0, fileHeader.getCompressedSize());
                this.copyByteArrayToArrayList(arrby2, list);
                n2 = n + 8 + 8;
            }
            n = n2;
            if (bl) {
                Raw.writeLongLittleEndian(arrby2, 0, fileHeader.getOffsetLocalHeader());
                this.copyByteArrayToArrayList(arrby2, list);
                n = n2 + 8;
            }
        }
        n2 = n;
        if (fileHeader.getAesExtraDataRecord() == null) return n2;
        object = fileHeader.getAesExtraDataRecord();
        Raw.writeShortLittleEndian(arrby, 0, (short)object.getSignature());
        this.copyByteArrayToArrayList(arrby, list);
        Raw.writeShortLittleEndian(arrby, 0, (short)object.getDataSize());
        this.copyByteArrayToArrayList(arrby, list);
        Raw.writeShortLittleEndian(arrby, 0, (short)object.getVersionNumber());
        this.copyByteArrayToArrayList(arrby, list);
        this.copyByteArrayToArrayList(object.getVendorID().getBytes(), list);
        this.copyByteArrayToArrayList(new byte[]{(byte)object.getAesStrength()}, list);
        Raw.writeShortLittleEndian(arrby, 0, (short)object.getCompressionMethod());
        this.copyByteArrayToArrayList(arrby, list);
        return n + 11;
    }

    private void writeZip64EndOfCentralDirectoryLocator(ZipModel zipModel, OutputStream arrby, List list) throws ZipException {
        if (zipModel != null && arrby != null) {
            try {
                arrby = new byte[4];
                byte[] arrby2 = new byte[8];
                Raw.writeIntLittleEndian(arrby, 0, 117853008);
                this.copyByteArrayToArrayList(arrby, list);
                Raw.writeIntLittleEndian(arrby, 0, zipModel.getZip64EndCentralDirLocator().getNoOfDiskStartOfZip64EndOfCentralDirRec());
                this.copyByteArrayToArrayList(arrby, list);
                Raw.writeLongLittleEndian(arrby2, 0, zipModel.getZip64EndCentralDirLocator().getOffsetZip64EndOfCentralDirRec());
                this.copyByteArrayToArrayList(arrby2, list);
                Raw.writeIntLittleEndian(arrby, 0, zipModel.getZip64EndCentralDirLocator().getTotNumberOfDiscs());
                this.copyByteArrayToArrayList(arrby, list);
                return;
            }
            catch (Exception exception) {
                throw new ZipException(exception);
            }
            catch (ZipException zipException) {
                throw zipException;
            }
        }
        throw new ZipException("zip model or output stream is null, cannot write zip64 end of central directory locator");
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void writeZip64EndOfCentralDirectoryRecord(ZipModel zipModel, OutputStream arrby, int n, long l, List list) throws ZipException {
        int n2;
        int n3;
        byte[] arrby2;
        block8 : {
            block7 : {
                if (zipModel == null) throw new ZipException("zip model or output stream is null, cannot write zip64 end of central directory record");
                if (arrby == null) {
                    throw new ZipException("zip model or output stream is null, cannot write zip64 end of central directory record");
                }
                try {
                    arrby = new byte[2];
                    byte[] arrby3 = new byte[2];
                    byte[] arrby4 = new byte[4];
                    arrby2 = new byte[8];
                    Raw.writeIntLittleEndian(arrby4, 0, 101075792);
                    this.copyByteArrayToArrayList(arrby4, list);
                    Raw.writeLongLittleEndian(arrby2, 0, 44L);
                    this.copyByteArrayToArrayList(arrby2, list);
                    if (zipModel.getCentralDirectory() != null && zipModel.getCentralDirectory().getFileHeaders() != null && zipModel.getCentralDirectory().getFileHeaders().size() > 0) {
                        Raw.writeShortLittleEndian(arrby, 0, (short)((FileHeader)zipModel.getCentralDirectory().getFileHeaders().get(0)).getVersionMadeBy());
                        this.copyByteArrayToArrayList(arrby, list);
                        Raw.writeShortLittleEndian(arrby, 0, (short)((FileHeader)zipModel.getCentralDirectory().getFileHeaders().get(0)).getVersionNeededToExtract());
                        this.copyByteArrayToArrayList(arrby, list);
                    } else {
                        this.copyByteArrayToArrayList(arrby3, list);
                        this.copyByteArrayToArrayList(arrby3, list);
                    }
                    Raw.writeIntLittleEndian(arrby4, 0, zipModel.getEndCentralDirRecord().getNoOfThisDisk());
                    this.copyByteArrayToArrayList(arrby4, list);
                    Raw.writeIntLittleEndian(arrby4, 0, zipModel.getEndCentralDirRecord().getNoOfThisDiskStartOfCentralDir());
                    this.copyByteArrayToArrayList(arrby4, list);
                    if (zipModel.getCentralDirectory() == null) throw new ZipException("invalid central directory/file headers, cannot write end of central directory record");
                    if (zipModel.getCentralDirectory().getFileHeaders() == null) {
                        throw new ZipException("invalid central directory/file headers, cannot write end of central directory record");
                    }
                    n3 = zipModel.getCentralDirectory().getFileHeaders().size();
                    if (!zipModel.isSplitArchive()) break block7;
                    this.countNumberOfFileHeaderEntriesOnDisk(zipModel.getCentralDirectory().getFileHeaders(), zipModel.getEndCentralDirRecord().getNoOfThisDisk());
                    n2 = 0;
                    break block8;
                }
                catch (Exception exception) {
                    throw new ZipException(exception);
                }
                catch (ZipException zipException) {
                    throw zipException;
                }
            }
            n2 = n3;
        }
        Raw.writeLongLittleEndian(arrby2, 0, n2);
        this.copyByteArrayToArrayList(arrby2, list);
        Raw.writeLongLittleEndian(arrby2, 0, n3);
        this.copyByteArrayToArrayList(arrby2, list);
        Raw.writeLongLittleEndian(arrby2, 0, n);
        this.copyByteArrayToArrayList(arrby2, list);
        Raw.writeLongLittleEndian(arrby2, 0, l);
        this.copyByteArrayToArrayList(arrby2, list);
    }

    private void writeZipHeaderBytes(ZipModel zipModel, OutputStream outputStream, byte[] arrby) throws ZipException {
        if (arrby == null) {
            throw new ZipException("invalid buff to write as zip headers");
        }
        try {
            if (outputStream instanceof SplitOutputStream && ((SplitOutputStream)outputStream).checkBuffSizeAndStartNextSplitFile(arrby.length)) {
                this.finalizeZipFile(zipModel, outputStream);
                return;
            }
            outputStream.write(arrby);
            return;
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    public void finalizeZipFile(ZipModel zipModel, OutputStream outputStream) throws ZipException {
        if (zipModel != null && outputStream != null) {
            try {
                this.processHeaderData(zipModel, outputStream);
                long l = zipModel.getEndCentralDirRecord().getOffsetOfStartOfCentralDir();
                ArrayList arrayList = new ArrayList();
                int n = this.writeCentralDirectory(zipModel, outputStream, arrayList);
                if (zipModel.isZip64Format()) {
                    if (zipModel.getZip64EndCentralDirRecord() == null) {
                        zipModel.setZip64EndCentralDirRecord(new Zip64EndCentralDirRecord());
                    }
                    if (zipModel.getZip64EndCentralDirLocator() == null) {
                        zipModel.setZip64EndCentralDirLocator(new Zip64EndCentralDirLocator());
                    }
                    zipModel.getZip64EndCentralDirLocator().setOffsetZip64EndOfCentralDirRec(l + (long)n);
                    if (outputStream instanceof SplitOutputStream) {
                        zipModel.getZip64EndCentralDirLocator().setNoOfDiskStartOfZip64EndOfCentralDirRec(((SplitOutputStream)outputStream).getCurrSplitFileCounter());
                        zipModel.getZip64EndCentralDirLocator().setTotNumberOfDiscs(((SplitOutputStream)outputStream).getCurrSplitFileCounter() + 1);
                    } else {
                        zipModel.getZip64EndCentralDirLocator().setNoOfDiskStartOfZip64EndOfCentralDirRec(0);
                        zipModel.getZip64EndCentralDirLocator().setTotNumberOfDiscs(1);
                    }
                    this.writeZip64EndOfCentralDirectoryRecord(zipModel, outputStream, n, l, arrayList);
                    this.writeZip64EndOfCentralDirectoryLocator(zipModel, outputStream, arrayList);
                }
                this.writeEndOfCentralDirectoryRecord(zipModel, outputStream, n, l, arrayList);
                this.writeZipHeaderBytes(zipModel, outputStream, this.byteArrayListToByteArray(arrayList));
                return;
            }
            catch (Exception exception) {
                throw new ZipException(exception);
            }
            catch (ZipException zipException) {
                throw zipException;
            }
        }
        throw new ZipException("input parameters is null, cannot finalize zip file");
    }

    public void finalizeZipFileWithoutValidations(ZipModel zipModel, OutputStream outputStream) throws ZipException {
        if (zipModel != null && outputStream != null) {
            try {
                ArrayList arrayList = new ArrayList();
                long l = zipModel.getEndCentralDirRecord().getOffsetOfStartOfCentralDir();
                int n = this.writeCentralDirectory(zipModel, outputStream, arrayList);
                if (zipModel.isZip64Format()) {
                    if (zipModel.getZip64EndCentralDirRecord() == null) {
                        zipModel.setZip64EndCentralDirRecord(new Zip64EndCentralDirRecord());
                    }
                    if (zipModel.getZip64EndCentralDirLocator() == null) {
                        zipModel.setZip64EndCentralDirLocator(new Zip64EndCentralDirLocator());
                    }
                    zipModel.getZip64EndCentralDirLocator().setOffsetZip64EndOfCentralDirRec(l + (long)n);
                    this.writeZip64EndOfCentralDirectoryRecord(zipModel, outputStream, n, l, arrayList);
                    this.writeZip64EndOfCentralDirectoryLocator(zipModel, outputStream, arrayList);
                }
                this.writeEndOfCentralDirectoryRecord(zipModel, outputStream, n, l, arrayList);
                this.writeZipHeaderBytes(zipModel, outputStream, this.byteArrayListToByteArray(arrayList));
                return;
            }
            catch (Exception exception) {
                throw new ZipException(exception);
            }
            catch (ZipException zipException) {
                throw zipException;
            }
        }
        throw new ZipException("input parameters is null, cannot finalize zip file without validations");
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void updateLocalFileHeader(LocalFileHeader localFileHeader, long l, int n, ZipModel zipModel, byte[] arrby, int n2, SplitOutputStream splitOutputStream) throws ZipException {
        if (localFileHeader == null) throw new ZipException("invalid input parameters, cannot update local file header");
        if (l < 0L) throw new ZipException("invalid input parameters, cannot update local file header");
        if (zipModel == null) {
            throw new ZipException("invalid input parameters, cannot update local file header");
        }
        try {
            Object object;
            if (n2 != splitOutputStream.getCurrSplitFileCounter()) {
                object = new File(zipModel.getZipFile());
                CharSequence charSequence = object.getParent();
                object = Zip4jUtil.getZipFileNameWithoutExt(object.getName());
                charSequence = new StringBuffer(String.valueOf(charSequence));
                charSequence.append(System.getProperty("file.separator"));
                charSequence = charSequence.toString();
                if (n2 < 9) {
                    charSequence = new StringBuffer(String.valueOf(charSequence));
                    charSequence.append((String)object);
                    charSequence.append(".z0");
                    charSequence.append(n2 + 1);
                    object = charSequence.toString();
                } else {
                    charSequence = new StringBuffer(String.valueOf(charSequence));
                    charSequence.append((String)object);
                    charSequence.append(".z");
                    charSequence.append(n2 + 1);
                    object = charSequence.toString();
                }
                object = new SplitOutputStream(new File((String)object));
                n2 = 1;
            } else {
                object = splitOutputStream;
                n2 = 0;
            }
            long l2 = object.getFilePointer();
            if (n != 14) {
                if (n == 18 || n == 22) {
                    this.updateCompressedSizeInLocalFileHeader((SplitOutputStream)object, localFileHeader, l, n, arrby, zipModel.isZip64Format());
                }
            } else {
                object.seek(l + (long)n);
                object.write(arrby);
            }
            if (n2 != 0) {
                object.close();
                return;
            }
            splitOutputStream.seek(l2);
            return;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
    }

    public int writeExtendedLocalHeader(LocalFileHeader arrby, OutputStream outputStream) throws ZipException, IOException {
        if (arrby != null && outputStream != null) {
            long l;
            ArrayList arrayList = new ArrayList();
            byte[] arrby2 = new byte[4];
            Raw.writeIntLittleEndian(arrby2, 0, 134695760);
            this.copyByteArrayToArrayList(arrby2, arrayList);
            Raw.writeIntLittleEndian(arrby2, 0, (int)arrby.getCrc32());
            this.copyByteArrayToArrayList(arrby2, arrayList);
            long l2 = l = arrby.getCompressedSize();
            if (l >= Integer.MAX_VALUE) {
                l2 = Integer.MAX_VALUE;
            }
            Raw.writeIntLittleEndian(arrby2, 0, (int)l2);
            this.copyByteArrayToArrayList(arrby2, arrayList);
            l2 = l = arrby.getUncompressedSize();
            if (l >= Integer.MAX_VALUE) {
                l2 = Integer.MAX_VALUE;
            }
            Raw.writeIntLittleEndian(arrby2, 0, (int)l2);
            this.copyByteArrayToArrayList(arrby2, arrayList);
            arrby = this.byteArrayListToByteArray(arrayList);
            outputStream.write(arrby);
            return arrby.length;
        }
        throw new ZipException("input parameters is null, cannot write extended local header");
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public int writeLocalFileHeader(ZipModel object, LocalFileHeader localFileHeader, OutputStream outputStream) throws ZipException {
        byte[] arrby;
        ArrayList arrayList;
        byte[] arrby2;
        boolean bl;
        byte[] arrby3;
        int n;
        block12 : {
            if (localFileHeader == null) {
                throw new ZipException("input parameters are null, cannot write local file header");
            }
            arrayList = new ArrayList();
            arrby2 = new byte[2];
            byte[] arrby4 = new byte[4];
            arrby = new byte[8];
            arrby3 = new byte[8];
            Raw.writeIntLittleEndian(arrby4, 0, localFileHeader.getSignature());
            this.copyByteArrayToArrayList(arrby4, arrayList);
            Raw.writeShortLittleEndian(arrby2, 0, (short)localFileHeader.getVersionNeededToExtract());
            this.copyByteArrayToArrayList(arrby2, arrayList);
            this.copyByteArrayToArrayList(localFileHeader.getGeneralPurposeFlag(), arrayList);
            Raw.writeShortLittleEndian(arrby2, 0, (short)localFileHeader.getCompressionMethod());
            this.copyByteArrayToArrayList(arrby2, arrayList);
            Raw.writeIntLittleEndian(arrby4, 0, localFileHeader.getLastModFileTime());
            this.copyByteArrayToArrayList(arrby4, arrayList);
            Raw.writeIntLittleEndian(arrby4, 0, (int)localFileHeader.getCrc32());
            this.copyByteArrayToArrayList(arrby4, arrayList);
            if (localFileHeader.getUncompressedSize() + 50L >= 0xFFFFFFFFL) {
                Raw.writeLongLittleEndian(arrby, 0, 0xFFFFFFFFL);
                System.arraycopy(arrby, 0, arrby4, 0, 4);
                this.copyByteArrayToArrayList(arrby4, arrayList);
                this.copyByteArrayToArrayList(arrby4, arrayList);
                object.setZip64Format(true);
                localFileHeader.setWriteComprSizeInZip64ExtraRecord(true);
                bl = true;
            } else {
                Raw.writeLongLittleEndian(arrby, 0, localFileHeader.getCompressedSize());
                System.arraycopy(arrby, 0, arrby4, 0, 4);
                this.copyByteArrayToArrayList(arrby4, arrayList);
                Raw.writeLongLittleEndian(arrby, 0, localFileHeader.getUncompressedSize());
                System.arraycopy(arrby, 0, arrby4, 0, 4);
                this.copyByteArrayToArrayList(arrby4, arrayList);
                localFileHeader.setWriteComprSizeInZip64ExtraRecord(false);
                bl = false;
            }
            Raw.writeShortLittleEndian(arrby2, 0, (short)localFileHeader.getFileNameLength());
            this.copyByteArrayToArrayList(arrby2, arrayList);
            int n2 = bl ? 20 : 0;
            n = n2;
            if (localFileHeader.getAesExtraDataRecord() == null) break block12;
            n = n2 + 11;
        }
        try {
            Raw.writeShortLittleEndian(arrby2, 0, (short)n);
            this.copyByteArrayToArrayList(arrby2, arrayList);
            if (Zip4jUtil.isStringNotNullAndNotEmpty(object.getFileNameCharset())) {
                this.copyByteArrayToArrayList(localFileHeader.getFileName().getBytes(object.getFileNameCharset()), arrayList);
            } else {
                this.copyByteArrayToArrayList(Zip4jUtil.convertCharset(localFileHeader.getFileName()), arrayList);
            }
            if (bl) {
                Raw.writeShortLittleEndian(arrby2, 0, (short)1);
                this.copyByteArrayToArrayList(arrby2, arrayList);
                Raw.writeShortLittleEndian(arrby2, 0, (short)16);
                this.copyByteArrayToArrayList(arrby2, arrayList);
                Raw.writeLongLittleEndian(arrby, 0, localFileHeader.getUncompressedSize());
                this.copyByteArrayToArrayList(arrby, arrayList);
                this.copyByteArrayToArrayList(arrby3, arrayList);
            }
            if (localFileHeader.getAesExtraDataRecord() != null) {
                object = localFileHeader.getAesExtraDataRecord();
                Raw.writeShortLittleEndian(arrby2, 0, (short)object.getSignature());
                this.copyByteArrayToArrayList(arrby2, arrayList);
                Raw.writeShortLittleEndian(arrby2, 0, (short)object.getDataSize());
                this.copyByteArrayToArrayList(arrby2, arrayList);
                Raw.writeShortLittleEndian(arrby2, 0, (short)object.getVersionNumber());
                this.copyByteArrayToArrayList(arrby2, arrayList);
                this.copyByteArrayToArrayList(object.getVendorID().getBytes(), arrayList);
                this.copyByteArrayToArrayList(new byte[]{(byte)object.getAesStrength()}, arrayList);
                Raw.writeShortLittleEndian(arrby2, 0, (short)object.getCompressionMethod());
                this.copyByteArrayToArrayList(arrby2, arrayList);
            }
            object = this.byteArrayListToByteArray(arrayList);
            outputStream.write((byte[])object);
            return ((Object)object).length;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
        catch (ZipException zipException) {
            throw zipException;
        }
    }
}

