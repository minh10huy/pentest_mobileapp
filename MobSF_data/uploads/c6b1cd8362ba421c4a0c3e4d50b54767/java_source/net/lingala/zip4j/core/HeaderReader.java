/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.core;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.model.AESExtraDataRecord;
import net.lingala.zip4j.model.CentralDirectory;
import net.lingala.zip4j.model.DigitalSignature;
import net.lingala.zip4j.model.EndCentralDirRecord;
import net.lingala.zip4j.model.ExtraDataRecord;
import net.lingala.zip4j.model.FileHeader;
import net.lingala.zip4j.model.LocalFileHeader;
import net.lingala.zip4j.model.Zip64EndCentralDirLocator;
import net.lingala.zip4j.model.Zip64EndCentralDirRecord;
import net.lingala.zip4j.model.Zip64ExtendedInfo;
import net.lingala.zip4j.model.ZipModel;
import net.lingala.zip4j.util.Raw;
import net.lingala.zip4j.util.Zip4jUtil;

public class HeaderReader {
    private RandomAccessFile zip4jRaf = null;
    private ZipModel zipModel;

    public HeaderReader(RandomAccessFile randomAccessFile) {
        this.zip4jRaf = randomAccessFile;
    }

    private byte[] getLongByteFromIntByte(byte[] arrby) throws ZipException {
        if (arrby == null) {
            throw new ZipException("input parameter is null, cannot expand to 8 bytes");
        }
        if (arrby.length != 4) {
            throw new ZipException("invalid byte length, cannot expand to 8 bytes");
        }
        byte[] arrby2 = new byte[8];
        arrby2[0] = arrby[0];
        arrby2[1] = arrby[1];
        arrby2[2] = arrby[2];
        arrby2[3] = arrby[3];
        return arrby2;
    }

    private AESExtraDataRecord readAESExtraDataRecord(ArrayList object) throws ZipException {
        if (object == null) {
            return null;
        }
        int n = 0;
        while (n < object.size()) {
            byte[] arrby = (byte[])object.get(n);
            if (arrby != null && arrby.getHeader() == 39169L) {
                if (arrby.getData() == null) {
                    throw new ZipException("corrput AES extra data records");
                }
                object = new AESExtraDataRecord();
                object.setSignature(39169L);
                object.setDataSize(arrby.getSizeOfData());
                arrby = arrby.getData();
                object.setVersionNumber(Raw.readShortLittleEndian(arrby, 0));
                byte[] arrby2 = new byte[2];
                System.arraycopy(arrby, 2, arrby2, 0, 2);
                object.setVendorID(new String(arrby2));
                object.setAesStrength(arrby[4] & 255);
                object.setCompressionMethod(Raw.readShortLittleEndian(arrby, 5));
                return object;
            }
            ++n;
        }
        return null;
    }

    private void readAndSaveAESExtraDataRecord(FileHeader fileHeader) throws ZipException {
        if (fileHeader == null) {
            throw new ZipException("file header is null in reading Zip64 Extended Info");
        }
        if (fileHeader.getExtraDataRecords() != null) {
            if (fileHeader.getExtraDataRecords().size() <= 0) {
                return;
            }
            AESExtraDataRecord aESExtraDataRecord = this.readAESExtraDataRecord(fileHeader.getExtraDataRecords());
            if (aESExtraDataRecord != null) {
                fileHeader.setAesExtraDataRecord(aESExtraDataRecord);
                fileHeader.setEncryptionMethod(99);
            }
            return;
        }
    }

    private void readAndSaveAESExtraDataRecord(LocalFileHeader localFileHeader) throws ZipException {
        if (localFileHeader == null) {
            throw new ZipException("file header is null in reading Zip64 Extended Info");
        }
        if (localFileHeader.getExtraDataRecords() != null) {
            if (localFileHeader.getExtraDataRecords().size() <= 0) {
                return;
            }
            AESExtraDataRecord aESExtraDataRecord = this.readAESExtraDataRecord(localFileHeader.getExtraDataRecords());
            if (aESExtraDataRecord != null) {
                localFileHeader.setAesExtraDataRecord(aESExtraDataRecord);
                localFileHeader.setEncryptionMethod(99);
            }
            return;
        }
    }

    private void readAndSaveExtraDataRecord(FileHeader fileHeader) throws ZipException {
        if (this.zip4jRaf == null) {
            throw new ZipException("invalid file handler when trying to read extra data record");
        }
        if (fileHeader == null) {
            throw new ZipException("file header is null");
        }
        int n = fileHeader.getExtraFieldLength();
        if (n <= 0) {
            return;
        }
        fileHeader.setExtraDataRecords(this.readExtraDataRecords(n));
    }

    private void readAndSaveExtraDataRecord(LocalFileHeader localFileHeader) throws ZipException {
        if (this.zip4jRaf == null) {
            throw new ZipException("invalid file handler when trying to read extra data record");
        }
        if (localFileHeader == null) {
            throw new ZipException("file header is null");
        }
        int n = localFileHeader.getExtraFieldLength();
        if (n <= 0) {
            return;
        }
        localFileHeader.setExtraDataRecords(this.readExtraDataRecords(n));
    }

    private void readAndSaveZip64ExtendedInfo(FileHeader fileHeader) throws ZipException {
        if (fileHeader == null) {
            throw new ZipException("file header is null in reading Zip64 Extended Info");
        }
        if (fileHeader.getExtraDataRecords() != null) {
            if (fileHeader.getExtraDataRecords().size() <= 0) {
                return;
            }
            Zip64ExtendedInfo zip64ExtendedInfo = this.readZip64ExtendedInfo(fileHeader.getExtraDataRecords(), fileHeader.getUncompressedSize(), fileHeader.getCompressedSize(), fileHeader.getOffsetLocalHeader(), fileHeader.getDiskNumberStart());
            if (zip64ExtendedInfo != null) {
                fileHeader.setZip64ExtendedInfo(zip64ExtendedInfo);
                if (zip64ExtendedInfo.getUnCompressedSize() != -1L) {
                    fileHeader.setUncompressedSize(zip64ExtendedInfo.getUnCompressedSize());
                }
                if (zip64ExtendedInfo.getCompressedSize() != -1L) {
                    fileHeader.setCompressedSize(zip64ExtendedInfo.getCompressedSize());
                }
                if (zip64ExtendedInfo.getOffsetLocalHeader() != -1L) {
                    fileHeader.setOffsetLocalHeader(zip64ExtendedInfo.getOffsetLocalHeader());
                }
                if (zip64ExtendedInfo.getDiskNumberStart() != -1) {
                    fileHeader.setDiskNumberStart(zip64ExtendedInfo.getDiskNumberStart());
                }
            }
            return;
        }
    }

    private void readAndSaveZip64ExtendedInfo(LocalFileHeader localFileHeader) throws ZipException {
        if (localFileHeader == null) {
            throw new ZipException("file header is null in reading Zip64 Extended Info");
        }
        if (localFileHeader.getExtraDataRecords() != null) {
            if (localFileHeader.getExtraDataRecords().size() <= 0) {
                return;
            }
            Zip64ExtendedInfo zip64ExtendedInfo = this.readZip64ExtendedInfo(localFileHeader.getExtraDataRecords(), localFileHeader.getUncompressedSize(), localFileHeader.getCompressedSize(), -1L, -1);
            if (zip64ExtendedInfo != null) {
                localFileHeader.setZip64ExtendedInfo(zip64ExtendedInfo);
                if (zip64ExtendedInfo.getUnCompressedSize() != -1L) {
                    localFileHeader.setUncompressedSize(zip64ExtendedInfo.getUnCompressedSize());
                }
                if (zip64ExtendedInfo.getCompressedSize() != -1L) {
                    localFileHeader.setCompressedSize(zip64ExtendedInfo.getCompressedSize());
                }
            }
            return;
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private CentralDirectory readCentralDirectory() throws ZipException {
        if (this.zip4jRaf == null) {
            throw new ZipException("random access file was null", 3);
        }
        if (this.zipModel.getEndCentralDirRecord() == null) {
            throw new ZipException("EndCentralRecord was null, maybe a corrupt zip file");
        }
        try {
            var11_1 = new CentralDirectory();
            var12_2 = new ArrayList<FileHeader>();
            var9_3 = this.zipModel.getEndCentralDirRecord();
            var5_5 = var9_3.getOffsetOfStartOfCentralDir();
            var1_6 = var9_3.getTotNoOfEntriesInCentralDir();
            if (this.zipModel.isZip64Format()) {
                var5_5 = this.zipModel.getZip64EndCentralDirRecord().getOffsetStartCenDirWRTStartDiskNo();
                var1_6 = (int)this.zipModel.getZip64EndCentralDirRecord().getTotNoOfEntriesInCentralDir();
            }
            this.zip4jRaf.seek(var5_5);
            var13_7 = new byte[4];
            var14_8 = new byte[2];
            var9_3 = new byte[8];
            var2_9 = 0;
            do {
                if (var2_9 >= var1_6) {
                    var11_1.setFileHeaders(var12_2);
                    var9_3 = new DigitalSignature();
                    this.readIntoBuff(this.zip4jRaf, var13_7);
                    var1_6 = Raw.readIntLittleEndian(var13_7, 0);
                    if ((long)var1_6 != 84233040L) {
                        return var11_1;
                    }
                    var9_3.setHeaderSignature(var1_6);
                    this.readIntoBuff(this.zip4jRaf, var14_8);
                    var1_6 = Raw.readShortLittleEndian(var14_8, 0);
                    var9_3.setSizeOfData(var1_6);
                    if (var1_6 <= 0) return var11_1;
                    var10_14 = new byte[var1_6];
                    this.readIntoBuff(this.zip4jRaf, (byte[])var10_14);
                    var9_3.setSignatureData(new String((byte[])var10_14));
                    return var11_1;
                }
                var15_15 = new FileHeader();
                this.readIntoBuff(this.zip4jRaf, var13_7);
                var3_10 = Raw.readIntLittleEndian(var13_7, 0);
                var5_5 = var3_10;
                var8_13 = true;
                if (var5_5 != 33639248L) {
                    var9_3 = new StringBuffer("Expected central directory entry not found (#");
                    var9_3.append(var2_9 + 1);
                    var9_3.append(")");
                    throw new ZipException(var9_3.toString());
                }
                var15_15.setSignature(var3_10);
                this.readIntoBuff(this.zip4jRaf, var14_8);
                var15_15.setVersionMadeBy(Raw.readShortLittleEndian(var14_8, 0));
                this.readIntoBuff(this.zip4jRaf, var14_8);
                var15_15.setVersionNeededToExtract(Raw.readShortLittleEndian(var14_8, 0));
                this.readIntoBuff(this.zip4jRaf, var14_8);
                var7_12 = (Raw.readShortLittleEndian(var14_8, 0) & 2048) != 0;
                var15_15.setFileNameUTF8Encoded(var7_12);
                break;
            } while (true);
        }
        catch (IOException var9_4) {
            throw new ZipException(var9_4);
        }
        {
            var3_10 = var14_8[0];
            if ((var3_10 & 1) == 0) ** GOTO lbl60
            var15_15.setEncrypted(true);
lbl60: // 2 sources:
            var15_15.setGeneralPurposeFlag((byte[])var14_8.clone());
            var7_12 = var3_10 >> 3 == 1;
            var15_15.setDataDescriptorExists(var7_12);
            this.readIntoBuff(this.zip4jRaf, var14_8);
            var15_15.setCompressionMethod(Raw.readShortLittleEndian(var14_8, 0));
            this.readIntoBuff(this.zip4jRaf, var13_7);
            var15_15.setLastModFileTime(Raw.readIntLittleEndian(var13_7, 0));
            this.readIntoBuff(this.zip4jRaf, var13_7);
            var15_15.setCrc32(Raw.readIntLittleEndian(var13_7, 0));
            var15_15.setCrcBuff((byte[])var13_7.clone());
            this.readIntoBuff(this.zip4jRaf, var13_7);
            var15_15.setCompressedSize(Raw.readLongLittleEndian(this.getLongByteFromIntByte(var13_7), 0));
            this.readIntoBuff(this.zip4jRaf, var13_7);
            var15_15.setUncompressedSize(Raw.readLongLittleEndian(this.getLongByteFromIntByte(var13_7), 0));
            this.readIntoBuff(this.zip4jRaf, var14_8);
            var3_10 = Raw.readShortLittleEndian(var14_8, 0);
            var15_15.setFileNameLength(var3_10);
            this.readIntoBuff(this.zip4jRaf, var14_8);
            var15_15.setExtraFieldLength(Raw.readShortLittleEndian(var14_8, 0));
            this.readIntoBuff(this.zip4jRaf, var14_8);
            var4_11 = Raw.readShortLittleEndian(var14_8, 0);
            var15_15.setFileComment(new String(var14_8));
            this.readIntoBuff(this.zip4jRaf, var14_8);
            var15_15.setDiskNumberStart(Raw.readShortLittleEndian(var14_8, 0));
            this.readIntoBuff(this.zip4jRaf, var14_8);
            var15_15.setInternalFileAttr((byte[])var14_8.clone());
            this.readIntoBuff(this.zip4jRaf, var13_7);
            var15_15.setExternalFileAttr((byte[])var13_7.clone());
            this.readIntoBuff(this.zip4jRaf, var13_7);
            var15_15.setOffsetLocalHeader(Raw.readLongLittleEndian(this.getLongByteFromIntByte(var13_7), 0) & 0xFFFFFFFFL);
            if (var3_10 > 0) {
                var9_3 = new byte[var3_10];
                this.readIntoBuff(this.zip4jRaf, (byte[])var9_3);
                var9_3 = Zip4jUtil.isStringNotNullAndNotEmpty(this.zipModel.getFileNameCharset()) != false ? new String((byte[])var9_3, this.zipModel.getFileNameCharset()) : Zip4jUtil.decodeFileName((byte[])var9_3, var15_15.isFileNameUTF8Encoded());
                if (var9_3 == null) {
                    throw new ZipException("fileName is null when reading central directory");
                }
                var16_16 = new StringBuffer(":");
                var16_16.append(System.getProperty("file.separator"));
                var10_14 = var9_3;
                if (var9_3.indexOf(var16_16.toString()) >= 0) {
                    var10_14 = new StringBuffer(":");
                    var10_14.append(System.getProperty("file.separator"));
                    var10_14 = var9_3.substring(var9_3.indexOf(var10_14.toString()) + 2);
                }
                var15_15.setFileName((String)var10_14);
                var7_12 = var8_13;
                if (!var10_14.endsWith("/")) {
                    var7_12 = var8_13;
                    if (!var10_14.endsWith("\\")) {
                        var7_12 = false;
                    }
                }
                var15_15.setDirectory(var7_12);
            } else {
                var15_15.setFileName(null);
            }
            this.readAndSaveExtraDataRecord(var15_15);
            this.readAndSaveZip64ExtendedInfo(var15_15);
            this.readAndSaveAESExtraDataRecord(var15_15);
            if (var4_11 > 0) {
                var9_3 = new byte[var4_11];
                this.readIntoBuff(this.zip4jRaf, (byte[])var9_3);
                var15_15.setFileComment(new String((byte[])var9_3));
            }
            var12_2.add(var15_15);
            ++var2_9;
            continue;
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private EndCentralDirRecord readEndOfCentralDirectoryRecord() throws ZipException {
        if (this.zip4jRaf == null) {
            throw new ZipException("random access file was null", 3);
        }
        try {
            var5_1 = new byte[4];
            var2_2 = this.zip4jRaf.length() - 22L;
            var4_3 = new EndCentralDirRecord();
            var1_5 = 0;
lbl8: // 2 sources:
            this.zip4jRaf.seek(var2_2);
            if ((long)Raw.readLeInt(this.zip4jRaf, var5_1) == 101010256L || ++var1_5 > 3000) {
                if ((long)Raw.readIntLittleEndian(var5_1, 0) != 101010256L) {
                    throw new ZipException("zip headers not found. probably not a zip file");
                }
                var5_1 = new byte[4];
                var6_6 = new byte[2];
                var4_3.setSignature(101010256L);
                this.readIntoBuff(this.zip4jRaf, var6_6);
                var4_3.setNoOfThisDisk(Raw.readShortLittleEndian(var6_6, 0));
                this.readIntoBuff(this.zip4jRaf, var6_6);
                var4_3.setNoOfThisDiskStartOfCentralDir(Raw.readShortLittleEndian(var6_6, 0));
                this.readIntoBuff(this.zip4jRaf, var6_6);
                var4_3.setTotNoOfEntriesInCentralDirOnThisDisk(Raw.readShortLittleEndian(var6_6, 0));
                this.readIntoBuff(this.zip4jRaf, var6_6);
                var4_3.setTotNoOfEntriesInCentralDir(Raw.readShortLittleEndian(var6_6, 0));
                this.readIntoBuff(this.zip4jRaf, var5_1);
                var4_3.setSizeOfCentralDir(Raw.readIntLittleEndian(var5_1, 0));
                this.readIntoBuff(this.zip4jRaf, var5_1);
                var4_3.setOffsetOfStartOfCentralDir(Raw.readLongLittleEndian(this.getLongByteFromIntByte(var5_1), 0));
                this.readIntoBuff(this.zip4jRaf, var6_6);
                var1_5 = Raw.readShortLittleEndian(var6_6, 0);
                var4_3.setCommentLength(var1_5);
                if (var1_5 > 0) {
                    var5_1 = new byte[var1_5];
                    this.readIntoBuff(this.zip4jRaf, var5_1);
                    var4_3.setComment(new String(var5_1));
                    var4_3.setCommentBytes(var5_1);
                } else {
                    var4_3.setComment(null);
                }
                if (var4_3.getNoOfThisDisk() > 0) {
                    this.zipModel.setSplitArchive(true);
                    return var4_3;
                }
                this.zipModel.setSplitArchive(false);
                return var4_3;
            }
        }
        catch (IOException var4_4) {
            throw new ZipException("Probably not a zip file or a corrupted zip file", var4_4, 4);
        }
        --var2_2;
        ** GOTO lbl8
    }

    private ArrayList readExtraDataRecords(int n) throws ZipException {
        int n2;
        ArrayList<ExtraDataRecord> arrayList;
        byte[] arrby;
        if (n <= 0) {
            return null;
        }
        try {
            arrby = new byte[n];
            this.zip4jRaf.read(arrby);
            arrayList = new ArrayList<ExtraDataRecord>();
            n2 = 0;
            do {
                if (n2 >= n) break block12;
                break;
            } while (true);
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
        {
            int n3;
            ExtraDataRecord extraDataRecord;
            block14 : {
                int n4;
                block13 : {
                    block12 : {
                        extraDataRecord = new ExtraDataRecord();
                        extraDataRecord.setHeader(Raw.readShortLittleEndian(arrby, n2));
                        n4 = n2 + 2;
                        n2 = n3 = Raw.readShortLittleEndian(arrby, n4);
                        if (n3 + 2 <= n) break block13;
                        n2 = n3 = (int)Raw.readShortBigEndian(arrby, n4);
                        if (n3 + 2 <= n) break block13;
                    }
                    if (arrayList.size() > 0) {
                        return arrayList;
                    }
                }
                extraDataRecord.setSizeOfData(n2);
                n3 = n4 + 2;
                if (n2 <= 0) break block14;
                byte[] arrby2 = new byte[n2];
                System.arraycopy(arrby, n3, arrby2, 0, n2);
                extraDataRecord.setData(arrby2);
            }
            n2 = n3 + n2;
            arrayList.add(extraDataRecord);
            continue;
        }
        return null;
    }

    private byte[] readIntoBuff(RandomAccessFile randomAccessFile, byte[] arrby) throws ZipException {
        block3 : {
            try {
                if (randomAccessFile.read(arrby, 0, arrby.length) == -1) break block3;
                return arrby;
            }
            catch (IOException iOException) {
                throw new ZipException("IOException when reading short buff", iOException);
            }
        }
        throw new ZipException("unexpected end of file when reading short buff");
    }

    private Zip64EndCentralDirLocator readZip64EndCentralDirLocator() throws ZipException {
        block5 : {
            byte[] arrby;
            Zip64EndCentralDirLocator zip64EndCentralDirLocator;
            byte[] arrby2;
            long l;
            if (this.zip4jRaf == null) {
                throw new ZipException("invalid file handler when trying to read Zip64EndCentralDirLocator");
            }
            try {
                zip64EndCentralDirLocator = new Zip64EndCentralDirLocator();
                this.setFilePointerToReadZip64EndCentralDirLoc();
                arrby = new byte[4];
                arrby2 = new byte[8];
                this.readIntoBuff(this.zip4jRaf, arrby);
                l = Raw.readIntLittleEndian(arrby, 0);
                if (l != 117853008L) break block5;
            }
            catch (Exception exception) {
                throw new ZipException(exception);
            }
            this.zipModel.setZip64Format(true);
            zip64EndCentralDirLocator.setSignature(l);
            this.readIntoBuff(this.zip4jRaf, arrby);
            zip64EndCentralDirLocator.setNoOfDiskStartOfZip64EndOfCentralDirRec(Raw.readIntLittleEndian(arrby, 0));
            this.readIntoBuff(this.zip4jRaf, arrby2);
            zip64EndCentralDirLocator.setOffsetZip64EndOfCentralDirRec(Raw.readLongLittleEndian(arrby2, 0));
            this.readIntoBuff(this.zip4jRaf, arrby);
            zip64EndCentralDirLocator.setTotNumberOfDiscs(Raw.readIntLittleEndian(arrby, 0));
            return zip64EndCentralDirLocator;
        }
        this.zipModel.setZip64Format(false);
        return null;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private Zip64EndCentralDirRecord readZip64EndCentralDirRec() throws ZipException {
        if (this.zipModel.getZip64EndCentralDirLocator() == null) {
            throw new ZipException("invalid zip64 end of central directory locator");
        }
        long l = this.zipModel.getZip64EndCentralDirLocator().getOffsetZip64EndOfCentralDirRec();
        if (l < 0L) {
            throw new ZipException("invalid offset for start of end of central directory record");
        }
        try {
            this.zip4jRaf.seek(l);
            Zip64EndCentralDirRecord zip64EndCentralDirRecord = new Zip64EndCentralDirRecord();
            byte[] arrby = new byte[2];
            byte[] arrby2 = new byte[4];
            byte[] arrby3 = new byte[8];
            this.readIntoBuff(this.zip4jRaf, arrby2);
            l = Raw.readIntLittleEndian(arrby2, 0);
            if (l != 101075792L) {
                throw new ZipException("invalid signature for zip64 end of central directory record");
            }
            zip64EndCentralDirRecord.setSignature(l);
            this.readIntoBuff(this.zip4jRaf, arrby3);
            zip64EndCentralDirRecord.setSizeOfZip64EndCentralDirRec(Raw.readLongLittleEndian(arrby3, 0));
            this.readIntoBuff(this.zip4jRaf, arrby);
            zip64EndCentralDirRecord.setVersionMadeBy(Raw.readShortLittleEndian(arrby, 0));
            this.readIntoBuff(this.zip4jRaf, arrby);
            zip64EndCentralDirRecord.setVersionNeededToExtract(Raw.readShortLittleEndian(arrby, 0));
            this.readIntoBuff(this.zip4jRaf, arrby2);
            zip64EndCentralDirRecord.setNoOfThisDisk(Raw.readIntLittleEndian(arrby2, 0));
            this.readIntoBuff(this.zip4jRaf, arrby2);
            zip64EndCentralDirRecord.setNoOfThisDiskStartOfCentralDir(Raw.readIntLittleEndian(arrby2, 0));
            this.readIntoBuff(this.zip4jRaf, arrby3);
            zip64EndCentralDirRecord.setTotNoOfEntriesInCentralDirOnThisDisk(Raw.readLongLittleEndian(arrby3, 0));
            this.readIntoBuff(this.zip4jRaf, arrby3);
            zip64EndCentralDirRecord.setTotNoOfEntriesInCentralDir(Raw.readLongLittleEndian(arrby3, 0));
            this.readIntoBuff(this.zip4jRaf, arrby3);
            zip64EndCentralDirRecord.setSizeOfCentralDir(Raw.readLongLittleEndian(arrby3, 0));
            this.readIntoBuff(this.zip4jRaf, arrby3);
            zip64EndCentralDirRecord.setOffsetStartCenDirWRTStartDiskNo(Raw.readLongLittleEndian(arrby3, 0));
            l = zip64EndCentralDirRecord.getSizeOfZip64EndCentralDirRec() - 44L;
            if (l > 0L) {
                arrby = new byte[(int)l];
                this.readIntoBuff(this.zip4jRaf, arrby);
                zip64EndCentralDirRecord.setExtensibleDataSector(arrby);
            }
            return zip64EndCentralDirRecord;
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private Zip64ExtendedInfo readZip64ExtendedInfo(ArrayList object, long l, long l2, long l3, int n) throws ZipException {
        int n2 = 0;
        while (n2 < object.size()) {
            ExtraDataRecord extraDataRecord = (ExtraDataRecord)object.get(n2);
            if (extraDataRecord != null && extraDataRecord.getHeader() == 1L) {
                boolean bl;
                object = new Zip64ExtendedInfo();
                byte[] arrby = extraDataRecord.getData();
                if (extraDataRecord.getSizeOfData() <= 0) return null;
                byte[] arrby2 = new byte[8];
                byte[] arrby3 = new byte[4];
                boolean bl2 = true;
                if ((l & 65535L) == 65535L && extraDataRecord.getSizeOfData() > 0) {
                    System.arraycopy(arrby, 0, arrby2, 0, 8);
                    object.setUnCompressedSize(Raw.readLongLittleEndian(arrby2, 0));
                    n2 = 8;
                    bl = true;
                } else {
                    n2 = 0;
                    bl = false;
                }
                if ((l2 & 65535L) == 65535L && n2 < extraDataRecord.getSizeOfData()) {
                    System.arraycopy(arrby, n2, arrby2, 0, 8);
                    object.setCompressedSize(Raw.readLongLittleEndian(arrby2, 0));
                    n2 += 8;
                    bl = true;
                }
                int n3 = n2;
                boolean bl3 = bl;
                if ((l3 & 65535L) == 65535L) {
                    n3 = n2;
                    bl3 = bl;
                    if (n2 < extraDataRecord.getSizeOfData()) {
                        System.arraycopy(arrby, n2, arrby2, 0, 8);
                        object.setOffsetLocalHeader(Raw.readLongLittleEndian(arrby2, 0));
                        n3 = n2 + 8;
                        bl3 = true;
                    }
                }
                if ((n & 65535) != 65535) return object;
                if (n3 < extraDataRecord.getSizeOfData()) {
                    System.arraycopy(arrby, n3, arrby3, 0, 4);
                    object.setDiskNumberStart(Raw.readIntLittleEndian(arrby3, 0));
                    bl3 = bl2;
                }
                if (!bl3) return null;
                return object;
            }
            ++n2;
        }
        return null;
    }

    private void setFilePointerToReadZip64EndCentralDirLoc() throws ZipException {
        try {
            byte[] arrby = new byte[4];
            long l = this.zip4jRaf.length() - 22L;
            do {
                this.zip4jRaf.seek(l);
                if ((long)Raw.readLeInt(this.zip4jRaf, arrby) == 101010256L) {
                    this.zip4jRaf.seek(this.zip4jRaf.getFilePointer() - 4L - 4L - 8L - 4L - 4L);
                    return;
                }
                --l;
            } while (true);
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    public ZipModel readAllHeaders() throws ZipException {
        return this.readAllHeaders(null);
    }

    public ZipModel readAllHeaders(String string2) throws ZipException {
        this.zipModel = new ZipModel();
        this.zipModel.setFileNameCharset(string2);
        this.zipModel.setEndCentralDirRecord(this.readEndOfCentralDirectoryRecord());
        this.zipModel.setZip64EndCentralDirLocator(this.readZip64EndCentralDirLocator());
        if (this.zipModel.isZip64Format()) {
            this.zipModel.setZip64EndCentralDirRecord(this.readZip64EndCentralDirRec());
            if (this.zipModel.getZip64EndCentralDirRecord() != null && this.zipModel.getZip64EndCentralDirRecord().getNoOfThisDisk() > 0) {
                this.zipModel.setSplitArchive(true);
            } else {
                this.zipModel.setSplitArchive(false);
            }
        }
        this.zipModel.setCentralDirectory(this.readCentralDirectory());
        return this.zipModel;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public LocalFileHeader readLocalFileHeader(FileHeader var1_1) throws ZipException {
        block17 : {
            block16 : {
                if (var1_1 == null) throw new ZipException("invalid read parameters for local header");
                if (this.zip4jRaf == null) {
                    throw new ZipException("invalid read parameters for local header");
                }
                var6_4 = var8_3 = var1_1.getOffsetLocalHeader();
                if (var1_1.getZip64ExtendedInfo() != null) {
                    var6_4 = var8_3;
                    if (var1_1.getZip64ExtendedInfo().getOffsetLocalHeader() > 0L) {
                        var6_4 = var1_1.getOffsetLocalHeader();
                    }
                }
                if (var6_4 < 0L) {
                    throw new ZipException("invalid local header offset");
                }
                try {
                    this.zip4jRaf.seek(var6_4);
                    var13_5 = new LocalFileHeader();
                    var11_6 = new byte[2];
                    var12_7 = new byte[4];
                    var14_8 = new byte[8];
                    this.readIntoBuff(this.zip4jRaf, (byte[])var12_7);
                    var2_9 = Raw.readIntLittleEndian((byte[])var12_7, 0);
                    if ((long)var2_9 != 67324752L) {
                        var11_6 = new StringBuffer("invalid local header signature for file: ");
                        var11_6.append(var1_1.getFileName());
                        throw new ZipException(var11_6.toString());
                    }
                    var13_5.setSignature(var2_9);
                    this.readIntoBuff(this.zip4jRaf, (byte[])var11_6);
                    var13_5.setVersionNeededToExtract(Raw.readShortLittleEndian((byte[])var11_6, 0));
                    this.readIntoBuff(this.zip4jRaf, (byte[])var11_6);
                    var10_10 = (Raw.readShortLittleEndian((byte[])var11_6, 0) & 2048) != 0;
                    var13_5.setFileNameUTF8Encoded(var10_10);
                }
                catch (IOException var1_2) {
                    throw new ZipException(var1_2);
                }
                var3_11 = var11_6[0];
                if ((var3_11 & true) == 0) ** GOTO lbl35
                var13_5.setEncrypted(true);
lbl35: // 2 sources:
                var13_5.setGeneralPurposeFlag((byte[])var11_6);
                var14_8 = Integer.toBinaryString((int)var3_11);
                if (var14_8.length() >= 4) {
                    var10_10 = var14_8.charAt(3) == '1';
                    var13_5.setDataDescriptorExists(var10_10);
                }
                this.readIntoBuff(this.zip4jRaf, (byte[])var11_6);
                var13_5.setCompressionMethod(Raw.readShortLittleEndian((byte[])var11_6, 0));
                this.readIntoBuff(this.zip4jRaf, (byte[])var12_7);
                var13_5.setLastModFileTime(Raw.readIntLittleEndian((byte[])var12_7, 0));
                this.readIntoBuff(this.zip4jRaf, (byte[])var12_7);
                var13_5.setCrc32(Raw.readIntLittleEndian((byte[])var12_7, 0));
                var13_5.setCrcBuff((byte[])var12_7.clone());
                this.readIntoBuff(this.zip4jRaf, (byte[])var12_7);
                var13_5.setCompressedSize(Raw.readLongLittleEndian(this.getLongByteFromIntByte((byte[])var12_7), 0));
                this.readIntoBuff(this.zip4jRaf, (byte[])var12_7);
                var13_5.setUncompressedSize(Raw.readLongLittleEndian(this.getLongByteFromIntByte((byte[])var12_7), 0));
                this.readIntoBuff(this.zip4jRaf, (byte[])var11_6);
                var5_12 = Raw.readShortLittleEndian((byte[])var11_6, 0);
                var13_5.setFileNameLength(var5_12);
                this.readIntoBuff(this.zip4jRaf, (byte[])var11_6);
                var4_13 = Raw.readShortLittleEndian((byte[])var11_6, 0);
                var13_5.setExtraFieldLength(var4_13);
                var2_9 = 30;
                if (var5_12 <= 0) break block16;
                var11_6 = new byte[var5_12];
                this.readIntoBuff(this.zip4jRaf, (byte[])var11_6);
                var12_7 = Zip4jUtil.decodeFileName((byte[])var11_6, var13_5.isFileNameUTF8Encoded());
                if (var12_7 == null) {
                    throw new ZipException("file name is null, cannot assign file name to local file header");
                }
                var14_8 = new StringBuffer(":");
                var14_8.append(System.getProperty("file.separator"));
                var11_6 = var12_7;
                if (var12_7.indexOf(var14_8.toString()) >= 0) {
                    var11_6 = new StringBuffer(":");
                    var11_6.append(System.getProperty("file.separator"));
                    var11_6 = var12_7.substring(var12_7.indexOf(var11_6.toString()) + 2);
                }
                var13_5.setFileName((String)var11_6);
                var2_9 = 30 + var5_12;
                ** GOTO lbl78
            }
            var13_5.setFileName(null);
lbl78: // 2 sources:
            this.readAndSaveExtraDataRecord(var13_5);
            var13_5.setOffsetStartOfData(var6_4 + (long)(var2_9 + var4_13));
            var13_5.setPassword(var1_1.getPassword());
            this.readAndSaveZip64ExtendedInfo(var13_5);
            this.readAndSaveAESExtraDataRecord(var13_5);
            if (!var13_5.isEncrypted() || var13_5.getEncryptionMethod() == 99) ** GOTO lbl89
            if ((var3_11 & 64) != 64) ** GOTO lbl88
            var13_5.setEncryptionMethod(1);
            break block17;
lbl88: // 1 sources:
            var13_5.setEncryptionMethod(0);
        }
        if (var13_5.getCrc32() <= 0L) {
            var13_5.setCrc32(var1_1.getCrc32());
            var13_5.setCrcBuff(var1_1.getCrcBuff());
        }
        if (var13_5.getCompressedSize() <= 0L) {
            var13_5.setCompressedSize(var1_1.getCompressedSize());
        }
        if (var13_5.getUncompressedSize() > 0L) return var13_5;
        var13_5.setUncompressedSize(var1_1.getUncompressedSize());
        return var13_5;
    }
}

