/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.io;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.util.Raw;
import net.lingala.zip4j.util.Zip4jUtil;

public class SplitOutputStream
extends OutputStream {
    private long bytesWrittenForThisPart;
    private int currSplitFileCounter;
    private File outFile;
    private RandomAccessFile raf;
    private long splitLength;
    private File zipFile;

    public SplitOutputStream(File file) throws FileNotFoundException, ZipException {
        this(file, -1L);
    }

    public SplitOutputStream(File file, long l) throws FileNotFoundException, ZipException {
        if (l >= 0L && l < 65536L) {
            throw new ZipException("split length less than minimum allowed split length of 65536 Bytes");
        }
        this.raf = new RandomAccessFile(file, "rw");
        this.splitLength = l;
        this.outFile = file;
        this.zipFile = file;
        this.currSplitFileCounter = 0;
        this.bytesWrittenForThisPart = 0L;
    }

    public SplitOutputStream(String object) throws FileNotFoundException, ZipException {
        object = Zip4jUtil.isStringNotNullAndNotEmpty((String)object) ? new File((String)object) : null;
        this((File)object);
    }

    public SplitOutputStream(String object, long l) throws FileNotFoundException, ZipException {
        object = !Zip4jUtil.isStringNotNullAndNotEmpty((String)object) ? new File((String)object) : null;
        this((File)object, l);
    }

    private boolean isHeaderData(byte[] arrby) {
        if (arrby != null) {
            if (arrby.length < 4) {
                return false;
            }
            int n = Raw.readIntLittleEndian(arrby, 0);
            arrby = Zip4jUtil.getAllHeaderSignatures();
            if (arrby != null && arrby.length > 0) {
                int n2 = 0;
                do {
                    if (n2 >= arrby.length) {
                        return false;
                    }
                    if (arrby[n2] != 134695760L && arrby[n2] == (long)n) {
                        return true;
                    }
                    ++n2;
                } while (true);
            }
            return false;
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void startNextSplitFile() throws IOException {
        try {
            Object object;
            String string2 = Zip4jUtil.getZipFileNameWithoutExt(this.outFile.getName());
            CharSequence charSequence = this.zipFile.getAbsolutePath();
            if (this.outFile.getParent() == null) {
                object = "";
            } else {
                object = new StringBuffer(String.valueOf(this.outFile.getParent()));
                object.append(System.getProperty("file.separator"));
                object = object.toString();
            }
            if (this.currSplitFileCounter < 9) {
                object = new StringBuffer(String.valueOf(object));
                object.append(string2);
                object.append(".z0");
                object.append(this.currSplitFileCounter + 1);
                object = new File(object.toString());
            } else {
                object = new StringBuffer(String.valueOf(object));
                object.append(string2);
                object.append(".z");
                object.append(this.currSplitFileCounter + 1);
                object = new File(object.toString());
            }
            this.raf.close();
            if (object.exists()) {
                charSequence = new StringBuffer("split file: ");
                charSequence.append(object.getName());
                charSequence.append(" already exists in the current directory, cannot rename this file");
                throw new IOException(charSequence.toString());
            }
            if (!this.zipFile.renameTo((File)object)) {
                throw new IOException("cannot rename newly created split file");
            }
            this.zipFile = new File((String)charSequence);
            this.raf = new RandomAccessFile(this.zipFile, "rw");
            ++this.currSplitFileCounter;
            return;
        }
        catch (ZipException zipException) {
            throw new IOException(zipException.getMessage());
        }
    }

    public boolean checkBuffSizeAndStartNextSplitFile(int n) throws ZipException {
        if (n < 0) {
            throw new ZipException("negative buffersize for checkBuffSizeAndStartNextSplitFile");
        }
        if (!this.isBuffSizeFitForCurrSplitFile(n)) {
            try {
                this.startNextSplitFile();
                this.bytesWrittenForThisPart = 0L;
                return true;
            }
            catch (IOException iOException) {
                throw new ZipException(iOException);
            }
        }
        return false;
    }

    @Override
    public void close() throws IOException {
        if (this.raf != null) {
            this.raf.close();
        }
    }

    @Override
    public void flush() throws IOException {
    }

    public int getCurrSplitFileCounter() {
        return this.currSplitFileCounter;
    }

    public long getFilePointer() throws IOException {
        return this.raf.getFilePointer();
    }

    public long getSplitLength() {
        return this.splitLength;
    }

    public boolean isBuffSizeFitForCurrSplitFile(int n) throws ZipException {
        if (n < 0) {
            throw new ZipException("negative buffersize for isBuffSizeFitForCurrSplitFile");
        }
        if (this.splitLength >= 65536L) {
            if (this.bytesWrittenForThisPart + (long)n <= this.splitLength) {
                return true;
            }
            return false;
        }
        return true;
    }

    public boolean isSplitZipFile() {
        if (this.splitLength != -1L) {
            return true;
        }
        return false;
    }

    public void seek(long l) throws IOException {
        this.raf.seek(l);
    }

    @Override
    public void write(int n) throws IOException {
        this.write(new byte[]{(byte)n}, 0, 1);
    }

    @Override
    public void write(byte[] arrby) throws IOException {
        this.write(arrby, 0, arrby.length);
    }

    @Override
    public void write(byte[] arrby, int n, int n2) throws IOException {
        if (n2 <= 0) {
            return;
        }
        if (this.splitLength != -1L) {
            if (this.splitLength < 65536L) {
                throw new IOException("split length less than minimum allowed split length of 65536 Bytes");
            }
            if (this.bytesWrittenForThisPart >= this.splitLength) {
                this.startNextSplitFile();
                this.raf.write(arrby, n, n2);
                this.bytesWrittenForThisPart = n2;
                return;
            }
            long l = this.bytesWrittenForThisPart;
            long l2 = n2;
            if (l + l2 > this.splitLength) {
                if (this.isHeaderData(arrby)) {
                    this.startNextSplitFile();
                    this.raf.write(arrby, n, n2);
                    this.bytesWrittenForThisPart = l2;
                    return;
                }
                this.raf.write(arrby, n, (int)(this.splitLength - this.bytesWrittenForThisPart));
                this.startNextSplitFile();
                this.raf.write(arrby, n + (int)(this.splitLength - this.bytesWrittenForThisPart), (int)(l2 - (this.splitLength - this.bytesWrittenForThisPart)));
                this.bytesWrittenForThisPart = l2 - (this.splitLength - this.bytesWrittenForThisPart);
                return;
            }
            this.raf.write(arrby, n, n2);
            this.bytesWrittenForThisPart += l2;
            return;
        }
        this.raf.write(arrby, n, n2);
        this.bytesWrittenForThisPart += (long)n2;
    }
}

