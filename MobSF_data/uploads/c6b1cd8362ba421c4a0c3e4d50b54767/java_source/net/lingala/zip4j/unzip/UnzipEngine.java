/*
 * Decompiled with CFR 0_132.
 */
package net.lingala.zip4j.unzip;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.util.Arrays;
import java.util.zip.CRC32;
import net.lingala.zip4j.core.HeaderReader;
import net.lingala.zip4j.crypto.AESDecrypter;
import net.lingala.zip4j.crypto.IDecrypter;
import net.lingala.zip4j.crypto.StandardDecrypter;
import net.lingala.zip4j.exception.ZipException;
import net.lingala.zip4j.io.BaseInputStream;
import net.lingala.zip4j.io.InflaterInputStream;
import net.lingala.zip4j.io.PartInputStream;
import net.lingala.zip4j.io.ZipInputStream;
import net.lingala.zip4j.model.AESExtraDataRecord;
import net.lingala.zip4j.model.EndCentralDirRecord;
import net.lingala.zip4j.model.FileHeader;
import net.lingala.zip4j.model.LocalFileHeader;
import net.lingala.zip4j.model.UnzipParameters;
import net.lingala.zip4j.model.ZipModel;
import net.lingala.zip4j.progress.ProgressMonitor;
import net.lingala.zip4j.util.Raw;
import net.lingala.zip4j.util.Zip4jUtil;

public class UnzipEngine {
    private CRC32 crc;
    private int currSplitFileCounter = 0;
    private IDecrypter decrypter;
    private FileHeader fileHeader;
    private LocalFileHeader localFileHeader;
    private ZipModel zipModel;

    public UnzipEngine(ZipModel zipModel, FileHeader fileHeader) throws ZipException {
        if (zipModel != null && fileHeader != null) {
            this.zipModel = zipModel;
            this.fileHeader = fileHeader;
            this.crc = new CRC32();
            return;
        }
        throw new ZipException("Invalid parameters passed to StoreUnzip. One or more of the parameters were null");
    }

    private int calculateAESSaltLength(AESExtraDataRecord aESExtraDataRecord) throws ZipException {
        if (aESExtraDataRecord == null) {
            throw new ZipException("unable to determine salt length: AESExtraDataRecord is null");
        }
        switch (aESExtraDataRecord.getAesStrength()) {
            default: {
                throw new ZipException("unable to determine salt length: invalid aes key strength");
            }
            case 3: {
                return 16;
            }
            case 2: {
                return 12;
            }
            case 1: 
        }
        return 8;
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private boolean checkLocalHeader() throws ZipException {
        Object object;
        Object object2;
        block16 : {
            Object object3;
            block17 : {
                block15 : {
                    object3 = null;
                    object = null;
                    object2 = this.checkSplitFile();
                    if (object2 != null) break block15;
                    try {
                        object2 = object = new RandomAccessFile(new File(this.zipModel.getZipFile()), "r");
                    }
                    catch (Throwable throwable) {
                        break block16;
                    }
                    catch (FileNotFoundException fileNotFoundException) {
                        object = object2;
                        object2 = fileNotFoundException;
                        throw new ZipException((Throwable)object2);
                    }
                }
                object = object2;
                object3 = object2;
                this.localFileHeader = new HeaderReader((RandomAccessFile)object2).readLocalFileHeader(this.fileHeader);
                object = object2;
                object3 = object2;
                if (this.localFileHeader == null) {
                    object = object2;
                    object3 = object2;
                    throw new ZipException("error reading local file header. Is this a valid zip file?");
                }
                object = object2;
                object3 = object2;
                int n = this.localFileHeader.getCompressionMethod();
                object = object2;
                object3 = object2;
                int n2 = this.fileHeader.getCompressionMethod();
                if (n == n2) break block17;
                if (object2 == null) return false;
                object2.close();
                return false;
            }
            if (object2 == null) return true;
            object2.close();
            return true;
            catch (IOException | Exception exception) {
                return false;
            }
            catch (IOException | Exception exception) {
                return true;
            }
            catch (Throwable throwable) {
                object2 = object;
                object = throwable;
                break block16;
            }
            catch (FileNotFoundException fileNotFoundException) {
                object = object3;
            }
            {
                throw new ZipException((Throwable)object2);
            }
        }
        if (object2 == null) throw object;
        try {
            object2.close();
        }
        catch (IOException | Exception exception) {
            throw object;
        }
        throw object;
    }

    private RandomAccessFile checkSplitFile() throws ZipException {
        if (this.zipModel.isSplitArchive()) {
            int n;
            int n2 = this.fileHeader.getDiskNumberStart();
            this.currSplitFileCounter = n = n2 + 1;
            Object object = this.zipModel.getZipFile();
            if (n2 == this.zipModel.getEndCentralDirRecord().getNoOfThisDisk()) {
                object = this.zipModel.getZipFile();
            } else if (n2 >= 9) {
                object = new StringBuffer(String.valueOf(object.substring(0, object.lastIndexOf("."))));
                object.append(".z");
                object.append(n);
                object = object.toString();
            } else {
                object = new StringBuffer(String.valueOf(object.substring(0, object.lastIndexOf("."))));
                object.append(".z0");
                object.append(n);
                object = object.toString();
            }
            try {
                object = new RandomAccessFile((String)object, "r");
                if (this.currSplitFileCounter == 1) {
                    byte[] arrby = new byte[4];
                    object.read(arrby);
                    if ((long)Raw.readIntLittleEndian(arrby, 0) != 134695760L) {
                        throw new ZipException("invalid first part split file signature");
                    }
                }
                return object;
            }
            catch (IOException iOException) {
                throw new ZipException(iOException);
            }
            catch (FileNotFoundException fileNotFoundException) {
                throw new ZipException(fileNotFoundException);
            }
        }
        return null;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void closeStreams(InputStream var1_1, OutputStream var2_5) throws ZipException {
        if (var1_1 != null) {
            block13 : {
                block12 : {
                    try {
                        var1_1.close();
                        ** break block11
                    }
                    catch (Throwable var1_2) {
                        break block12;
                    }
                    catch (IOException var1_3) {
                        if (var1_3 != null && Zip4jUtil.isStringNotNullAndNotEmpty(var1_3.getMessage()) && var1_3.getMessage().indexOf(" - Wrong Password?") >= 0) {
                            throw new ZipException(var1_3.getMessage());
                        }
                        break block13;
                    }
                }
                if (var2_5 == null) throw var1_2;
                var2_5.close();
                throw var1_2;
            }
            if (var2_5 == null) return;
        } else lbl-1000: // 2 sources:
        {
            
            if (var2_5 == null) return;
        }
        try {
            var2_5.close();
            return;
        }
        catch (IOException var1_4) {
            return;
        }
        catch (IOException var2_6) {
            throw var1_2;
        }
    }

    private RandomAccessFile createFileHandler(String object) throws ZipException {
        if (this.zipModel != null && Zip4jUtil.isStringNotNullAndNotEmpty(this.zipModel.getZipFile())) {
            try {
                if (this.zipModel.isSplitArchive()) {
                    return this.checkSplitFile();
                }
                object = new RandomAccessFile(new File(this.zipModel.getZipFile()), (String)object);
                return object;
            }
            catch (Exception exception) {
                throw new ZipException(exception);
            }
            catch (FileNotFoundException fileNotFoundException) {
                throw new ZipException(fileNotFoundException);
            }
        }
        throw new ZipException("input parameter is null in getFilePointer");
    }

    private byte[] getAESPasswordVerifier(RandomAccessFile randomAccessFile) throws ZipException {
        try {
            byte[] arrby = new byte[2];
            randomAccessFile.read(arrby);
            return arrby;
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    private byte[] getAESSalt(RandomAccessFile randomAccessFile) throws ZipException {
        if (this.localFileHeader.getAesExtraDataRecord() == null) {
            return null;
        }
        try {
            byte[] arrby = new byte[this.calculateAESSaltLength(this.localFileHeader.getAesExtraDataRecord())];
            randomAccessFile.seek(this.localFileHeader.getOffsetStartOfData());
            randomAccessFile.read(arrby);
            return arrby;
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    private String getOutputFileNameWithPath(String charSequence, String string2) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty(string2)) {
            string2 = this.fileHeader.getFileName();
        }
        charSequence = new StringBuffer(String.valueOf(charSequence));
        charSequence.append(System.getProperty("file.separator"));
        charSequence.append(string2);
        return charSequence.toString();
    }

    private FileOutputStream getOutputStream(String object, String string2) throws ZipException {
        if (!Zip4jUtil.isStringNotNullAndNotEmpty((String)object)) {
            throw new ZipException("invalid output path");
        }
        try {
            object = new File(this.getOutputFileNameWithPath((String)object, string2));
            if (!object.getParentFile().exists()) {
                object.getParentFile().mkdirs();
            }
            if (object.exists()) {
                object.delete();
            }
            object = new FileOutputStream((File)object);
            return object;
        }
        catch (FileNotFoundException fileNotFoundException) {
            throw new ZipException(fileNotFoundException);
        }
    }

    private byte[] getStandardDecrypterHeaderBytes(RandomAccessFile randomAccessFile) throws ZipException {
        try {
            byte[] arrby = new byte[12];
            randomAccessFile.seek(this.localFileHeader.getOffsetStartOfData());
            randomAccessFile.read(arrby, 0, 12);
            return arrby;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
        catch (IOException iOException) {
            throw new ZipException(iOException);
        }
    }

    private void init(RandomAccessFile randomAccessFile) throws ZipException {
        if (this.localFileHeader == null) {
            throw new ZipException("local file header is null, cannot initialize input stream");
        }
        try {
            this.initDecrypter(randomAccessFile);
            return;
        }
        catch (Exception exception) {
            throw new ZipException(exception);
        }
        catch (ZipException zipException) {
            throw zipException;
        }
    }

    private void initDecrypter(RandomAccessFile randomAccessFile) throws ZipException {
        if (this.localFileHeader == null) {
            throw new ZipException("local file header is null, cannot init decrypter");
        }
        if (this.localFileHeader.isEncrypted()) {
            if (this.localFileHeader.getEncryptionMethod() == 0) {
                this.decrypter = new StandardDecrypter(this.fileHeader, this.getStandardDecrypterHeaderBytes(randomAccessFile));
                return;
            }
            if (this.localFileHeader.getEncryptionMethod() == 99) {
                this.decrypter = new AESDecrypter(this.localFileHeader, this.getAESSalt(randomAccessFile), this.getAESPasswordVerifier(randomAccessFile));
                return;
            }
            throw new ZipException("unsupported encryption method");
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public void checkCRC() throws ZipException {
        if (this.fileHeader == null) return;
        if (this.fileHeader.getEncryptionMethod() == 99) {
            if (this.decrypter == null || !(this.decrypter instanceof AESDecrypter)) return;
            Object object = ((AESDecrypter)this.decrypter).getCalculatedAuthenticationBytes();
            byte[] arrby = ((AESDecrypter)this.decrypter).getStoredMac();
            byte[] arrby2 = new byte[10];
            if (arrby2 != null && arrby != null) {
                System.arraycopy(object, 0, arrby2, 0, 10);
                if (Arrays.equals(arrby2, arrby)) return;
                object = new StringBuffer("invalid CRC (MAC) for file: ");
                object.append(this.fileHeader.getFileName());
                throw new ZipException(object.toString());
            }
            object = new StringBuffer("CRC (MAC) check failed for ");
            object.append(this.fileHeader.getFileName());
            throw new ZipException(object.toString());
        }
        if ((this.crc.getValue() & 0xFFFFFFFFL) == this.fileHeader.getCrc32()) return;
        CharSequence charSequence = new StringBuffer("invalid CRC for file: ");
        charSequence.append(this.fileHeader.getFileName());
        String string2 = charSequence.toString();
        charSequence = string2;
        if (!this.localFileHeader.isEncrypted()) throw new ZipException((String)charSequence);
        charSequence = string2;
        if (this.localFileHeader.getEncryptionMethod() != 0) throw new ZipException((String)charSequence);
        charSequence = new StringBuffer(String.valueOf(string2));
        charSequence.append(" - Wrong Password?");
        charSequence = charSequence.toString();
        throw new ZipException((String)charSequence);
    }

    public IDecrypter getDecrypter() {
        return this.decrypter;
    }

    public FileHeader getFileHeader() {
        return this.fileHeader;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public ZipInputStream getInputStream() throws ZipException {
        void var7_14;
        RandomAccessFile randomAccessFile;
        block22 : {
            void var7_12;
            block21 : {
                if (this.fileHeader == null) {
                    throw new ZipException("file header is null, cannot get inputstream");
                }
                randomAccessFile = this.createFileHandler("r");
                if (!this.checkLocalHeader()) {
                    throw new ZipException("local header and file header do not match");
                }
                this.init(randomAccessFile);
                long l2 = this.localFileHeader.getCompressedSize();
                long l = this.localFileHeader.getOffsetStartOfData();
                if (this.localFileHeader.isEncrypted()) {
                    if (this.localFileHeader.getEncryptionMethod() == 99) {
                        if (!(this.decrypter instanceof AESDecrypter)) {
                            StringBuffer stringBuffer = new StringBuffer("invalid decryptor when trying to calculate compressed size for AES encrypted file: ");
                            stringBuffer.append(this.fileHeader.getFileName());
                            throw new ZipException(stringBuffer.toString());
                        }
                        l2 -= (long)(((AESDecrypter)this.decrypter).getSaltLength() + ((AESDecrypter)this.decrypter).getPasswordVerifierLength() + 10);
                        l += (long)(((AESDecrypter)this.decrypter).getSaltLength() + ((AESDecrypter)this.decrypter).getPasswordVerifierLength());
                    } else if (this.localFileHeader.getEncryptionMethod() == 0) {
                        l2 -= 12L;
                        l += 12L;
                    }
                }
                int n = this.fileHeader.getCompressionMethod();
                if (this.fileHeader.getEncryptionMethod() == 99) {
                    if (this.fileHeader.getAesExtraDataRecord() == null) {
                        StringBuffer stringBuffer = new StringBuffer("AESExtraDataRecord does not exist for AES encrypted file: ");
                        stringBuffer.append(this.fileHeader.getFileName());
                        throw new ZipException(stringBuffer.toString());
                    }
                    n = this.fileHeader.getAesExtraDataRecord().getCompressionMethod();
                }
                randomAccessFile.seek(l);
                if (n == 0) return new ZipInputStream(new PartInputStream(randomAccessFile, l, l2, this));
                if (n == 8) return new ZipInputStream(new InflaterInputStream(randomAccessFile, l, l2, this));
                try {
                    throw new ZipException("compression type not supported");
                }
                catch (Exception exception) {
                    break block21;
                }
                catch (ZipException zipException) {
                    break block22;
                }
                catch (Exception exception) {
                    randomAccessFile = null;
                }
            }
            if (randomAccessFile == null) throw new ZipException((Throwable)var7_12);
            try {
                randomAccessFile.close();
                throw new ZipException((Throwable)var7_12);
            }
            catch (IOException iOException) {
                throw new ZipException((Throwable)var7_12);
            }
            catch (ZipException zipException) {
                randomAccessFile = null;
            }
        }
        if (randomAccessFile == null) throw var7_14;
        try {
            randomAccessFile.close();
        }
        catch (IOException iOException) {
            throw var7_14;
        }
        throw var7_14;
    }

    public LocalFileHeader getLocalFileHeader() {
        return this.localFileHeader;
    }

    public ZipModel getZipModel() {
        return this.zipModel;
    }

    public RandomAccessFile startNextSplitFile() throws IOException, FileNotFoundException {
        CharSequence charSequence = this.zipModel.getZipFile();
        if (this.currSplitFileCounter == this.zipModel.getEndCentralDirRecord().getNoOfThisDisk()) {
            charSequence = this.zipModel.getZipFile();
        } else if (this.currSplitFileCounter >= 9) {
            charSequence = new StringBuffer(String.valueOf(charSequence.substring(0, charSequence.lastIndexOf("."))));
            charSequence.append(".z");
            charSequence.append(this.currSplitFileCounter + 1);
            charSequence = charSequence.toString();
        } else {
            charSequence = new StringBuffer(String.valueOf(charSequence.substring(0, charSequence.lastIndexOf("."))));
            charSequence.append(".z0");
            charSequence.append(this.currSplitFileCounter + 1);
            charSequence = charSequence.toString();
        }
        ++this.currSplitFileCounter;
        try {
            if (!Zip4jUtil.checkFileExists((String)charSequence)) {
                StringBuffer stringBuffer = new StringBuffer("zip split file does not exist: ");
                stringBuffer.append((String)charSequence);
                throw new IOException(stringBuffer.toString());
            }
            return new RandomAccessFile((String)charSequence, "r");
        }
        catch (ZipException zipException) {
            throw new IOException(zipException.getMessage());
        }
    }

    /*
     * Exception decompiling
     */
    public void unzipFile(ProgressMonitor var1_1, String var2_6, String var3_10, UnzipParameters var4_14) throws ZipException {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [15[DOLOOP]], but top level block is 3[TRYBLOCK]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public void updateCRC(int n) {
        this.crc.update(n);
    }

    public void updateCRC(byte[] arrby, int n, int n2) {
        if (arrby != null) {
            this.crc.update(arrby, n, n2);
        }
    }
}

