/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  javax.annotation.Nullable
 *  okio.Buffer$1
 *  okio.Buffer$2
 *  okio.Buffer$UnsafeCursor
 *  okio.Options
 *  okio.SegmentedByteString
 *  okio.Util
 */
package okio;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.channels.ByteChannel;
import java.nio.charset.Charset;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import javax.annotation.Nullable;
import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import okio.Buffer;
import okio.BufferedSink;
import okio.BufferedSource;
import okio.ByteString;
import okio.Options;
import okio.Segment;
import okio.SegmentPool;
import okio.SegmentedByteString;
import okio.Sink;
import okio.Source;
import okio.Timeout;
import okio.Util;

public final class Buffer
implements BufferedSource,
BufferedSink,
Cloneable,
ByteChannel {
    private static final byte[] DIGITS = new byte[]{48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102};
    static final int REPLACEMENT_CHARACTER = 65533;
    @Nullable
    Segment head;
    long size;

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private ByteString digest(String object) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance((String)object);
            if (this.head == null) return ByteString.of(messageDigest.digest());
            messageDigest.update(this.head.data, this.head.pos, this.head.limit - this.head.pos);
            object = this.head;
            while ((object = object.next) != this.head) {
                messageDigest.update(object.data, object.pos, object.limit - object.pos);
            }
            return ByteString.of(messageDigest.digest());
        }
        catch (NoSuchAlgorithmException noSuchAlgorithmException) {
            throw new AssertionError();
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private ByteString hmac(String object, ByteString byteString) {
        try {
            Mac mac = Mac.getInstance((String)object);
            mac.init(new SecretKeySpec(byteString.toByteArray(), (String)object));
            if (this.head == null) return ByteString.of(mac.doFinal());
            mac.update(this.head.data, this.head.pos, this.head.limit - this.head.pos);
            object = this.head;
            while ((object = object.next) != this.head) {
                mac.update(object.data, object.pos, object.limit - object.pos);
            }
            return ByteString.of(mac.doFinal());
        }
        catch (InvalidKeyException invalidKeyException) {
            throw new IllegalArgumentException(invalidKeyException);
        }
        catch (NoSuchAlgorithmException noSuchAlgorithmException) {
            throw new AssertionError();
        }
    }

    private boolean rangeEquals(Segment arrby, int n, ByteString byteString, int n2, int n3) {
        int n4 = arrby.limit;
        byte[] arrby2 = arrby.data;
        while (n2 < n3) {
            int n5 = n4;
            byte[] arrby3 = arrby;
            int n6 = n;
            if (n == n4) {
                arrby3 = arrby.next;
                arrby = arrby3.data;
                n6 = arrby3.pos;
                n5 = arrby3.limit;
                arrby2 = arrby;
            }
            if (arrby2[n6] != byteString.getByte(n2)) {
                return false;
            }
            n = n6 + 1;
            ++n2;
            n4 = n5;
            arrby = arrby3;
        }
        return true;
    }

    private void readFrom(InputStream inputStream, long l, boolean bl) throws IOException {
        if (inputStream == null) {
            throw new IllegalArgumentException("in == null");
        }
        while (l > 0L || bl) {
            Segment segment = this.writableSegment(1);
            int n = (int)Math.min(l, (long)(8192 - segment.limit));
            if ((n = inputStream.read(segment.data, segment.limit, n)) == -1) {
                if (bl) {
                    return;
                }
                throw new EOFException();
            }
            segment.limit += n;
            long l2 = this.size;
            long l3 = n;
            this.size = l2 + l3;
            l -= l3;
        }
        return;
    }

    @Override
    public Buffer buffer() {
        return this;
    }

    public void clear() {
        try {
            this.skip(this.size);
            return;
        }
        catch (EOFException eOFException) {
            throw new AssertionError(eOFException);
        }
    }

    public Buffer clone() {
        Segment segment;
        Buffer buffer = new Buffer();
        if (this.size == 0L) {
            return buffer;
        }
        Segment segment2 = buffer.head = this.head.sharedCopy();
        Segment segment3 = buffer.head;
        segment3.prev = segment = buffer.head;
        segment2.next = segment;
        segment2 = this.head;
        while ((segment2 = segment2.next) != this.head) {
            buffer.head.prev.push(segment2.sharedCopy());
        }
        buffer.size = this.size;
        return buffer;
    }

    @Override
    public void close() {
    }

    public long completeSegmentByteCount() {
        long l = this.size;
        if (l == 0L) {
            return 0L;
        }
        Segment segment = this.head.prev;
        long l2 = l;
        if (segment.limit < 8192) {
            l2 = l;
            if (segment.owner) {
                l2 = l - (long)(segment.limit - segment.pos);
            }
        }
        return l2;
    }

    public Buffer copyTo(OutputStream outputStream) throws IOException {
        return this.copyTo(outputStream, 0L, this.size);
    }

    public Buffer copyTo(OutputStream outputStream, long l, long l2) throws IOException {
        Segment segment;
        long l3;
        long l4;
        if (outputStream == null) {
            throw new IllegalArgumentException("out == null");
        }
        Util.checkOffsetAndCount((long)this.size, (long)l, (long)l2);
        if (l2 == 0L) {
            return this;
        }
        Segment segment2 = this.head;
        do {
            segment = segment2;
            l3 = l;
            if (l < (long)(segment2.limit - segment2.pos)) break;
            l4 = segment2.limit - segment2.pos;
            segment2 = segment2.next;
            l -= l4;
        } while (true);
        for (l4 = l2; l4 > 0L; l4 -= l) {
            int n = (int)((long)segment.pos + l3);
            int n2 = (int)Math.min((long)(segment.limit - n), l4);
            outputStream.write(segment.data, n, n2);
            l = n2;
            segment = segment.next;
            l3 = 0L;
        }
        return this;
    }

    public Buffer copyTo(Buffer buffer, long l, long l2) {
        Segment segment;
        long l3;
        long l4;
        if (buffer == null) {
            throw new IllegalArgumentException("out == null");
        }
        Util.checkOffsetAndCount((long)this.size, (long)l, (long)l2);
        if (l2 == 0L) {
            return this;
        }
        buffer.size += l2;
        Segment segment2 = this.head;
        do {
            segment = segment2;
            l4 = l;
            if (l < (long)(segment2.limit - segment2.pos)) break;
            l3 = segment2.limit - segment2.pos;
            segment2 = segment2.next;
            l -= l3;
        } while (true);
        for (l3 = l2; l3 > 0L; l3 -= l) {
            segment2 = segment.sharedCopy();
            segment2.pos = (int)((long)segment2.pos + l4);
            segment2.limit = Math.min(segment2.pos + (int)l3, segment2.limit);
            if (buffer.head == null) {
                segment2.prev = segment2;
                segment2.next = segment2;
                buffer.head = segment2;
            } else {
                buffer.head.prev.push(segment2);
            }
            l = segment2.limit - segment2.pos;
            segment = segment.next;
            l4 = 0L;
        }
        return this;
    }

    @Override
    public BufferedSink emit() {
        return this;
    }

    @Override
    public Buffer emitCompleteSegments() {
        return this;
    }

    public boolean equals(Object object) {
        if (this == object) {
            return true;
        }
        if (!(object instanceof Buffer)) {
            return false;
        }
        object = (Buffer)object;
        if (this.size != object.size) {
            return false;
        }
        long l = this.size;
        if (l == 0L) {
            return true;
        }
        Segment segment = this.head;
        object = object.head;
        int n = segment.pos;
        int n2 = object.pos;
        for (long i = 0L; i < this.size; i += l) {
            l = Math.min(segment.limit - n, object.limit - n2);
            int n3 = 0;
            while ((long)n3 < l) {
                if (segment.data[n] != object.data[n2]) {
                    return false;
                }
                ++n3;
                ++n;
                ++n2;
            }
            if (n == segment.limit) {
                segment = segment.next;
                n = segment.pos;
            }
            if (n2 != object.limit) continue;
            object = object.next;
            n2 = object.pos;
        }
        return true;
    }

    @Override
    public boolean exhausted() {
        if (this.size == 0L) {
            return true;
        }
        return false;
    }

    @Override
    public void flush() {
    }

    public byte getByte(long l) {
        Util.checkOffsetAndCount((long)this.size, (long)l, (long)1L);
        if (this.size - l > l) {
            Segment segment = this.head;
            do {
                long l2;
                if (l < (l2 = (long)(segment.limit - segment.pos))) {
                    return segment.data[segment.pos + (int)l];
                }
                segment = segment.next;
                l -= l2;
            } while (true);
        }
        l -= this.size;
        Segment segment = this.head.prev;
        while ((l += (long)(segment.limit - segment.pos)) < 0L) {
            segment = segment.prev;
        }
        return segment.data[segment.pos + (int)l];
    }

    public int hashCode() {
        Segment segment;
        int n;
        Segment segment2 = this.head;
        if (segment2 == null) {
            return 0;
        }
        int n2 = 1;
        do {
            int n3 = segment2.limit;
            n = n2;
            for (int i = segment2.pos; i < n3; ++i) {
                n = n * 31 + segment2.data[i];
            }
            segment2 = segment = segment2.next;
            n2 = n;
        } while (segment != this.head);
        return n;
    }

    public ByteString hmacSha1(ByteString byteString) {
        return this.hmac("HmacSHA1", byteString);
    }

    public ByteString hmacSha256(ByteString byteString) {
        return this.hmac("HmacSHA256", byteString);
    }

    public ByteString hmacSha512(ByteString byteString) {
        return this.hmac("HmacSHA512", byteString);
    }

    @Override
    public long indexOf(byte by) {
        return this.indexOf(by, 0L, Long.MAX_VALUE);
    }

    @Override
    public long indexOf(byte by, long l) {
        return this.indexOf(by, l, Long.MAX_VALUE);
    }

    @Override
    public long indexOf(byte by, long l, long l2) {
        long l3 = 0L;
        if (l >= 0L && l2 >= l) {
            long l4 = l2 > this.size ? this.size : l2;
            if (l == l4) {
                return -1L;
            }
            Object object = this.head;
            if (object == null) {
                return -1L;
            }
            l2 = l3;
            byte[] arrby = object;
            if (this.size - l < l) {
                l3 = this.size;
                arrby = object;
                do {
                    l2 = l3;
                    object = arrby;
                    if (l3 > l) {
                        arrby = arrby.prev;
                        l3 -= (long)(arrby.limit - arrby.pos);
                        continue;
                    }
                    break;
                } while (true);
            } else {
                do {
                    l3 = l2 + (long)(arrby.limit - arrby.pos);
                    object = arrby;
                    if (l3 >= l) break;
                    arrby = arrby.next;
                    l2 = l3;
                } while (true);
            }
            while (l2 < l4) {
                arrby = object.data;
                int n = (int)Math.min((long)object.limit, (long)object.pos + l4 - l2);
                for (int i = (int)((long)object.pos + l - l2); i < n; ++i) {
                    if (arrby[i] != by) continue;
                    return (long)(i - object.pos) + l2;
                }
                l = object.limit - object.pos;
                object = object.next;
                l2 = l = l2 + l;
            }
            return -1L;
        }
        throw new IllegalArgumentException(String.format("size=%s fromIndex=%s toIndex=%s", this.size, l, l2));
    }

    @Override
    public long indexOf(ByteString byteString) throws IOException {
        return this.indexOf(byteString, 0L);
    }

    @Override
    public long indexOf(ByteString byteString, long l) throws IOException {
        long l2;
        byte[] arrby = this;
        if (byteString.size() == 0) {
            throw new IllegalArgumentException("bytes is empty");
        }
        long l3 = 0L;
        if (l < 0L) {
            throw new IllegalArgumentException("fromIndex < 0");
        }
        byte[] arrby2 = arrby.head;
        if (arrby2 == null) {
            return -1L;
        }
        Object object = arrby2;
        if (arrby.size - l < l) {
            l2 = arrby.size;
            object = arrby2;
            do {
                l3 = l2;
                arrby2 = object;
                if (l2 > l) {
                    object = object.prev;
                    l2 -= (long)(object.limit - object.pos);
                    continue;
                }
                break;
            } while (true);
        } else {
            do {
                l2 = l3 + (long)(object.limit - object.pos);
                arrby2 = object;
                if (l2 >= l) break;
                object = object.next;
                l3 = l2;
            } while (true);
        }
        byte by = byteString.getByte(0);
        int n = byteString.size();
        l2 = arrby.size - (long)n + 1L;
        object = arrby2;
        while (l3 < l2) {
            arrby = object.data;
            int n2 = (int)Math.min((long)object.limit, (long)object.pos + l2 - l3);
            arrby2 = object;
            object = arrby;
            for (int i = (int)((long)object.pos + l - l3); i < n2; ++i) {
                if (object[i] != by || !Buffer.super.rangeEquals((Segment)arrby2, i + 1, byteString, 1, n)) continue;
                return (long)(i - arrby2.pos) + l3;
            }
            l = arrby2.limit - arrby2.pos;
            object = arrby2.next;
            l3 = l = l3 + l;
        }
        return -1L;
    }

    @Override
    public long indexOfElement(ByteString byteString) {
        return this.indexOfElement(byteString, 0L);
    }

    @Override
    public long indexOfElement(ByteString arrby, long l) {
        long l2;
        long l3 = 0L;
        if (l < 0L) {
            throw new IllegalArgumentException("fromIndex < 0");
        }
        Object object = this.head;
        if (object == null) {
            return -1L;
        }
        byte[] arrby2 = object;
        if (this.size - l < l) {
            l2 = this.size;
            arrby2 = object;
            do {
                l3 = l2;
                object = arrby2;
                if (l2 > l) {
                    arrby2 = arrby2.prev;
                    l2 -= (long)(arrby2.limit - arrby2.pos);
                    continue;
                }
                break;
            } while (true);
        } else {
            do {
                l2 = l3 + (long)(arrby2.limit - arrby2.pos);
                object = arrby2;
                if (l2 >= l) break;
                arrby2 = arrby2.next;
                l3 = l2;
            } while (true);
        }
        if (arrby.size() == 2) {
            byte by = arrby.getByte(0);
            byte by2 = arrby.getByte(1);
            while (l3 < this.size) {
                arrby = object.data;
                int n = object.limit;
                for (int i = (int)((long)object.pos + l - l3); i < n; ++i) {
                    byte by3 = arrby[i];
                    if (by3 != by && by3 != by2) {
                        continue;
                    }
                    return (long)(i - object.pos) + l3;
                }
                l = object.limit - object.pos;
                object = object.next;
                l3 = l = l3 + l;
            }
        } else {
            arrby = arrby.internalArray();
            while (l3 < this.size) {
                arrby2 = object.data;
                int n = object.limit;
                for (int i = (int)((long)object.pos + l - l3); i < n; ++i) {
                    byte by = arrby2[i];
                    int n2 = arrby.length;
                    for (int j = 0; j < n2; ++j) {
                        if (by != arrby[j]) continue;
                        return (long)(i - object.pos) + l3;
                    }
                }
                l = object.limit - object.pos;
                object = object.next;
                l3 = l = l3 + l;
            }
        }
        return -1L;
    }

    @Override
    public InputStream inputStream() {
        return new 2(this);
    }

    @Override
    public boolean isOpen() {
        return true;
    }

    public ByteString md5() {
        return this.digest("MD5");
    }

    @Override
    public OutputStream outputStream() {
        return new 1(this);
    }

    @Override
    public boolean rangeEquals(long l, ByteString byteString) {
        return this.rangeEquals(l, byteString, 0, byteString.size());
    }

    @Override
    public boolean rangeEquals(long l, ByteString byteString, int n, int n2) {
        if (l >= 0L && n >= 0 && n2 >= 0 && this.size - l >= (long)n2) {
            if (byteString.size() - n < n2) {
                return false;
            }
            for (int i = 0; i < n2; ++i) {
                if (this.getByte(l + (long)i) == byteString.getByte(n + i)) continue;
                return false;
            }
            return true;
        }
        return false;
    }

    @Override
    public int read(ByteBuffer byteBuffer) throws IOException {
        Segment segment = this.head;
        if (segment == null) {
            return -1;
        }
        int n = Math.min(byteBuffer.remaining(), segment.limit - segment.pos);
        byteBuffer.put(segment.data, segment.pos, n);
        segment.pos += n;
        this.size -= (long)n;
        if (segment.pos == segment.limit) {
            this.head = segment.pop();
            SegmentPool.recycle(segment);
        }
        return n;
    }

    @Override
    public int read(byte[] arrby) {
        return this.read(arrby, 0, arrby.length);
    }

    @Override
    public int read(byte[] arrby, int n, int n2) {
        Util.checkOffsetAndCount((long)arrby.length, (long)n, (long)n2);
        Segment segment = this.head;
        if (segment == null) {
            return -1;
        }
        n2 = Math.min(n2, segment.limit - segment.pos);
        System.arraycopy(segment.data, segment.pos, arrby, n, n2);
        segment.pos += n2;
        this.size -= (long)n2;
        if (segment.pos == segment.limit) {
            this.head = segment.pop();
            SegmentPool.recycle(segment);
        }
        return n2;
    }

    @Override
    public long read(Buffer object, long l) {
        if (object == null) {
            throw new IllegalArgumentException("sink == null");
        }
        if (l < 0L) {
            object = new StringBuilder();
            object.append("byteCount < 0: ");
            object.append(l);
            throw new IllegalArgumentException(object.toString());
        }
        if (this.size == 0L) {
            return -1L;
        }
        long l2 = l;
        if (l > this.size) {
            l2 = this.size;
        }
        object.write(this, l2);
        return l2;
    }

    @Override
    public long readAll(Sink sink) throws IOException {
        long l = this.size;
        if (l > 0L) {
            sink.write(this, l);
        }
        return l;
    }

    public  readAndWriteUnsafe() {
        return this.readAndWriteUnsafe(new /* Unavailable Anonymous Inner Class!! */);
    }

    public  readAndWriteUnsafe( unsafeCursor) {
        if (unsafeCursor.buffer != null) {
            throw new IllegalStateException("already attached to a buffer");
        }
        unsafeCursor.buffer = this;
        unsafeCursor.readWrite = true;
        return unsafeCursor;
    }

    @Override
    public byte readByte() {
        if (this.size == 0L) {
            throw new IllegalStateException("size == 0");
        }
        Segment segment = this.head;
        int n = segment.pos;
        int n2 = segment.limit;
        byte[] arrby = segment.data;
        int n3 = n + 1;
        byte by = arrby[n];
        --this.size;
        if (n3 == n2) {
            this.head = segment.pop();
            SegmentPool.recycle(segment);
            return by;
        }
        segment.pos = n3;
        return by;
    }

    @Override
    public byte[] readByteArray() {
        try {
            byte[] arrby = this.readByteArray(this.size);
            return arrby;
        }
        catch (EOFException eOFException) {
            throw new AssertionError(eOFException);
        }
    }

    @Override
    public byte[] readByteArray(long l) throws EOFException {
        Util.checkOffsetAndCount((long)this.size, (long)0L, (long)l);
        if (l > Integer.MAX_VALUE) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("byteCount > Integer.MAX_VALUE: ");
            stringBuilder.append(l);
            throw new IllegalArgumentException(stringBuilder.toString());
        }
        byte[] arrby = new byte[(int)l];
        this.readFully(arrby);
        return arrby;
    }

    @Override
    public ByteString readByteString() {
        return new ByteString(this.readByteArray());
    }

    @Override
    public ByteString readByteString(long l) throws EOFException {
        return new ByteString(this.readByteArray(l));
    }

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public long readDecimalLong() {
        Object object;
        int n;
        long l;
        Object object2;
        int n2;
        block11 : {
            int n3;
            l = this.size;
            long l2 = 0L;
            if (l == 0L) {
                throw new IllegalStateException("size == 0");
            }
            n2 = 0;
            long l3 = -7L;
            int n4 = 0;
            int n5 = 0;
            do {
                int n6;
                int n7;
                block10 : {
                    object = this.head;
                    object2 = object.data;
                    n6 = object.pos;
                    n7 = object.limit;
                    n3 = n2;
                    n = n4;
                    l = l2;
                    do {
                        n2 = n5;
                        if (n6 >= n7) break block10;
                        n2 = object2[n6];
                        if (n2 >= 48 && n2 <= 57) {
                            n4 = 48 - n2;
                            if (l < -922337203685477580L || l == -922337203685477580L && (long)n4 < l3) break block11;
                            l = l * 10L + (long)n4;
                        } else {
                            if (n2 != 45 || n3 != 0) break;
                            --l3;
                            n = 1;
                        }
                        ++n6;
                        ++n3;
                    } while (true);
                    if (n3 == 0) {
                        object = new StringBuilder();
                        object.append("Expected leading [0-9] or '-' character but was 0x");
                        object.append(Integer.toHexString(n2));
                        throw new NumberFormatException(object.toString());
                    }
                    n2 = 1;
                }
                if (n6 == n7) {
                    this.head = object.pop();
                    SegmentPool.recycle((Segment)object);
                } else {
                    object.pos = n6;
                }
                if (n2 != 0) break;
                l2 = l;
                n4 = n;
                n5 = n2;
                n2 = n3;
            } while (this.head != null);
            this.size -= (long)n3;
            if (n != 0) {
                return l;
            }
            return - l;
        }
        object = new Buffer().writeDecimalLong(l).writeByte(n2);
        if (n == 0) {
            object.readByte();
        }
        object2 = new StringBuilder();
        object2.append("Number too large: ");
        object2.append(object.readUtf8());
        throw new NumberFormatException(object2.toString());
    }

    public Buffer readFrom(InputStream inputStream) throws IOException {
        this.readFrom(inputStream, Long.MAX_VALUE, true);
        return this;
    }

    public Buffer readFrom(InputStream object, long l) throws IOException {
        if (l < 0L) {
            object = new StringBuilder();
            object.append("byteCount < 0: ");
            object.append(l);
            throw new IllegalArgumentException(object.toString());
        }
        this.readFrom((InputStream)object, l, false);
        return this;
    }

    @Override
    public void readFully(Buffer buffer, long l) throws EOFException {
        if (this.size < l) {
            buffer.write(this, this.size);
            throw new EOFException();
        }
        buffer.write(this, l);
    }

    @Override
    public void readFully(byte[] arrby) throws EOFException {
        int n;
        for (int i = 0; i < arrby.length; i += n) {
            n = this.read(arrby, i, arrby.length - i);
            if (n != -1) continue;
            throw new EOFException();
        }
    }

    @Override
    public long readHexadecimalUnsignedLong() {
        int n;
        long l;
        if (this.size == 0L) {
            throw new IllegalStateException("size == 0");
        }
        int n2 = 0;
        long l2 = 0L;
        byte by = 0;
        do {
            int n3;
            Object object;
            int n4;
            byte by2;
            block11 : {
                object = this.head;
                Object object2 = object.data;
                n4 = object.pos;
                n3 = object.limit;
                l = l2;
                n = n2;
                do {
                    by2 = by;
                    if (n4 >= n3) break block11;
                    by2 = object2[n4];
                    if (by2 >= 48 && by2 <= 57) {
                        n2 = by2 - 48;
                    } else if (by2 >= 97 && by2 <= 102) {
                        n2 = by2 - 97 + 10;
                    } else {
                        if (by2 < 65 || by2 > 70) break;
                        n2 = by2 - 65 + 10;
                    }
                    if ((l & -1152921504606846976L) != 0L) {
                        object = new Buffer().writeHexadecimalUnsignedLong(l).writeByte(by2);
                        object2 = new StringBuilder();
                        object2.append("Number too large: ");
                        object2.append(object.readUtf8());
                        throw new NumberFormatException(object2.toString());
                    }
                    l2 = n2;
                    ++n4;
                    ++n;
                    l = l << 4 | l2;
                } while (true);
                if (n == 0) {
                    object = new StringBuilder();
                    object.append("Expected leading [0-9a-fA-F] character but was 0x");
                    object.append(Integer.toHexString(by2));
                    throw new NumberFormatException(object.toString());
                }
                by2 = 1;
            }
            if (n4 == n3) {
                this.head = object.pop();
                SegmentPool.recycle((Segment)object);
            } else {
                object.pos = n4;
            }
            if (by2 != 0) break;
            n2 = n;
            by = by2;
            l2 = l;
        } while (this.head != null);
        this.size -= (long)n;
        return l;
    }

    @Override
    public int readInt() {
        if (this.size < 4L) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("size < 4: ");
            stringBuilder.append(this.size);
            throw new IllegalStateException(stringBuilder.toString());
        }
        Segment segment = this.head;
        int n = segment.limit;
        int n2 = segment.pos;
        if (n - n2 < 4) {
            return (this.readByte() & 255) << 24 | (this.readByte() & 255) << 16 | (this.readByte() & 255) << 8 | this.readByte() & 255;
        }
        byte[] arrby = segment.data;
        int n3 = n2 + 1;
        n2 = arrby[n2];
        int n4 = n3 + 1;
        n3 = arrby[n3];
        int n5 = n4 + 1;
        byte by = arrby[n4];
        n4 = n5 + 1;
        n2 = (n2 & 255) << 24 | (n3 & 255) << 16 | (by & 255) << 8 | arrby[n5] & 255;
        this.size -= 4L;
        if (n4 == n) {
            this.head = segment.pop();
            SegmentPool.recycle(segment);
            return n2;
        }
        segment.pos = n4;
        return n2;
    }

    @Override
    public int readIntLe() {
        return Util.reverseBytesInt((int)this.readInt());
    }

    @Override
    public long readLong() {
        if (this.size < 8L) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("size < 8: ");
            stringBuilder.append(this.size);
            throw new IllegalStateException(stringBuilder.toString());
        }
        Segment segment = this.head;
        int n = segment.limit;
        int n2 = segment.pos;
        if (n - n2 < 8) {
            return ((long)this.readInt() & 0xFFFFFFFFL) << 32 | (long)this.readInt() & 0xFFFFFFFFL;
        }
        byte[] arrby = segment.data;
        int n3 = n2 + 1;
        long l = arrby[n2];
        n2 = n3 + 1;
        long l2 = arrby[n3];
        n3 = n2 + 1;
        long l3 = arrby[n2];
        n2 = n3 + 1;
        long l4 = arrby[n3];
        n3 = n2 + 1;
        long l5 = arrby[n2];
        n2 = n3 + 1;
        long l6 = arrby[n3];
        n3 = n2 + 1;
        long l7 = arrby[n2];
        n2 = n3 + 1;
        l = (l & 255L) << 56 | (l2 & 255L) << 48 | (l3 & 255L) << 40 | (l4 & 255L) << 32 | (l5 & 255L) << 24 | (l6 & 255L) << 16 | (l7 & 255L) << 8 | (long)arrby[n3] & 255L;
        this.size -= 8L;
        if (n2 == n) {
            this.head = segment.pop();
            SegmentPool.recycle(segment);
            return l;
        }
        segment.pos = n2;
        return l;
    }

    @Override
    public long readLongLe() {
        return Util.reverseBytesLong((long)this.readLong());
    }

    @Override
    public short readShort() {
        if (this.size < 2L) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("size < 2: ");
            stringBuilder.append(this.size);
            throw new IllegalStateException(stringBuilder.toString());
        }
        Segment segment = this.head;
        int n = segment.limit;
        int n2 = segment.pos;
        if (n - n2 < 2) {
            return (short)((this.readByte() & 255) << 8 | this.readByte() & 255);
        }
        byte[] arrby = segment.data;
        int n3 = n2 + 1;
        n2 = arrby[n2];
        int n4 = n3 + 1;
        n3 = arrby[n3];
        this.size -= 2L;
        if (n4 == n) {
            this.head = segment.pop();
            SegmentPool.recycle(segment);
        } else {
            segment.pos = n4;
        }
        return (short)((n2 & 255) << 8 | n3 & 255);
    }

    @Override
    public short readShortLe() {
        return Util.reverseBytesShort((short)this.readShort());
    }

    @Override
    public String readString(long l, Charset object) throws EOFException {
        Util.checkOffsetAndCount((long)this.size, (long)0L, (long)l);
        if (object == null) {
            throw new IllegalArgumentException("charset == null");
        }
        if (l > Integer.MAX_VALUE) {
            object = new StringBuilder();
            object.append("byteCount > Integer.MAX_VALUE: ");
            object.append(l);
            throw new IllegalArgumentException(object.toString());
        }
        if (l == 0L) {
            return "";
        }
        Segment segment = this.head;
        if ((long)segment.pos + l > (long)segment.limit) {
            return new String(this.readByteArray(l), (Charset)object);
        }
        object = new String(segment.data, segment.pos, (int)l, (Charset)object);
        segment.pos = (int)((long)segment.pos + l);
        this.size -= l;
        if (segment.pos == segment.limit) {
            this.head = segment.pop();
            SegmentPool.recycle(segment);
        }
        return object;
    }

    @Override
    public String readString(Charset object) {
        try {
            object = this.readString(this.size, (Charset)object);
            return object;
        }
        catch (EOFException eOFException) {
            throw new AssertionError(eOFException);
        }
    }

    public  readUnsafe() {
        return this.readUnsafe(new /* Unavailable Anonymous Inner Class!! */);
    }

    public  readUnsafe( unsafeCursor) {
        if (unsafeCursor.buffer != null) {
            throw new IllegalStateException("already attached to a buffer");
        }
        unsafeCursor.buffer = this;
        unsafeCursor.readWrite = false;
        return unsafeCursor;
    }

    @Override
    public String readUtf8() {
        try {
            String string2 = this.readString(this.size, Util.UTF_8);
            return string2;
        }
        catch (EOFException eOFException) {
            throw new AssertionError(eOFException);
        }
    }

    @Override
    public String readUtf8(long l) throws EOFException {
        return this.readString(l, Util.UTF_8);
    }

    @Override
    public int readUtf8CodePoint() throws EOFException {
        block14 : {
            byte by;
            int n;
            int n2;
            int n3;
            int n4;
            block11 : {
                block13 : {
                    block12 : {
                        block10 : {
                            if (this.size == 0L) {
                                throw new EOFException();
                            }
                            by = this.getByte(0L);
                            n2 = 1;
                            if ((by & 128) != 0) break block10;
                            n4 = by & 127;
                            n3 = 1;
                            n = 0;
                            break block11;
                        }
                        if ((by & 224) != 192) break block12;
                        n4 = by & 31;
                        n3 = 2;
                        n = 128;
                        break block11;
                    }
                    if ((by & 240) != 224) break block13;
                    n4 = by & 15;
                    n3 = 3;
                    n = 2048;
                    break block11;
                }
                if ((by & 248) != 240) break block14;
                n4 = by & 7;
                n3 = 4;
                n = 65536;
            }
            long l = this.size;
            long l2 = n3;
            if (l < l2) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("size < ");
                stringBuilder.append(n3);
                stringBuilder.append(": ");
                stringBuilder.append(this.size);
                stringBuilder.append(" (to read code point prefixed 0x");
                stringBuilder.append(Integer.toHexString(by));
                stringBuilder.append(")");
                throw new EOFException(stringBuilder.toString());
            }
            while (n2 < n3) {
                l = n2;
                by = this.getByte(l);
                if ((by & 192) == 128) {
                    n4 = n4 << 6 | by & 63;
                    ++n2;
                    continue;
                }
                this.skip(l);
                return 65533;
            }
            this.skip(l2);
            if (n4 > 1114111) {
                return 65533;
            }
            if (n4 >= 55296 && n4 <= 57343) {
                return 65533;
            }
            if (n4 < n) {
                return 65533;
            }
            return n4;
        }
        this.skip(1L);
        return 65533;
    }

    @Nullable
    @Override
    public String readUtf8Line() throws EOFException {
        long l = this.indexOf((byte)10);
        if (l == -1L) {
            if (this.size != 0L) {
                return this.readUtf8(this.size);
            }
            return null;
        }
        return this.readUtf8Line(l);
    }

    String readUtf8Line(long l) throws EOFException {
        long l2;
        if (l > 0L && this.getByte(l2 = l - 1L) == 13) {
            String string2 = this.readUtf8(l2);
            this.skip(2L);
            return string2;
        }
        String string3 = this.readUtf8(l);
        this.skip(1L);
        return string3;
    }

    @Override
    public String readUtf8LineStrict() throws EOFException {
        return this.readUtf8LineStrict(Long.MAX_VALUE);
    }

    @Override
    public String readUtf8LineStrict(long l) throws EOFException {
        if (l < 0L) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("limit < 0: ");
            stringBuilder.append(l);
            throw new IllegalArgumentException(stringBuilder.toString());
        }
        long l2 = Long.MAX_VALUE;
        if (l != Long.MAX_VALUE) {
            l2 = l + 1L;
        }
        long l3 = this.indexOf((byte)10, 0L, l2);
        if (l3 != -1L) {
            return this.readUtf8Line(l3);
        }
        if (l2 < this.size() && this.getByte(l2 - 1L) == 13 && this.getByte(l2) == 10) {
            return this.readUtf8Line(l2);
        }
        Buffer buffer = new Buffer();
        this.copyTo(buffer, 0L, Math.min(32L, this.size()));
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("\\n not found: limit=");
        stringBuilder.append(Math.min(this.size(), l));
        stringBuilder.append(" content=");
        stringBuilder.append(buffer.readByteString().hex());
        stringBuilder.append('\u2026');
        throw new EOFException(stringBuilder.toString());
    }

    @Override
    public boolean request(long l) {
        if (this.size >= l) {
            return true;
        }
        return false;
    }

    @Override
    public void require(long l) throws EOFException {
        if (this.size < l) {
            throw new EOFException();
        }
    }

    List<Integer> segmentSizes() {
        if (this.head == null) {
            return Collections.emptyList();
        }
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        arrayList.add(this.head.limit - this.head.pos);
        Segment segment = this.head;
        while ((segment = segment.next) != this.head) {
            arrayList.add(segment.limit - segment.pos);
        }
        return arrayList;
    }

    @Override
    public int select(Options arrbyteString) {
        Segment segment = this.head;
        if (segment == null) {
            return arrbyteString.indexOf((Object)ByteString.EMPTY);
        }
        arrbyteString = arrbyteString.byteStrings;
        int n = arrbyteString.length;
        for (int i = 0; i < n; ++i) {
            ByteString byteString = arrbyteString[i];
            if (this.size < (long)byteString.size() || !this.rangeEquals(segment, segment.pos, byteString, 0, byteString.size())) continue;
            try {
                this.skip(byteString.size());
                return i;
            }
            catch (EOFException eOFException) {
                throw new AssertionError(eOFException);
            }
        }
        return -1;
    }

    int selectPrefix(Options arrbyteString) {
        Segment segment = this.head;
        arrbyteString = arrbyteString.byteStrings;
        int n = arrbyteString.length;
        for (int i = 0; i < n; ++i) {
            ByteString byteString = arrbyteString[i];
            int n2 = (int)Math.min(this.size, (long)byteString.size());
            if (n2 != 0) {
                if (!this.rangeEquals(segment, segment.pos, byteString, 0, n2)) continue;
                return i;
            }
            return i;
        }
        return -1;
    }

    public ByteString sha1() {
        return this.digest("SHA-1");
    }

    public ByteString sha256() {
        return this.digest("SHA-256");
    }

    public ByteString sha512() {
        return this.digest("SHA-512");
    }

    public long size() {
        return this.size;
    }

    @Override
    public void skip(long l) throws EOFException {
        while (l > 0L) {
            if (this.head == null) {
                throw new EOFException();
            }
            int n = (int)Math.min(l, (long)(this.head.limit - this.head.pos));
            long l2 = this.size;
            long l3 = n;
            this.size = l2 - l3;
            Segment segment = this.head;
            segment.pos += n;
            if (this.head.pos == this.head.limit) {
                segment = this.head;
                this.head = segment.pop();
                SegmentPool.recycle(segment);
            }
            l -= l3;
        }
    }

    public ByteString snapshot() {
        if (this.size > Integer.MAX_VALUE) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("size > Integer.MAX_VALUE: ");
            stringBuilder.append(this.size);
            throw new IllegalArgumentException(stringBuilder.toString());
        }
        return this.snapshot((int)this.size);
    }

    public ByteString snapshot(int n) {
        if (n == 0) {
            return ByteString.EMPTY;
        }
        return new SegmentedByteString(this, n);
    }

    @Override
    public Timeout timeout() {
        return Timeout.NONE;
    }

    public String toString() {
        return this.snapshot().toString();
    }

    Segment writableSegment(int n) {
        block4 : {
            Segment segment;
            block6 : {
                Segment segment2;
                block5 : {
                    if (n < 1 || n > 8192) break block4;
                    if (this.head == null) {
                        Segment segment3;
                        Segment segment4 = this.head = SegmentPool.take();
                        Segment segment5 = this.head;
                        segment5.prev = segment3 = this.head;
                        segment4.next = segment3;
                        return segment3;
                    }
                    segment2 = this.head.prev;
                    if (segment2.limit + n > 8192) break block5;
                    segment = segment2;
                    if (segment2.owner) break block6;
                }
                segment = segment2.push(SegmentPool.take());
            }
            return segment;
        }
        throw new IllegalArgumentException();
    }

    @Override
    public int write(ByteBuffer byteBuffer) throws IOException {
        int n;
        if (byteBuffer == null) {
            throw new IllegalArgumentException("source == null");
        }
        int n2 = n = byteBuffer.remaining();
        while (n2 > 0) {
            Segment segment = this.writableSegment(1);
            int n3 = Math.min(n2, 8192 - segment.limit);
            byteBuffer.get(segment.data, segment.limit, n3);
            n2 -= n3;
            segment.limit += n3;
        }
        this.size += (long)n;
        return n;
    }

    @Override
    public Buffer write(ByteString byteString) {
        if (byteString == null) {
            throw new IllegalArgumentException("byteString == null");
        }
        byteString.write(this);
        return this;
    }

    @Override
    public Buffer write(byte[] arrby) {
        if (arrby == null) {
            throw new IllegalArgumentException("source == null");
        }
        return this.write(arrby, 0, arrby.length);
    }

    @Override
    public Buffer write(byte[] arrby, int n, int n2) {
        if (arrby == null) {
            throw new IllegalArgumentException("source == null");
        }
        long l = arrby.length;
        long l2 = n;
        long l3 = n2;
        Util.checkOffsetAndCount((long)l, (long)l2, (long)l3);
        while (n < (n2 += n)) {
            Segment segment = this.writableSegment(1);
            int n3 = Math.min(n2 - n, 8192 - segment.limit);
            System.arraycopy(arrby, n, segment.data, segment.limit, n3);
            n += n3;
            segment.limit += n3;
        }
        this.size += l3;
        return this;
    }

    @Override
    public BufferedSink write(Source source, long l) throws IOException {
        while (l > 0L) {
            long l2 = source.read(this, l);
            if (l2 == -1L) {
                throw new EOFException();
            }
            l -= l2;
        }
        return this;
    }

    @Override
    public void write(Buffer buffer, long l) {
        if (buffer == null) {
            throw new IllegalArgumentException("source == null");
        }
        if (buffer == this) {
            throw new IllegalArgumentException("source == this");
        }
        Util.checkOffsetAndCount((long)buffer.size, (long)0L, (long)l);
        while (l > 0L) {
            Segment segment;
            long l2;
            if (l < (long)(buffer.head.limit - buffer.head.pos)) {
                int n;
                segment = this.head != null ? this.head.prev : null;
                if (segment != null && segment.owner && l + (l2 = (long)segment.limit) - (long)(n = segment.shared ? 0 : segment.pos) <= 8192L) {
                    buffer.head.writeTo(segment, (int)l);
                    buffer.size -= l;
                    this.size += l;
                    return;
                }
                buffer.head = buffer.head.split((int)l);
            }
            segment = buffer.head;
            l2 = segment.limit - segment.pos;
            buffer.head = segment.pop();
            if (this.head == null) {
                Segment segment2;
                segment = this.head = segment;
                Segment segment3 = this.head;
                segment3.prev = segment2 = this.head;
                segment.next = segment2;
            } else {
                this.head.prev.push(segment).compact();
            }
            buffer.size -= l2;
            this.size += l2;
            l -= l2;
        }
    }

    @Override
    public long writeAll(Source source) throws IOException {
        long l;
        if (source == null) {
            throw new IllegalArgumentException("source == null");
        }
        long l2 = 0L;
        while ((l = source.read(this, 8192L)) != -1L) {
            l2 += l;
        }
        return l2;
    }

    @Override
    public Buffer writeByte(int n) {
        Segment segment = this.writableSegment(1);
        byte[] arrby = segment.data;
        int n2 = segment.limit;
        segment.limit = n2 + 1;
        arrby[n2] = (byte)n;
        ++this.size;
        return this;
    }

    @Override
    public Buffer writeDecimalLong(long l) {
        if (l == 0L) {
            return this.writeByte(48);
        }
        boolean bl = false;
        int n = 1;
        long l2 = l;
        if (l < 0L) {
            l2 = - l;
            if (l2 < 0L) {
                return this.writeUtf8("-9223372036854775808");
            }
            bl = true;
        }
        if (l2 < 100000000L) {
            if (l2 < 10000L) {
                if (l2 < 100L) {
                    if (l2 >= 10L) {
                        n = 2;
                    }
                } else {
                    n = l2 < 1000L ? 3 : 4;
                }
            } else {
                n = l2 < 1000000L ? (l2 < 100000L ? 5 : 6) : (l2 < 10000000L ? 7 : 8);
            }
        } else {
            n = l2 < 1000000000000L ? (l2 < 10000000000L ? (l2 < 1000000000L ? 9 : 10) : (l2 < 100000000000L ? 11 : 12)) : (l2 < 1000000000000000L ? (l2 < 10000000000000L ? 13 : (l2 < 100000000000000L ? 14 : 15)) : (l2 < 100000000000000000L ? (l2 < 10000000000000000L ? 16 : 17) : (l2 < 1000000000000000000L ? 18 : 19)));
        }
        int n2 = n;
        if (bl) {
            n2 = n + 1;
        }
        Segment segment = this.writableSegment(n2);
        byte[] arrby = segment.data;
        n = segment.limit + n2;
        while (l2 != 0L) {
            int n3 = (int)(l2 % 10L);
            arrby[--n] = DIGITS[n3];
            l2 /= 10L;
        }
        if (bl) {
            arrby[n - 1] = 45;
        }
        segment.limit += n2;
        this.size += (long)n2;
        return this;
    }

    @Override
    public Buffer writeHexadecimalUnsignedLong(long l) {
        if (l == 0L) {
            return this.writeByte(48);
        }
        int n = Long.numberOfTrailingZeros(Long.highestOneBit(l)) / 4 + 1;
        Segment segment = this.writableSegment(n);
        byte[] arrby = segment.data;
        int n2 = segment.limit;
        for (int i = segment.limit + n - 1; i >= n2; --i) {
            arrby[i] = DIGITS[(int)(l & 15L)];
            l >>>= 4;
        }
        segment.limit += n;
        this.size += (long)n;
        return this;
    }

    @Override
    public Buffer writeInt(int n) {
        Segment segment = this.writableSegment(4);
        byte[] arrby = segment.data;
        int n2 = segment.limit;
        int n3 = n2 + 1;
        arrby[n2] = (byte)(n >>> 24 & 255);
        n2 = n3 + 1;
        arrby[n3] = (byte)(n >>> 16 & 255);
        n3 = n2 + 1;
        arrby[n2] = (byte)(n >>> 8 & 255);
        arrby[n3] = (byte)(n & 255);
        segment.limit = n3 + 1;
        this.size += 4L;
        return this;
    }

    @Override
    public Buffer writeIntLe(int n) {
        return this.writeInt(Util.reverseBytesInt((int)n));
    }

    @Override
    public Buffer writeLong(long l) {
        Segment segment = this.writableSegment(8);
        byte[] arrby = segment.data;
        int n = segment.limit;
        int n2 = n + 1;
        arrby[n] = (byte)(l >>> 56 & 255L);
        n = n2 + 1;
        arrby[n2] = (byte)(l >>> 48 & 255L);
        n2 = n + 1;
        arrby[n] = (byte)(l >>> 40 & 255L);
        n = n2 + 1;
        arrby[n2] = (byte)(l >>> 32 & 255L);
        n2 = n + 1;
        arrby[n] = (byte)(l >>> 24 & 255L);
        n = n2 + 1;
        arrby[n2] = (byte)(l >>> 16 & 255L);
        n2 = n + 1;
        arrby[n] = (byte)(l >>> 8 & 255L);
        arrby[n2] = (byte)(l & 255L);
        segment.limit = n2 + 1;
        this.size += 8L;
        return this;
    }

    @Override
    public Buffer writeLongLe(long l) {
        return this.writeLong(Util.reverseBytesLong((long)l));
    }

    @Override
    public Buffer writeShort(int n) {
        Segment segment = this.writableSegment(2);
        byte[] arrby = segment.data;
        int n2 = segment.limit;
        int n3 = n2 + 1;
        arrby[n2] = (byte)(n >>> 8 & 255);
        arrby[n3] = (byte)(n & 255);
        segment.limit = n3 + 1;
        this.size += 2L;
        return this;
    }

    @Override
    public Buffer writeShortLe(int n) {
        return this.writeShort(Util.reverseBytesShort((short)((short)n)));
    }

    @Override
    public Buffer writeString(String charSequence, int n, int n2, Charset object) {
        if (charSequence == null) {
            throw new IllegalArgumentException("string == null");
        }
        if (n < 0) {
            charSequence = new StringBuilder();
            charSequence.append("beginIndex < 0: ");
            charSequence.append(n);
            throw new IllegalAccessError(charSequence.toString());
        }
        if (n2 < n) {
            charSequence = new StringBuilder();
            charSequence.append("endIndex < beginIndex: ");
            charSequence.append(n2);
            charSequence.append(" < ");
            charSequence.append(n);
            throw new IllegalArgumentException(charSequence.toString());
        }
        if (n2 > charSequence.length()) {
            object = new StringBuilder();
            object.append("endIndex > string.length: ");
            object.append(n2);
            object.append(" > ");
            object.append(charSequence.length());
            throw new IllegalArgumentException(object.toString());
        }
        if (object == null) {
            throw new IllegalArgumentException("charset == null");
        }
        if (object.equals(Util.UTF_8)) {
            return this.writeUtf8((String)charSequence, n, n2);
        }
        charSequence = charSequence.substring(n, n2).getBytes((Charset)object);
        return this.write((byte[])charSequence, 0, ((CharSequence)charSequence).length);
    }

    @Override
    public Buffer writeString(String string2, Charset charset) {
        return this.writeString(string2, 0, string2.length(), charset);
    }

    public Buffer writeTo(OutputStream outputStream) throws IOException {
        return this.writeTo(outputStream, this.size);
    }

    public Buffer writeTo(OutputStream outputStream, long l) throws IOException {
        if (outputStream == null) {
            throw new IllegalArgumentException("out == null");
        }
        Util.checkOffsetAndCount((long)this.size, (long)0L, (long)l);
        Segment segment = this.head;
        while (l > 0L) {
            int n = (int)Math.min(l, (long)(segment.limit - segment.pos));
            outputStream.write(segment.data, segment.pos, n);
            segment.pos += n;
            long l2 = this.size;
            long l3 = n;
            this.size = l2 - l3;
            Segment segment2 = segment;
            if (segment.pos == segment.limit) {
                this.head = segment2 = segment.pop();
                SegmentPool.recycle(segment);
            }
            l -= l3;
            segment = segment2;
        }
        return this;
    }

    @Override
    public Buffer writeUtf8(String string2) {
        return this.writeUtf8(string2, 0, string2.length());
    }

    @Override
    public Buffer writeUtf8(String charSequence, int n, int n2) {
        if (charSequence == null) {
            throw new IllegalArgumentException("string == null");
        }
        if (n < 0) {
            charSequence = new StringBuilder();
            charSequence.append("beginIndex < 0: ");
            charSequence.append(n);
            throw new IllegalArgumentException(charSequence.toString());
        }
        if (n2 < n) {
            charSequence = new StringBuilder();
            charSequence.append("endIndex < beginIndex: ");
            charSequence.append(n2);
            charSequence.append(" < ");
            charSequence.append(n);
            throw new IllegalArgumentException(charSequence.toString());
        }
        if (n2 > charSequence.length()) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("endIndex > string.length: ");
            stringBuilder.append(n2);
            stringBuilder.append(" > ");
            stringBuilder.append(charSequence.length());
            throw new IllegalArgumentException(stringBuilder.toString());
        }
        while (n < n2) {
            int n3;
            int n4;
            char c = charSequence.charAt(n);
            if (c < '?') {
                Segment segment = this.writableSegment(1);
                byte[] arrby = segment.data;
                n3 = segment.limit - n;
                int n5 = Math.min(n2, 8192 - n3);
                n4 = n + 1;
                arrby[n + n3] = (byte)c;
                n = n4;
                while (n < n5 && (n4 = (int)charSequence.charAt(n)) < 128) {
                    arrby[n + n3] = (byte)n4;
                    ++n;
                }
                n4 = n3 + n - segment.limit;
                segment.limit += n4;
                this.size += (long)n4;
                continue;
            }
            if (c < '\u0800') {
                this.writeByte(c >> 6 | 192);
                this.writeByte(c & 63 | 128);
                ++n;
                continue;
            }
            if (c >= '\ud800' && c <= '\udfff') {
                n3 = n + 1;
                n4 = n3 < n2 ? charSequence.charAt(n3) : 0;
                if (c <= '\udbff' && n4 >= 56320 && n4 <= 57343) {
                    n4 = ((c & -55297) << 10 | -56321 & n4) + 65536;
                    this.writeByte(n4 >> 18 | 240);
                    this.writeByte(n4 >> 12 & 63 | 128);
                    this.writeByte(n4 >> 6 & 63 | 128);
                    this.writeByte(n4 & 63 | 128);
                    n += 2;
                    continue;
                }
                this.writeByte(63);
                n = n3;
                continue;
            }
            this.writeByte(c >> 12 | 224);
            this.writeByte(c >> 6 & 63 | 128);
            this.writeByte(c & 63 | 128);
            ++n;
        }
        return this;
    }

    @Override
    public Buffer writeUtf8CodePoint(int n) {
        if (n < 128) {
            this.writeByte(n);
            return this;
        }
        if (n < 2048) {
            this.writeByte(n >> 6 | 192);
            this.writeByte(n & 63 | 128);
            return this;
        }
        if (n < 65536) {
            if (n >= 55296 && n <= 57343) {
                this.writeByte(63);
                return this;
            }
            this.writeByte(n >> 12 | 224);
            this.writeByte(n >> 6 & 63 | 128);
            this.writeByte(n & 63 | 128);
            return this;
        }
        if (n <= 1114111) {
            this.writeByte(n >> 18 | 240);
            this.writeByte(n >> 12 & 63 | 128);
            this.writeByte(n >> 6 & 63 | 128);
            this.writeByte(n & 63 | 128);
            return this;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Unexpected code point: ");
        stringBuilder.append(Integer.toHexString(n));
        throw new IllegalArgumentException(stringBuilder.toString());
    }
}

