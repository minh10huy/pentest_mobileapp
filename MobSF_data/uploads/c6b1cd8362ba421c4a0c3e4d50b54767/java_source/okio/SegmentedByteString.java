/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  okio.Buffer
 *  okio.ByteString
 *  okio.Segment
 */
package okio;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.Arrays;
import okio.Buffer;
import okio.ByteString;
import okio.Segment;
import okio.Util;

final class SegmentedByteString
extends ByteString {
    final transient int[] directory;
    final transient byte[][] segments;

    SegmentedByteString(Buffer buffer, int n) {
        super(null);
        Util.checkOffsetAndCount(buffer.size, 0L, n);
        Segment segment = buffer.head;
        int n2 = 0;
        int n3 = 0;
        int n4 = 0;
        while (n3 < n) {
            if (segment.limit == segment.pos) {
                throw new AssertionError((Object)"s.limit == s.pos");
            }
            n3 += segment.limit - segment.pos;
            ++n4;
            segment = segment.next;
        }
        this.segments = new byte[n4][];
        this.directory = new int[n4 * 2];
        buffer = buffer.head;
        n3 = 0;
        n4 = n2;
        while (n4 < n) {
            this.segments[n3] = buffer.data;
            n4 = n2 = n4 + (buffer.limit - buffer.pos);
            if (n2 > n) {
                n4 = n;
            }
            this.directory[n3] = n4;
            this.directory[this.segments.length + n3] = buffer.pos;
            buffer.shared = true;
            ++n3;
            buffer = buffer.next;
        }
    }

    private int segment(int n) {
        if ((n = Arrays.binarySearch(this.directory, 0, this.segments.length, n + 1)) >= 0) {
            return n;
        }
        return ~ n;
    }

    private ByteString toByteString() {
        return new ByteString(this.toByteArray());
    }

    private Object writeReplace() {
        return this.toByteString();
    }

    public ByteBuffer asByteBuffer() {
        return ByteBuffer.wrap(this.toByteArray()).asReadOnlyBuffer();
    }

    public String base64() {
        return this.toByteString().base64();
    }

    public String base64Url() {
        return this.toByteString().base64Url();
    }

    public boolean equals(Object object) {
        if (object == this) {
            return true;
        }
        if (object instanceof ByteString && (object = (ByteString)object).size() == this.size() && this.rangeEquals(0, (ByteString)object, 0, this.size())) {
            return true;
        }
        return false;
    }

    public byte getByte(int n) {
        Util.checkOffsetAndCount(this.directory[this.segments.length - 1], n, 1L);
        int n2 = this.segment(n);
        int n3 = n2 == 0 ? 0 : this.directory[n2 - 1];
        int n4 = this.directory[this.segments.length + n2];
        return this.segments[n2][n - n3 + n4];
    }

    public int hashCode() {
        int n = this.hashCode;
        if (n != 0) {
            return n;
        }
        int n2 = this.segments.length;
        int n3 = 0;
        int n4 = 1;
        for (int i = 0; i < n2; ++i) {
            byte[] arrby = this.segments[i];
            int n5 = this.directory[n2 + i];
            int n6 = this.directory[i];
            for (n = n5; n < n6 - n3 + n5; ++n) {
                n4 = n4 * 31 + arrby[n];
            }
            n3 = n6;
        }
        this.hashCode = n4;
        return n4;
    }

    public String hex() {
        return this.toByteString().hex();
    }

    public ByteString hmacSha1(ByteString byteString) {
        return this.toByteString().hmacSha1(byteString);
    }

    public ByteString hmacSha256(ByteString byteString) {
        return this.toByteString().hmacSha256(byteString);
    }

    public int indexOf(byte[] arrby, int n) {
        return this.toByteString().indexOf(arrby, n);
    }

    byte[] internalArray() {
        return this.toByteArray();
    }

    public int lastIndexOf(byte[] arrby, int n) {
        return this.toByteString().lastIndexOf(arrby, n);
    }

    public ByteString md5() {
        return this.toByteString().md5();
    }

    public boolean rangeEquals(int n, ByteString byteString, int n2, int n3) {
        if (n >= 0) {
            if (n > this.size() - n3) {
                return false;
            }
            int n4 = this.segment(n);
            int n5 = n;
            n = n4;
            while (n3 > 0) {
                n4 = n == 0 ? 0 : this.directory[n - 1];
                int n6 = this.directory[this.segments.length + n];
                int n7 = Math.min(n3, this.directory[n] - n4 + n4 - n5);
                if (!byteString.rangeEquals(n2, this.segments[n], n5 - n4 + n6, n7)) {
                    return false;
                }
                n5 += n7;
                n2 += n7;
                n3 -= n7;
                ++n;
            }
            return true;
        }
        return false;
    }

    public boolean rangeEquals(int n, byte[] arrby, int n2, int n3) {
        if (n >= 0 && n <= this.size() - n3 && n2 >= 0) {
            if (n2 > arrby.length - n3) {
                return false;
            }
            int n4 = this.segment(n);
            int n5 = n;
            n = n4;
            while (n3 > 0) {
                n4 = n == 0 ? 0 : this.directory[n - 1];
                int n6 = this.directory[this.segments.length + n];
                int n7 = Math.min(n3, this.directory[n] - n4 + n4 - n5);
                if (!Util.arrayRangeEquals(this.segments[n], n5 - n4 + n6, arrby, n2, n7)) {
                    return false;
                }
                n5 += n7;
                n2 += n7;
                n3 -= n7;
                ++n;
            }
            return true;
        }
        return false;
    }

    public ByteString sha1() {
        return this.toByteString().sha1();
    }

    public ByteString sha256() {
        return this.toByteString().sha256();
    }

    public int size() {
        return this.directory[this.segments.length - 1];
    }

    public String string(Charset charset) {
        return this.toByteString().string(charset);
    }

    public ByteString substring(int n) {
        return this.toByteString().substring(n);
    }

    public ByteString substring(int n, int n2) {
        return this.toByteString().substring(n, n2);
    }

    public ByteString toAsciiLowercase() {
        return this.toByteString().toAsciiLowercase();
    }

    public ByteString toAsciiUppercase() {
        return this.toByteString().toAsciiUppercase();
    }

    public byte[] toByteArray() {
        byte[] arrby = new byte[this.directory[this.segments.length - 1]];
        int n = this.segments.length;
        int n2 = 0;
        for (int i = 0; i < n; ++i) {
            int n3 = this.directory[n + i];
            int n4 = this.directory[i];
            System.arraycopy(this.segments[i], n3, arrby, n2, n4 - n2);
            n2 = n4;
        }
        return arrby;
    }

    public String toString() {
        return this.toByteString().toString();
    }

    public String utf8() {
        return this.toByteString().utf8();
    }

    public void write(OutputStream outputStream) throws IOException {
        if (outputStream == null) {
            throw new IllegalArgumentException("out == null");
        }
        int n = this.segments.length;
        int n2 = 0;
        for (int i = 0; i < n; ++i) {
            int n3 = this.directory[n + i];
            int n4 = this.directory[i];
            outputStream.write(this.segments[i], n3, n4 - n2);
            n2 = n4;
        }
    }

    void write(Buffer buffer) {
        int n = this.segments.length;
        int n2 = 0;
        for (int i = 0; i < n; ++i) {
            int n3 = this.directory[n + i];
            int n4 = this.directory[i];
            Segment segment = new Segment(this.segments[i], n3, n3 + n4 - n2, true, false);
            if (buffer.head == null) {
                segment.prev = segment;
                segment.next = segment;
                buffer.head = segment;
            } else {
                buffer.head.prev.push(segment);
            }
            n2 = n4;
        }
        buffer.size += (long)n2;
    }
}

