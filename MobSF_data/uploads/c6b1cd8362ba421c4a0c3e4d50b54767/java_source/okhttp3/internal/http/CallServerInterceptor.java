/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  okhttp3.Connection
 *  okhttp3.EventListener
 *  okhttp3.Handshake
 *  okhttp3.Interceptor$Chain
 *  okhttp3.Request
 *  okhttp3.RequestBody
 *  okhttp3.Response
 *  okhttp3.Response$Builder
 *  okhttp3.ResponseBody
 *  okhttp3.internal.Util
 *  okhttp3.internal.connection.RealConnection
 *  okio.Buffer
 *  okio.BufferedSink
 *  okio.ForwardingSink
 *  okio.Sink
 */
package okhttp3.internal.http;

import java.io.IOException;
import java.net.ProtocolException;
import okhttp3.Call;
import okhttp3.Connection;
import okhttp3.EventListener;
import okhttp3.Handshake;
import okhttp3.Interceptor;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okhttp3.internal.Util;
import okhttp3.internal.connection.RealConnection;
import okhttp3.internal.connection.StreamAllocation;
import okhttp3.internal.http.HttpCodec;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.http.RealInterceptorChain;
import okio.Buffer;
import okio.BufferedSink;
import okio.ForwardingSink;
import okio.Okio;
import okio.Sink;

public final class CallServerInterceptor
implements Interceptor {
    private final boolean forWebSocket;

    public CallServerInterceptor(boolean bl) {
        this.forWebSocket = bl;
    }

    @Override
    public Response intercept(Interceptor object) throws IOException {
        int n;
        RealInterceptorChain realInterceptorChain = (RealInterceptorChain)object;
        HttpCodec httpCodec = realInterceptorChain.httpStream();
        StreamAllocation streamAllocation = realInterceptorChain.streamAllocation();
        RealConnection realConnection = (RealConnection)realInterceptorChain.connection();
        Request request = realInterceptorChain.request();
        long l = System.currentTimeMillis();
        realInterceptorChain.eventListener().requestHeadersStart(realInterceptorChain.call());
        httpCodec.writeRequestHeaders(request);
        realInterceptorChain.eventListener().requestHeadersEnd(realInterceptorChain.call(), request);
        boolean bl = HttpMethod.permitsRequestBody(request.method());
        BufferedSink bufferedSink = null;
        Object object2 = null;
        object = bufferedSink;
        if (bl) {
            object = bufferedSink;
            if (request.body() != null) {
                if ("100-continue".equalsIgnoreCase(request.header("Expect"))) {
                    httpCodec.flushRequest();
                    realInterceptorChain.eventListener().responseHeadersStart(realInterceptorChain.call());
                    object2 = httpCodec.readResponseHeaders(true);
                }
                if (object2 == null) {
                    realInterceptorChain.eventListener().requestBodyStart(realInterceptorChain.call());
                    object = new CountingSink(httpCodec.createRequestBody(request, request.body().contentLength()));
                    bufferedSink = Okio.buffer((Sink)object);
                    request.body().writeTo(bufferedSink);
                    bufferedSink.close();
                    realInterceptorChain.eventListener().requestBodyEnd(realInterceptorChain.call(), object.successfulCount);
                    object = object2;
                } else {
                    object = object2;
                    if (!realConnection.isMultiplexed()) {
                        streamAllocation.noNewStreams();
                        object = object2;
                    }
                }
            }
        }
        httpCodec.finishRequest();
        object2 = object;
        if (object == null) {
            realInterceptorChain.eventListener().responseHeadersStart(realInterceptorChain.call());
            object2 = httpCodec.readResponseHeaders(false);
        }
        object = object2.request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(l).receivedResponseAtMillis(System.currentTimeMillis()).build();
        int n2 = n = object.code();
        if (n == 100) {
            object = httpCodec.readResponseHeaders(false).request(request).handshake(streamAllocation.connection().handshake()).sentRequestAtMillis(l).receivedResponseAtMillis(System.currentTimeMillis()).build();
            n2 = object.code();
        }
        realInterceptorChain.eventListener().responseHeadersEnd(realInterceptorChain.call(), (Response)object);
        object = this.forWebSocket && n2 == 101 ? object.newBuilder().body(Util.EMPTY_RESPONSE).build() : object.newBuilder().body(httpCodec.openResponseBody((Response)object)).build();
        if ("close".equalsIgnoreCase(object.request().header("Connection")) || "close".equalsIgnoreCase(object.header("Connection"))) {
            streamAllocation.noNewStreams();
        }
        if ((n2 == 204 || n2 == 205) && object.body().contentLength() > 0L) {
            object2 = new StringBuilder();
            object2.append("HTTP ");
            object2.append(n2);
            object2.append(" had non-zero Content-Length: ");
            object2.append(object.body().contentLength());
            throw new ProtocolException(object2.toString());
        }
        return object;
    }

    static final class CountingSink
    extends ForwardingSink {
        long successfulCount;

        CountingSink(Sink sink) {
            super(sink);
        }

        public void write(Buffer buffer, long l) throws IOException {
            super.write(buffer, l);
            this.successfulCount += l;
        }
    }

}

