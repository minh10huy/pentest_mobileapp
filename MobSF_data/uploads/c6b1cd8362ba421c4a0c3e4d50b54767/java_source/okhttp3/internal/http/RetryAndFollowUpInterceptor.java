/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  okhttp3.Address
 *  okhttp3.Authenticator
 *  okhttp3.CertificatePinner
 *  okhttp3.ConnectionPool
 *  okhttp3.EventListener
 *  okhttp3.HttpUrl
 *  okhttp3.Interceptor$Chain
 *  okhttp3.OkHttpClient
 *  okhttp3.Request
 *  okhttp3.Request$Builder
 *  okhttp3.RequestBody
 *  okhttp3.Response
 *  okhttp3.Response$Builder
 *  okhttp3.ResponseBody
 *  okhttp3.Route
 *  okhttp3.internal.Util
 *  okhttp3.internal.connection.RealConnection
 */
package okhttp3.internal.http;

import java.io.Closeable;
import java.io.IOException;
import java.io.InterruptedIOException;
import java.net.HttpRetryException;
import java.net.ProtocolException;
import java.net.Proxy;
import java.net.ProxySelector;
import java.net.SocketTimeoutException;
import java.security.cert.CertificateException;
import java.util.List;
import javax.net.SocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLHandshakeException;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSocketFactory;
import okhttp3.Address;
import okhttp3.Authenticator;
import okhttp3.Call;
import okhttp3.CertificatePinner;
import okhttp3.ConnectionPool;
import okhttp3.Dns;
import okhttp3.EventListener;
import okhttp3.HttpUrl;
import okhttp3.Interceptor;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okhttp3.Route;
import okhttp3.internal.Util;
import okhttp3.internal.connection.RealConnection;
import okhttp3.internal.connection.RouteException;
import okhttp3.internal.connection.StreamAllocation;
import okhttp3.internal.http.HttpCodec;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.http.RealInterceptorChain;
import okhttp3.internal.http.UnrepeatableRequestBody;
import okhttp3.internal.http2.ConnectionShutdownException;

public final class RetryAndFollowUpInterceptor
implements Interceptor {
    private static final int MAX_FOLLOW_UPS = 20;
    private Object callStackTrace;
    private volatile boolean canceled;
    private final OkHttpClient client;
    private final boolean forWebSocket;
    private volatile StreamAllocation streamAllocation;

    public RetryAndFollowUpInterceptor(OkHttpClient okHttpClient, boolean bl) {
        this.client = okHttpClient;
        this.forWebSocket = bl;
    }

    private Address createAddress(HttpUrl httpUrl) {
        HostnameVerifier hostnameVerifier;
        HostnameVerifier hostnameVerifier2;
        Object object;
        if (httpUrl.isHttps()) {
            object = this.client.sslSocketFactory();
            hostnameVerifier = this.client.hostnameVerifier();
            CertificatePinner certificatePinner = this.client.certificatePinner();
            hostnameVerifier2 = certificatePinner;
        } else {
            HostnameVerifier hostnameVerifier3;
            hostnameVerifier2 = hostnameVerifier = (hostnameVerifier3 = null);
            object = hostnameVerifier3;
        }
        return new Address(httpUrl.host(), httpUrl.port(), this.client.dns(), this.client.socketFactory(), (SSLSocketFactory)object, hostnameVerifier, (CertificatePinner)hostnameVerifier2, this.client.proxyAuthenticator(), this.client.proxy(), this.client.protocols(), this.client.connectionSpecs(), this.client.proxySelector());
    }

    private Request followUpRequest(Response response, Route object) throws IOException {
        if (response == null) {
            throw new IllegalStateException();
        }
        int n = response.code();
        String string2 = response.request().method();
        Proxy proxy = null;
        switch (n) {
            default: {
                return null;
            }
            case 503: {
                if (response.priorResponse() != null && response.priorResponse().code() == 503) {
                    return null;
                }
                if (this.retryAfter(response, Integer.MAX_VALUE) == 0) {
                    return response.request();
                }
                return null;
            }
            case 408: {
                if (!this.client.retryOnConnectionFailure()) {
                    return null;
                }
                if (response.request().body() instanceof UnrepeatableRequestBody) {
                    return null;
                }
                if (response.priorResponse() != null && response.priorResponse().code() == 408) {
                    return null;
                }
                if (this.retryAfter(response, 0) > 0) {
                    return null;
                }
                return response.request();
            }
            case 407: {
                proxy = object != null ? object.proxy() : this.client.proxy();
                if (proxy.type() != Proxy.Type.HTTP) {
                    throw new ProtocolException("Received HTTP_PROXY_AUTH (407) code while not using proxy");
                }
                return this.client.proxyAuthenticator().authenticate(object, response);
            }
            case 401: {
                return this.client.authenticator().authenticate(object, response);
            }
            case 307: 
            case 308: {
                if (string2.equals("GET") || string2.equals("HEAD")) break;
                return null;
            }
            case 300: 
            case 301: 
            case 302: 
            case 303: 
        }
        if (!this.client.followRedirects()) {
            return null;
        }
        object = response.header("Location");
        if (object == null) {
            return null;
        }
        HttpUrl httpUrl = response.request().url().resolve((String)object);
        if (httpUrl == null) {
            return null;
        }
        if (!httpUrl.scheme().equals(response.request().url().scheme()) && !this.client.followSslRedirects()) {
            return null;
        }
        Request.Builder builder2 = response.request().newBuilder();
        if (HttpMethod.permitsRequestBody(string2)) {
            boolean bl = HttpMethod.redirectsWithBody(string2);
            if (HttpMethod.redirectsToGet(string2)) {
                builder2.method("GET", null);
            } else {
                object = proxy;
                if (bl) {
                    object = response.request().body();
                }
                builder2.method(string2, (RequestBody)object);
            }
            if (!bl) {
                builder2.removeHeader("Transfer-Encoding");
                builder2.removeHeader("Content-Length");
                builder2.removeHeader("Content-Type");
            }
        }
        if (!this.sameConnection(response, httpUrl)) {
            builder2.removeHeader("Authorization");
        }
        return builder2.url(httpUrl).build();
    }

    private boolean isRecoverable(IOException iOException, boolean bl) {
        boolean bl2 = iOException instanceof ProtocolException;
        boolean bl3 = false;
        if (bl2) {
            return false;
        }
        if (iOException instanceof InterruptedIOException) {
            bl2 = bl3;
            if (iOException instanceof SocketTimeoutException) {
                bl2 = bl3;
                if (!bl) {
                    bl2 = true;
                }
            }
            return bl2;
        }
        if (iOException instanceof SSLHandshakeException && iOException.getCause() instanceof CertificateException) {
            return false;
        }
        if (iOException instanceof SSLPeerUnverifiedException) {
            return false;
        }
        return true;
    }

    private boolean recover(IOException iOException, StreamAllocation streamAllocation, boolean bl, Request request) {
        streamAllocation.streamFailed(iOException);
        if (!this.client.retryOnConnectionFailure()) {
            return false;
        }
        if (bl && request.body() instanceof UnrepeatableRequestBody) {
            return false;
        }
        if (!this.isRecoverable(iOException, bl)) {
            return false;
        }
        if (!streamAllocation.hasMoreRoutes()) {
            return false;
        }
        return true;
    }

    private int retryAfter(Response object, int n) {
        if ((object = object.header("Retry-After")) == null) {
            return n;
        }
        if (object.matches("\\d+")) {
            return Integer.valueOf((String)object);
        }
        return Integer.MAX_VALUE;
    }

    private boolean sameConnection(Response response, HttpUrl httpUrl) {
        if ((response = response.request().url()).host().equals(httpUrl.host()) && response.port() == httpUrl.port() && response.scheme().equals(httpUrl.scheme())) {
            return true;
        }
        return false;
    }

    public void cancel() {
        this.canceled = true;
        StreamAllocation streamAllocation = this.streamAllocation;
        if (streamAllocation != null) {
            streamAllocation.cancel();
        }
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    @Override
    public Response intercept(Interceptor var1_1) throws IOException {
        var6_3 /* !! */  = var1_1.request();
        var8_6 = (RealInterceptorChain)var1_1;
        var9_7 = var8_6.call();
        var10_8 = var8_6.eventListener();
        var4_9 = new StreamAllocation(this.client.connectionPool(), this.createAddress(var6_3 /* !! */ .url()), var9_7, var10_8, this.callStackTrace);
        this.streamAllocation = var4_9;
        var5_10 = null;
        var2_11 = 0;
        var1_1 = var6_3 /* !! */ ;
        do {
            if (this.canceled) {
                var4_9.release();
                throw new IOException("Canceled");
            }
            var6_3 /* !! */  = var8_6.proceed((Request)var1_1, (StreamAllocation)var4_9, null, null);
            var1_1 = var5_10 != null ? var6_3 /* !! */ .newBuilder().priorResponse(var5_10.newBuilder().body(null).build()).build() : var6_3 /* !! */ ;
            var7_13 = this.followUpRequest((Response)var1_1, var4_9.route());
            if (var7_13 == null) {
                if (this.forWebSocket != false) return var1_1;
                var4_9.release();
                return var1_1;
            }
            Util.closeQuietly((Closeable)var1_1.body());
            if (++var2_11 > 20) {
                var4_9.release();
                var1_1 = new StringBuilder();
                var1_1.append("Too many follow-up requests: ");
                var1_1.append(var2_11);
                throw new ProtocolException(var1_1.toString());
            }
            if (var7_13.body() instanceof UnrepeatableRequestBody) {
                var4_9.release();
                throw new HttpRetryException("Cannot retry streamed HTTP body", var1_1.code());
            }
            if (!this.sameConnection((Response)var1_1, var7_13.url())) {
                var4_9.release();
                var6_3 /* !! */  = new StreamAllocation(this.client.connectionPool(), this.createAddress(var7_13.url()), var9_7, var10_8, this.callStackTrace);
                this.streamAllocation = var6_3 /* !! */ ;
            } else {
                var6_3 /* !! */  = var4_9;
                if (var4_9.codec() != null) {
                    var4_9 = new StringBuilder();
                    var4_9.append("Closing the body of ");
                    var4_9.append(var1_1);
                    var4_9.append(" didn't close its backing stream. Bad interceptor?");
                    throw new IllegalStateException(var4_9.toString());
                }
            }
            var5_10 = var1_1;
            var1_1 = var7_13;
            var4_9 = var6_3 /* !! */ ;
            continue;
            {
                catch (Throwable var1_2) {
                    ** GOTO lbl54
                }
                catch (IOException var6_4) {}
                {
                    catch (RouteException var6_5) {
                        if (this.recover(var6_5.getLastConnectException(), (StreamAllocation)var4_9, false, (Request)var1_1)) continue;
                        throw var6_5.getLastConnectException();
                    }
lbl54: // 1 sources:
                    var4_9.streamFailed(null);
                    var4_9.release();
                    throw var1_2;
                    var3_12 = var6_4 instanceof ConnectionShutdownException == false;
                    if (!this.recover(var6_4, (StreamAllocation)var4_9, var3_12, (Request)var1_1)) throw var6_4;
                    continue;
                }
            }
            break;
        } while (true);
    }

    public boolean isCanceled() {
        return this.canceled;
    }

    public void setCallStackTrace(Object object) {
        this.callStackTrace = object;
    }

    public StreamAllocation streamAllocation() {
        return this.streamAllocation;
    }
}

