/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  okhttp3.internal.Util
 *  okhttp3.internal.platform.Platform
 *  okio.Source
 */
package okhttp3.internal.publicsuffix;

import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.net.IDN;
import java.nio.charset.Charset;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicBoolean;
import okhttp3.internal.Util;
import okhttp3.internal.platform.Platform;
import okio.GzipSource;
import okio.Okio;
import okio.Source;

public final class PublicSuffixDatabase {
    private static final String[] EMPTY_RULE;
    private static final byte EXCEPTION_MARKER = 33;
    private static final String[] PREVAILING_RULE;
    public static final String PUBLIC_SUFFIX_RESOURCE = "publicsuffixes.gz";
    private static final byte[] WILDCARD_LABEL;
    private static final PublicSuffixDatabase instance;
    private final AtomicBoolean listRead = new AtomicBoolean(false);
    private byte[] publicSuffixExceptionListBytes;
    private byte[] publicSuffixListBytes;
    private final CountDownLatch readCompleteLatch = new CountDownLatch(1);

    static {
        WILDCARD_LABEL = new byte[]{42};
        EMPTY_RULE = new String[0];
        PREVAILING_RULE = new String[]{"*"};
        instance = new PublicSuffixDatabase();
    }

    /*
     * Enabled aggressive block sorting
     */
    private static String binarySearchBytes(byte[] arrby, byte[][] arrby2, int n) {
        int n2 = arrby.length;
        int n3 = 0;
        block0 : while (n3 < n2) {
            int n4;
            int n5;
            for (n4 = (n3 + n2) / 2; n4 > -1 && arrby[n4] != 10; --n4) {
            }
            int n6 = n4 + 1;
            n4 = 1;
            while (arrby[n5 = n6 + n4] != 10) {
                ++n4;
            }
            int n7 = n5 - n6;
            int n8 = n;
            boolean bl = false;
            n4 = 0;
            int n9 = 0;
            do {
                int n10;
                block13 : {
                    block17 : {
                        block18 : {
                            block15 : {
                                block16 : {
                                    int n11;
                                    block14 : {
                                        block11 : {
                                            int n12;
                                            block12 : {
                                                if (bl) {
                                                    bl = false;
                                                    n10 = 46;
                                                } else {
                                                    n10 = arrby2[n8][n4] & 255;
                                                }
                                                n11 = n10 - (arrby[n6 + n9] & 255);
                                                if (n11 != 0) break block11;
                                                n10 = n9 + 1;
                                                n12 = n4 + 1;
                                                if (n10 != n7) break block12;
                                                n4 = n12;
                                                n9 = n10;
                                                break block11;
                                            }
                                            n4 = n12;
                                            n9 = n10;
                                            if (arrby2[n8].length != n12) continue;
                                            if (n8 != arrby2.length - 1) break block13;
                                            n9 = n10;
                                            n4 = n12;
                                        }
                                        if (n11 >= 0) break block14;
                                        n4 = n6 - 1;
                                        break block15;
                                    }
                                    if (n11 <= 0) break block16;
                                    n4 = n5 + 1;
                                    break block17;
                                }
                                n9 = n7 - n9;
                                n4 = arrby2[n8].length - n4;
                                while (++n8 < arrby2.length) {
                                    n4 += arrby2[n8].length;
                                }
                                if (n4 >= n9) break block18;
                                n4 = n6 - 1;
                            }
                            n2 = n4;
                            continue block0;
                        }
                        if (n4 <= n9) {
                            return new String(arrby, n6, n7, Util.UTF_8);
                        }
                        n4 = n5 + 1;
                    }
                    n3 = n4;
                    continue block0;
                }
                ++n8;
                bl = true;
                n4 = -1;
                n9 = n10;
            } while (true);
            break;
        }
        return null;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private String[] findMatchingRule(String[] object) {
        Object object2;
        byte[][] arrarrby;
        int n;
        Object object3;
        block22 : {
            block21 : {
                boolean bl = this.listRead.get();
                int n2 = 0;
                if (!bl && this.listRead.compareAndSet(false, true)) {
                    this.readTheListUninterruptibly();
                } else {
                    try {
                        this.readCompleteLatch.await();
                    }
                    catch (InterruptedException interruptedException) {}
                }
                synchronized (this) {
                    if (this.publicSuffixListBytes == null) {
                        throw new IllegalStateException("Unable to load publicsuffixes.gz resource from the classpath.");
                    }
                }
                arrarrby = new byte[((String[])object).length][];
                for (n = 0; n < ((String[])object).length; ++n) {
                    arrarrby[n] = object[n].getBytes(Util.UTF_8);
                }
                for (n = 0; n < arrarrby.length; ++n) {
                    object = PublicSuffixDatabase.binarySearchBytes(this.publicSuffixListBytes, arrarrby, n);
                    if (object == null) {
                        continue;
                    }
                    break block21;
                }
                object = null;
            }
            if (arrarrby.length <= 1) return PREVAILING_RULE;
            object2 = (byte[][])arrarrby.clone();
            for (n = 0; n < ((byte[][])object2).length - 1; ++n) {
                object2[n] = WILDCARD_LABEL;
                object3 = PublicSuffixDatabase.binarySearchBytes(this.publicSuffixListBytes, object2, n);
                if (object3 == null) {
                    continue;
                }
                break block22;
            }
            object3 = null;
        }
        if (object3 != null) {
            for (n = n2; n < arrarrby.length - 1; ++n) {
                object2 = PublicSuffixDatabase.binarySearchBytes(this.publicSuffixExceptionListBytes, arrarrby, n);
                if (object2 == null) {
                    continue;
                }
                break;
            }
        } else {
            object2 = null;
        }
        if (object2 != null) {
            object = new StringBuilder();
            object.append("!");
            object.append((String)object2);
            return object.toString().split("\\.");
        }
        if (object == null && object3 == null) {
            return PREVAILING_RULE;
        }
        object = object != null ? object.split("\\.") : EMPTY_RULE;
        object3 = object3 != null ? object3.split("\\.") : EMPTY_RULE;
        if (((Object)object).length > ((String[])object3).length) {
            return object;
        }
        return object3;
    }

    public static PublicSuffixDatabase get() {
        return instance;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void readTheList() throws IOException {
        InputStream inputStream = PublicSuffixDatabase.class.getResourceAsStream(PUBLIC_SUFFIX_RESOURCE);
        if (inputStream == null) {
            return;
        }
        inputStream = Okio.buffer(new GzipSource(Okio.source(inputStream)));
        byte[] arrby = new byte[inputStream.readInt()];
        inputStream.readFully(arrby);
        byte[] arrby2 = new byte[inputStream.readInt()];
        inputStream.readFully(arrby2);
        synchronized (this) {
            this.publicSuffixListBytes = arrby;
            this.publicSuffixExceptionListBytes = arrby2;
        }
        this.readCompleteLatch.countDown();
        return;
        finally {
            Util.closeQuietly((Closeable)inputStream);
        }
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void readTheListUninterruptibly() {
        boolean bl = false;
        do {
            Throwable throwable2222;
            try {
                this.readTheList();
                if (!bl) return;
                Thread.currentThread().interrupt();
                return;
            }
            catch (InterruptedIOException interruptedIOException) {}
            {
                catch (Throwable throwable2222) {
                }
                catch (IOException iOException) {}
                {
                    Platform.get().log(5, "Failed to read public suffix list", (Throwable)iOException);
                    if (!bl) return;
                    Thread.currentThread().interrupt();
                    return;
                }
            }
            if (!bl) throw throwable2222;
            Thread.currentThread().interrupt();
            throw throwable2222;
            bl = true;
        } while (true);
    }

    public String getEffectiveTldPlusOne(String arrstring) {
        String[] arrstring2;
        if (arrstring == null) {
            throw new NullPointerException("domain == null");
        }
        Object object = IDN.toUnicode((String)arrstring).split("\\.");
        if (((String[])object).length == (arrstring2 = this.findMatchingRule((String[])object)).length && arrstring2[0].charAt(0) != '!') {
            return null;
        }
        int n = arrstring2[0].charAt(0) == '!' ? ((String[])object).length - arrstring2.length : ((String[])object).length - (arrstring2.length + 1);
        object = new StringBuilder();
        arrstring = arrstring.split("\\.");
        while (n < arrstring.length) {
            object.append(arrstring[n]);
            object.append('.');
            ++n;
        }
        object.deleteCharAt(object.length() - 1);
        return object.toString();
    }

    void setListBytes(byte[] arrby, byte[] arrby2) {
        this.publicSuffixListBytes = arrby;
        this.publicSuffixExceptionListBytes = arrby2;
        this.listRead.set(true);
        this.readCompleteLatch.countDown();
    }
}

