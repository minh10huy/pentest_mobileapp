/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  javax.annotation.Nullable
 *  okhttp3.Call
 *  okhttp3.CipherSuite
 *  okhttp3.Interceptor
 *  okhttp3.Protocol
 *  okhttp3.internal.Internal
 *  okhttp3.internal.Version
 *  okhttp3.internal.connection.ConnectionSpecSelector
 *  okhttp3.internal.connection.RealConnection$1
 *  okhttp3.internal.connection.RouteException
 *  okhttp3.internal.connection.StreamAllocation
 *  okhttp3.internal.http.HttpCodec
 *  okhttp3.internal.http.HttpHeaders
 *  okhttp3.internal.http1.Http1Codec
 *  okhttp3.internal.http2.ErrorCode
 *  okhttp3.internal.http2.Http2Codec
 *  okhttp3.internal.http2.Http2Connection
 *  okhttp3.internal.http2.Http2Connection$Builder
 *  okhttp3.internal.http2.Http2Stream
 *  okhttp3.internal.tls.OkHostnameVerifier
 *  okhttp3.internal.ws.RealWebSocket$Streams
 *  okio.Okio
 */
package okhttp3.internal.connection;

import java.io.IOException;
import java.lang.ref.Reference;
import java.net.ConnectException;
import java.net.InetSocketAddress;
import java.net.ProtocolException;
import java.net.Proxy;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownServiceException;
import java.security.Principal;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import javax.annotation.Nullable;
import javax.net.SocketFactory;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import okhttp3.Address;
import okhttp3.Authenticator;
import okhttp3.Call;
import okhttp3.CertificatePinner;
import okhttp3.CipherSuite;
import okhttp3.Connection;
import okhttp3.ConnectionPool;
import okhttp3.ConnectionSpec;
import okhttp3.EventListener;
import okhttp3.Handshake;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.Interceptor;
import okhttp3.OkHttpClient;
import okhttp3.Protocol;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.Route;
import okhttp3.internal.Internal;
import okhttp3.internal.Util;
import okhttp3.internal.Version;
import okhttp3.internal.connection.ConnectionSpecSelector;
import okhttp3.internal.connection.RealConnection;
import okhttp3.internal.connection.RouteException;
import okhttp3.internal.connection.StreamAllocation;
import okhttp3.internal.http.HttpCodec;
import okhttp3.internal.http.HttpHeaders;
import okhttp3.internal.http1.Http1Codec;
import okhttp3.internal.http2.ErrorCode;
import okhttp3.internal.http2.Http2Codec;
import okhttp3.internal.http2.Http2Connection;
import okhttp3.internal.http2.Http2Stream;
import okhttp3.internal.platform.Platform;
import okhttp3.internal.tls.OkHostnameVerifier;
import okhttp3.internal.ws.RealWebSocket;
import okio.Buffer;
import okio.BufferedSink;
import okio.BufferedSource;
import okio.Okio;
import okio.Sink;
import okio.Source;
import okio.Timeout;

public final class RealConnection
extends Http2Connection.Listener
implements Connection {
    private static final int MAX_TUNNEL_ATTEMPTS = 21;
    private static final String NPE_THROW_WITH_NULL = "throw with null exception";
    public int allocationLimit = 1;
    public final List<Reference<StreamAllocation>> allocations = new ArrayList<Reference<StreamAllocation>>();
    private final ConnectionPool connectionPool;
    private Handshake handshake;
    private Http2Connection http2Connection;
    public long idleAtNanos = Long.MAX_VALUE;
    public boolean noNewStreams;
    private Protocol protocol;
    private Socket rawSocket;
    private final Route route;
    private BufferedSink sink;
    private Socket socket;
    private BufferedSource source;
    public int successCount;

    public RealConnection(ConnectionPool connectionPool, Route route) {
        this.connectionPool = connectionPool;
        this.route = route;
    }

    private void connectSocket(int n, int n2, Call call, EventListener object) throws IOException {
        Proxy proxy = this.route.proxy();
        Object object2 = this.route.address();
        object2 = proxy.type() != Proxy.Type.DIRECT && proxy.type() != Proxy.Type.HTTP ? new Socket(proxy) : object2.socketFactory().createSocket();
        this.rawSocket = object2;
        object.connectStart(call, this.route.socketAddress(), proxy);
        this.rawSocket.setSoTimeout(n2);
        try {
            Platform.get().connectSocket(this.rawSocket, this.route.socketAddress(), n);
        }
        catch (ConnectException connectException) {
            object = new StringBuilder();
            object.append("Failed to connect to ");
            object.append(this.route.socketAddress());
            object = new ConnectException(object.toString());
            object.initCause(connectException);
            throw object;
        }
        try {
            this.source = Okio.buffer((Source)Okio.source((Socket)this.rawSocket));
            this.sink = Okio.buffer((Sink)Okio.sink((Socket)this.rawSocket));
            return;
        }
        catch (NullPointerException nullPointerException) {
            if (NPE_THROW_WITH_NULL.equals(nullPointerException.getMessage())) {
                throw new IOException(nullPointerException);
            }
            return;
        }
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void connectTls(ConnectionSpecSelector var1_1) throws IOException {
        block14 : {
            var6_5 = this.route.address();
            var3_6 = var6_5.sslSocketFactory();
            var2_8 = null;
            var5_10 = null;
            var4_11 = null;
            var3_6 = (SSLSocket)var3_6.createSocket(this.rawSocket, var6_5.url().host(), var6_5.url().port(), true);
            try {
                var5_10 = var1_1.configureSecureSocket((SSLSocket)var3_6);
                if (var5_10.supportsTlsExtensions()) {
                    Platform.get().configureTlsExtensions((SSLSocket)var3_6, var6_5.url().host(), var6_5.protocols());
                }
                var3_6.startHandshake();
                var1_1 = var3_6.getSession();
                if (!this.isValid((SSLSession)var1_1)) {
                    throw new IOException("a valid ssl session was not established");
                }
                var2_8 = Handshake.get((SSLSession)var1_1);
                if (!var6_5.hostnameVerifier().verify(var6_5.url().host(), (SSLSession)var1_1)) {
                    var1_1 = (X509Certificate)var2_8.peerCertificates().get(0);
                    var2_8 = new StringBuilder();
                    var2_8.append("Hostname ");
                    var2_8.append(var6_5.url().host());
                    var2_8.append(" not verified:\n    certificate: ");
                    var2_8.append(CertificatePinner.pin((Certificate)var1_1));
                    var2_8.append("\n    DN: ");
                    var2_8.append(var1_1.getSubjectDN().getName());
                    var2_8.append("\n    subjectAltNames: ");
                    var2_8.append(OkHostnameVerifier.allSubjectAltNames((X509Certificate)var1_1));
                    throw new SSLPeerUnverifiedException(var2_8.toString());
                }
                var6_5.certificatePinner().check(var6_5.url().host(), var2_8.peerCertificates());
                var1_1 = var4_11;
                if (var5_10.supportsTlsExtensions()) {
                    var1_1 = Platform.get().getSelectedProtocol((SSLSocket)var3_6);
                }
                this.socket = var3_6;
                this.source = Okio.buffer((Source)Okio.source((Socket)this.socket));
                this.sink = Okio.buffer((Sink)Okio.sink((Socket)this.socket));
                this.handshake = var2_8;
                var1_1 = var1_1 != null ? Protocol.get((String)var1_1) : Protocol.HTTP_1_1;
                this.protocol = var1_1;
                if (var3_6 == null) return;
                Platform.get().afterHandshake((SSLSocket)var3_6);
                return;
            }
            catch (AssertionError var2_9) {
                var1_1 = var3_6;
                var3_6 = var2_9;
            }
            ** finally { 
lbl46: // 1 sources:
            break block14;
            catch (Throwable var1_3) {
                var3_6 = var2_8;
                break block14;
            }
            catch (AssertionError var3_7) {
                var1_1 = var5_10;
            }
            var2_8 = var1_1;
            {
                if (Util.isAndroidGetsocknameError((AssertionError)var3_6)) {
                    var2_8 = var1_1;
                    throw new IOException((Throwable)var3_6);
                }
                var2_8 = var1_1;
                throw var3_6;
            }
        }
        if (var3_6 != null) {
            Platform.get().afterHandshake((SSLSocket)var3_6);
        }
        Util.closeQuietly((Socket)var3_6);
        throw var1_4;
    }

    private void connectTunnel(int n, int n2, int n3, Call call, EventListener eventListener) throws IOException {
        Request request = this.createTunnelRequest();
        HttpUrl httpUrl = request.url();
        for (int i = 0; i < 21; ++i) {
            this.connectSocket(n, n2, call, eventListener);
            request = this.createTunnel(n2, n3, request, httpUrl);
            if (request == null) {
                return;
            }
            Util.closeQuietly(this.rawSocket);
            this.rawSocket = null;
            this.sink = null;
            this.source = null;
            eventListener.connectEnd(call, this.route.socketAddress(), this.route.proxy(), null);
        }
    }

    private Request createTunnel(int n, int n2, Request object, HttpUrl object2) throws IOException {
        block4 : {
            Object object3 = new StringBuilder();
            object3.append("CONNECT ");
            object3.append(Util.hostHeader((HttpUrl)object2, true));
            object3.append(" HTTP/1.1");
            object2 = object3.toString();
            do {
                long l;
                Http1Codec http1Codec = new Http1Codec(null, null, this.source, this.sink);
                this.source.timeout().timeout(n, TimeUnit.MILLISECONDS);
                this.sink.timeout().timeout(n2, TimeUnit.MILLISECONDS);
                http1Codec.writeRequest(object.headers(), (String)object2);
                http1Codec.finishRequest();
                object3 = http1Codec.readResponseHeaders(false).request((Request)object).build();
                long l2 = l = HttpHeaders.contentLength((Response)object3);
                if (l == -1L) {
                    l2 = 0L;
                }
                object = http1Codec.newFixedLengthSource(l2);
                Util.skipAll((Source)object, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
                object.close();
                int n3 = object3.code();
                if (n3 == 200) break block4;
                if (n3 != 407) {
                    object = new StringBuilder();
                    object.append("Unexpected response code for CONNECT: ");
                    object.append(object3.code());
                    throw new IOException(object.toString());
                }
                object = this.route.address().proxyAuthenticator().authenticate(this.route, (Response)object3);
                if (object != null) continue;
                throw new IOException("Failed to authenticate with proxy");
            } while (!"close".equalsIgnoreCase(object3.header("Connection")));
            return object;
        }
        if (this.source.buffer().exhausted() && this.sink.buffer().exhausted()) {
            return null;
        }
        throw new IOException("TLS tunnel buffered too many bytes!");
    }

    private Request createTunnelRequest() {
        return new Request.Builder().url(this.route.address().url()).header("Host", Util.hostHeader(this.route.address().url(), true)).header("Proxy-Connection", "Keep-Alive").header("User-Agent", Version.userAgent()).build();
    }

    private void establishProtocol(ConnectionSpecSelector connectionSpecSelector, int n, Call call, EventListener eventListener) throws IOException {
        if (this.route.address().sslSocketFactory() == null) {
            this.protocol = Protocol.HTTP_1_1;
            this.socket = this.rawSocket;
            return;
        }
        eventListener.secureConnectStart(call);
        this.connectTls(connectionSpecSelector);
        eventListener.secureConnectEnd(call, this.handshake);
        if (this.protocol == Protocol.HTTP_2) {
            this.socket.setSoTimeout(0);
            this.http2Connection = new Http2Connection.Builder(true).socket(this.socket, this.route.address().url().host(), this.source, this.sink).listener((Http2Connection.Listener)this).pingIntervalMillis(n).build();
            this.http2Connection.start();
        }
    }

    private boolean isValid(SSLSession sSLSession) {
        if (!"NONE".equals(sSLSession.getProtocol()) && !"SSL_NULL_WITH_NULL_NULL".equals(sSLSession.getCipherSuite())) {
            return true;
        }
        return false;
    }

    public static RealConnection testConnection(ConnectionPool object, Route route, Socket socket, long l) {
        object = new RealConnection((ConnectionPool)object, route);
        object.socket = socket;
        object.idleAtNanos = l;
        return object;
    }

    public void cancel() {
        Util.closeQuietly(this.rawSocket);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    public void connect(int n, int n2, int n3, int n4, boolean bl, Call object, EventListener eventListener) {
        RouteException routeException;
        if (this.protocol != null) {
            throw new IllegalStateException("already connected");
        }
        Object object2 = this.route.address().connectionSpecs();
        ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(object2);
        if (this.route.address().sslSocketFactory() == null) {
            if (!object2.contains(ConnectionSpec.CLEARTEXT)) {
                throw new RouteException((IOException)new UnknownServiceException("CLEARTEXT communication not enabled for client"));
            }
            object2 = this.route.address().url().host();
            if (!Platform.get().isCleartextTrafficPermitted((String)object2)) {
                object = new StringBuilder();
                object.append("CLEARTEXT communication to ");
                object.append((String)object2);
                object.append(" not permitted by network security policy");
                throw new RouteException((IOException)new UnknownServiceException(object.toString()));
            }
        }
        RouteException routeException2 = null;
        do {
            block19 : {
                block18 : {
                    block17 : {
                        block16 : {
                            if (!this.route.requiresTunnel()) break block16;
                            this.connectTunnel(n, n2, n3, (Call)object, eventListener);
                            object2 = this.rawSocket;
                            if (object2 != null) break block17;
                            break block18;
                        }
                        try {
                            this.connectSocket(n, n2, (Call)object, eventListener);
                        }
                        catch (IOException iOException3) {
                            break block19;
                        }
                    }
                    try {
                        this.establishProtocol(connectionSpecSelector, n4, (Call)object, eventListener);
                        eventListener.connectEnd((Call)object, this.route.socketAddress(), this.route.proxy(), this.protocol);
                    }
                    catch (IOException iOException) {}
                }
                if (this.route.requiresTunnel() && this.rawSocket == null) {
                    throw new RouteException((IOException)new ProtocolException("Too many tunnel connections attempted: 21"));
                }
                if (this.http2Connection == null) return;
                object = this.connectionPool;
                // MONITORENTER : object
                this.allocationLimit = this.http2Connection.maxConcurrentStreams();
                // MONITOREXIT : object
                return;
                break block19;
                catch (IOException iOException2) {
                    // empty catch block
                }
            }
            Util.closeQuietly(this.socket);
            Util.closeQuietly(this.rawSocket);
            this.socket = null;
            this.rawSocket = null;
            this.source = null;
            this.sink = null;
            this.handshake = null;
            this.protocol = null;
            this.http2Connection = null;
            eventListener.connectFailed((Call)object, this.route.socketAddress(), this.route.proxy(), null, (IOException)object2);
            if (routeException2 == null) {
                routeException = new RouteException((IOException)object2);
            } else {
                routeException2.addConnectException((IOException)object2);
                routeException = routeException2;
            }
            if (!bl) throw routeException;
            routeException2 = routeException;
        } while (connectionSpecSelector.connectionFailed((IOException)object2));
        throw routeException;
    }

    @Override
    public Handshake handshake() {
        return this.handshake;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public boolean isEligible(Address address, @Nullable Route route) {
        if (this.allocations.size() >= this.allocationLimit) return false;
        if (this.noNewStreams) {
            return false;
        }
        if (!Internal.instance.equalsNonHost(this.route.address(), address)) {
            return false;
        }
        if (address.url().host().equals(this.route().address().url().host())) {
            return true;
        }
        if (this.http2Connection == null) {
            return false;
        }
        if (route == null) {
            return false;
        }
        if (route.proxy().type() != Proxy.Type.DIRECT) {
            return false;
        }
        if (this.route.proxy().type() != Proxy.Type.DIRECT) {
            return false;
        }
        if (!this.route.socketAddress().equals(route.socketAddress())) {
            return false;
        }
        if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) {
            return false;
        }
        if (!this.supportsUrl(address.url())) {
            return false;
        }
        try {
            address.certificatePinner().check(address.url().host(), this.handshake().peerCertificates());
            return true;
        }
        catch (SSLPeerUnverifiedException sSLPeerUnverifiedException) {
            return false;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public boolean isHealthy(boolean bl) {
        int n;
        block10 : {
            if (this.socket.isClosed() || this.socket.isInputShutdown()) return false;
            if (this.socket.isOutputShutdown()) {
                return false;
            }
            if (this.http2Connection != null) {
                return this.http2Connection.isShutdown() ^ true;
            }
            if (!bl) return true;
            n = this.socket.getSoTimeout();
            try {
                this.socket.setSoTimeout(1);
                bl = this.source.exhausted();
                if (!bl) break block10;
            }
            catch (Throwable throwable) {
                try {
                    this.socket.setSoTimeout(n);
                    throw throwable;
                }
                catch (SocketTimeoutException socketTimeoutException) {
                    return true;
                }
                catch (IOException iOException) {
                    return false;
                }
            }
            this.socket.setSoTimeout(n);
            return false;
        }
        this.socket.setSoTimeout(n);
        return true;
    }

    public boolean isMultiplexed() {
        if (this.http2Connection != null) {
            return true;
        }
        return false;
    }

    public HttpCodec newCodec(OkHttpClient okHttpClient, Interceptor.Chain chain, StreamAllocation streamAllocation) throws SocketException {
        if (this.http2Connection != null) {
            return new Http2Codec(okHttpClient, chain, streamAllocation, this.http2Connection);
        }
        this.socket.setSoTimeout(chain.readTimeoutMillis());
        this.source.timeout().timeout(chain.readTimeoutMillis(), TimeUnit.MILLISECONDS);
        this.sink.timeout().timeout(chain.writeTimeoutMillis(), TimeUnit.MILLISECONDS);
        return new Http1Codec(okHttpClient, streamAllocation, this.source, this.sink);
    }

    public RealWebSocket newWebSocketStreams(StreamAllocation streamAllocation) {
        return new 1(this, true, this.source, this.sink, streamAllocation);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public void onSettings(Http2Connection http2Connection) {
        ConnectionPool connectionPool = this.connectionPool;
        synchronized (connectionPool) {
            this.allocationLimit = http2Connection.maxConcurrentStreams();
            return;
        }
    }

    @Override
    public void onStream(Http2Stream http2Stream) throws IOException {
        http2Stream.close(ErrorCode.REFUSED_STREAM);
    }

    @Override
    public Protocol protocol() {
        return this.protocol;
    }

    @Override
    public Route route() {
        return this.route;
    }

    @Override
    public Socket socket() {
        return this.socket;
    }

    public boolean supportsUrl(HttpUrl httpUrl) {
        if (httpUrl.port() != this.route.address().url().port()) {
            return false;
        }
        if (!httpUrl.host().equals(this.route.address().url().host())) {
            if (this.handshake != null && OkHostnameVerifier.INSTANCE.verify(httpUrl.host(), (X509Certificate)this.handshake.peerCertificates().get(0))) {
                return true;
            }
            return false;
        }
        return true;
    }

    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Connection{");
        stringBuilder.append(this.route.address().url().host());
        stringBuilder.append(":");
        stringBuilder.append(this.route.address().url().port());
        stringBuilder.append(", proxy=");
        stringBuilder.append(this.route.proxy());
        stringBuilder.append(" hostAddress=");
        stringBuilder.append(this.route.socketAddress());
        stringBuilder.append(" cipherSuite=");
        String string2 = this.handshake != null ? this.handshake.cipherSuite() : "none";
        stringBuilder.append((Object)string2);
        stringBuilder.append(" protocol=");
        stringBuilder.append((Object)this.protocol);
        stringBuilder.append('}');
        return stringBuilder.toString();
    }
}

