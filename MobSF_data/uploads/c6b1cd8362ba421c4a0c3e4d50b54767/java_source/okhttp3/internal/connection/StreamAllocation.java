/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  okhttp3.Address
 *  okhttp3.Connection
 *  okhttp3.ConnectionPool
 *  okhttp3.EventListener
 *  okhttp3.Interceptor$Chain
 *  okhttp3.OkHttpClient
 *  okhttp3.Route
 *  okhttp3.internal.Util
 *  okhttp3.internal.connection.RealConnection
 */
package okhttp3.internal.connection;

import java.io.IOException;
import java.io.Serializable;
import java.lang.ref.Reference;
import java.lang.ref.WeakReference;
import java.net.Socket;
import java.util.List;
import okhttp3.Address;
import okhttp3.Call;
import okhttp3.Connection;
import okhttp3.ConnectionPool;
import okhttp3.EventListener;
import okhttp3.Interceptor;
import okhttp3.OkHttpClient;
import okhttp3.Route;
import okhttp3.internal.Internal;
import okhttp3.internal.Util;
import okhttp3.internal.connection.RealConnection;
import okhttp3.internal.connection.RouteDatabase;
import okhttp3.internal.connection.RouteException;
import okhttp3.internal.connection.RouteSelector;
import okhttp3.internal.http.HttpCodec;
import okhttp3.internal.http2.ConnectionShutdownException;
import okhttp3.internal.http2.ErrorCode;
import okhttp3.internal.http2.StreamResetException;

public final class StreamAllocation {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    public final Address address;
    public final Call call;
    private final Object callStackTrace;
    private boolean canceled;
    private HttpCodec codec;
    private RealConnection connection;
    private final ConnectionPool connectionPool;
    public final EventListener eventListener;
    private int refusedStreamCount;
    private boolean released;
    private boolean reportedAcquired;
    private Route route;
    private RouteSelector.Selection routeSelection;
    private final RouteSelector routeSelector;

    public StreamAllocation(ConnectionPool connectionPool, Address address, Call call, EventListener eventListener, Object object) {
        this.connectionPool = connectionPool;
        this.address = address;
        this.call = call;
        this.eventListener = eventListener;
        this.routeSelector = new RouteSelector(address, this.routeDatabase(), call, eventListener);
        this.callStackTrace = object;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private Socket deallocate(boolean var1_1, boolean var2_2, boolean var3_3) {
        if (var3_3) {
            this.codec = null;
        }
        if (var2_2) {
            this.released = true;
        }
        if (this.connection == null) return null;
        if (var1_1) {
            this.connection.noNewStreams = true;
        }
        if (this.codec != null) return null;
        if (!this.released) {
            if (this.connection.noNewStreams == false) return null;
        }
        this.release(this.connection);
        if (!this.connection.allocations.isEmpty()) ** GOTO lbl-1000
        this.connection.idleAtNanos = System.nanoTime();
        if (Internal.instance.connectionBecameIdle(this.connectionPool, this.connection)) {
            var4_4 = this.connection.socket();
        } else lbl-1000: // 2 sources:
        {
            var4_4 = null;
        }
        this.connection = null;
        return var4_4;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    private RealConnection findConnection(int var1_1, int var2_2, int var3_3, int var4_4, boolean var5_5) throws IOException {
        block31 : {
            block32 : {
                block29 : {
                    block30 : {
                        var15_6 = this.connectionPool;
                        // MONITORENTER : var15_6
                        if (this.released) {
                            throw new IllegalStateException("released");
                        }
                        if (this.codec != null) {
                            throw new IllegalStateException("codec != null");
                        }
                        if (this.canceled) {
                            throw new IOException("Canceled");
                        }
                        var11_7 = this.connection;
                        var16_8 = this.releaseIfNoNewStreams();
                        var10_9 = this.connection;
                        var14_10 = null;
                        if (var10_9 != null) {
                            var10_9 = this.connection;
                            var11_7 = null;
                        } else {
                            var10_9 = null;
                        }
                        var13_11 = var11_7;
                        if (!this.reportedAcquired) {
                            var13_11 = null;
                        }
                        if (var10_9 != null) break block29;
                        Internal.instance.get(this.connectionPool, this.address, this, null);
                        if (this.connection == null) break block30;
                        var11_7 = this.connection;
                        var10_9 = null;
                        var6_12 = true;
                        break block31;
                    }
                    var12_13 /* !! */  = this.route;
                    break block32;
                }
                var12_13 /* !! */  = null;
            }
            var6_12 = false;
            var11_7 = var10_9;
            var10_9 = var12_13 /* !! */ ;
        }
        // MONITOREXIT : var15_6
        Util.closeQuietly((Socket)var16_8);
        if (var13_11 != null) {
            this.eventListener.connectionReleased(this.call, (Connection)var13_11);
        }
        if (var6_12) {
            this.eventListener.connectionAcquired(this.call, (Connection)var11_7);
        }
        if (var11_7 != null) {
            return var11_7;
        }
        if (!(var10_9 != null || this.routeSelection != null && this.routeSelection.hasNext())) {
            this.routeSelection = this.routeSelector.next();
            var8_14 = 1;
        } else {
            var8_14 = 0;
        }
        var13_11 = this.connectionPool;
        // MONITORENTER : var13_11
        if (this.canceled) {
            throw new IOException("Canceled");
        }
        var7_15 = var6_12;
        var12_13 /* !! */  = var11_7;
        if (var8_14 == 0) ** GOTO lbl71
        var15_6 = this.routeSelection.getAll();
        var9_16 = var15_6.size();
        var8_14 = 0;
        do {
            block34 : {
                block33 : {
                    var7_15 = var6_12;
                    var12_13 /* !! */  = var11_7;
                    if (var8_14 >= var9_16) break block33;
                    var16_8 = (Route)var15_6.get(var8_14);
                    Internal.instance.get(this.connectionPool, this.address, this, (Route)var16_8);
                    if (this.connection == null) break block34;
                    var12_13 /* !! */  = this.connection;
                    this.route = var16_8;
                    var7_15 = true;
                }
                var11_7 = var12_13 /* !! */ ;
                if (!var7_15) {
                    var11_7 = var10_9;
                    if (var10_9 == null) {
                        var11_7 = this.routeSelection.next();
                    }
                    this.route = var11_7;
                    this.refusedStreamCount = 0;
                    var11_7 = new RealConnection(this.connectionPool, (Route)var11_7);
                    this.acquire(var11_7, false);
                }
                // MONITOREXIT : var13_11
                if (var7_15) {
                    this.eventListener.connectionAcquired(this.call, (Connection)var11_7);
                    return var11_7;
                }
                var11_7.connect(var1_1, var2_2, var3_3, var4_4, var5_5, this.call, this.eventListener);
                this.routeDatabase().connected(var11_7.route());
                var13_11 = this.connectionPool;
                // MONITORENTER : var13_11
                this.reportedAcquired = true;
                Internal.instance.put(this.connectionPool, var11_7);
                var12_13 /* !! */  = var14_10;
                var10_9 = var11_7;
                if (var11_7.isMultiplexed()) {
                    var12_13 /* !! */  = Internal.instance.deduplicate(this.connectionPool, this.address, this);
                    var10_9 = this.connection;
                }
                // MONITOREXIT : var13_11
                Util.closeQuietly((Socket)var12_13 /* !! */ );
                this.eventListener.connectionAcquired(this.call, (Connection)var10_9);
                return var10_9;
            }
            ++var8_14;
        } while (true);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    private RealConnection findHealthyConnection(int n, int n2, int n3, int n4, boolean bl, boolean bl2) throws IOException {
        do {
            RealConnection realConnection = this.findConnection(n, n2, n3, n4, bl);
            ConnectionPool connectionPool = this.connectionPool;
            // MONITORENTER : connectionPool
            if (realConnection.successCount == 0) {
                // MONITOREXIT : connectionPool
                return realConnection;
            }
            // MONITOREXIT : connectionPool
            if (realConnection.isHealthy(bl2)) return realConnection;
            this.noNewStreams();
        } while (true);
    }

    private void release(RealConnection realConnection) {
        int n = realConnection.allocations.size();
        for (int i = 0; i < n; ++i) {
            if (((Reference)realConnection.allocations.get(i)).get() != this) continue;
            realConnection.allocations.remove(i);
            return;
        }
        throw new IllegalStateException();
    }

    private Socket releaseIfNoNewStreams() {
        RealConnection realConnection = this.connection;
        if (realConnection != null && realConnection.noNewStreams) {
            return this.deallocate(false, false, true);
        }
        return null;
    }

    private RouteDatabase routeDatabase() {
        return Internal.instance.routeDatabase(this.connectionPool);
    }

    public void acquire(RealConnection realConnection, boolean bl) {
        if (this.connection != null) {
            throw new IllegalStateException();
        }
        this.connection = realConnection;
        this.reportedAcquired = bl;
        realConnection.allocations.add(new StreamAllocationReference(this, this.callStackTrace));
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    public void cancel() {
        ConnectionPool connectionPool = this.connectionPool;
        // MONITORENTER : connectionPool
        this.canceled = true;
        HttpCodec httpCodec = this.codec;
        RealConnection realConnection = this.connection;
        // MONITOREXIT : connectionPool
        if (httpCodec != null) {
            httpCodec.cancel();
            return;
        }
        if (realConnection == null) return;
        realConnection.cancel();
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public HttpCodec codec() {
        ConnectionPool connectionPool = this.connectionPool;
        synchronized (connectionPool) {
            return this.codec;
        }
    }

    public RealConnection connection() {
        synchronized (this) {
            RealConnection realConnection = this.connection;
            return realConnection;
        }
    }

    public boolean hasMoreRoutes() {
        if (!(this.route != null || this.routeSelection != null && this.routeSelection.hasNext() || this.routeSelector.hasNext())) {
            return false;
        }
        return true;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public HttpCodec newStream(OkHttpClient okHttpClient, Interceptor object, boolean bl) {
        int n = object.connectTimeoutMillis();
        int n2 = object.readTimeoutMillis();
        int n3 = object.writeTimeoutMillis();
        int n4 = okHttpClient.pingIntervalMillis();
        boolean bl2 = okHttpClient.retryOnConnectionFailure();
        try {
            object = this.findHealthyConnection(n, n2, n3, n4, bl2, bl).newCodec(okHttpClient, object, this);
            okHttpClient = this.connectionPool;
            synchronized (okHttpClient) {
                this.codec = object;
            }
        }
        catch (IOException iOException) {
            throw new RouteException(iOException);
        }
        return object;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void noNewStreams() {
        Socket socket;
        RealConnection realConnection;
        ConnectionPool connectionPool = this.connectionPool;
        synchronized (connectionPool) {
            realConnection = this.connection;
            socket = this.deallocate(true, false, false);
            if (this.connection != null) {
                realConnection = null;
            }
        }
        Util.closeQuietly((Socket)socket);
        if (realConnection != null) {
            this.eventListener.connectionReleased(this.call, (Connection)realConnection);
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void release() {
        Socket socket;
        RealConnection realConnection;
        ConnectionPool connectionPool = this.connectionPool;
        synchronized (connectionPool) {
            realConnection = this.connection;
            socket = this.deallocate(false, true, false);
            if (this.connection != null) {
                realConnection = null;
            }
        }
        Util.closeQuietly((Socket)socket);
        if (realConnection != null) {
            this.eventListener.connectionReleased(this.call, (Connection)realConnection);
        }
    }

    public Socket releaseAndAcquire(RealConnection realConnection) {
        if (this.codec == null && this.connection.allocations.size() == 1) {
            Reference reference = (Reference)this.connection.allocations.get(0);
            Socket socket = this.deallocate(true, false, false);
            this.connection = realConnection;
            realConnection.allocations.add(reference);
            return socket;
        }
        throw new IllegalStateException();
    }

    public Route route() {
        return this.route;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    public void streamFailed(IOException var1_1) {
        block9 : {
            var3_2 = this.connectionPool;
            // MONITORENTER : var3_2
            if (!(var1_1 instanceof StreamResetException)) break block9;
            var1_1 = (StreamResetException)var1_1;
            if (var1_1.errorCode == ErrorCode.REFUSED_STREAM) {
                ++this.refusedStreamCount;
            }
            if (var1_1.errorCode == ErrorCode.REFUSED_STREAM && this.refusedStreamCount <= 1) ** GOTO lbl-1000
            this.route = null;
            ** GOTO lbl16
        }
        if (this.connection != null && (!this.connection.isMultiplexed() || var1_1 instanceof ConnectionShutdownException)) {
            if (this.connection.successCount == 0) {
                if (this.route != null && var1_1 != null) {
                    this.routeSelector.connectFailed(this.route, var1_1);
                }
                this.route = null;
            }
lbl16: // 4 sources:
            var2_3 = true;
        } else lbl-1000: // 2 sources:
        {
            var2_3 = false;
        }
        var1_1 = this.connection;
        var4_4 = this.deallocate(var2_3, false, true);
        if (this.connection != null || !this.reportedAcquired) {
            var1_1 = null;
        }
        // MONITOREXIT : var3_2
        Util.closeQuietly((Socket)var4_4);
        if (var1_1 == null) return;
        this.eventListener.connectionReleased(this.call, (Connection)var1_1);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void streamFinished(boolean bl, HttpCodec httpCodec, long l, IOException serializable) {
        this.eventListener.responseBodyEnd(this.call, l);
        ConnectionPool connectionPool = this.connectionPool;
        synchronized (connectionPool) {
            block10 : {
                if (httpCodec != null) {
                    if (httpCodec != this.codec) break block10;
                    if (!bl) {
                        httpCodec = this.connection;
                        ++httpCodec.successCount;
                    }
                    httpCodec = this.connection;
                    Socket socket = this.deallocate(bl, false, true);
                    if (this.connection != null) {
                        httpCodec = null;
                    }
                    bl = this.released;
                    // MONITOREXIT [0, 2, 9] lbl15 : MonitorExitStatement: MONITOREXIT : var6_6
                    Util.closeQuietly((Socket)socket);
                    if (httpCodec != null) {
                        this.eventListener.connectionReleased(this.call, (Connection)httpCodec);
                    }
                    if (serializable != null) {
                        this.eventListener.callFailed(this.call, (IOException)serializable);
                        return;
                    }
                    if (bl) {
                        this.eventListener.callEnd(this.call);
                    }
                    return;
                }
            }
            try {
                serializable = new StringBuilder();
                serializable.append("expected ");
                serializable.append(this.codec);
                serializable.append(" but was ");
                serializable.append(httpCodec);
                throw new IllegalStateException(serializable.toString());
            }
            catch (Throwable throwable) {}
            throw throwable;
        }
    }

    public String toString() {
        RealConnection realConnection = this.connection();
        if (realConnection != null) {
            return realConnection.toString();
        }
        return this.address.toString();
    }

    public static final class StreamAllocationReference
    extends WeakReference<StreamAllocation> {
        public final Object callStackTrace;

        StreamAllocationReference(StreamAllocation streamAllocation, Object object) {
            super(streamAllocation);
            this.callStackTrace = object;
        }
    }

}

