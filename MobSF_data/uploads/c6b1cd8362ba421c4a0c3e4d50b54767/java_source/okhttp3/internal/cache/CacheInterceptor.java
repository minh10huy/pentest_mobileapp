/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  okhttp3.Headers
 *  okhttp3.Interceptor$Chain
 *  okhttp3.Request
 *  okhttp3.Response
 *  okhttp3.Response$Builder
 *  okhttp3.ResponseBody
 *  okhttp3.internal.Util
 *  okhttp3.internal.cache.CacheStrategy
 *  okhttp3.internal.http.RealResponseBody
 *  okio.Buffer
 *  okio.BufferedSink
 *  okio.BufferedSource
 *  okio.Sink
 *  okio.Source
 *  okio.Timeout
 */
package okhttp3.internal.cache;

import java.io.Closeable;
import java.io.IOException;
import java.util.concurrent.TimeUnit;
import okhttp3.Headers;
import okhttp3.Interceptor;
import okhttp3.Protocol;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okhttp3.internal.Internal;
import okhttp3.internal.Util;
import okhttp3.internal.cache.CacheRequest;
import okhttp3.internal.cache.CacheStrategy;
import okhttp3.internal.cache.InternalCache;
import okhttp3.internal.http.HttpHeaders;
import okhttp3.internal.http.HttpMethod;
import okhttp3.internal.http.RealResponseBody;
import okio.Buffer;
import okio.BufferedSink;
import okio.BufferedSource;
import okio.Okio;
import okio.Sink;
import okio.Source;
import okio.Timeout;

public final class CacheInterceptor
implements Interceptor {
    final InternalCache cache;

    public CacheInterceptor(InternalCache internalCache) {
        this.cache = internalCache;
    }

    private Response cacheWritingResponse(CacheRequest object, Response response) throws IOException {
        if (object == null) {
            return response;
        }
        Object object2 = object.body();
        if (object2 == null) {
            return response;
        }
        object = new Source(response.body().source(), (CacheRequest)object, Okio.buffer(object2)){
            boolean cacheRequestClosed;
            final /* synthetic */ BufferedSink val$cacheBody;
            final /* synthetic */ CacheRequest val$cacheRequest;
            final /* synthetic */ BufferedSource val$source;
            {
                this.val$source = bufferedSource;
                this.val$cacheRequest = cacheRequest;
                this.val$cacheBody = bufferedSink;
            }

            public void close() throws IOException {
                if (!this.cacheRequestClosed && !Util.discard((Source)this, (int)100, (TimeUnit)TimeUnit.MILLISECONDS)) {
                    this.cacheRequestClosed = true;
                    this.val$cacheRequest.abort();
                }
                this.val$source.close();
            }

            public long read(Buffer buffer, long l) throws IOException {
                block3 : {
                    block4 : {
                        try {
                            l = this.val$source.read(buffer, l);
                            if (l != -1L) break block3;
                            if (this.cacheRequestClosed) break block4;
                            this.cacheRequestClosed = true;
                        }
                        catch (IOException iOException) {
                            if (!this.cacheRequestClosed) {
                                this.cacheRequestClosed = true;
                                this.val$cacheRequest.abort();
                            }
                            throw iOException;
                        }
                        this.val$cacheBody.close();
                    }
                    return -1L;
                }
                buffer.copyTo(this.val$cacheBody.buffer(), buffer.size() - l, l);
                this.val$cacheBody.emitCompleteSegments();
                return l;
            }

            public Timeout timeout() {
                return this.val$source.timeout();
            }
        };
        object2 = response.header("Content-Type");
        long l = response.body().contentLength();
        return response.newBuilder().body((ResponseBody)new RealResponseBody((String)object2, l, Okio.buffer((Source)object))).build();
    }

    private static Headers combine(Headers object, Headers headers) {
        int n;
        Headers.Builder builder2 = new Headers.Builder();
        int n2 = object.size();
        int n3 = 0;
        for (n = 0; n < n2; ++n) {
            String string2 = object.name(n);
            String string3 = object.value(n);
            if ("Warning".equalsIgnoreCase(string2) && string3.startsWith("1") || !CacheInterceptor.isContentSpecificHeader(string2) && CacheInterceptor.isEndToEnd(string2) && headers.get(string2) != null) continue;
            Internal.instance.addLenient(builder2, string2, string3);
        }
        n2 = headers.size();
        for (n = n3; n < n2; ++n) {
            object = headers.name(n);
            if (CacheInterceptor.isContentSpecificHeader((String)object) || !CacheInterceptor.isEndToEnd((String)object)) continue;
            Internal.instance.addLenient(builder2, (String)object, headers.value(n));
        }
        return builder2.build();
    }

    static boolean isContentSpecificHeader(String string2) {
        if (!("Content-Length".equalsIgnoreCase(string2) || "Content-Encoding".equalsIgnoreCase(string2) || "Content-Type".equalsIgnoreCase(string2))) {
            return false;
        }
        return true;
    }

    static boolean isEndToEnd(String string2) {
        if (!("Connection".equalsIgnoreCase(string2) || "Keep-Alive".equalsIgnoreCase(string2) || "Proxy-Authenticate".equalsIgnoreCase(string2) || "Proxy-Authorization".equalsIgnoreCase(string2) || "TE".equalsIgnoreCase(string2) || "Trailers".equalsIgnoreCase(string2) || "Transfer-Encoding".equalsIgnoreCase(string2) || "Upgrade".equalsIgnoreCase(string2))) {
            return true;
        }
        return false;
    }

    private static Response stripBody(Response response) {
        Response response2 = response;
        if (response != null) {
            response2 = response;
            if (response.body() != null) {
                response2 = response.newBuilder().body(null).build();
            }
        }
        return response2;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public Response intercept(Interceptor chain) throws IOException {
        Response response2;
        Response response;
        Request request;
        block11 : {
            response2 = this.cache != null ? this.cache.get(chain.request()) : null;
            CacheStrategy cacheStrategy = new CacheStrategy.Factory(System.currentTimeMillis(), chain.request(), response2).get();
            request = cacheStrategy.networkRequest;
            response = cacheStrategy.cacheResponse;
            if (this.cache != null) {
                this.cache.trackResponse(cacheStrategy);
            }
            if (response2 != null && response == null) {
                Util.closeQuietly((Closeable)response2.body());
            }
            if (request == null && response == null) {
                return new Response.Builder().request(chain.request()).protocol(Protocol.HTTP_1_1).code(504).message("Unsatisfiable Request (only-if-cached)").body(Util.EMPTY_RESPONSE).sentRequestAtMillis(-1L).receivedResponseAtMillis(System.currentTimeMillis()).build();
            }
            if (request == null) {
                return response.newBuilder().cacheResponse(CacheInterceptor.stripBody(response)).build();
            }
            try {
                chain = chain.proceed(request);
                if (chain != null || response2 == null) break block11;
            }
            catch (Throwable throwable) {
                if (response2 == null) throw throwable;
                Util.closeQuietly((Closeable)response2.body());
                throw throwable;
            }
            Util.closeQuietly((Closeable)response2.body());
        }
        if (response != null) {
            if (chain.code() == 304) {
                response2 = response.newBuilder().headers(CacheInterceptor.combine(response.headers(), chain.headers())).sentRequestAtMillis(chain.sentRequestAtMillis()).receivedResponseAtMillis(chain.receivedResponseAtMillis()).cacheResponse(CacheInterceptor.stripBody(response)).networkResponse(CacheInterceptor.stripBody((Response)chain)).build();
                chain.body().close();
                this.cache.trackConditionalCacheHit();
                this.cache.update(response, response2);
                return response2;
            }
            Util.closeQuietly((Closeable)response.body());
        }
        chain = chain.newBuilder().cacheResponse(CacheInterceptor.stripBody(response)).networkResponse(CacheInterceptor.stripBody((Response)chain)).build();
        if (this.cache == null) return chain;
        if (HttpHeaders.hasBody((Response)chain) && CacheStrategy.isCacheable((Response)chain, (Request)request)) {
            return this.cacheWritingResponse(this.cache.put((Response)chain), (Response)chain);
        }
        if (!HttpMethod.invalidatesCache(request.method())) return chain;
        try {
            this.cache.remove(request);
        }
        catch (IOException iOException) {
            return chain;
        }
        return chain;
    }

}

