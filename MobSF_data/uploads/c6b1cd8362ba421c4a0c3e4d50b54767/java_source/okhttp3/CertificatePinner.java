/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  javax.annotation.Nullable
 *  okhttp3.CertificatePinner$Builder
 *  okhttp3.CertificatePinner$Pin
 *  okhttp3.internal.tls.CertificateChainCleaner
 */
package okhttp3;

import java.security.Principal;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import javax.annotation.Nullable;
import javax.net.ssl.SSLPeerUnverifiedException;
import okhttp3.CertificatePinner;
import okhttp3.internal.Util;
import okhttp3.internal.tls.CertificateChainCleaner;
import okio.ByteString;

public final class CertificatePinner {
    public static final CertificatePinner DEFAULT = new /* Unavailable Anonymous Inner Class!! */.build();
    @Nullable
    private final CertificateChainCleaner certificateChainCleaner;
    private final Set<> pins;

    CertificatePinner(Set<> set, @Nullable CertificateChainCleaner certificateChainCleaner) {
        this.pins = set;
        this.certificateChainCleaner = certificateChainCleaner;
    }

    public static String pin(Certificate certificate) {
        if (!(certificate instanceof X509Certificate)) {
            throw new IllegalArgumentException("Certificate pinning requires X509 certificates");
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("sha256/");
        stringBuilder.append(CertificatePinner.sha256((X509Certificate)certificate).base64());
        return stringBuilder.toString();
    }

    static ByteString sha1(X509Certificate x509Certificate) {
        return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha1();
    }

    static ByteString sha256(X509Certificate x509Certificate) {
        return ByteString.of(x509Certificate.getPublicKey().getEncoded()).sha256();
    }

    public void check(String charSequence, List<Certificate> object) throws SSLPeerUnverifiedException {
        int n;
        X509Certificate x509Certificate;
        int n2;
        List<> list = this.findMatchingPins((String)charSequence);
        if (list.isEmpty()) {
            return;
        }
        List list2 = object;
        if (this.certificateChainCleaner != null) {
            list2 = this.certificateChainCleaner.clean(object, (String)charSequence);
        }
        int n3 = list2.size();
        int n4 = 0;
        for (n2 = 0; n2 < n3; ++n2) {
            X509Certificate x509Certificate2 = (X509Certificate)list2.get(n2);
            int n5 = list.size();
            x509Certificate = null;
            object = x509Certificate;
            for (n = 0; n < n5; ++n) {
                Object object2;
                 pin = list.get(n);
                if (pin.hashAlgorithm.equals("sha256/")) {
                    object2 = x509Certificate;
                    if (x509Certificate == null) {
                        object2 = CertificatePinner.sha256(x509Certificate2);
                    }
                    x509Certificate = object2;
                    if (!pin.hash.equals(object2)) continue;
                    return;
                }
                if (pin.hashAlgorithm.equals("sha1/")) {
                    object2 = object;
                    if (object == null) {
                        object2 = CertificatePinner.sha1(x509Certificate2);
                    }
                    object = object2;
                    if (!pin.hash.equals(object2)) continue;
                    return;
                }
                charSequence = new StringBuilder();
                charSequence.append("unsupported hashAlgorithm: ");
                charSequence.append(pin.hashAlgorithm);
                throw new AssertionError((Object)charSequence.toString());
            }
        }
        object = new StringBuilder();
        object.append("Certificate pinning failure!");
        object.append("\n  Peer certificate chain:");
        n = list2.size();
        for (n2 = 0; n2 < n; ++n2) {
            x509Certificate = (X509Certificate)list2.get(n2);
            object.append("\n    ");
            object.append(CertificatePinner.pin(x509Certificate));
            object.append(": ");
            object.append(x509Certificate.getSubjectDN().getName());
        }
        object.append("\n  Pinned certificates for ");
        object.append((String)charSequence);
        object.append(":");
        n = list.size();
        for (n2 = n4; n2 < n; ++n2) {
            charSequence = list.get(n2);
            object.append("\n    ");
            object.append((Object)charSequence);
        }
        throw new SSLPeerUnverifiedException(object.toString());
    }

    public /* varargs */ void check(String string2, Certificate ... arrcertificate) throws SSLPeerUnverifiedException {
        this.check(string2, Arrays.asList(arrcertificate));
    }

    public boolean equals(@Nullable Object object) {
        if (object == this) {
            return true;
        }
        if (object instanceof CertificatePinner) {
            CertificateChainCleaner certificateChainCleaner = this.certificateChainCleaner;
            object = (CertificatePinner)object;
            if (Util.equal((Object)certificateChainCleaner, (Object)object.certificateChainCleaner) && this.pins.equals(object.pins)) {
                return true;
            }
        }
        return false;
    }

    List<> findMatchingPins(String string2) {
        List<> list = Collections.emptyList();
        for ( pin : this.pins) {
            if (!pin.matches(string2)) continue;
            List<> list2 = list;
            if (list.isEmpty()) {
                list2 = new ArrayList<>();
            }
            list2.add(pin);
            list = list2;
        }
        return list;
    }

    public int hashCode() {
        int n = this.certificateChainCleaner != null ? this.certificateChainCleaner.hashCode() : 0;
        return n * 31 + this.pins.hashCode();
    }

    CertificatePinner withCertificateChainCleaner(@Nullable CertificateChainCleaner certificateChainCleaner) {
        if (Util.equal((Object)this.certificateChainCleaner, (Object)certificateChainCleaner)) {
            return this;
        }
        return new CertificatePinner(this.pins, certificateChainCleaner);
    }
}

