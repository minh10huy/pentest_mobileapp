/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.processors;

import io.reactivex.annotations.CheckReturnValue;
import io.reactivex.annotations.NonNull;
import io.reactivex.internal.subscriptions.DeferredScalarSubscription;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.FlowableProcessor;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class AsyncProcessor<T>
extends FlowableProcessor<T> {
    static final AsyncSubscription[] EMPTY = new AsyncSubscription[0];
    static final AsyncSubscription[] TERMINATED = new AsyncSubscription[0];
    Throwable error;
    final AtomicReference<AsyncSubscription<T>[]> subscribers = new AtomicReference<AsyncSubscription[]>(EMPTY);
    T value;

    AsyncProcessor() {
    }

    @CheckReturnValue
    @NonNull
    public static <T> AsyncProcessor<T> create() {
        return new AsyncProcessor<T>();
    }

    boolean add(AsyncSubscription<T> asyncSubscription) {
        AsyncSubscription[] arrasyncSubscription;
        AsyncSubscription<T>[] arrasyncSubscription2;
        do {
            if ((arrasyncSubscription2 = this.subscribers.get()) == TERMINATED) {
                return false;
            }
            int n = arrasyncSubscription2.length;
            arrasyncSubscription = new AsyncSubscription[n + 1];
            System.arraycopy(arrasyncSubscription2, 0, arrasyncSubscription, 0, n);
            arrasyncSubscription[n] = asyncSubscription;
        } while (!this.subscribers.compareAndSet(arrasyncSubscription2, arrasyncSubscription));
        return true;
    }

    @Override
    public Throwable getThrowable() {
        if (this.subscribers.get() == TERMINATED) {
            return this.error;
        }
        return null;
    }

    public T getValue() {
        if (this.subscribers.get() == TERMINATED) {
            return this.value;
        }
        return null;
    }

    public Object[] getValues() {
        T t = this.getValue();
        if (t != null) {
            return new Object[]{t};
        }
        return new Object[0];
    }

    public T[] getValues(T[] arrT) {
        T t = this.getValue();
        if (t == null) {
            if (arrT.length != 0) {
                arrT[0] = null;
            }
            return arrT;
        }
        T[] arrT2 = arrT;
        if (arrT.length == 0) {
            arrT2 = Arrays.copyOf(arrT, 1);
        }
        arrT2[0] = t;
        if (arrT2.length != 1) {
            arrT2[1] = null;
        }
        return arrT2;
    }

    @Override
    public boolean hasComplete() {
        if (this.subscribers.get() == TERMINATED && this.error == null) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasSubscribers() {
        if (this.subscribers.get().length != 0) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasThrowable() {
        if (this.subscribers.get() == TERMINATED && this.error != null) {
            return true;
        }
        return false;
    }

    public boolean hasValue() {
        if (this.subscribers.get() == TERMINATED && this.value != null) {
            return true;
        }
        return false;
    }

    void nullOnNext() {
        this.value = null;
        NullPointerException nullPointerException = new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.");
        this.error = nullPointerException;
        AsyncSubscription[] arrasyncSubscription = this.subscribers.getAndSet(TERMINATED);
        int n = arrasyncSubscription.length;
        for (int i = 0; i < n; ++i) {
            arrasyncSubscription[i].onError(nullPointerException);
        }
    }

    public void onComplete() {
        int n;
        if (this.subscribers.get() == TERMINATED) {
            return;
        }
        T t = this.value;
        AsyncSubscription[] arrasyncSubscription = this.subscribers.getAndSet(TERMINATED);
        int n2 = 0;
        if (t == null) {
            n2 = arrasyncSubscription.length;
            for (n = 0; n < n2; ++n) {
                arrasyncSubscription[n].onComplete();
            }
        } else {
            int n3 = arrasyncSubscription.length;
            for (n = n2; n < n3; ++n) {
                arrasyncSubscription[n].complete(t);
            }
        }
    }

    public void onError(Throwable arrasyncSubscription) {
        AsyncSubscription[] arrasyncSubscription2 = arrasyncSubscription;
        if (arrasyncSubscription == null) {
            arrasyncSubscription2 = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
        }
        if (this.subscribers.get() == TERMINATED) {
            RxJavaPlugins.onError((Throwable)arrasyncSubscription2);
            return;
        }
        this.value = null;
        this.error = arrasyncSubscription2;
        arrasyncSubscription = this.subscribers.getAndSet(TERMINATED);
        int n = arrasyncSubscription.length;
        for (int i = 0; i < n; ++i) {
            arrasyncSubscription[i].onError((Throwable)arrasyncSubscription2);
        }
    }

    public void onNext(T t) {
        if (this.subscribers.get() == TERMINATED) {
            return;
        }
        if (t == null) {
            this.nullOnNext();
            return;
        }
        this.value = t;
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        if (this.subscribers.get() == TERMINATED) {
            subscription.cancel();
            return;
        }
        subscription.request(Long.MAX_VALUE);
    }

    void remove(AsyncSubscription<T> asyncSubscription) {
        AsyncSubscription[] arrasyncSubscription;
        AsyncSubscription<T>[] arrasyncSubscription2;
        do {
            int n;
            int n2;
            if ((n2 = (arrasyncSubscription2 = this.subscribers.get()).length) == 0) {
                return;
            }
            int n3 = -1;
            int n4 = 0;
            do {
                n = n3;
                if (n4 >= n2) break;
                if (arrasyncSubscription2[n4] == asyncSubscription) {
                    n = n4;
                    break;
                }
                ++n4;
            } while (true);
            if (n < 0) {
                return;
            }
            if (n2 == 1) {
                arrasyncSubscription = EMPTY;
                continue;
            }
            arrasyncSubscription = new AsyncSubscription[n2 - 1];
            System.arraycopy(arrasyncSubscription2, 0, arrasyncSubscription, 0, n);
            System.arraycopy(arrasyncSubscription2, n + 1, arrasyncSubscription, n, n2 - n - 1);
        } while (!this.subscribers.compareAndSet(arrasyncSubscription2, arrasyncSubscription));
    }

    @Override
    protected void subscribeActual(Subscriber<? super T> object) {
        AsyncSubscription<Subscriber<? super T>> asyncSubscription = new AsyncSubscription<Subscriber<? super T>>((Subscriber<Subscriber<? super T>>)object, this);
        object.onSubscribe(asyncSubscription);
        if (this.add(asyncSubscription)) {
            if (asyncSubscription.isCancelled()) {
                this.remove(asyncSubscription);
                return;
            }
        } else {
            Throwable throwable = this.error;
            if (throwable != null) {
                object.onError(throwable);
                return;
            }
            object = this.value;
            if (object != null) {
                asyncSubscription.complete((Subscriber<? super T>)object);
                return;
            }
            asyncSubscription.onComplete();
        }
    }

    static final class AsyncSubscription<T>
    extends DeferredScalarSubscription<T> {
        private static final long serialVersionUID = 5629876084736248016L;
        final AsyncProcessor<T> parent;

        AsyncSubscription(Subscriber<? super T> subscriber, AsyncProcessor<T> asyncProcessor) {
            super(subscriber);
            this.parent = asyncProcessor;
        }

        @Override
        public void cancel() {
            if (super.tryCancel()) {
                this.parent.remove(this);
            }
        }

        void onComplete() {
            if (!this.isCancelled()) {
                this.actual.onComplete();
            }
        }

        void onError(Throwable throwable) {
            if (this.isCancelled()) {
                RxJavaPlugins.onError(throwable);
                return;
            }
            this.actual.onError(throwable);
        }
    }

}

