/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.processors;

import io.reactivex.Scheduler;
import io.reactivex.annotations.CheckReturnValue;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.FlowableProcessor;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class ReplayProcessor<T>
extends FlowableProcessor<T> {
    static final ReplaySubscription[] EMPTY;
    private static final Object[] EMPTY_ARRAY;
    static final ReplaySubscription[] TERMINATED;
    final ReplayBuffer<T> buffer;
    boolean done;
    final AtomicReference<ReplaySubscription<T>[]> subscribers;

    static {
        EMPTY_ARRAY = new Object[0];
        EMPTY = new ReplaySubscription[0];
        TERMINATED = new ReplaySubscription[0];
    }

    ReplayProcessor(ReplayBuffer<T> replayBuffer) {
        this.buffer = replayBuffer;
        this.subscribers = new AtomicReference<ReplaySubscription[]>(EMPTY);
    }

    @CheckReturnValue
    public static <T> ReplayProcessor<T> create() {
        return new ReplayProcessor(new UnboundedReplayBuffer(16));
    }

    @CheckReturnValue
    public static <T> ReplayProcessor<T> create(int n) {
        return new ReplayProcessor(new UnboundedReplayBuffer(n));
    }

    static <T> ReplayProcessor<T> createUnbounded() {
        return new ReplayProcessor(new SizeBoundReplayBuffer(Integer.MAX_VALUE));
    }

    @CheckReturnValue
    public static <T> ReplayProcessor<T> createWithSize(int n) {
        return new ReplayProcessor(new SizeBoundReplayBuffer(n));
    }

    @CheckReturnValue
    public static <T> ReplayProcessor<T> createWithTime(long l, TimeUnit timeUnit, Scheduler scheduler) {
        return new ReplayProcessor(new SizeAndTimeBoundReplayBuffer(Integer.MAX_VALUE, l, timeUnit, scheduler));
    }

    @CheckReturnValue
    public static <T> ReplayProcessor<T> createWithTimeAndSize(long l, TimeUnit timeUnit, Scheduler scheduler, int n) {
        return new ReplayProcessor(new SizeAndTimeBoundReplayBuffer(n, l, timeUnit, scheduler));
    }

    boolean add(ReplaySubscription<T> replaySubscription) {
        ReplaySubscription[] arrreplaySubscription;
        ReplaySubscription<T>[] arrreplaySubscription2;
        do {
            if ((arrreplaySubscription2 = this.subscribers.get()) == TERMINATED) {
                return false;
            }
            int n = arrreplaySubscription2.length;
            arrreplaySubscription = new ReplaySubscription[n + 1];
            System.arraycopy(arrreplaySubscription2, 0, arrreplaySubscription, 0, n);
            arrreplaySubscription[n] = replaySubscription;
        } while (!this.subscribers.compareAndSet(arrreplaySubscription2, arrreplaySubscription));
        return true;
    }

    @Override
    public Throwable getThrowable() {
        ReplayBuffer<T> replayBuffer = this.buffer;
        if (replayBuffer.isDone()) {
            return replayBuffer.getError();
        }
        return null;
    }

    public T getValue() {
        return this.buffer.getValue();
    }

    public Object[] getValues() {
        Object[] arrobject = this.getValues(EMPTY_ARRAY);
        if (arrobject == EMPTY_ARRAY) {
            return new Object[0];
        }
        return arrobject;
    }

    public T[] getValues(T[] arrT) {
        return this.buffer.getValues(arrT);
    }

    @Override
    public boolean hasComplete() {
        ReplayBuffer<T> replayBuffer = this.buffer;
        if (replayBuffer.isDone() && replayBuffer.getError() == null) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasSubscribers() {
        if (this.subscribers.get().length != 0) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasThrowable() {
        ReplayBuffer<T> replayBuffer = this.buffer;
        if (replayBuffer.isDone() && replayBuffer.getError() != null) {
            return true;
        }
        return false;
    }

    public boolean hasValue() {
        if (this.buffer.size() != 0) {
            return true;
        }
        return false;
    }

    public void onComplete() {
        if (this.done) {
            return;
        }
        this.done = true;
        ReplayBuffer<T> replayBuffer = this.buffer;
        replayBuffer.complete();
        ReplaySubscription[] arrreplaySubscription = this.subscribers.getAndSet(TERMINATED);
        int n = arrreplaySubscription.length;
        for (int i = 0; i < n; ++i) {
            replayBuffer.replay(arrreplaySubscription[i]);
        }
    }

    public void onError(Throwable object) {
        ReplaySubscription[] arrreplaySubscription = object;
        if (object == null) {
            arrreplaySubscription = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
        }
        if (this.done) {
            RxJavaPlugins.onError((Throwable)arrreplaySubscription);
            return;
        }
        this.done = true;
        object = this.buffer;
        object.error((Throwable)arrreplaySubscription);
        arrreplaySubscription = this.subscribers.getAndSet(TERMINATED);
        int n = arrreplaySubscription.length;
        for (int i = 0; i < n; ++i) {
            object.replay(arrreplaySubscription[i]);
        }
    }

    public void onNext(T object) {
        if (object == null) {
            this.onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
            return;
        }
        if (this.done) {
            return;
        }
        ReplayBuffer<T> replayBuffer = this.buffer;
        replayBuffer.next(object);
        object = this.subscribers.get();
        int n = ((T)object).length;
        for (int i = 0; i < n; ++i) {
            replayBuffer.replay((ReplaySubscription<T>)object[i]);
        }
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        if (this.done) {
            subscription.cancel();
            return;
        }
        subscription.request(Long.MAX_VALUE);
    }

    void remove(ReplaySubscription<T> replaySubscription) {
        ReplaySubscription<T>[] arrreplaySubscription;
        while ((arrreplaySubscription = this.subscribers.get()) != TERMINATED) {
            int n;
            ReplaySubscription[] arrreplaySubscription2;
            if (arrreplaySubscription == EMPTY) {
                return;
            }
            int n2 = arrreplaySubscription.length;
            int n3 = -1;
            int n4 = 0;
            do {
                n = n3;
                if (n4 >= n2) break;
                if (arrreplaySubscription[n4] == replaySubscription) {
                    n = n4;
                    break;
                }
                ++n4;
            } while (true);
            if (n < 0) {
                return;
            }
            if (n2 == 1) {
                arrreplaySubscription2 = EMPTY;
            } else {
                arrreplaySubscription2 = new ReplaySubscription[n2 - 1];
                System.arraycopy(arrreplaySubscription, 0, arrreplaySubscription2, 0, n);
                System.arraycopy(arrreplaySubscription, n + 1, arrreplaySubscription2, n, n2 - n - 1);
            }
            if (!this.subscribers.compareAndSet(arrreplaySubscription, arrreplaySubscription2)) continue;
            return;
        }
    }

    int size() {
        return this.buffer.size();
    }

    @Override
    protected void subscribeActual(Subscriber<? super T> subscriber) {
        ReplaySubscription<? super T> replaySubscription = new ReplaySubscription<T>(subscriber, this);
        subscriber.onSubscribe(replaySubscription);
        if (this.add(replaySubscription) && replaySubscription.cancelled) {
            this.remove(replaySubscription);
            return;
        }
        this.buffer.replay(replaySubscription);
    }

    int subscriberCount() {
        return this.subscribers.get().length;
    }

    static final class Node<T>
    extends AtomicReference<Node<T>> {
        private static final long serialVersionUID = 6404226426336033100L;
        final T value;

        Node(T t) {
            this.value = t;
        }
    }

    static interface ReplayBuffer<T> {
        public void complete();

        public void error(Throwable var1);

        public Throwable getError();

        public T getValue();

        public T[] getValues(T[] var1);

        public boolean isDone();

        public void next(T var1);

        public void replay(ReplaySubscription<T> var1);

        public int size();
    }

    static final class ReplaySubscription<T>
    extends AtomicInteger
    implements Subscription {
        private static final long serialVersionUID = 466549804534799122L;
        final Subscriber<? super T> actual;
        volatile boolean cancelled;
        long emitted;
        Object index;
        final AtomicLong requested;
        final ReplayProcessor<T> state;

        ReplaySubscription(Subscriber<? super T> subscriber, ReplayProcessor<T> replayProcessor) {
            this.actual = subscriber;
            this.state = replayProcessor;
            this.requested = new AtomicLong();
        }

        public void cancel() {
            if (!this.cancelled) {
                this.cancelled = true;
                this.state.remove(this);
            }
        }

        public void request(long l) {
            if (SubscriptionHelper.validate(l)) {
                BackpressureHelper.add(this.requested, l);
                this.state.buffer.replay(this);
            }
        }
    }

    static final class SizeAndTimeBoundReplayBuffer<T>
    implements ReplayBuffer<T> {
        volatile boolean done;
        Throwable error;
        volatile TimedNode<T> head;
        final long maxAge;
        final int maxSize;
        final Scheduler scheduler;
        int size;
        TimedNode<T> tail;
        final TimeUnit unit;

        SizeAndTimeBoundReplayBuffer(int n, long l, TimeUnit object, Scheduler scheduler) {
            this.maxSize = ObjectHelper.verifyPositive(n, "maxSize");
            this.maxAge = ObjectHelper.verifyPositive(l, "maxAge");
            this.unit = ObjectHelper.requireNonNull(object, "unit is null");
            this.scheduler = ObjectHelper.requireNonNull(scheduler, "scheduler is null");
            object = new TimedNode<Object>(null, 0L);
            this.tail = object;
            this.head = object;
        }

        @Override
        public void complete() {
            this.trimFinal();
            this.done = true;
        }

        @Override
        public void error(Throwable throwable) {
            this.trimFinal();
            this.error = throwable;
            this.done = true;
        }

        @Override
        public Throwable getError() {
            return this.error;
        }

        TimedNode<T> getHead() {
            TimedNode timedNode = this.head;
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            TimedNode timedNode2 = (TimedNode)timedNode.get();
            while (timedNode2 != null) {
                if (timedNode2.time > l - l2) {
                    return timedNode;
                }
                TimedNode timedNode3 = (TimedNode)timedNode2.get();
                timedNode = timedNode2;
                timedNode2 = timedNode3;
            }
            return timedNode;
        }

        @Override
        public T getValue() {
            TimedNode timedNode = this.head;
            do {
                TimedNode timedNode2;
                if ((timedNode2 = (TimedNode)timedNode.get()) == null) {
                    long l;
                    long l2 = this.scheduler.now(this.unit);
                    if (timedNode.time < l2 - (l = this.maxAge)) {
                        return null;
                    }
                    return timedNode.value;
                }
                timedNode = timedNode2;
            } while (true);
        }

        @Override
        public T[] getValues(T[] arrT) {
            Object object;
            TimedNode<T> timedNode = this.getHead();
            int n = this.size(timedNode);
            int n2 = 0;
            if (n == 0) {
                object = arrT;
                if (arrT.length != 0) {
                    arrT[0] = null;
                    return arrT;
                }
            } else {
                object = timedNode;
                int n3 = n2;
                Object[] arrobject = arrT;
                if (arrT.length < n) {
                    arrobject = (Object[])Array.newInstance(arrT.getClass().getComponentType(), n);
                    n3 = n2;
                    object = timedNode;
                }
                while (n3 != n) {
                    object = (TimedNode)object.get();
                    arrobject[n3] = object.value;
                    ++n3;
                }
                object = arrobject;
                if (arrobject.length > n) {
                    arrobject[n] = null;
                    object = arrobject;
                }
            }
            return object;
        }

        @Override
        public boolean isDone() {
            return this.done;
        }

        @Override
        public void next(T object) {
            object = new TimedNode<T>(object, this.scheduler.now(this.unit));
            TimedNode<T> timedNode = this.tail;
            this.tail = object;
            ++this.size;
            timedNode.set(object);
            this.trim();
        }

        @Override
        public void replay(ReplaySubscription<T> serializable) {
            TimedNode timedNode;
            int n;
            if (serializable.getAndIncrement() != 0) {
                return;
            }
            Subscriber subscriber = serializable.actual;
            TimedNode timedNode2 = timedNode = (TimedNode)serializable.index;
            if (timedNode == null) {
                timedNode2 = this.getHead();
            }
            long l = serializable.emitted;
            int n2 = 1;
            do {
                long l2 = serializable.requested.get();
                while (l != l2) {
                    if (serializable.cancelled) {
                        serializable.index = null;
                        return;
                    }
                    boolean bl = this.done;
                    timedNode = (TimedNode)timedNode2.get();
                    n = timedNode == null ? 1 : 0;
                    if (bl && n != 0) {
                        serializable.index = null;
                        serializable.cancelled = true;
                        serializable = this.error;
                        if (serializable == null) {
                            subscriber.onComplete();
                            return;
                        }
                        subscriber.onError(serializable);
                        return;
                    }
                    if (n != 0) break;
                    subscriber.onNext(timedNode.value);
                    timedNode2 = timedNode;
                    ++l;
                }
                if (l == l2) {
                    if (serializable.cancelled) {
                        serializable.index = null;
                        return;
                    }
                    if (this.done && timedNode2.get() == null) {
                        serializable.index = null;
                        serializable.cancelled = true;
                        serializable = this.error;
                        if (serializable == null) {
                            subscriber.onComplete();
                            return;
                        }
                        subscriber.onError(serializable);
                        return;
                    }
                }
                serializable.index = timedNode2;
                serializable.emitted = l;
                n2 = n = serializable.addAndGet(- n2);
            } while (n != 0);
        }

        @Override
        public int size() {
            return this.size(this.getHead());
        }

        int size(TimedNode<T> timedNode) {
            int n;
            for (n = 0; n != Integer.MAX_VALUE; ++n) {
                if ((timedNode = (TimedNode)timedNode.get()) != null) continue;
                return n;
            }
            return n;
        }

        void trim() {
            if (this.size > this.maxSize) {
                --this.size;
                this.head = (TimedNode)this.head.get();
            }
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            TimedNode timedNode = this.head;
            do {
                TimedNode timedNode2;
                if ((timedNode2 = (TimedNode)timedNode.get()) == null) {
                    this.head = timedNode;
                    return;
                }
                if (timedNode2.time > l - l2) {
                    this.head = timedNode;
                    return;
                }
                timedNode = timedNode2;
            } while (true);
        }

        void trimFinal() {
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            TimedNode timedNode = this.head;
            do {
                TimedNode timedNode2;
                if ((timedNode2 = (TimedNode)timedNode.get()) == null) {
                    this.head = timedNode;
                    return;
                }
                if (timedNode2.time > l - l2) {
                    this.head = timedNode;
                    return;
                }
                timedNode = timedNode2;
            } while (true);
        }
    }

    static final class SizeBoundReplayBuffer<T>
    implements ReplayBuffer<T> {
        volatile boolean done;
        Throwable error;
        volatile Node<T> head;
        final int maxSize;
        int size;
        Node<T> tail;

        SizeBoundReplayBuffer(int n) {
            this.maxSize = ObjectHelper.verifyPositive(n, "maxSize");
            Node<Object> node = new Node<Object>(null);
            this.tail = node;
            this.head = node;
        }

        @Override
        public void complete() {
            this.done = true;
        }

        @Override
        public void error(Throwable throwable) {
            this.error = throwable;
            this.done = true;
        }

        @Override
        public Throwable getError() {
            return this.error;
        }

        @Override
        public T getValue() {
            Node node = this.head;
            Node node2;
            while ((node2 = (Node)node.get()) != null) {
                node = node2;
            }
            return node.value;
        }

        @Override
        public T[] getValues(T[] arrT) {
            T[] arrT2 = this.head;
            int n = 0;
            Object[] arrobject = arrT2;
            int n2 = 0;
            do {
                if ((arrobject = (T[])arrobject.get()) == null) {
                    Object object = arrT2;
                    int n3 = n;
                    arrobject = arrT;
                    if (arrT.length < n2) {
                        arrobject = (Object[])Array.newInstance(arrT.getClass().getComponentType(), n2);
                        n3 = n;
                        object = arrT2;
                    }
                    while (n3 < n2) {
                        object = (Node)object.get();
                        arrobject[n3] = object.value;
                        ++n3;
                    }
                    if (arrobject.length > n2) {
                        arrobject[n2] = null;
                    }
                    return arrobject;
                }
                ++n2;
            } while (true);
        }

        @Override
        public boolean isDone() {
            return this.done;
        }

        @Override
        public void next(T object) {
            object = new Node<T>(object);
            Node<T> node = this.tail;
            this.tail = object;
            ++this.size;
            node.set(object);
            this.trim();
        }

        @Override
        public void replay(ReplaySubscription<T> serializable) {
            Node node;
            int n;
            if (serializable.getAndIncrement() != 0) {
                return;
            }
            Subscriber subscriber = serializable.actual;
            Node node2 = node = (Node)serializable.index;
            if (node == null) {
                node2 = this.head;
            }
            long l = serializable.emitted;
            int n2 = 1;
            do {
                long l2 = serializable.requested.get();
                while (l != l2) {
                    if (serializable.cancelled) {
                        serializable.index = null;
                        return;
                    }
                    boolean bl = this.done;
                    node = (Node)node2.get();
                    n = node == null ? 1 : 0;
                    if (bl && n != 0) {
                        serializable.index = null;
                        serializable.cancelled = true;
                        serializable = this.error;
                        if (serializable == null) {
                            subscriber.onComplete();
                            return;
                        }
                        subscriber.onError(serializable);
                        return;
                    }
                    if (n != 0) break;
                    subscriber.onNext(node.value);
                    node2 = node;
                    ++l;
                }
                if (l == l2) {
                    if (serializable.cancelled) {
                        serializable.index = null;
                        return;
                    }
                    if (this.done && node2.get() == null) {
                        serializable.index = null;
                        serializable.cancelled = true;
                        serializable = this.error;
                        if (serializable == null) {
                            subscriber.onComplete();
                            return;
                        }
                        subscriber.onError(serializable);
                        return;
                    }
                }
                serializable.index = node2;
                serializable.emitted = l;
                n2 = n = serializable.addAndGet(- n2);
            } while (n != 0);
        }

        @Override
        public int size() {
            int n;
            Node node = this.head;
            for (n = 0; n != Integer.MAX_VALUE; ++n) {
                if ((node = (Node)node.get()) != null) continue;
                return n;
            }
            return n;
        }

        void trim() {
            if (this.size > this.maxSize) {
                --this.size;
                this.head = (Node)this.head.get();
            }
        }
    }

    static final class TimedNode<T>
    extends AtomicReference<TimedNode<T>> {
        private static final long serialVersionUID = 6404226426336033100L;
        final long time;
        final T value;

        TimedNode(T t, long l) {
            this.value = t;
            this.time = l;
        }
    }

    static final class UnboundedReplayBuffer<T>
    implements ReplayBuffer<T> {
        final List<T> buffer;
        volatile boolean done;
        Throwable error;
        volatile int size;

        UnboundedReplayBuffer(int n) {
            this.buffer = new ArrayList<T>(ObjectHelper.verifyPositive(n, "capacityHint"));
        }

        @Override
        public void complete() {
            this.done = true;
        }

        @Override
        public void error(Throwable throwable) {
            this.error = throwable;
            this.done = true;
        }

        @Override
        public Throwable getError() {
            return this.error;
        }

        @Override
        public T getValue() {
            int n = this.size;
            if (n == 0) {
                return null;
            }
            return this.buffer.get(n - 1);
        }

        @Override
        public T[] getValues(T[] arrT) {
            int n = this.size;
            int n2 = 0;
            if (n == 0) {
                if (arrT.length != 0) {
                    arrT[0] = null;
                }
                return arrT;
            }
            List<T> list = this.buffer;
            int n3 = n2;
            Object[] arrobject = arrT;
            if (arrT.length < n) {
                arrobject = (Object[])Array.newInstance(arrT.getClass().getComponentType(), n);
                n3 = n2;
            }
            while (n3 < n) {
                arrobject[n3] = list.get(n3);
                ++n3;
            }
            if (arrobject.length > n) {
                arrobject[n] = null;
            }
            return arrobject;
        }

        @Override
        public boolean isDone() {
            return this.done;
        }

        @Override
        public void next(T t) {
            this.buffer.add(t);
            ++this.size;
        }

        @Override
        public void replay(ReplaySubscription<T> serializable) {
            int n;
            if (serializable.getAndIncrement() != 0) {
                return;
            }
            List<T> list = this.buffer;
            Subscriber subscriber = serializable.actual;
            Integer n2 = (Integer)serializable.index;
            int n3 = 0;
            if (n2 != null) {
                n3 = n2;
            } else {
                serializable.index = 0;
            }
            long l = serializable.emitted;
            int n4 = 1;
            do {
                boolean bl;
                long l2 = serializable.requested.get();
                while (l != l2) {
                    if (serializable.cancelled) {
                        serializable.index = null;
                        return;
                    }
                    bl = this.done;
                    n = this.size;
                    if (bl && n3 == n) {
                        serializable.index = null;
                        serializable.cancelled = true;
                        serializable = this.error;
                        if (serializable == null) {
                            subscriber.onComplete();
                            return;
                        }
                        subscriber.onError(serializable);
                        return;
                    }
                    if (n3 == n) break;
                    subscriber.onNext(list.get(n3));
                    ++n3;
                    ++l;
                }
                if (l == l2) {
                    if (serializable.cancelled) {
                        serializable.index = null;
                        return;
                    }
                    bl = this.done;
                    n = this.size;
                    if (bl && n3 == n) {
                        serializable.index = null;
                        serializable.cancelled = true;
                        serializable = this.error;
                        if (serializable == null) {
                            subscriber.onComplete();
                            return;
                        }
                        subscriber.onError(serializable);
                        return;
                    }
                }
                serializable.index = n3;
                serializable.emitted = l;
                n4 = n = serializable.addAndGet(- n4);
            } while (n != 0);
        }

        @Override
        public int size() {
            return this.size;
        }
    }

}

