/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.processors;

import io.reactivex.annotations.CheckReturnValue;
import io.reactivex.annotations.Experimental;
import io.reactivex.exceptions.MissingBackpressureException;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.processors.FlowableProcessor;
import java.io.Serializable;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class PublishProcessor<T>
extends FlowableProcessor<T> {
    static final PublishSubscription[] EMPTY;
    static final PublishSubscription[] TERMINATED;
    Throwable error;
    final AtomicReference<PublishSubscription<T>[]> subscribers = new AtomicReference<PublishSubscription[]>(EMPTY);

    static {
        TERMINATED = new PublishSubscription[0];
        EMPTY = new PublishSubscription[0];
    }

    PublishProcessor() {
    }

    @CheckReturnValue
    public static <T> PublishProcessor<T> create() {
        return new PublishProcessor<T>();
    }

    boolean add(PublishSubscription<T> publishSubscription) {
        PublishSubscription[] arrpublishSubscription;
        PublishSubscription<T>[] arrpublishSubscription2;
        do {
            if ((arrpublishSubscription2 = this.subscribers.get()) == TERMINATED) {
                return false;
            }
            int n = arrpublishSubscription2.length;
            arrpublishSubscription = new PublishSubscription[n + 1];
            System.arraycopy(arrpublishSubscription2, 0, arrpublishSubscription, 0, n);
            arrpublishSubscription[n] = publishSubscription;
        } while (!this.subscribers.compareAndSet(arrpublishSubscription2, arrpublishSubscription));
        return true;
    }

    @Override
    public Throwable getThrowable() {
        if (this.subscribers.get() == TERMINATED) {
            return this.error;
        }
        return null;
    }

    @Override
    public boolean hasComplete() {
        if (this.subscribers.get() == TERMINATED && this.error == null) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasSubscribers() {
        if (this.subscribers.get().length != 0) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasThrowable() {
        if (this.subscribers.get() == TERMINATED && this.error != null) {
            return true;
        }
        return false;
    }

    @Experimental
    public boolean offer(T t) {
        int n;
        if (t == null) {
            this.onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
            return true;
        }
        PublishSubscription<T>[] arrpublishSubscription = this.subscribers.get();
        int n2 = arrpublishSubscription.length;
        int n3 = 0;
        for (n = 0; n < n2; ++n) {
            if (!arrpublishSubscription[n].isFull()) continue;
            return false;
        }
        n2 = arrpublishSubscription.length;
        for (n = n3; n < n2; ++n) {
            arrpublishSubscription[n].onNext(t);
        }
        return true;
    }

    public void onComplete() {
        if (this.subscribers.get() == TERMINATED) {
            return;
        }
        PublishSubscription[] arrpublishSubscription = this.subscribers.getAndSet(TERMINATED);
        int n = arrpublishSubscription.length;
        for (int i = 0; i < n; ++i) {
            arrpublishSubscription[i].onComplete();
        }
    }

    public void onError(Throwable arrpublishSubscription) {
        if (this.subscribers.get() == TERMINATED) {
            RxJavaPlugins.onError((Throwable)arrpublishSubscription);
            return;
        }
        PublishSubscription[] arrpublishSubscription2 = arrpublishSubscription;
        if (arrpublishSubscription == null) {
            arrpublishSubscription2 = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
        }
        this.error = arrpublishSubscription2;
        arrpublishSubscription = this.subscribers.getAndSet(TERMINATED);
        int n = arrpublishSubscription.length;
        for (int i = 0; i < n; ++i) {
            arrpublishSubscription[i].onError((Throwable)arrpublishSubscription2);
        }
    }

    public void onNext(T t) {
        if (this.subscribers.get() == TERMINATED) {
            return;
        }
        if (t == null) {
            this.onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
            return;
        }
        PublishSubscription<T>[] arrpublishSubscription = this.subscribers.get();
        int n = arrpublishSubscription.length;
        for (int i = 0; i < n; ++i) {
            arrpublishSubscription[i].onNext(t);
        }
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        if (this.subscribers.get() == TERMINATED) {
            subscription.cancel();
            return;
        }
        subscription.request(Long.MAX_VALUE);
    }

    void remove(PublishSubscription<T> publishSubscription) {
        PublishSubscription<T>[] arrpublishSubscription;
        while ((arrpublishSubscription = this.subscribers.get()) != TERMINATED) {
            int n;
            PublishSubscription[] arrpublishSubscription2;
            if (arrpublishSubscription == EMPTY) {
                return;
            }
            int n2 = arrpublishSubscription.length;
            int n3 = -1;
            int n4 = 0;
            do {
                n = n3;
                if (n4 >= n2) break;
                if (arrpublishSubscription[n4] == publishSubscription) {
                    n = n4;
                    break;
                }
                ++n4;
            } while (true);
            if (n < 0) {
                return;
            }
            if (n2 == 1) {
                arrpublishSubscription2 = EMPTY;
            } else {
                arrpublishSubscription2 = new PublishSubscription[n2 - 1];
                System.arraycopy(arrpublishSubscription, 0, arrpublishSubscription2, 0, n);
                System.arraycopy(arrpublishSubscription, n + 1, arrpublishSubscription2, n, n2 - n - 1);
            }
            if (!this.subscribers.compareAndSet(arrpublishSubscription, arrpublishSubscription2)) continue;
            return;
        }
    }

    @Override
    public void subscribeActual(Subscriber<? super T> subscriber) {
        Serializable serializable = new PublishSubscription<T>(subscriber, this);
        subscriber.onSubscribe(serializable);
        if (this.add((PublishSubscription<T>)serializable)) {
            if (serializable.isCancelled()) {
                this.remove((PublishSubscription<T>)serializable);
                return;
            }
        } else {
            serializable = this.error;
            if (serializable != null) {
                subscriber.onError(serializable);
                return;
            }
            subscriber.onComplete();
        }
    }

    static final class PublishSubscription<T>
    extends AtomicLong
    implements Subscription {
        private static final long serialVersionUID = 3562861878281475070L;
        final Subscriber<? super T> actual;
        final PublishProcessor<T> parent;

        PublishSubscription(Subscriber<? super T> subscriber, PublishProcessor<T> publishProcessor) {
            this.actual = subscriber;
            this.parent = publishProcessor;
        }

        public void cancel() {
            if (this.getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE) {
                this.parent.remove(this);
            }
        }

        public boolean isCancelled() {
            if (this.get() == Long.MIN_VALUE) {
                return true;
            }
            return false;
        }

        boolean isFull() {
            if (this.get() == 0L) {
                return true;
            }
            return false;
        }

        public void onComplete() {
            if (this.get() != Long.MIN_VALUE) {
                this.actual.onComplete();
            }
        }

        public void onError(Throwable throwable) {
            if (this.get() != Long.MIN_VALUE) {
                this.actual.onError(throwable);
                return;
            }
            RxJavaPlugins.onError(throwable);
        }

        public void onNext(T t) {
            long l = this.get();
            if (l == Long.MIN_VALUE) {
                return;
            }
            if (l != 0L) {
                this.actual.onNext(t);
                BackpressureHelper.producedCancel(this, 1L);
                return;
            }
            this.cancel();
            this.actual.onError((Throwable)new MissingBackpressureException("Could not emit value due to lack of requests"));
        }

        public void request(long l) {
            if (SubscriptionHelper.validate(l)) {
                BackpressureHelper.addCancel(this, l);
            }
        }
    }

}

