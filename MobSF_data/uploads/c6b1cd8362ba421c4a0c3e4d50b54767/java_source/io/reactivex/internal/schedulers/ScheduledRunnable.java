/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.schedulers;

import io.reactivex.disposables.Disposable;
import io.reactivex.internal.disposables.DisposableContainer;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.concurrent.Callable;
import java.util.concurrent.Future;
import java.util.concurrent.atomic.AtomicReferenceArray;

public final class ScheduledRunnable
extends AtomicReferenceArray<Object>
implements Runnable,
Callable<Object>,
Disposable {
    static final Object ASYNC_DISPOSED;
    static final Object DONE;
    static final int FUTURE_INDEX = 1;
    static final Object PARENT_DISPOSED;
    static final int PARENT_INDEX = 0;
    static final Object SYNC_DISPOSED;
    static final int THREAD_INDEX = 2;
    private static final long serialVersionUID = -6120223772001106981L;
    final Runnable actual;

    static {
        PARENT_DISPOSED = new Object();
        SYNC_DISPOSED = new Object();
        ASYNC_DISPOSED = new Object();
        DONE = new Object();
    }

    public ScheduledRunnable(Runnable runnable, DisposableContainer disposableContainer) {
        super(3);
        this.actual = runnable;
        this.lazySet(0, disposableContainer);
    }

    @Override
    public Object call() {
        this.run();
        return null;
    }

    @Override
    public void dispose() {
        Object e;
        Object object;
        while ((e = this.get(1)) != DONE && e != SYNC_DISPOSED && e != ASYNC_DISPOSED) {
            boolean bl = this.get(2) != Thread.currentThread();
            object = bl ? ASYNC_DISPOSED : SYNC_DISPOSED;
            if (!this.compareAndSet(1, e, object)) continue;
            if (e == null) break;
            ((Future)e).cancel(bl);
            break;
        }
        while ((object = this.get(0)) != DONE && object != PARENT_DISPOSED) {
            if (object == null) {
                return;
            }
            if (!this.compareAndSet(0, object, PARENT_DISPOSED)) continue;
            ((DisposableContainer)object).delete(this);
            return;
        }
    }

    @Override
    public boolean isDisposed() {
        boolean bl = false;
        Object e = this.get(0);
        if (e == PARENT_DISPOSED || e == DONE) {
            bl = true;
        }
        return bl;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    @Override
    public void run() {
        Throwable throwable22222;
        block9 : {
            block8 : {
                this.lazySet(2, Thread.currentThread());
                try {
                    this.actual.run();
                    break block8;
                }
                catch (Throwable throwable22222) {
                    break block9;
                }
                catch (Throwable throwable3) {
                    RxJavaPlugins.onError(throwable3);
                }
            }
            this.lazySet(2, null);
            Object e = this.get(0);
            if (e != PARENT_DISPOSED && this.compareAndSet(0, e, DONE) && e != null) {
                ((DisposableContainer)e).delete(this);
            }
            do {
                if ((e = this.get(1)) == SYNC_DISPOSED) return;
                if (e == ASYNC_DISPOSED) return;
            } while (!this.compareAndSet(1, e, DONE));
            return;
        }
        this.lazySet(2, null);
        Object e = this.get(0);
        if (e != PARENT_DISPOSED && this.compareAndSet(0, e, DONE) && e != null) {
            ((DisposableContainer)e).delete(this);
        }
        do {
            if ((e = this.get(1)) == SYNC_DISPOSED) throw throwable22222;
            if (e == ASYNC_DISPOSED) throw throwable22222;
        } while (!this.compareAndSet(1, e, DONE));
        throw throwable22222;
    }

    public void setFuture(Future<?> future) {
        Object e;
        do {
            if ((e = this.get(1)) == DONE) {
                return;
            }
            if (e == SYNC_DISPOSED) {
                future.cancel(false);
                return;
            }
            if (e != ASYNC_DISPOSED) continue;
            future.cancel(true);
            return;
        } while (!this.compareAndSet(1, e, future));
    }
}

