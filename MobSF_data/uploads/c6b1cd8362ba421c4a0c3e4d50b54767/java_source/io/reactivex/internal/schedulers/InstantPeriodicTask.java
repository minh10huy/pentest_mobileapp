/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.schedulers;

import io.reactivex.disposables.Disposable;
import io.reactivex.internal.functions.Functions;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.atomic.AtomicReference;

final class InstantPeriodicTask
implements Callable<Void>,
Disposable {
    static final FutureTask<Void> CANCELLED = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, null);
    final ExecutorService executor;
    final AtomicReference<Future<?>> first;
    final AtomicReference<Future<?>> rest;
    Thread runner;
    final Runnable task;

    InstantPeriodicTask(Runnable runnable, ExecutorService executorService) {
        this.task = runnable;
        this.first = new AtomicReference();
        this.rest = new AtomicReference();
        this.executor = executorService;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public Void call() throws Exception {
        try {
            this.runner = Thread.currentThread();
            try {
                this.task.run();
                this.setRest(this.executor.submit(this));
                return null;
            }
            catch (Throwable throwable) {
                RxJavaPlugins.onError(throwable);
                return null;
            }
        }
        finally {
            this.runner = null;
        }
    }

    @Override
    public void dispose() {
        boolean bl;
        Future future = this.first.getAndSet(CANCELLED);
        boolean bl2 = false;
        if (future != null && future != CANCELLED) {
            bl = this.runner != Thread.currentThread();
            future.cancel(bl);
        }
        if ((future = (Future)this.rest.getAndSet(CANCELLED)) != null && future != CANCELLED) {
            bl = bl2;
            if (this.runner != Thread.currentThread()) {
                bl = true;
            }
            future.cancel(bl);
        }
    }

    @Override
    public boolean isDisposed() {
        if (this.first.get() == CANCELLED) {
            return true;
        }
        return false;
    }

    void setFirst(Future<?> future) {
        Future<?> future2;
        do {
            if ((future2 = this.first.get()) != CANCELLED) continue;
            boolean bl = this.runner != Thread.currentThread();
            future.cancel(bl);
        } while (!this.first.compareAndSet(future2, future));
    }

    void setRest(Future<?> future) {
        Future<?> future2;
        do {
            if ((future2 = this.rest.get()) != CANCELLED) continue;
            boolean bl = this.runner != Thread.currentThread();
            future.cancel(bl);
        } while (!this.rest.compareAndSet(future2, future));
    }
}

