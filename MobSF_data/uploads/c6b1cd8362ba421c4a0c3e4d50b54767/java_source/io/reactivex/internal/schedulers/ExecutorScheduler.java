/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.schedulers;

import io.reactivex.Scheduler;
import io.reactivex.annotations.NonNull;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.disposables.DisposableContainer;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.disposables.EmptyDisposable;
import io.reactivex.internal.disposables.SequentialDisposable;
import io.reactivex.internal.queue.MpscLinkedQueue;
import io.reactivex.internal.schedulers.DisposeOnCancel;
import io.reactivex.internal.schedulers.ScheduledDirectPeriodicTask;
import io.reactivex.internal.schedulers.ScheduledDirectTask;
import io.reactivex.internal.schedulers.ScheduledRunnable;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Schedulers;
import java.util.concurrent.Callable;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public final class ExecutorScheduler
extends Scheduler {
    static final Scheduler HELPER = Schedulers.single();
    @NonNull
    final Executor executor;

    public ExecutorScheduler(@NonNull Executor executor) {
        this.executor = executor;
    }

    @NonNull
    @Override
    public Scheduler.Worker createWorker() {
        return new ExecutorWorker(this.executor);
    }

    @NonNull
    @Override
    public Disposable scheduleDirect(@NonNull Runnable object) {
        block3 : {
            object = RxJavaPlugins.onSchedule((Runnable)object);
            try {
                if (!(this.executor instanceof ExecutorService)) break block3;
                object = new ScheduledDirectTask((Runnable)object);
                object.setFuture(((ExecutorService)this.executor).submit(object));
                return object;
            }
            catch (RejectedExecutionException rejectedExecutionException) {
                RxJavaPlugins.onError(rejectedExecutionException);
                return EmptyDisposable.INSTANCE;
            }
        }
        object = new ExecutorWorker.BooleanRunnable((Runnable)object);
        this.executor.execute((Runnable)object);
        return object;
    }

    @NonNull
    @Override
    public Disposable scheduleDirect(@NonNull Runnable object, long l, TimeUnit object2) {
        object = RxJavaPlugins.onSchedule((Runnable)object);
        if (this.executor instanceof ScheduledExecutorService) {
            try {
                object = new ScheduledDirectTask((Runnable)object);
                object.setFuture(((ScheduledExecutorService)this.executor).schedule(object, l, (TimeUnit)((Object)object2)));
                return object;
            }
            catch (RejectedExecutionException rejectedExecutionException) {
                RxJavaPlugins.onError(rejectedExecutionException);
                return EmptyDisposable.INSTANCE;
            }
        }
        object = new DelayedRunnable((Runnable)object);
        object2 = HELPER.scheduleDirect(new DelayedDispose((DelayedRunnable)object), l, (TimeUnit)((Object)object2));
        object.timed.replace((Disposable)object2);
        return object;
    }

    @NonNull
    @Override
    public Disposable schedulePeriodicallyDirect(@NonNull Runnable runnable, long l, long l2, TimeUnit timeUnit) {
        if (this.executor instanceof ScheduledExecutorService) {
            runnable = RxJavaPlugins.onSchedule(runnable);
            try {
                runnable = new ScheduledDirectPeriodicTask(runnable);
                runnable.setFuture(((ScheduledExecutorService)this.executor).scheduleAtFixedRate(runnable, l, l2, timeUnit));
                return runnable;
            }
            catch (RejectedExecutionException rejectedExecutionException) {
                RxJavaPlugins.onError(rejectedExecutionException);
                return EmptyDisposable.INSTANCE;
            }
        }
        return super.schedulePeriodicallyDirect(runnable, l, l2, timeUnit);
    }

    final class DelayedDispose
    implements Runnable {
        private final DelayedRunnable dr;

        DelayedDispose(DelayedRunnable delayedRunnable) {
            this.dr = delayedRunnable;
        }

        @Override
        public void run() {
            this.dr.direct.replace(ExecutorScheduler.this.scheduleDirect(this.dr));
        }
    }

    static final class DelayedRunnable
    extends AtomicReference<Runnable>
    implements Runnable,
    Disposable {
        private static final long serialVersionUID = -4101336210206799084L;
        final SequentialDisposable direct = new SequentialDisposable();
        final SequentialDisposable timed = new SequentialDisposable();

        DelayedRunnable(Runnable runnable) {
            super(runnable);
        }

        @Override
        public void dispose() {
            if (this.getAndSet(null) != null) {
                this.timed.dispose();
                this.direct.dispose();
            }
        }

        @Override
        public boolean isDisposed() {
            if (this.get() == null) {
                return true;
            }
            return false;
        }

        @Override
        public void run() {
            Runnable runnable = (Runnable)this.get();
            if (runnable != null) {
                try {
                    runnable.run();
                    return;
                }
                finally {
                    this.lazySet(null);
                    this.timed.lazySet(DisposableHelper.DISPOSED);
                    this.direct.lazySet(DisposableHelper.DISPOSED);
                }
            }
        }
    }

    public static final class ExecutorWorker
    extends Scheduler.Worker
    implements Runnable {
        volatile boolean disposed;
        final Executor executor;
        final MpscLinkedQueue<Runnable> queue;
        final CompositeDisposable tasks = new CompositeDisposable();
        final AtomicInteger wip = new AtomicInteger();

        public ExecutorWorker(Executor executor) {
            this.executor = executor;
            this.queue = new MpscLinkedQueue();
        }

        @Override
        public void dispose() {
            if (!this.disposed) {
                this.disposed = true;
                this.tasks.dispose();
                if (this.wip.getAndIncrement() == 0) {
                    this.queue.clear();
                }
            }
        }

        @Override
        public boolean isDisposed() {
            return this.disposed;
        }

        @Override
        public void run() {
            MpscLinkedQueue<Runnable> mpscLinkedQueue = this.queue;
            int n = 1;
            block0 : do {
                if (this.disposed) {
                    mpscLinkedQueue.clear();
                    return;
                }
                do {
                    Runnable runnable;
                    if ((runnable = mpscLinkedQueue.poll()) == null) {
                        int n2;
                        if (this.disposed) {
                            mpscLinkedQueue.clear();
                            return;
                        }
                        n = n2 = this.wip.addAndGet(- n);
                        if (n2 != 0) continue block0;
                        return;
                    }
                    runnable.run();
                } while (!this.disposed);
                break;
            } while (true);
            mpscLinkedQueue.clear();
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable runnable) {
            if (this.disposed) {
                return EmptyDisposable.INSTANCE;
            }
            runnable = new BooleanRunnable(RxJavaPlugins.onSchedule(runnable));
            this.queue.offer(runnable);
            if (this.wip.getAndIncrement() == 0) {
                try {
                    this.executor.execute(this);
                    return runnable;
                }
                catch (RejectedExecutionException rejectedExecutionException) {
                    this.disposed = true;
                    this.queue.clear();
                    RxJavaPlugins.onError(rejectedExecutionException);
                    return EmptyDisposable.INSTANCE;
                }
            }
            return runnable;
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable runnable, long l, @NonNull TimeUnit timeUnit) {
            if (l <= 0L) {
                return this.schedule(runnable);
            }
            if (this.disposed) {
                return EmptyDisposable.INSTANCE;
            }
            SequentialDisposable sequentialDisposable = new SequentialDisposable();
            SequentialDisposable sequentialDisposable2 = new SequentialDisposable(sequentialDisposable);
            runnable = new ScheduledRunnable(new SequentialDispose(sequentialDisposable2, RxJavaPlugins.onSchedule(runnable)), this.tasks);
            this.tasks.add((Disposable)((Object)runnable));
            if (this.executor instanceof ScheduledExecutorService) {
                try {
                    runnable.setFuture(((ScheduledExecutorService)this.executor).schedule(runnable, l, timeUnit));
                }
                catch (RejectedExecutionException rejectedExecutionException) {
                    this.disposed = true;
                    RxJavaPlugins.onError(rejectedExecutionException);
                    return EmptyDisposable.INSTANCE;
                }
            } else {
                runnable.setFuture(new DisposeOnCancel(ExecutorScheduler.HELPER.scheduleDirect(runnable, l, timeUnit)));
            }
            sequentialDisposable.replace((Disposable)((Object)runnable));
            return sequentialDisposable2;
        }

        static final class BooleanRunnable
        extends AtomicBoolean
        implements Runnable,
        Disposable {
            private static final long serialVersionUID = -2421395018820541164L;
            final Runnable actual;

            BooleanRunnable(Runnable runnable) {
                this.actual = runnable;
            }

            @Override
            public void dispose() {
                this.lazySet(true);
            }

            @Override
            public boolean isDisposed() {
                return this.get();
            }

            @Override
            public void run() {
                if (this.get()) {
                    return;
                }
                try {
                    this.actual.run();
                    return;
                }
                finally {
                    this.lazySet(true);
                }
            }
        }

        final class SequentialDispose
        implements Runnable {
            private final Runnable decoratedRun;
            private final SequentialDisposable mar;

            SequentialDispose(SequentialDisposable sequentialDisposable, Runnable runnable) {
                this.mar = sequentialDisposable;
                this.decoratedRun = runnable;
            }

            @Override
            public void run() {
                this.mar.replace(ExecutorWorker.this.schedule(this.decoratedRun));
            }
        }

    }

}

