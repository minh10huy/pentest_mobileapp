/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.schedulers;

import io.reactivex.Completable;
import io.reactivex.CompletableObserver;
import io.reactivex.Flowable;
import io.reactivex.Scheduler;
import io.reactivex.annotations.Experimental;
import io.reactivex.annotations.NonNull;
import io.reactivex.disposables.Disposable;
import io.reactivex.disposables.Disposables;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.Function;
import io.reactivex.processors.FlowableProcessor;
import io.reactivex.processors.UnicastProcessor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

@Experimental
public class SchedulerWhen
extends Scheduler
implements Disposable {
    static final Disposable DISPOSED;
    static final Disposable SUBSCRIBED;
    private final Scheduler actualScheduler;
    private Disposable disposable;
    private final FlowableProcessor<Flowable<Completable>> workerProcessor;

    static {
        SUBSCRIBED = new SubscribedDisposable();
        DISPOSED = Disposables.disposed();
    }

    public SchedulerWhen(Function<Flowable<Flowable<Completable>>, Completable> function, Scheduler scheduler) {
        this.actualScheduler = scheduler;
        this.workerProcessor = UnicastProcessor.create().toSerialized();
        try {
            this.disposable = function.apply(this.workerProcessor).subscribe();
            return;
        }
        catch (Throwable throwable) {
            Exceptions.propagate(throwable);
            return;
        }
    }

    @NonNull
    @Override
    public Scheduler.Worker createWorker() {
        Scheduler.Worker worker = this.actualScheduler.createWorker();
        FlowableProcessor<ScheduledAction> flowableProcessor = UnicastProcessor.create().toSerialized();
        Flowable flowable = flowableProcessor.map(new CreateWorkerFunction(worker));
        worker = new QueueWorker(flowableProcessor, worker);
        this.workerProcessor.onNext(flowable);
        return worker;
    }

    @Override
    public void dispose() {
        this.disposable.dispose();
    }

    @Override
    public boolean isDisposed() {
        return this.disposable.isDisposed();
    }

    static final class CreateWorkerFunction
    implements Function<ScheduledAction, Completable> {
        final Scheduler.Worker actualWorker;

        CreateWorkerFunction(Scheduler.Worker worker) {
            this.actualWorker = worker;
        }

        @Override
        public Completable apply(ScheduledAction scheduledAction) {
            return new WorkerCompletable(scheduledAction);
        }

        final class WorkerCompletable
        extends Completable {
            final ScheduledAction action;

            WorkerCompletable(ScheduledAction scheduledAction) {
                this.action = scheduledAction;
            }

            @Override
            protected void subscribeActual(CompletableObserver completableObserver) {
                completableObserver.onSubscribe(this.action);
                this.action.call(CreateWorkerFunction.this.actualWorker, completableObserver);
            }
        }

    }

    static class DelayedAction
    extends ScheduledAction {
        private final Runnable action;
        private final long delayTime;
        private final TimeUnit unit;

        DelayedAction(Runnable runnable, long l, TimeUnit timeUnit) {
            this.action = runnable;
            this.delayTime = l;
            this.unit = timeUnit;
        }

        @Override
        protected Disposable callActual(Scheduler.Worker worker, CompletableObserver completableObserver) {
            return worker.schedule(new OnCompletedAction(this.action, completableObserver), this.delayTime, this.unit);
        }
    }

    static class ImmediateAction
    extends ScheduledAction {
        private final Runnable action;

        ImmediateAction(Runnable runnable) {
            this.action = runnable;
        }

        @Override
        protected Disposable callActual(Scheduler.Worker worker, CompletableObserver completableObserver) {
            return worker.schedule(new OnCompletedAction(this.action, completableObserver));
        }
    }

    static class OnCompletedAction
    implements Runnable {
        final Runnable action;
        final CompletableObserver actionCompletable;

        OnCompletedAction(Runnable runnable, CompletableObserver completableObserver) {
            this.action = runnable;
            this.actionCompletable = completableObserver;
        }

        @Override
        public void run() {
            try {
                this.action.run();
                return;
            }
            finally {
                this.actionCompletable.onComplete();
            }
        }
    }

    static final class QueueWorker
    extends Scheduler.Worker {
        private final FlowableProcessor<ScheduledAction> actionProcessor;
        private final Scheduler.Worker actualWorker;
        private final AtomicBoolean unsubscribed;

        QueueWorker(FlowableProcessor<ScheduledAction> flowableProcessor, Scheduler.Worker worker) {
            this.actionProcessor = flowableProcessor;
            this.actualWorker = worker;
            this.unsubscribed = new AtomicBoolean();
        }

        @Override
        public void dispose() {
            if (this.unsubscribed.compareAndSet(false, true)) {
                this.actionProcessor.onComplete();
                this.actualWorker.dispose();
            }
        }

        @Override
        public boolean isDisposed() {
            return this.unsubscribed.get();
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable object) {
            object = new ImmediateAction((Runnable)object);
            this.actionProcessor.onNext(object);
            return object;
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable object, long l, @NonNull TimeUnit timeUnit) {
            object = new DelayedAction((Runnable)object, l, timeUnit);
            this.actionProcessor.onNext(object);
            return object;
        }
    }

    static abstract class ScheduledAction
    extends AtomicReference<Disposable>
    implements Disposable {
        ScheduledAction() {
            super(SchedulerWhen.SUBSCRIBED);
        }

        void call(Scheduler.Worker disposable, CompletableObserver completableObserver) {
            Disposable disposable2 = (Disposable)this.get();
            if (disposable2 == SchedulerWhen.DISPOSED) {
                return;
            }
            if (disposable2 != SchedulerWhen.SUBSCRIBED) {
                return;
            }
            if (!this.compareAndSet(SchedulerWhen.SUBSCRIBED, disposable = this.callActual((Scheduler.Worker)disposable, completableObserver))) {
                disposable.dispose();
            }
        }

        protected abstract Disposable callActual(Scheduler.Worker var1, CompletableObserver var2);

        @Override
        public void dispose() {
            Disposable disposable;
            Disposable disposable2 = SchedulerWhen.DISPOSED;
            do {
                if ((disposable = (Disposable)this.get()) != SchedulerWhen.DISPOSED) continue;
                return;
            } while (!this.compareAndSet(disposable, disposable2));
            if (disposable != SchedulerWhen.SUBSCRIBED) {
                disposable.dispose();
            }
        }

        @Override
        public boolean isDisposed() {
            return ((Disposable)this.get()).isDisposed();
        }
    }

    static final class SubscribedDisposable
    implements Disposable {
        SubscribedDisposable() {
        }

        @Override
        public void dispose() {
        }

        @Override
        public boolean isDisposed() {
            return false;
        }
    }

}

