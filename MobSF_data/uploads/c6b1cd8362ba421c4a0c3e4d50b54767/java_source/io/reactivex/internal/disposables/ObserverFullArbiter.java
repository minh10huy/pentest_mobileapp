/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.disposables;

import io.reactivex.Observer;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.disposables.EmptyDisposable;
import io.reactivex.internal.disposables.FullArbiterPad1;
import io.reactivex.internal.queue.SpscLinkedArrayQueue;
import io.reactivex.internal.util.NotificationLite;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.concurrent.atomic.AtomicInteger;

public final class ObserverFullArbiter<T>
extends FullArbiterPad1
implements Disposable {
    final Observer<? super T> actual;
    volatile boolean cancelled;
    final SpscLinkedArrayQueue<Object> queue;
    Disposable resource;
    volatile Disposable s;

    public ObserverFullArbiter(Observer<? super T> observer, Disposable disposable, int n) {
        this.actual = observer;
        this.resource = disposable;
        this.queue = new SpscLinkedArrayQueue(n);
        this.s = EmptyDisposable.INSTANCE;
    }

    @Override
    public void dispose() {
        if (!this.cancelled) {
            this.cancelled = true;
            this.disposeResource();
        }
    }

    void disposeResource() {
        Disposable disposable = this.resource;
        this.resource = null;
        if (disposable != null) {
            disposable.dispose();
        }
    }

    void drain() {
        if (this.wip.getAndIncrement() != 0) {
            return;
        }
        SpscLinkedArrayQueue<Object> spscLinkedArrayQueue = this.queue;
        Observer observer = this.actual;
        int n = 1;
        do {
            Object object;
            if ((object = spscLinkedArrayQueue.poll()) == null) {
                int n2;
                n = n2 = this.wip.addAndGet(- n);
                if (n2 != 0) continue;
                return;
            }
            Object object2 = spscLinkedArrayQueue.poll();
            if (object != this.s) continue;
            if (NotificationLite.isDisposable(object2)) {
                object = NotificationLite.getDisposable(object2);
                this.s.dispose();
                if (!this.cancelled) {
                    this.s = object;
                    continue;
                }
                object.dispose();
                continue;
            }
            if (NotificationLite.isError(object2)) {
                spscLinkedArrayQueue.clear();
                this.disposeResource();
                object = NotificationLite.getError(object2);
                if (!this.cancelled) {
                    this.cancelled = true;
                    observer.onError((Throwable)object);
                    continue;
                }
                RxJavaPlugins.onError((Throwable)object);
                continue;
            }
            if (NotificationLite.isComplete(object2)) {
                spscLinkedArrayQueue.clear();
                this.disposeResource();
                if (this.cancelled) continue;
                this.cancelled = true;
                observer.onComplete();
                continue;
            }
            observer.onNext(NotificationLite.getValue(object2));
        } while (true);
    }

    @Override
    public boolean isDisposed() {
        Disposable disposable = this.resource;
        if (disposable != null) {
            return disposable.isDisposed();
        }
        return this.cancelled;
    }

    public void onComplete(Disposable disposable) {
        this.queue.offer(disposable, NotificationLite.complete());
        this.drain();
    }

    public void onError(Throwable throwable, Disposable disposable) {
        if (this.cancelled) {
            RxJavaPlugins.onError(throwable);
            return;
        }
        this.queue.offer(disposable, NotificationLite.error(throwable));
        this.drain();
    }

    public boolean onNext(T t, Disposable disposable) {
        if (this.cancelled) {
            return false;
        }
        this.queue.offer(disposable, NotificationLite.next(t));
        this.drain();
        return true;
    }

    public boolean setDisposable(Disposable disposable) {
        if (this.cancelled) {
            return false;
        }
        this.queue.offer(this.s, NotificationLite.disposable(disposable));
        this.drain();
        return true;
    }
}

