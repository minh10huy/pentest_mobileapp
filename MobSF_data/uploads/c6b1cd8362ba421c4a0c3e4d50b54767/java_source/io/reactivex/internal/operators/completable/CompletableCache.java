/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.operators.completable;

import io.reactivex.Completable;
import io.reactivex.CompletableObserver;
import io.reactivex.CompletableSource;
import io.reactivex.annotations.Experimental;
import io.reactivex.disposables.Disposable;
import java.io.Serializable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

@Experimental
public final class CompletableCache
extends Completable
implements CompletableObserver {
    static final InnerCompletableCache[] EMPTY = new InnerCompletableCache[0];
    static final InnerCompletableCache[] TERMINATED = new InnerCompletableCache[0];
    Throwable error;
    final AtomicReference<InnerCompletableCache[]> observers;
    final AtomicBoolean once;
    final CompletableSource source;

    public CompletableCache(CompletableSource completableSource) {
        this.source = completableSource;
        this.observers = new AtomicReference<InnerCompletableCache[]>(EMPTY);
        this.once = new AtomicBoolean();
    }

    boolean add(InnerCompletableCache innerCompletableCache) {
        InnerCompletableCache[] arrinnerCompletableCache;
        InnerCompletableCache[] arrinnerCompletableCache2;
        do {
            if ((arrinnerCompletableCache2 = this.observers.get()) == TERMINATED) {
                return false;
            }
            int n = arrinnerCompletableCache2.length;
            arrinnerCompletableCache = new InnerCompletableCache[n + 1];
            System.arraycopy(arrinnerCompletableCache2, 0, arrinnerCompletableCache, 0, n);
            arrinnerCompletableCache[n] = innerCompletableCache;
        } while (!this.observers.compareAndSet(arrinnerCompletableCache2, arrinnerCompletableCache));
        return true;
    }

    @Override
    public void onComplete() {
        for (InnerCompletableCache innerCompletableCache : this.observers.getAndSet(TERMINATED)) {
            if (innerCompletableCache.get()) continue;
            innerCompletableCache.actual.onComplete();
        }
    }

    @Override
    public void onError(Throwable throwable) {
        this.error = throwable;
        for (InnerCompletableCache innerCompletableCache : this.observers.getAndSet(TERMINATED)) {
            if (innerCompletableCache.get()) continue;
            innerCompletableCache.actual.onError(throwable);
        }
    }

    @Override
    public void onSubscribe(Disposable disposable) {
    }

    void remove(InnerCompletableCache innerCompletableCache) {
        InnerCompletableCache[] arrinnerCompletableCache;
        InnerCompletableCache[] arrinnerCompletableCache2;
        do {
            int n;
            int n2;
            if ((n2 = (arrinnerCompletableCache = this.observers.get()).length) == 0) {
                return;
            }
            int n3 = -1;
            int n4 = 0;
            do {
                n = n3;
                if (n4 >= n2) break;
                if (arrinnerCompletableCache[n4] == innerCompletableCache) {
                    n = n4;
                    break;
                }
                ++n4;
            } while (true);
            if (n < 0) {
                return;
            }
            if (n2 == 1) {
                arrinnerCompletableCache2 = EMPTY;
                continue;
            }
            arrinnerCompletableCache2 = new InnerCompletableCache[n2 - 1];
            System.arraycopy(arrinnerCompletableCache, 0, arrinnerCompletableCache2, 0, n);
            System.arraycopy(arrinnerCompletableCache, n + 1, arrinnerCompletableCache2, n, n2 - n - 1);
        } while (!this.observers.compareAndSet(arrinnerCompletableCache, arrinnerCompletableCache2));
    }

    @Override
    protected void subscribeActual(CompletableObserver completableObserver) {
        Serializable serializable = new InnerCompletableCache(completableObserver);
        completableObserver.onSubscribe((Disposable)((Object)serializable));
        if (this.add((InnerCompletableCache)serializable)) {
            if (serializable.isDisposed()) {
                this.remove((InnerCompletableCache)serializable);
            }
            if (this.once.compareAndSet(false, true)) {
                this.source.subscribe(this);
                return;
            }
        } else {
            serializable = this.error;
            if (serializable != null) {
                completableObserver.onError((Throwable)serializable);
                return;
            }
            completableObserver.onComplete();
        }
    }

    final class InnerCompletableCache
    extends AtomicBoolean
    implements Disposable {
        private static final long serialVersionUID = 8943152917179642732L;
        final CompletableObserver actual;

        InnerCompletableCache(CompletableObserver completableObserver) {
            this.actual = completableObserver;
        }

        @Override
        public void dispose() {
            if (this.compareAndSet(false, true)) {
                CompletableCache.this.remove(this);
            }
        }

        @Override
        public boolean isDisposed() {
            return this.get();
        }
    }

}

