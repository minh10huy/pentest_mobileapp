/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.internal.operators.flowable;

import io.reactivex.Flowable;
import io.reactivex.FlowableSubscriber;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.exceptions.MissingBackpressureException;
import io.reactivex.functions.Function;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.fuseable.QueueSubscription;
import io.reactivex.internal.fuseable.SimpleQueue;
import io.reactivex.internal.operators.flowable.AbstractFlowableWithUpstream;
import io.reactivex.internal.subscriptions.EmptySubscription;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.internal.util.QueueDrainHelper;
import io.reactivex.plugins.RxJavaPlugins;
import java.io.Serializable;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class FlowablePublishMulticast<T, R>
extends AbstractFlowableWithUpstream<T, R> {
    final boolean delayError;
    final int prefetch;
    final Function<? super Flowable<T>, ? extends Publisher<? extends R>> selector;

    public FlowablePublishMulticast(Flowable<T> flowable, Function<? super Flowable<T>, ? extends Publisher<? extends R>> function, int n, boolean bl) {
        super(flowable);
        this.selector = function;
        this.prefetch = n;
        this.delayError = bl;
    }

    @Override
    protected void subscribeActual(Subscriber<? super R> subscriber) {
        MulticastProcessor multicastProcessor = new MulticastProcessor(this.prefetch, this.delayError);
        try {
            Publisher<R> publisher = ObjectHelper.requireNonNull(this.selector.apply(multicastProcessor), "selector returned a null Publisher");
            publisher.subscribe(new OutputCanceller<R>(subscriber, multicastProcessor));
            this.source.subscribe(multicastProcessor);
            return;
        }
        catch (Throwable throwable) {
            Exceptions.throwIfFatal(throwable);
            EmptySubscription.error(throwable, subscriber);
            return;
        }
    }

    static final class MulticastProcessor<T>
    extends Flowable<T>
    implements FlowableSubscriber<T>,
    Disposable {
        static final MulticastSubscription[] EMPTY = new MulticastSubscription[0];
        static final MulticastSubscription[] TERMINATED = new MulticastSubscription[0];
        int consumed;
        final boolean delayError;
        volatile boolean done;
        Throwable error;
        final int limit;
        final int prefetch;
        volatile SimpleQueue<T> queue;
        final AtomicReference<Subscription> s;
        int sourceMode;
        final AtomicReference<MulticastSubscription<T>[]> subscribers;
        final AtomicInteger wip;

        MulticastProcessor(int n, boolean bl) {
            this.prefetch = n;
            this.limit = n - (n >> 2);
            this.delayError = bl;
            this.wip = new AtomicInteger();
            this.s = new AtomicReference();
            this.subscribers = new AtomicReference<MulticastSubscription[]>(EMPTY);
        }

        boolean add(MulticastSubscription<T> multicastSubscription) {
            MulticastSubscription[] arrmulticastSubscription;
            MulticastSubscription<T>[] arrmulticastSubscription2;
            do {
                if ((arrmulticastSubscription2 = this.subscribers.get()) == TERMINATED) {
                    return false;
                }
                int n = arrmulticastSubscription2.length;
                arrmulticastSubscription = new MulticastSubscription[n + 1];
                System.arraycopy(arrmulticastSubscription2, 0, arrmulticastSubscription, 0, n);
                arrmulticastSubscription[n] = multicastSubscription;
            } while (!this.subscribers.compareAndSet(arrmulticastSubscription2, arrmulticastSubscription));
            return true;
        }

        void completeAll() {
            for (MulticastSubscription multicastSubscription : this.subscribers.getAndSet(TERMINATED)) {
                if (multicastSubscription.get() == Long.MIN_VALUE) continue;
                multicastSubscription.actual.onComplete();
            }
        }

        @Override
        public void dispose() {
            SimpleQueue<T> simpleQueue;
            SubscriptionHelper.cancel(this.s);
            if (this.wip.getAndIncrement() == 0 && (simpleQueue = this.queue) != null) {
                simpleQueue.clear();
            }
        }

        void drain() {
            if (this.wip.getAndIncrement() != 0) {
                return;
            }
            Object object = this.queue;
            int n = this.consumed;
            int n2 = this.limit;
            boolean bl = this.sourceMode != 1;
            int n3 = 1;
            do {
                Object object2 = this.subscribers.get();
                int n4 = ((MulticastSubscription<T>[])object2).length;
                int n5 = n;
                if (object != null) {
                    n5 = n;
                    if (n4 != 0) {
                        Object object3;
                        boolean bl2;
                        long l;
                        n4 = ((MulticastSubscription<T>[])object2).length;
                        long l2 = Long.MAX_VALUE;
                        for (n5 = 0; n5 < n4; ++n5) {
                            long l3 = object2[n5].get();
                            l = l2;
                            if (l3 != Long.MIN_VALUE) {
                                l = l2;
                                if (l2 > l3) {
                                    l = l3;
                                }
                            }
                            l2 = l;
                        }
                        for (l = 0L; l != l2; ++l) {
                            if (this.isDisposed()) {
                                object.clear();
                                return;
                            }
                            bl2 = this.done;
                            if (bl2 && !this.delayError && (object3 = this.error) != null) {
                                this.errorAll((Throwable)object3);
                                return;
                            }
                            try {
                                object3 = object.poll();
                                n5 = object3 == null ? 1 : 0;
                                if (bl2 && n5 != 0) {
                                    object = this.error;
                                    if (object != null) {
                                        this.errorAll((Throwable)object);
                                        return;
                                    }
                                    this.completeAll();
                                    return;
                                }
                                if (n5 != 0) break;
                            }
                            catch (Throwable throwable) {
                                Exceptions.throwIfFatal(throwable);
                                SubscriptionHelper.cancel(this.s);
                                this.errorAll(throwable);
                                return;
                            }
                            for (MulticastSubscription<T> multicastSubscription : object2) {
                                if (multicastSubscription.get() == Long.MIN_VALUE) continue;
                                multicastSubscription.actual.onNext(object3);
                            }
                            n5 = n;
                            if (bl && (n5 = n + 1) == n2) {
                                this.s.get().request((long)n2);
                                n5 = 0;
                            }
                            n = n5;
                            continue;
                        }
                        if (l == l2) {
                            if (this.isDisposed()) {
                                object.clear();
                                return;
                            }
                            bl2 = this.done;
                            if (bl2 && !this.delayError && (object3 = this.error) != null) {
                                this.errorAll((Throwable)object3);
                                return;
                            }
                            if (bl2 && object.isEmpty()) {
                                object = this.error;
                                if (object != null) {
                                    this.errorAll((Throwable)object);
                                    return;
                                }
                                this.completeAll();
                                return;
                            }
                        }
                        int n6 = ((MulticastSubscription<T>[])object2).length;
                        n4 = 0;
                        do {
                            n5 = n;
                            if (n4 >= n6) break;
                            BackpressureHelper.produced(object2[n4], l);
                            ++n4;
                        } while (true);
                    }
                }
                this.consumed = n5;
                if ((n3 = this.wip.addAndGet(- n3)) == 0) {
                    return;
                }
                object2 = object;
                if (object == null) {
                    object2 = this.queue;
                }
                object = object2;
                n = n5;
            } while (true);
        }

        void errorAll(Throwable throwable) {
            for (MulticastSubscription multicastSubscription : this.subscribers.getAndSet(TERMINATED)) {
                if (multicastSubscription.get() == Long.MIN_VALUE) continue;
                multicastSubscription.actual.onError(throwable);
            }
        }

        @Override
        public boolean isDisposed() {
            return SubscriptionHelper.isCancelled(this.s.get());
        }

        public void onComplete() {
            if (!this.done) {
                this.done = true;
                this.drain();
            }
        }

        public void onError(Throwable throwable) {
            if (this.done) {
                RxJavaPlugins.onError(throwable);
                return;
            }
            this.error = throwable;
            this.done = true;
            this.drain();
        }

        public void onNext(T t) {
            if (this.done) {
                return;
            }
            if (this.sourceMode == 0 && !this.queue.offer(t)) {
                this.s.get().cancel();
                this.onError(new MissingBackpressureException());
                return;
            }
            this.drain();
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            if (SubscriptionHelper.setOnce(this.s, subscription)) {
                if (subscription instanceof QueueSubscription) {
                    QueueSubscription queueSubscription = (QueueSubscription)subscription;
                    int n = queueSubscription.requestFusion(3);
                    if (n == 1) {
                        this.sourceMode = n;
                        this.queue = queueSubscription;
                        this.done = true;
                        this.drain();
                        return;
                    }
                    if (n == 2) {
                        this.sourceMode = n;
                        this.queue = queueSubscription;
                        QueueDrainHelper.request(subscription, this.prefetch);
                        return;
                    }
                }
                this.queue = QueueDrainHelper.createQueue(this.prefetch);
                QueueDrainHelper.request(subscription, this.prefetch);
            }
        }

        void remove(MulticastSubscription<T> multicastSubscription) {
            MulticastSubscription<T>[] arrmulticastSubscription;
            while ((arrmulticastSubscription = this.subscribers.get()) != TERMINATED) {
                int n;
                MulticastSubscription[] arrmulticastSubscription2;
                if (arrmulticastSubscription == EMPTY) {
                    return;
                }
                int n2 = arrmulticastSubscription.length;
                int n3 = -1;
                int n4 = 0;
                do {
                    n = n3;
                    if (n4 >= n2) break;
                    if (arrmulticastSubscription[n4] == multicastSubscription) {
                        n = n4;
                        break;
                    }
                    ++n4;
                } while (true);
                if (n < 0) {
                    return;
                }
                if (n2 == 1) {
                    arrmulticastSubscription2 = EMPTY;
                } else {
                    arrmulticastSubscription2 = new MulticastSubscription[n2 - 1];
                    System.arraycopy(arrmulticastSubscription, 0, arrmulticastSubscription2, 0, n);
                    System.arraycopy(arrmulticastSubscription, n + 1, arrmulticastSubscription2, n, n2 - n - 1);
                }
                if (!this.subscribers.compareAndSet(arrmulticastSubscription, arrmulticastSubscription2)) continue;
                return;
            }
        }

        @Override
        protected void subscribeActual(Subscriber<? super T> subscriber) {
            Serializable serializable = new MulticastSubscription<T>(subscriber, this);
            subscriber.onSubscribe(serializable);
            if (this.add((MulticastSubscription<T>)serializable)) {
                if (serializable.isCancelled()) {
                    this.remove((MulticastSubscription<T>)serializable);
                    return;
                }
                this.drain();
                return;
            }
            serializable = this.error;
            if (serializable != null) {
                subscriber.onError(serializable);
                return;
            }
            subscriber.onComplete();
        }
    }

    static final class MulticastSubscription<T>
    extends AtomicLong
    implements Subscription {
        private static final long serialVersionUID = 8664815189257569791L;
        final Subscriber<? super T> actual;
        final MulticastProcessor<T> parent;

        MulticastSubscription(Subscriber<? super T> subscriber, MulticastProcessor<T> multicastProcessor) {
            this.actual = subscriber;
            this.parent = multicastProcessor;
        }

        public void cancel() {
            if (this.getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE) {
                this.parent.remove(this);
                this.parent.drain();
            }
        }

        public boolean isCancelled() {
            if (this.get() == Long.MIN_VALUE) {
                return true;
            }
            return false;
        }

        public void request(long l) {
            if (SubscriptionHelper.validate(l)) {
                BackpressureHelper.addCancel(this, l);
                this.parent.drain();
            }
        }
    }

    static final class OutputCanceller<R>
    implements FlowableSubscriber<R>,
    Subscription {
        final Subscriber<? super R> actual;
        final MulticastProcessor<?> processor;
        Subscription s;

        OutputCanceller(Subscriber<? super R> subscriber, MulticastProcessor<?> multicastProcessor) {
            this.actual = subscriber;
            this.processor = multicastProcessor;
        }

        public void cancel() {
            this.s.cancel();
            this.processor.dispose();
        }

        public void onComplete() {
            this.actual.onComplete();
            this.processor.dispose();
        }

        public void onError(Throwable throwable) {
            this.actual.onError(throwable);
            this.processor.dispose();
        }

        public void onNext(R r) {
            this.actual.onNext(r);
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            if (SubscriptionHelper.validate(this.s, subscription)) {
                this.s = subscription;
                this.actual.onSubscribe((Subscription)this);
            }
        }

        public void request(long l) {
            this.s.request(l);
        }
    }

}

