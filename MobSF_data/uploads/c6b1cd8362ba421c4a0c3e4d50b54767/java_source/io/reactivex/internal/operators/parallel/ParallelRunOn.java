/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.internal.operators.parallel;

import io.reactivex.FlowableSubscriber;
import io.reactivex.Scheduler;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.MissingBackpressureException;
import io.reactivex.internal.fuseable.ConditionalSubscriber;
import io.reactivex.internal.queue.SpscArrayQueue;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.parallel.ParallelFlowable;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class ParallelRunOn<T>
extends ParallelFlowable<T> {
    final int prefetch;
    final Scheduler scheduler;
    final ParallelFlowable<? extends T> source;

    public ParallelRunOn(ParallelFlowable<? extends T> parallelFlowable, Scheduler scheduler, int n) {
        this.source = parallelFlowable;
        this.scheduler = scheduler;
        this.prefetch = n;
    }

    @Override
    public int parallelism() {
        return this.source.parallelism();
    }

    @Override
    public void subscribe(Subscriber<? super T>[] arrsubscriber) {
        if (!this.validate(arrsubscriber)) {
            return;
        }
        int n = arrsubscriber.length;
        Subscriber[] arrsubscriber2 = new Subscriber[n];
        int n2 = this.prefetch;
        for (int i = 0; i < n; ++i) {
            Subscriber<? super T> subscriber = arrsubscriber[i];
            Scheduler.Worker worker = this.scheduler.createWorker();
            SpscArrayQueue spscArrayQueue = new SpscArrayQueue(n2);
            arrsubscriber2[i] = subscriber instanceof ConditionalSubscriber ? new RunOnConditionalSubscriber((ConditionalSubscriber)subscriber, n2, spscArrayQueue, worker) : new RunOnSubscriber<T>(subscriber, n2, spscArrayQueue, worker);
        }
        this.source.subscribe(arrsubscriber2);
    }

    static abstract class BaseRunOnSubscriber<T>
    extends AtomicInteger
    implements FlowableSubscriber<T>,
    Subscription,
    Runnable {
        private static final long serialVersionUID = 9222303586456402150L;
        volatile boolean cancelled;
        int consumed;
        volatile boolean done;
        Throwable error;
        final int limit;
        final int prefetch;
        final SpscArrayQueue<T> queue;
        final AtomicLong requested = new AtomicLong();
        Subscription s;
        final Scheduler.Worker worker;

        BaseRunOnSubscriber(int n, SpscArrayQueue<T> spscArrayQueue, Scheduler.Worker worker) {
            this.prefetch = n;
            this.queue = spscArrayQueue;
            this.limit = n - (n >> 2);
            this.worker = worker;
        }

        public final void cancel() {
            if (!this.cancelled) {
                this.cancelled = true;
                this.s.cancel();
                this.worker.dispose();
                if (this.getAndIncrement() == 0) {
                    this.queue.clear();
                }
            }
        }

        public final void onComplete() {
            if (this.done) {
                return;
            }
            this.done = true;
            this.schedule();
        }

        public final void onError(Throwable throwable) {
            if (this.done) {
                RxJavaPlugins.onError(throwable);
                return;
            }
            this.error = throwable;
            this.done = true;
            this.schedule();
        }

        public final void onNext(T t) {
            if (this.done) {
                return;
            }
            if (!this.queue.offer(t)) {
                this.s.cancel();
                this.onError(new MissingBackpressureException("Queue is full?!"));
                return;
            }
            this.schedule();
        }

        public final void request(long l) {
            if (SubscriptionHelper.validate(l)) {
                BackpressureHelper.add(this.requested, l);
                this.schedule();
            }
        }

        final void schedule() {
            if (this.getAndIncrement() == 0) {
                this.worker.schedule(this);
            }
        }
    }

    static final class RunOnConditionalSubscriber<T>
    extends BaseRunOnSubscriber<T> {
        private static final long serialVersionUID = 1075119423897941642L;
        final ConditionalSubscriber<? super T> actual;

        RunOnConditionalSubscriber(ConditionalSubscriber<? super T> conditionalSubscriber, int n, SpscArrayQueue<T> spscArrayQueue, Scheduler.Worker worker) {
            super(n, spscArrayQueue, worker);
            this.actual = conditionalSubscriber;
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            if (SubscriptionHelper.validate(this.s, subscription)) {
                this.s = subscription;
                this.actual.onSubscribe(this);
                subscription.request((long)this.prefetch);
            }
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        @Override
        public void run() {
            var3_1 = this.consumed;
            var13_2 = this.queue;
            var14_3 = this.actual;
            var5_4 = this.limit;
            var1_5 = 1;
            do lbl-1000: // 3 sources:
            {
                var10_10 = this.requested.get();
                var6_8 = 0L;
                var2_6 = var1_5;
                while (var6_8 != var10_10) {
                    if (this.cancelled) {
                        var13_2.clear();
                        return;
                    }
                    var12_11 = this.done;
                    if (var12_11 && (var15_13 = this.error) != null) {
                        var13_2.clear();
                        var14_3.onError(var15_13);
                        this.worker.dispose();
                        return;
                    }
                    var15_15 = var13_2.poll();
                    var1_5 = var15_15 == null ? 1 : 0;
                    if (!var12_11) break;
                    if (var1_5 != 0) {
                        var14_3.onComplete();
                        this.worker.dispose();
                        return;
                    }
                    if (var1_5 != 0) break;
                    var8_9 = var6_8;
                    if (var14_3.tryOnNext((T)var15_15)) {
                        var8_9 = var6_8 + 1L;
                    }
                    if ((var1_5 = var3_1 + 1) == var5_4) {
                        this.s.request((long)var1_5);
                        var1_5 = 0;
                    }
                    var3_1 = var1_5;
                    var6_8 = var8_9;
                }
                if (var6_8 == var10_10) {
                    if (this.cancelled) {
                        var13_2.clear();
                        return;
                    }
                    if (this.done) {
                        var15_16 = this.error;
                        if (var15_16 != null) {
                            var13_2.clear();
                            var14_3.onError(var15_16);
                            this.worker.dispose();
                            return;
                        }
                        if (var13_2.isEmpty()) {
                            var14_3.onComplete();
                            this.worker.dispose();
                            return;
                        }
                    }
                }
                if (var6_8 != 0L && var10_10 != Long.MAX_VALUE) {
                    this.requested.addAndGet(- var6_8);
                }
                var1_5 = var4_7 = this.get();
                if (var4_7 != var2_6) ** GOTO lbl-1000
                this.consumed = var3_1;
                var1_5 = var2_6 = this.addAndGet(- var2_6);
            } while (var2_6 != 0);
        }
    }

    static final class RunOnSubscriber<T>
    extends BaseRunOnSubscriber<T> {
        private static final long serialVersionUID = 1075119423897941642L;
        final Subscriber<? super T> actual;

        RunOnSubscriber(Subscriber<? super T> subscriber, int n, SpscArrayQueue<T> spscArrayQueue, Scheduler.Worker worker) {
            super(n, spscArrayQueue, worker);
            this.actual = subscriber;
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            if (SubscriptionHelper.validate(this.s, subscription)) {
                this.s = subscription;
                this.actual.onSubscribe((Subscription)this);
                subscription.request((long)this.prefetch);
            }
        }

        @Override
        public void run() {
            int n = this.consumed;
            SpscArrayQueue spscArrayQueue = this.queue;
            Subscriber<? super T> subscriber = this.actual;
            int n2 = this.limit;
            int n3 = 1;
            do {
                long l;
                Throwable throwable;
                int n4;
                long l2 = this.requested.get();
                for (l = 0L; l != l2; ++l) {
                    if (this.cancelled) {
                        spscArrayQueue.clear();
                        return;
                    }
                    boolean bl = this.done;
                    if (bl && (throwable = this.error) != null) {
                        spscArrayQueue.clear();
                        subscriber.onError(throwable);
                        this.worker.dispose();
                        return;
                    }
                    throwable = spscArrayQueue.poll();
                    n4 = throwable == null ? 1 : 0;
                    if (bl && n4 != 0) {
                        subscriber.onComplete();
                        this.worker.dispose();
                        return;
                    }
                    if (n4 != 0) break;
                    subscriber.onNext((Object)throwable);
                    n = n4 = n + 1;
                    if (n4 != n2) continue;
                    this.s.request((long)n4);
                    n = 0;
                }
                if (l == l2) {
                    if (this.cancelled) {
                        spscArrayQueue.clear();
                        return;
                    }
                    if (this.done) {
                        throwable = this.error;
                        if (throwable != null) {
                            spscArrayQueue.clear();
                            subscriber.onError(throwable);
                            this.worker.dispose();
                            return;
                        }
                        if (spscArrayQueue.isEmpty()) {
                            subscriber.onComplete();
                            this.worker.dispose();
                            return;
                        }
                    }
                }
                if (l != 0L && l2 != Long.MAX_VALUE) {
                    this.requested.addAndGet(- l);
                }
                if ((n4 = this.get()) == n3) {
                    this.consumed = n;
                    n3 = n4 = this.addAndGet(- n3);
                    if (n4 != 0) continue;
                    return;
                }
                n3 = n4;
            } while (true);
        }
    }

}

