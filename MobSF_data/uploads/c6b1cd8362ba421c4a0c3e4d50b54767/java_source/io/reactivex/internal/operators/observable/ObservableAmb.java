/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.operators.observable;

import io.reactivex.Observable;
import io.reactivex.ObservableSource;
import io.reactivex.Observer;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.disposables.EmptyDisposable;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public final class ObservableAmb<T>
extends Observable<T> {
    final ObservableSource<? extends T>[] sources;
    final Iterable<? extends ObservableSource<? extends T>> sourcesIterable;

    public ObservableAmb(ObservableSource<? extends T>[] arrobservableSource, Iterable<? extends ObservableSource<? extends T>> iterable) {
        this.sources = arrobservableSource;
        this.sourcesIterable = iterable;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public void subscribeActual(Observer<? super T> observer) {
        int n;
        ObservableSource<? extends T>[] arrobservableSource = this.sources;
        if (arrobservableSource != null) {
            n = arrobservableSource.length;
        } else {
            int n2;
            Iterator<ObservableSource<T>> iterator;
            ObservableSource<Object>[] arrobservableSource2 = new Observable[8];
            try {
                iterator = this.sourcesIterable.iterator();
                n2 = 0;
            }
            catch (Throwable throwable) {
                Exceptions.throwIfFatal(throwable);
                EmptyDisposable.error(throwable, observer);
                return;
            }
            do {
                arrobservableSource = arrobservableSource2;
                n = n2;
                if (!iterator.hasNext()) break;
                ObservableSource<? extends T> observableSource = iterator.next();
                if (observableSource == null) {
                    EmptyDisposable.error((Throwable)new NullPointerException("One of the sources is null"), observer);
                    return;
                }
                arrobservableSource = arrobservableSource2;
                if (n2 == arrobservableSource2.length) {
                    arrobservableSource = new ObservableSource[(n2 >> 2) + n2];
                    System.arraycopy(arrobservableSource2, 0, arrobservableSource, 0, n2);
                }
                arrobservableSource[n2] = observableSource;
                ++n2;
                arrobservableSource2 = arrobservableSource;
            } while (true);
        }
        if (n == 0) {
            EmptyDisposable.complete(observer);
            return;
        }
        if (n == 1) {
            arrobservableSource[0].subscribe(observer);
            return;
        }
        new AmbCoordinator<T>(observer, n).subscribe(arrobservableSource);
    }

    static final class AmbCoordinator<T>
    implements Disposable {
        final Observer<? super T> actual;
        final AmbInnerObserver<T>[] observers;
        final AtomicInteger winner = new AtomicInteger();

        AmbCoordinator(Observer<? super T> observer, int n) {
            this.actual = observer;
            this.observers = new AmbInnerObserver[n];
        }

        @Override
        public void dispose() {
            if (this.winner.get() != -1) {
                this.winner.lazySet(-1);
                AmbInnerObserver<T>[] arrambInnerObserver = this.observers;
                int n = arrambInnerObserver.length;
                for (int i = 0; i < n; ++i) {
                    arrambInnerObserver[i].dispose();
                }
            }
        }

        @Override
        public boolean isDisposed() {
            if (this.winner.get() == -1) {
                return true;
            }
            return false;
        }

        public void subscribe(ObservableSource<? extends T>[] arrobservableSource) {
            AmbInnerObserver<T>[] arrambInnerObserver = this.observers;
            int n = arrambInnerObserver.length;
            int n2 = 0;
            int n3 = 0;
            while (n3 < n) {
                int n4 = n3 + 1;
                arrambInnerObserver[n3] = new AmbInnerObserver<T>(this, n4, this.actual);
                n3 = n4;
            }
            this.winner.lazySet(0);
            this.actual.onSubscribe(this);
            for (n3 = n2; n3 < n; ++n3) {
                if (this.winner.get() != 0) {
                    return;
                }
                arrobservableSource[n3].subscribe(arrambInnerObserver[n3]);
            }
        }

        public boolean win(int n) {
            int n2 = this.winner.get();
            int n3 = 0;
            if (n2 == 0) {
                if (this.winner.compareAndSet(0, n)) {
                    AmbInnerObserver<T>[] arrambInnerObserver = this.observers;
                    int n4 = arrambInnerObserver.length;
                    while (n3 < n4) {
                        n2 = n3 + 1;
                        if (n2 != n) {
                            arrambInnerObserver[n3].dispose();
                        }
                        n3 = n2;
                    }
                    return true;
                }
                return false;
            }
            if (n2 == n) {
                return true;
            }
            return false;
        }
    }

    static final class AmbInnerObserver<T>
    extends AtomicReference<Disposable>
    implements Observer<T> {
        private static final long serialVersionUID = -1185974347409665484L;
        final Observer<? super T> actual;
        final int index;
        final AmbCoordinator<T> parent;
        boolean won;

        AmbInnerObserver(AmbCoordinator<T> ambCoordinator, int n, Observer<? super T> observer) {
            this.parent = ambCoordinator;
            this.index = n;
            this.actual = observer;
        }

        public void dispose() {
            DisposableHelper.dispose(this);
        }

        @Override
        public void onComplete() {
            if (this.won) {
                this.actual.onComplete();
                return;
            }
            if (this.parent.win(this.index)) {
                this.won = true;
                this.actual.onComplete();
            }
        }

        @Override
        public void onError(Throwable throwable) {
            if (this.won) {
                this.actual.onError(throwable);
                return;
            }
            if (this.parent.win(this.index)) {
                this.won = true;
                this.actual.onError(throwable);
                return;
            }
            RxJavaPlugins.onError(throwable);
        }

        @Override
        public void onNext(T t) {
            if (this.won) {
                this.actual.onNext(t);
                return;
            }
            if (this.parent.win(this.index)) {
                this.won = true;
                this.actual.onNext(t);
                return;
            }
            ((Disposable)this.get()).dispose();
        }

        @Override
        public void onSubscribe(Disposable disposable) {
            DisposableHelper.setOnce(this, disposable);
        }
    }

}

