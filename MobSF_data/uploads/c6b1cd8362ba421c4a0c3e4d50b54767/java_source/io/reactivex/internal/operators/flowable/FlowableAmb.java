/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.internal.operators.flowable;

import io.reactivex.Flowable;
import io.reactivex.FlowableSubscriber;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.internal.subscriptions.EmptySubscription;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class FlowableAmb<T>
extends Flowable<T> {
    final Publisher<? extends T>[] sources;
    final Iterable<? extends Publisher<? extends T>> sourcesIterable;

    public FlowableAmb(Publisher<? extends T>[] arrpublisher, Iterable<? extends Publisher<? extends T>> iterable) {
        this.sources = arrpublisher;
        this.sourcesIterable = iterable;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public void subscribeActual(Subscriber<? super T> subscriber) {
        int n;
        Publisher<? extends T>[] arrpublisher = this.sources;
        if (arrpublisher != null) {
            n = arrpublisher.length;
        } else {
            int n2;
            Iterator<Publisher<T>> iterator;
            Publisher[] arrpublisher2 = new Publisher[8];
            try {
                iterator = this.sourcesIterable.iterator();
                n2 = 0;
            }
            catch (Throwable throwable) {
                Exceptions.throwIfFatal(throwable);
                EmptySubscription.error(throwable, subscriber);
                return;
            }
            do {
                arrpublisher = arrpublisher2;
                n = n2;
                if (!iterator.hasNext()) break;
                Publisher<? extends T> publisher = iterator.next();
                if (publisher == null) {
                    EmptySubscription.error(new NullPointerException("One of the sources is null"), subscriber);
                    return;
                }
                arrpublisher = arrpublisher2;
                if (n2 == arrpublisher2.length) {
                    arrpublisher = new Publisher[(n2 >> 2) + n2];
                    System.arraycopy(arrpublisher2, 0, arrpublisher, 0, n2);
                }
                arrpublisher[n2] = publisher;
                ++n2;
                arrpublisher2 = arrpublisher;
            } while (true);
        }
        if (n == 0) {
            EmptySubscription.complete(subscriber);
            return;
        }
        if (n == 1) {
            arrpublisher[0].subscribe(subscriber);
            return;
        }
        new AmbCoordinator<T>(subscriber, n).subscribe(arrpublisher);
    }

    static final class AmbCoordinator<T>
    implements Subscription {
        final Subscriber<? super T> actual;
        final AmbInnerSubscriber<T>[] subscribers;
        final AtomicInteger winner = new AtomicInteger();

        AmbCoordinator(Subscriber<? super T> subscriber, int n) {
            this.actual = subscriber;
            this.subscribers = new AmbInnerSubscriber[n];
        }

        public void cancel() {
            if (this.winner.get() != -1) {
                this.winner.lazySet(-1);
                AmbInnerSubscriber<T>[] arrambInnerSubscriber = this.subscribers;
                int n = arrambInnerSubscriber.length;
                for (int i = 0; i < n; ++i) {
                    arrambInnerSubscriber[i].cancel();
                }
            }
        }

        public void request(long l) {
            if (SubscriptionHelper.validate(l)) {
                int n = this.winner.get();
                if (n > 0) {
                    this.subscribers[n - 1].request(l);
                    return;
                }
                if (n == 0) {
                    AmbInnerSubscriber<T>[] arrambInnerSubscriber = this.subscribers;
                    int n2 = arrambInnerSubscriber.length;
                    for (n = 0; n < n2; ++n) {
                        arrambInnerSubscriber[n].request(l);
                    }
                }
            }
        }

        public void subscribe(Publisher<? extends T>[] arrpublisher) {
            AmbInnerSubscriber<T>[] arrambInnerSubscriber = this.subscribers;
            int n = arrambInnerSubscriber.length;
            int n2 = 0;
            int n3 = 0;
            while (n3 < n) {
                int n4 = n3 + 1;
                arrambInnerSubscriber[n3] = new AmbInnerSubscriber<T>(this, n4, this.actual);
                n3 = n4;
            }
            this.winner.lazySet(0);
            this.actual.onSubscribe((Subscription)this);
            for (n3 = n2; n3 < n; ++n3) {
                if (this.winner.get() != 0) {
                    return;
                }
                arrpublisher[n3].subscribe(arrambInnerSubscriber[n3]);
            }
        }

        public boolean win(int n) {
            int n2 = this.winner.get();
            int n3 = 0;
            if (n2 == 0 && this.winner.compareAndSet(0, n)) {
                AmbInnerSubscriber<T>[] arrambInnerSubscriber = this.subscribers;
                int n4 = arrambInnerSubscriber.length;
                while (n3 < n4) {
                    n2 = n3 + 1;
                    if (n2 != n) {
                        arrambInnerSubscriber[n3].cancel();
                    }
                    n3 = n2;
                }
                return true;
            }
            return false;
        }
    }

    static final class AmbInnerSubscriber<T>
    extends AtomicReference<Subscription>
    implements FlowableSubscriber<T>,
    Subscription {
        private static final long serialVersionUID = -1185974347409665484L;
        final Subscriber<? super T> actual;
        final int index;
        final AtomicLong missedRequested = new AtomicLong();
        final AmbCoordinator<T> parent;
        boolean won;

        AmbInnerSubscriber(AmbCoordinator<T> ambCoordinator, int n, Subscriber<? super T> subscriber) {
            this.parent = ambCoordinator;
            this.index = n;
            this.actual = subscriber;
        }

        public void cancel() {
            SubscriptionHelper.cancel(this);
        }

        public void onComplete() {
            if (this.won) {
                this.actual.onComplete();
                return;
            }
            if (this.parent.win(this.index)) {
                this.won = true;
                this.actual.onComplete();
                return;
            }
            ((Subscription)this.get()).cancel();
        }

        public void onError(Throwable throwable) {
            if (this.won) {
                this.actual.onError(throwable);
                return;
            }
            if (this.parent.win(this.index)) {
                this.won = true;
                this.actual.onError(throwable);
                return;
            }
            ((Subscription)this.get()).cancel();
            RxJavaPlugins.onError(throwable);
        }

        public void onNext(T t) {
            if (this.won) {
                this.actual.onNext(t);
                return;
            }
            if (this.parent.win(this.index)) {
                this.won = true;
                this.actual.onNext(t);
                return;
            }
            ((Subscription)this.get()).cancel();
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            SubscriptionHelper.deferredSetOnce(this, this.missedRequested, subscription);
        }

        public void request(long l) {
            SubscriptionHelper.deferredRequest(this, this.missedRequested, l);
        }
    }

}

