/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.operators.observable;

import io.reactivex.Observable;
import io.reactivex.ObservableEmitter;
import io.reactivex.ObservableOnSubscribe;
import io.reactivex.Observer;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.Cancellable;
import io.reactivex.internal.disposables.CancellableDisposable;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.queue.SpscLinkedArrayQueue;
import io.reactivex.internal.util.AtomicThrowable;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public final class ObservableCreate<T>
extends Observable<T> {
    final ObservableOnSubscribe<T> source;

    public ObservableCreate(ObservableOnSubscribe<T> observableOnSubscribe) {
        this.source = observableOnSubscribe;
    }

    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        CreateEmitter<T> createEmitter = new CreateEmitter<T>(observer);
        observer.onSubscribe(createEmitter);
        try {
            this.source.subscribe(createEmitter);
            return;
        }
        catch (Throwable throwable) {
            Exceptions.throwIfFatal(throwable);
            createEmitter.onError(throwable);
            return;
        }
    }

    static final class CreateEmitter<T>
    extends AtomicReference<Disposable>
    implements ObservableEmitter<T>,
    Disposable {
        private static final long serialVersionUID = -3434801548987643227L;
        final Observer<? super T> observer;

        CreateEmitter(Observer<? super T> observer) {
            this.observer = observer;
        }

        @Override
        public void dispose() {
            DisposableHelper.dispose(this);
        }

        @Override
        public boolean isDisposed() {
            return DisposableHelper.isDisposed((Disposable)this.get());
        }

        @Override
        public void onComplete() {
            if (!this.isDisposed()) {
                try {
                    this.observer.onComplete();
                    return;
                }
                finally {
                    this.dispose();
                }
            }
        }

        @Override
        public void onError(Throwable throwable) {
            if (!this.tryOnError(throwable)) {
                RxJavaPlugins.onError(throwable);
            }
        }

        @Override
        public void onNext(T t) {
            if (t == null) {
                this.onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
                return;
            }
            if (!this.isDisposed()) {
                this.observer.onNext(t);
            }
        }

        @Override
        public ObservableEmitter<T> serialize() {
            return new SerializedEmitter(this);
        }

        @Override
        public void setCancellable(Cancellable cancellable) {
            this.setDisposable(new CancellableDisposable(cancellable));
        }

        @Override
        public void setDisposable(Disposable disposable) {
            DisposableHelper.set(this, disposable);
        }

        @Override
        public boolean tryOnError(Throwable throwable) {
            Throwable throwable2 = throwable;
            if (throwable == null) {
                throwable2 = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
            }
            if (!this.isDisposed()) {
                try {
                    this.observer.onError(throwable2);
                    return true;
                }
                finally {
                    this.dispose();
                }
            }
            return false;
        }
    }

    static final class SerializedEmitter<T>
    extends AtomicInteger
    implements ObservableEmitter<T> {
        private static final long serialVersionUID = 4883307006032401862L;
        volatile boolean done;
        final ObservableEmitter<T> emitter;
        final AtomicThrowable error;
        final SpscLinkedArrayQueue<T> queue;

        SerializedEmitter(ObservableEmitter<T> observableEmitter) {
            this.emitter = observableEmitter;
            this.error = new AtomicThrowable();
            this.queue = new SpscLinkedArrayQueue(16);
        }

        void drain() {
            if (this.getAndIncrement() == 0) {
                this.drainLoop();
            }
        }

        void drainLoop() {
            ObservableEmitter<T> observableEmitter = this.emitter;
            SpscLinkedArrayQueue<T> spscLinkedArrayQueue = this.queue;
            AtomicThrowable atomicThrowable = this.error;
            int n = 1;
            do {
                if (observableEmitter.isDisposed()) {
                    spscLinkedArrayQueue.clear();
                    return;
                }
                if (atomicThrowable.get() != null) {
                    spscLinkedArrayQueue.clear();
                    observableEmitter.onError(atomicThrowable.terminate());
                    return;
                }
                boolean bl = this.done;
                T t = spscLinkedArrayQueue.poll();
                int n2 = t == null ? 1 : 0;
                if (bl && n2 != 0) {
                    observableEmitter.onComplete();
                    return;
                }
                if (n2 != 0) {
                    n = n2 = this.addAndGet(- n);
                    if (n2 != 0) continue;
                    return;
                }
                observableEmitter.onNext(t);
            } while (true);
        }

        @Override
        public boolean isDisposed() {
            return this.emitter.isDisposed();
        }

        @Override
        public void onComplete() {
            if (!this.emitter.isDisposed()) {
                if (this.done) {
                    return;
                }
                this.done = true;
                this.drain();
                return;
            }
        }

        @Override
        public void onError(Throwable throwable) {
            if (!this.tryOnError(throwable)) {
                RxJavaPlugins.onError(throwable);
            }
        }

        /*
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         * Converted monitor instructions to comments
         * Lifted jumps to return sites
         */
        @Override
        public void onNext(T t) {
            if (this.emitter.isDisposed()) return;
            if (this.done) {
                return;
            }
            if (t == null) {
                this.onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
                return;
            }
            if (this.get() == 0 && this.compareAndSet(0, 1)) {
                this.emitter.onNext(t);
                if (this.decrementAndGet() == 0) {
                    return;
                }
            } else {
                SpscLinkedArrayQueue<T> spscLinkedArrayQueue = this.queue;
                // MONITORENTER : spscLinkedArrayQueue
                spscLinkedArrayQueue.offer(t);
                // MONITOREXIT : spscLinkedArrayQueue
                if (this.getAndIncrement() != 0) {
                    return;
                }
            }
            this.drainLoop();
        }

        @Override
        public ObservableEmitter<T> serialize() {
            return this;
        }

        @Override
        public void setCancellable(Cancellable cancellable) {
            this.emitter.setCancellable(cancellable);
        }

        @Override
        public void setDisposable(Disposable disposable) {
            this.emitter.setDisposable(disposable);
        }

        @Override
        public boolean tryOnError(Throwable throwable) {
            if (!this.emitter.isDisposed()) {
                if (this.done) {
                    return false;
                }
                Throwable throwable2 = throwable;
                if (throwable == null) {
                    throwable2 = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
                }
                if (this.error.addThrowable(throwable2)) {
                    this.done = true;
                    this.drain();
                    return true;
                }
                return false;
            }
            return false;
        }
    }

}

