/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.internal.operators.parallel;

import io.reactivex.FlowableSubscriber;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.exceptions.MissingBackpressureException;
import io.reactivex.internal.fuseable.QueueSubscription;
import io.reactivex.internal.fuseable.SimpleQueue;
import io.reactivex.internal.queue.SpscArrayQueue;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.parallel.ParallelFlowable;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLongArray;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class ParallelFromPublisher<T>
extends ParallelFlowable<T> {
    final int parallelism;
    final int prefetch;
    final Publisher<? extends T> source;

    public ParallelFromPublisher(Publisher<? extends T> publisher, int n, int n2) {
        this.source = publisher;
        this.parallelism = n;
        this.prefetch = n2;
    }

    @Override
    public int parallelism() {
        return this.parallelism;
    }

    @Override
    public void subscribe(Subscriber<? super T>[] arrsubscriber) {
        if (!this.validate(arrsubscriber)) {
            return;
        }
        this.source.subscribe(new ParallelDispatcher<T>(arrsubscriber, this.prefetch));
    }

    static final class ParallelDispatcher<T>
    extends AtomicInteger
    implements FlowableSubscriber<T> {
        private static final long serialVersionUID = -4470634016609963609L;
        volatile boolean cancelled;
        volatile boolean done;
        final long[] emissions;
        Throwable error;
        int index;
        final int limit;
        final int prefetch;
        int produced;
        SimpleQueue<T> queue;
        final AtomicLongArray requests;
        Subscription s;
        int sourceMode;
        final AtomicInteger subscriberCount = new AtomicInteger();
        final Subscriber<? super T>[] subscribers;

        ParallelDispatcher(Subscriber<? super T>[] arrsubscriber, int n) {
            this.subscribers = arrsubscriber;
            this.prefetch = n;
            this.limit = n - (n >> 2);
            n = arrsubscriber.length;
            int n2 = n + n;
            this.requests = new AtomicLongArray(n2 + 1);
            this.requests.lazySet(n2, n);
            this.emissions = new long[n];
        }

        void cancel(int n) {
            if (this.requests.decrementAndGet(n) == 0L) {
                this.cancelled = true;
                this.s.cancel();
                if (this.getAndIncrement() == 0) {
                    this.queue.clear();
                }
            }
        }

        void drain() {
            if (this.getAndIncrement() != 0) {
                return;
            }
            if (this.sourceMode == 1) {
                this.drainSync();
                return;
            }
            this.drainAsync();
        }

        void drainAsync() {
            SimpleQueue<T> simpleQueue = this.queue;
            Subscriber<? super T>[] arrsubscriber = this.subscribers;
            AtomicLongArray atomicLongArray = this.requests;
            long[] arrl = this.emissions;
            int n = arrl.length;
            int n2 = this.index;
            int n3 = this.produced;
            int n4 = 1;
            do {
                int n5;
                int n6;
                block14 : {
                    int n7;
                    int n8 = 0;
                    int n9 = 0;
                    int n10 = 0;
                    int n11 = 0;
                    n6 = n3;
                    do {
                        block17 : {
                            block16 : {
                                long l;
                                Throwable throwable;
                                block15 : {
                                    if (this.cancelled) {
                                        simpleQueue.clear();
                                        return;
                                    }
                                    boolean bl = this.done;
                                    if (bl && (throwable = this.error) != null) {
                                        simpleQueue.clear();
                                        n4 = arrsubscriber.length;
                                        for (n3 = n10; n3 < n4; ++n3) {
                                            arrsubscriber[n3].onError(throwable);
                                        }
                                        return;
                                    }
                                    boolean bl2 = simpleQueue.isEmpty();
                                    if (bl && bl2) {
                                        n4 = arrsubscriber.length;
                                        for (n3 = n8; n3 < n4; ++n3) {
                                            arrsubscriber[n3].onComplete();
                                        }
                                        return;
                                    }
                                    if (bl2) {
                                        n3 = n2;
                                        break block14;
                                    }
                                    long l2 = atomicLongArray.get(n2);
                                    if (l2 == (l = arrl[n2]) || atomicLongArray.get(n + n2) != 0L) break block16;
                                    try {
                                        throwable = simpleQueue.poll();
                                        if (throwable != null) break block15;
                                        n3 = n2;
                                        break block14;
                                    }
                                    catch (Throwable throwable2) {
                                        Exceptions.throwIfFatal(throwable2);
                                        this.s.cancel();
                                        n4 = arrsubscriber.length;
                                        for (n3 = n9; n3 < n4; ++n3) {
                                            arrsubscriber[n3].onError(throwable2);
                                        }
                                        return;
                                    }
                                }
                                arrsubscriber[n2].onNext((Object)throwable);
                                arrl[n2] = l + 1L;
                                n3 = ++n6;
                                if (n6 == this.limit) {
                                    this.s.request((long)n6);
                                    n3 = 0;
                                }
                                n7 = 0;
                                n5 = n3;
                                break block17;
                            }
                            n7 = n11 + 1;
                            n5 = n6;
                        }
                        n3 = ++n2;
                        if (n2 == n) {
                            n3 = 0;
                        }
                        n2 = n3;
                        n11 = n7;
                        n6 = n5;
                    } while (n7 != n);
                    n6 = n5;
                }
                n2 = this.get();
                if (n2 == n4) {
                    this.index = n3;
                    this.produced = n6;
                    n5 = this.addAndGet(- n4);
                    n2 = n3;
                    n4 = n5;
                    n3 = n6;
                    if (n5 != 0) continue;
                    return;
                }
                n4 = n2;
                n2 = n3;
                n3 = n6;
            } while (true);
        }

        void drainSync() {
            SimpleQueue<T> simpleQueue = this.queue;
            Subscriber<? super T>[] arrsubscriber = this.subscribers;
            AtomicLongArray atomicLongArray = this.requests;
            long[] arrl = this.emissions;
            int n = arrl.length;
            int n2 = this.index;
            int n3 = 1;
            do {
                int n4;
                int n5 = 0;
                int n6 = 0;
                int n7 = 0;
                int n8 = 0;
                int n9 = n2;
                do {
                    block13 : {
                        block12 : {
                            T t;
                            long l;
                            block11 : {
                                if (this.cancelled) {
                                    simpleQueue.clear();
                                    return;
                                }
                                if (simpleQueue.isEmpty()) {
                                    n3 = arrsubscriber.length;
                                    for (n2 = n7; n2 < n3; ++n2) {
                                        arrsubscriber[n2].onComplete();
                                    }
                                    return;
                                }
                                long l2 = atomicLongArray.get(n9);
                                if (l2 == (l = arrl[n9]) || atomicLongArray.get(n + n9) != 0L) break block12;
                                try {
                                    t = simpleQueue.poll();
                                    if (t != null) break block11;
                                }
                                catch (Throwable throwable) {
                                    Exceptions.throwIfFatal(throwable);
                                    this.s.cancel();
                                    n3 = arrsubscriber.length;
                                    for (n2 = n6; n2 < n3; ++n2) {
                                        arrsubscriber[n2].onError(throwable);
                                    }
                                    return;
                                }
                                n3 = arrsubscriber.length;
                                for (n2 = n5; n2 < n3; ++n2) {
                                    arrsubscriber[n2].onComplete();
                                }
                                return;
                            }
                            arrsubscriber[n9].onNext(t);
                            arrl[n9] = l + 1L;
                            n4 = 0;
                            break block13;
                        }
                        n4 = n8 + 1;
                    }
                    n2 = ++n9;
                    if (n9 == n) {
                        n2 = 0;
                    }
                    n9 = n2;
                    n8 = n4;
                } while (n4 != n);
                n4 = this.get();
                if (n4 == n3) {
                    this.index = n2;
                    n3 = n4 = this.addAndGet(- n3);
                    if (n4 != 0) continue;
                    return;
                }
                n3 = n4;
            } while (true);
        }

        public void onComplete() {
            this.done = true;
            this.drain();
        }

        public void onError(Throwable throwable) {
            this.error = throwable;
            this.done = true;
            this.drain();
        }

        public void onNext(T t) {
            if (this.sourceMode == 0 && !this.queue.offer(t)) {
                this.s.cancel();
                this.onError(new MissingBackpressureException("Queue is full?"));
                return;
            }
            this.drain();
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            if (SubscriptionHelper.validate(this.s, subscription)) {
                this.s = subscription;
                if (subscription instanceof QueueSubscription) {
                    QueueSubscription queueSubscription = (QueueSubscription)subscription;
                    int n = queueSubscription.requestFusion(7);
                    if (n == 1) {
                        this.sourceMode = n;
                        this.queue = queueSubscription;
                        this.done = true;
                        this.setupSubscribers();
                        this.drain();
                        return;
                    }
                    if (n == 2) {
                        this.sourceMode = n;
                        this.queue = queueSubscription;
                        this.setupSubscribers();
                        subscription.request((long)this.prefetch);
                        return;
                    }
                }
                this.queue = new SpscArrayQueue<T>(this.prefetch);
                this.setupSubscribers();
                subscription.request((long)this.prefetch);
            }
        }

        void setupSubscribers() {
            Subscriber<? super T>[] arrsubscriber = this.subscribers;
            int n = arrsubscriber.length;
            int n2 = 0;
            while (n2 < n) {
                if (this.cancelled) {
                    return;
                }
                AtomicInteger atomicInteger = this.subscriberCount;
                int n3 = n2 + 1;
                atomicInteger.lazySet(n3);
                arrsubscriber[n2].onSubscribe((Subscription)new RailSubscription(n2, n));
                n2 = n3;
            }
        }

        final class RailSubscription
        implements Subscription {
            final int j;
            final int m;

            RailSubscription(int n, int n2) {
                this.j = n;
                this.m = n2;
            }

            public void cancel() {
                AtomicLongArray atomicLongArray = ParallelDispatcher.this.requests;
                int n = this.m;
                if (atomicLongArray.compareAndSet(this.j + n, 0L, 1L)) {
                    ParallelDispatcher.this.cancel(this.m + this.m);
                }
            }

            public void request(long l) {
                if (SubscriptionHelper.validate(l)) {
                    long l2;
                    long l3;
                    AtomicLongArray atomicLongArray = ParallelDispatcher.this.requests;
                    do {
                        if ((l2 = atomicLongArray.get(this.j)) != Long.MAX_VALUE) continue;
                        return;
                    } while (!atomicLongArray.compareAndSet(this.j, l2, l3 = BackpressureHelper.addCap(l2, l)));
                    if (ParallelDispatcher.this.subscriberCount.get() == this.m) {
                        ParallelDispatcher.this.drain();
                    }
                }
            }
        }

    }

}

