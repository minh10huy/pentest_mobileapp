/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscription
 */
package io.reactivex.internal.operators.flowable;

import io.reactivex.Flowable;
import io.reactivex.FlowableSubscriber;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.MissingBackpressureException;
import io.reactivex.internal.queue.SpscArrayQueue;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BlockingHelper;
import io.reactivex.internal.util.ExceptionHelper;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.reactivestreams.Subscription;

public final class BlockingFlowableIterable<T>
implements Iterable<T> {
    final int bufferSize;
    final Flowable<T> source;

    public BlockingFlowableIterable(Flowable<T> flowable, int n) {
        this.source = flowable;
        this.bufferSize = n;
    }

    @Override
    public Iterator<T> iterator() {
        BlockingFlowableIterator blockingFlowableIterator = new BlockingFlowableIterator(this.bufferSize);
        this.source.subscribe(blockingFlowableIterator);
        return blockingFlowableIterator;
    }

    static final class BlockingFlowableIterator<T>
    extends AtomicReference<Subscription>
    implements FlowableSubscriber<T>,
    Iterator<T>,
    Runnable,
    Disposable {
        private static final long serialVersionUID = 6695226475494099826L;
        final long batchSize;
        final Condition condition;
        volatile boolean done;
        Throwable error;
        final long limit;
        final Lock lock;
        long produced;
        final SpscArrayQueue<T> queue;

        BlockingFlowableIterator(int n) {
            this.queue = new SpscArrayQueue(n);
            this.batchSize = n;
            this.limit = n - (n >> 2);
            this.lock = new ReentrantLock();
            this.condition = this.lock.newCondition();
        }

        @Override
        public void dispose() {
            SubscriptionHelper.cancel(this);
        }

        /*
         * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
         * Loose catch block
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         * Lifted jumps to return sites
         */
        @Override
        public boolean hasNext() {
            Throwable throwable3222;
            do {
                boolean bl = this.done;
                boolean bl2 = this.queue.isEmpty();
                if (bl) {
                    Throwable throwable2 = this.error;
                    if (throwable2 != null) {
                        throw ExceptionHelper.wrapOrThrow(throwable2);
                    }
                    if (bl2) {
                        return false;
                    }
                }
                if (!bl2) return true;
                BlockingHelper.verifyNonBlocking();
                this.lock.lock();
                while (!this.done && this.queue.isEmpty()) {
                    this.condition.await();
                }
                this.lock.unlock();
                continue;
                {
                    catch (Throwable throwable3222) {
                        break;
                    }
                    catch (InterruptedException interruptedException) {}
                    {
                        this.run();
                        throw ExceptionHelper.wrapOrThrow(interruptedException);
                    }
                }
            } while (true);
            this.lock.unlock();
            throw throwable3222;
        }

        @Override
        public boolean isDisposed() {
            return SubscriptionHelper.isCancelled((Subscription)this.get());
        }

        @Override
        public T next() {
            if (this.hasNext()) {
                T t = this.queue.poll();
                long l = this.produced + 1L;
                if (l == this.limit) {
                    this.produced = 0L;
                    ((Subscription)this.get()).request(l);
                    return t;
                }
                this.produced = l;
                return t;
            }
            throw new NoSuchElementException();
        }

        public void onComplete() {
            this.done = true;
            this.signalConsumer();
        }

        public void onError(Throwable throwable) {
            this.error = throwable;
            this.done = true;
            this.signalConsumer();
        }

        public void onNext(T t) {
            if (!this.queue.offer(t)) {
                SubscriptionHelper.cancel(this);
                this.onError(new MissingBackpressureException("Queue full?!"));
                return;
            }
            this.signalConsumer();
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            if (SubscriptionHelper.setOnce(this, subscription)) {
                subscription.request(this.batchSize);
            }
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException("remove");
        }

        @Override
        public void run() {
            SubscriptionHelper.cancel(this);
            this.signalConsumer();
        }

        void signalConsumer() {
            this.lock.lock();
            try {
                this.condition.signalAll();
                return;
            }
            finally {
                this.lock.unlock();
            }
        }
    }

}

