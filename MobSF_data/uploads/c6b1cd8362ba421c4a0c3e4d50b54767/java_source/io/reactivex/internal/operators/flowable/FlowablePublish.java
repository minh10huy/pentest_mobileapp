/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.reactivestreams.Subscriber
 *  org.reactivestreams.Subscription
 */
package io.reactivex.internal.operators.flowable;

import io.reactivex.Flowable;
import io.reactivex.FlowableSubscriber;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.exceptions.MissingBackpressureException;
import io.reactivex.flowables.ConnectableFlowable;
import io.reactivex.functions.Consumer;
import io.reactivex.internal.fuseable.HasUpstreamPublisher;
import io.reactivex.internal.fuseable.QueueSubscription;
import io.reactivex.internal.fuseable.SimpleQueue;
import io.reactivex.internal.queue.SpscArrayQueue;
import io.reactivex.internal.subscriptions.SubscriptionHelper;
import io.reactivex.internal.util.BackpressureHelper;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.internal.util.NotificationLite;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;
import org.reactivestreams.Subscription;

public final class FlowablePublish<T>
extends ConnectableFlowable<T>
implements HasUpstreamPublisher<T> {
    static final long CANCELLED = Long.MIN_VALUE;
    final int bufferSize;
    final AtomicReference<PublishSubscriber<T>> current;
    final Publisher<T> onSubscribe;
    final Flowable<T> source;

    private FlowablePublish(Publisher<T> publisher, Flowable<T> flowable, AtomicReference<PublishSubscriber<T>> atomicReference, int n) {
        this.onSubscribe = publisher;
        this.source = flowable;
        this.current = atomicReference;
        this.bufferSize = n;
    }

    public static <T> ConnectableFlowable<T> create(Flowable<T> flowable, int n) {
        AtomicReference atomicReference = new AtomicReference();
        return RxJavaPlugins.onAssembly(new FlowablePublish(new FlowablePublisher(atomicReference, n), flowable, atomicReference, n));
    }

    @Override
    public void connect(Consumer<? super Disposable> consumer) {
        PublishSubscriber<T> publishSubscriber;
        PublishSubscriber<T> publishSubscriber2;
        do {
            if ((publishSubscriber = this.current.get()) == null) continue;
            publishSubscriber2 = publishSubscriber;
            if (!publishSubscriber.isDisposed()) break;
        } while (!this.current.compareAndSet(publishSubscriber, publishSubscriber2 = new PublishSubscriber<T>(this.current, this.bufferSize)));
        boolean bl = publishSubscriber2.shouldConnect.get();
        boolean bl2 = true;
        if (bl || !publishSubscriber2.shouldConnect.compareAndSet(false, true)) {
            bl2 = false;
        }
        try {
            consumer.accept(publishSubscriber2);
            if (bl2) {
                this.source.subscribe(publishSubscriber2);
            }
            return;
        }
        catch (Throwable throwable) {
            Exceptions.throwIfFatal(throwable);
            throw ExceptionHelper.wrapOrThrow(throwable);
        }
    }

    @Override
    public Publisher<T> source() {
        return this.source;
    }

    @Override
    protected void subscribeActual(Subscriber<? super T> subscriber) {
        this.onSubscribe.subscribe(subscriber);
    }

    static final class FlowablePublisher<T>
    implements Publisher<T> {
        private final int bufferSize;
        private final AtomicReference<PublishSubscriber<T>> curr;

        FlowablePublisher(AtomicReference<PublishSubscriber<T>> atomicReference, int n) {
            this.curr = atomicReference;
            this.bufferSize = n;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        @Override
        public void subscribe(Subscriber<? super T> var1_1) {
            var3_2 = new InnerSubscriber<T>(var1_1);
            var1_1.onSubscribe(var3_2);
            do lbl-1000: // 3 sources:
            {
                if ((var2_3 = this.curr.get()) != null) {
                    var1_1 = var2_3;
                    if (!var2_3.isDisposed()) continue;
                }
                if (!this.curr.compareAndSet(var2_3, (PublishSubscriber<T>)(var1_1 = new PublishSubscriber<T>(this.curr, this.bufferSize)))) ** GOTO lbl-1000
            } while (!var1_1.add(var3_2));
            if (var3_2.get() == Long.MIN_VALUE) {
                var1_1.remove(var3_2);
            } else {
                var3_2.parent = var1_1;
            }
            var1_1.dispatch();
        }
    }

    static final class InnerSubscriber<T>
    extends AtomicLong
    implements Subscription {
        private static final long serialVersionUID = -4453897557930727610L;
        final Subscriber<? super T> child;
        volatile PublishSubscriber<T> parent;

        InnerSubscriber(Subscriber<? super T> subscriber) {
            this.child = subscriber;
        }

        public void cancel() {
            PublishSubscriber<T> publishSubscriber;
            if (this.get() != Long.MIN_VALUE && this.getAndSet(Long.MIN_VALUE) != Long.MIN_VALUE && (publishSubscriber = this.parent) != null) {
                publishSubscriber.remove(this);
                publishSubscriber.dispatch();
            }
        }

        public long produced(long l) {
            return BackpressureHelper.producedCancel(this, l);
        }

        public void request(long l) {
            if (SubscriptionHelper.validate(l)) {
                BackpressureHelper.addCancel(this, l);
                PublishSubscriber<T> publishSubscriber = this.parent;
                if (publishSubscriber != null) {
                    publishSubscriber.dispatch();
                }
            }
        }
    }

    static final class PublishSubscriber<T>
    extends AtomicInteger
    implements FlowableSubscriber<T>,
    Disposable {
        static final InnerSubscriber[] EMPTY = new InnerSubscriber[0];
        static final InnerSubscriber[] TERMINATED = new InnerSubscriber[0];
        private static final long serialVersionUID = -202316842419149694L;
        final int bufferSize;
        final AtomicReference<PublishSubscriber<T>> current;
        volatile SimpleQueue<T> queue;
        final AtomicReference<Subscription> s = new AtomicReference();
        final AtomicBoolean shouldConnect;
        int sourceMode;
        final AtomicReference<InnerSubscriber[]> subscribers = new AtomicReference<InnerSubscriber[]>(EMPTY);
        volatile Object terminalEvent;

        PublishSubscriber(AtomicReference<PublishSubscriber<T>> atomicReference, int n) {
            this.current = atomicReference;
            this.shouldConnect = new AtomicBoolean();
            this.bufferSize = n;
        }

        boolean add(InnerSubscriber<T> innerSubscriber) {
            InnerSubscriber[] arrinnerSubscriber;
            InnerSubscriber[] arrinnerSubscriber2;
            do {
                if ((arrinnerSubscriber = this.subscribers.get()) == TERMINATED) {
                    return false;
                }
                int n = arrinnerSubscriber.length;
                arrinnerSubscriber2 = new InnerSubscriber[n + 1];
                System.arraycopy(arrinnerSubscriber, 0, arrinnerSubscriber2, 0, n);
                arrinnerSubscriber2[n] = innerSubscriber;
            } while (!this.subscribers.compareAndSet(arrinnerSubscriber, arrinnerSubscriber2));
            return true;
        }

        boolean checkTerminated(Object arrinnerSubscriber, boolean bl) {
            int n = 0;
            if (arrinnerSubscriber != null) {
                int n2;
                if (NotificationLite.isComplete(arrinnerSubscriber)) {
                    if (bl) {
                        this.current.compareAndSet(this, null);
                        arrinnerSubscriber = this.subscribers.getAndSet(TERMINATED);
                        n = arrinnerSubscriber.length;
                        for (n2 = 0; n2 < n; ++n2) {
                            arrinnerSubscriber[n2].child.onComplete();
                        }
                        return true;
                    }
                } else {
                    arrinnerSubscriber = NotificationLite.getError(arrinnerSubscriber);
                    this.current.compareAndSet(this, null);
                    InnerSubscriber[] arrinnerSubscriber2 = this.subscribers.getAndSet(TERMINATED);
                    if (arrinnerSubscriber2.length != 0) {
                        int n3 = arrinnerSubscriber2.length;
                        for (n2 = n; n2 < n3; ++n2) {
                            arrinnerSubscriber2[n2].child.onError((Throwable)arrinnerSubscriber);
                        }
                    } else {
                        RxJavaPlugins.onError((Throwable)arrinnerSubscriber);
                    }
                    return true;
                }
            }
            return false;
        }

        void dispatch() {
            if (this.getAndIncrement() != 0) {
                return;
            }
            int n = 1;
            do {
                int n2;
                Object object = this.terminalEvent;
                SimpleQueue<T> simpleQueue = this.queue;
                boolean bl = simpleQueue == null || simpleQueue.isEmpty();
                if (this.checkTerminated(object, bl)) {
                    return;
                }
                if (!bl) {
                    long l;
                    InnerSubscriber[] arrinnerSubscriber = this.subscribers.get();
                    int n3 = arrinnerSubscriber.length;
                    int n4 = arrinnerSubscriber.length;
                    long l2 = Long.MAX_VALUE;
                    n2 = 0;
                    for (int i = 0; i < n4; ++i) {
                        int n5;
                        long l3 = arrinnerSubscriber[i].get();
                        if (l3 >= 0L) {
                            l = Math.min(l2, l3);
                            n5 = n2;
                        } else {
                            n5 = n2;
                            l = l2;
                            if (l3 == Long.MIN_VALUE) {
                                n5 = n2 + 1;
                                l = l2;
                            }
                        }
                        n2 = n5;
                        l2 = l;
                    }
                    if (n3 == n2) {
                        void var15_17;
                        object = this.terminalEvent;
                        try {
                            T t = simpleQueue.poll();
                        }
                        catch (Throwable throwable) {
                            Exceptions.throwIfFatal(throwable);
                            this.s.get().cancel();
                            this.terminalEvent = object = NotificationLite.error(throwable);
                            Object var15_16 = null;
                        }
                        bl = var15_17 == null;
                        if (this.checkTerminated(object, bl)) {
                            return;
                        }
                        if (this.sourceMode == 1) continue;
                        this.s.get().request(1L);
                        continue;
                    }
                    n2 = 0;
                    while ((l = (long)n2) < l2) {
                        void var15_20;
                        object = this.terminalEvent;
                        try {
                            T t = simpleQueue.poll();
                        }
                        catch (Throwable throwable) {
                            Exceptions.throwIfFatal(throwable);
                            this.s.get().cancel();
                            this.terminalEvent = object = NotificationLite.error(throwable);
                            Object var15_19 = null;
                        }
                        bl = var15_20 == null;
                        if (this.checkTerminated(object, bl)) {
                            return;
                        }
                        if (bl) break;
                        object = NotificationLite.getValue(var15_20);
                        for (InnerSubscriber innerSubscriber : arrinnerSubscriber) {
                            if (innerSubscriber.get() <= 0L) continue;
                            innerSubscriber.child.onNext(object);
                            innerSubscriber.produced(1L);
                        }
                        ++n2;
                    }
                    if (n2 > 0 && this.sourceMode != 1) {
                        this.s.get().request(l);
                    }
                    n2 = n;
                    if (l2 != 0L) {
                        n2 = n;
                        if (!bl) {
                            continue;
                        }
                    }
                } else {
                    n2 = n;
                }
                if ((n = this.addAndGet(- n2)) == 0) break;
            } while (true);
        }

        @Override
        public void dispose() {
            if (this.subscribers.get() != TERMINATED && this.subscribers.getAndSet(TERMINATED) != TERMINATED) {
                this.current.compareAndSet(this, null);
                SubscriptionHelper.cancel(this.s);
            }
        }

        @Override
        public boolean isDisposed() {
            if (this.subscribers.get() == TERMINATED) {
                return true;
            }
            return false;
        }

        public void onComplete() {
            if (this.terminalEvent == null) {
                this.terminalEvent = NotificationLite.complete();
                this.dispatch();
            }
        }

        public void onError(Throwable throwable) {
            if (this.terminalEvent == null) {
                this.terminalEvent = NotificationLite.error(throwable);
                this.dispatch();
                return;
            }
            RxJavaPlugins.onError(throwable);
        }

        public void onNext(T t) {
            if (this.sourceMode == 0 && !this.queue.offer(t)) {
                this.onError(new MissingBackpressureException("Prefetch queue is full?!"));
                return;
            }
            this.dispatch();
        }

        @Override
        public void onSubscribe(Subscription subscription) {
            if (SubscriptionHelper.setOnce(this.s, subscription)) {
                if (subscription instanceof QueueSubscription) {
                    QueueSubscription queueSubscription = (QueueSubscription)subscription;
                    int n = queueSubscription.requestFusion(3);
                    if (n == 1) {
                        this.sourceMode = n;
                        this.queue = queueSubscription;
                        this.terminalEvent = NotificationLite.complete();
                        this.dispatch();
                        return;
                    }
                    if (n == 2) {
                        this.sourceMode = n;
                        this.queue = queueSubscription;
                        subscription.request((long)this.bufferSize);
                        return;
                    }
                }
                this.queue = new SpscArrayQueue<T>(this.bufferSize);
                subscription.request((long)this.bufferSize);
            }
        }

        void remove(InnerSubscriber<T> innerSubscriber) {
            InnerSubscriber[] arrinnerSubscriber;
            InnerSubscriber[] arrinnerSubscriber2;
            do {
                int n;
                int n2;
                if ((n2 = (arrinnerSubscriber2 = this.subscribers.get()).length) == 0) {
                    return;
                }
                int n3 = -1;
                int n4 = 0;
                do {
                    n = n3;
                    if (n4 >= n2) break;
                    if (arrinnerSubscriber2[n4].equals(innerSubscriber)) {
                        n = n4;
                        break;
                    }
                    ++n4;
                } while (true);
                if (n < 0) {
                    return;
                }
                if (n2 == 1) {
                    arrinnerSubscriber = EMPTY;
                    continue;
                }
                arrinnerSubscriber = new InnerSubscriber[n2 - 1];
                System.arraycopy(arrinnerSubscriber2, 0, arrinnerSubscriber, 0, n);
                System.arraycopy(arrinnerSubscriber2, n + 1, arrinnerSubscriber, n, n2 - n - 1);
            } while (!this.subscribers.compareAndSet(arrinnerSubscriber2, arrinnerSubscriber));
        }
    }

}

