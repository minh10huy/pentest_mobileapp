/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.operators.observable;

import io.reactivex.Observable;
import io.reactivex.ObservableSource;
import io.reactivex.Observer;
import io.reactivex.Scheduler;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.functions.Consumer;
import io.reactivex.functions.Function;
import io.reactivex.internal.disposables.DisposableHelper;
import io.reactivex.internal.disposables.EmptyDisposable;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.fuseable.HasUpstreamObservableSource;
import io.reactivex.internal.operators.observable.ObserverResourceWrapper;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.internal.util.NotificationLite;
import io.reactivex.observables.ConnectableObservable;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.schedulers.Timed;
import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.Callable;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public final class ObservableReplay<T>
extends ConnectableObservable<T>
implements HasUpstreamObservableSource<T>,
Disposable {
    static final BufferSupplier DEFAULT_UNBOUNDED_FACTORY = new UnBoundedFactory();
    final BufferSupplier<T> bufferFactory;
    final AtomicReference<ReplayObserver<T>> current;
    final ObservableSource<T> onSubscribe;
    final ObservableSource<T> source;

    private ObservableReplay(ObservableSource<T> observableSource, ObservableSource<T> observableSource2, AtomicReference<ReplayObserver<T>> atomicReference, BufferSupplier<T> bufferSupplier) {
        this.onSubscribe = observableSource;
        this.source = observableSource2;
        this.current = atomicReference;
        this.bufferFactory = bufferSupplier;
    }

    public static <T> ConnectableObservable<T> create(ObservableSource<T> observableSource, int n) {
        if (n == Integer.MAX_VALUE) {
            return ObservableReplay.createFrom(observableSource);
        }
        return ObservableReplay.create(observableSource, new ReplayBufferSupplier(n));
    }

    public static <T> ConnectableObservable<T> create(ObservableSource<T> observableSource, long l, TimeUnit timeUnit, Scheduler scheduler) {
        return ObservableReplay.create(observableSource, l, timeUnit, scheduler, Integer.MAX_VALUE);
    }

    public static <T> ConnectableObservable<T> create(ObservableSource<T> observableSource, long l, TimeUnit timeUnit, Scheduler scheduler, int n) {
        return ObservableReplay.create(observableSource, new ScheduledReplaySupplier(n, l, timeUnit, scheduler));
    }

    static <T> ConnectableObservable<T> create(ObservableSource<T> observableSource, BufferSupplier<T> bufferSupplier) {
        AtomicReference atomicReference = new AtomicReference();
        return RxJavaPlugins.onAssembly(new ObservableReplay(new ReplaySource(atomicReference, bufferSupplier), observableSource, atomicReference, bufferSupplier));
    }

    public static <T> ConnectableObservable<T> createFrom(ObservableSource<? extends T> observableSource) {
        return ObservableReplay.create(observableSource, DEFAULT_UNBOUNDED_FACTORY);
    }

    public static <U, R> Observable<R> multicastSelector(Callable<? extends ConnectableObservable<U>> callable, Function<? super Observable<U>, ? extends ObservableSource<R>> function) {
        return RxJavaPlugins.onAssembly(new MulticastReplay(callable, function));
    }

    public static <T> ConnectableObservable<T> observeOn(ConnectableObservable<T> connectableObservable, Scheduler scheduler) {
        return RxJavaPlugins.onAssembly(new Replay<T>(connectableObservable, connectableObservable.observeOn(scheduler)));
    }

    @Override
    public void connect(Consumer<? super Disposable> consumer) {
        ReplayObserver<T> replayObserver;
        ReplayObserver<T> replayObserver2;
        do {
            if ((replayObserver = this.current.get()) == null) continue;
            replayObserver2 = replayObserver;
            if (!replayObserver.isDisposed()) break;
        } while (!this.current.compareAndSet(replayObserver, replayObserver2 = new ReplayObserver<T>(this.bufferFactory.call())));
        boolean bl = !replayObserver2.shouldConnect.get() && replayObserver2.shouldConnect.compareAndSet(false, true);
        try {
            consumer.accept(replayObserver2);
            if (bl) {
                this.source.subscribe(replayObserver2);
            }
            return;
        }
        catch (Throwable throwable) {
            if (bl) {
                replayObserver2.shouldConnect.compareAndSet(true, false);
            }
            Exceptions.throwIfFatal(throwable);
            throw ExceptionHelper.wrapOrThrow(throwable);
        }
    }

    @Override
    public void dispose() {
        this.current.lazySet(null);
    }

    @Override
    public boolean isDisposed() {
        Disposable disposable = this.current.get();
        if (disposable != null && !disposable.isDisposed()) {
            return false;
        }
        return true;
    }

    @Override
    public ObservableSource<T> source() {
        return this.source;
    }

    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        this.onSubscribe.subscribe(observer);
    }

    static abstract class BoundedReplayBuffer<T>
    extends AtomicReference<Node>
    implements ReplayBuffer<T> {
        private static final long serialVersionUID = 2346567790059478686L;
        int size;
        Node tail;

        BoundedReplayBuffer() {
            Node node;
            this.tail = node = new Node(null);
            this.set(node);
        }

        final void addLast(Node node) {
            this.tail.set(node);
            this.tail = node;
            ++this.size;
        }

        final void collect(Collection<? super T> collection) {
            Object object;
            Node node = this.getHead();
            while ((node = (Node)node.get()) != null && !NotificationLite.isComplete(object = this.leaveTransform(node.value))) {
                if (NotificationLite.isError(object)) {
                    return;
                }
                collection.add(NotificationLite.getValue(object));
            }
        }

        @Override
        public final void complete() {
            this.addLast(new Node(this.enterTransform(NotificationLite.complete())));
            this.truncateFinal();
        }

        Object enterTransform(Object object) {
            return object;
        }

        @Override
        public final void error(Throwable throwable) {
            this.addLast(new Node(this.enterTransform(NotificationLite.error(throwable))));
            this.truncateFinal();
        }

        Node getHead() {
            return (Node)this.get();
        }

        boolean hasCompleted() {
            if (this.tail.value != null && NotificationLite.isComplete(this.leaveTransform(this.tail.value))) {
                return true;
            }
            return false;
        }

        boolean hasError() {
            if (this.tail.value != null && NotificationLite.isError(this.leaveTransform(this.tail.value))) {
                return true;
            }
            return false;
        }

        Object leaveTransform(Object object) {
            return object;
        }

        @Override
        public final void next(T t) {
            this.addLast(new Node(this.enterTransform(NotificationLite.next(t))));
            this.truncate();
        }

        final void removeFirst() {
            Node node = (Node)((Node)this.get()).get();
            --this.size;
            this.setFirst(node);
        }

        final void removeSome(int n) {
            Node node = (Node)this.get();
            while (n > 0) {
                node = (Node)node.get();
                --n;
                --this.size;
            }
            this.setFirst(node);
        }

        @Override
        public final void replay(InnerDisposable<T> innerDisposable) {
            int n;
            if (innerDisposable.getAndIncrement() != 0) {
                return;
            }
            int n2 = 1;
            do {
                Node node;
                Node node2 = node = (Node)innerDisposable.index();
                if (node == null) {
                    node2 = this.getHead();
                    innerDisposable.index = node2;
                }
                do {
                    if (innerDisposable.isDisposed()) {
                        return;
                    }
                    node = (Node)node2.get();
                    if (node == null) break;
                    if (NotificationLite.accept(this.leaveTransform(node.value), innerDisposable.child)) {
                        innerDisposable.index = null;
                        return;
                    }
                    node2 = node;
                } while (true);
                innerDisposable.index = node2;
                n2 = n = innerDisposable.addAndGet(- n2);
            } while (n != 0);
        }

        final void setFirst(Node node) {
            this.set(node);
        }

        abstract void truncate();

        void truncateFinal() {
        }
    }

    static interface BufferSupplier<T> {
        public ReplayBuffer<T> call();
    }

    static final class DisposeConsumer<R>
    implements Consumer<Disposable> {
        private final ObserverResourceWrapper<R> srw;

        DisposeConsumer(ObserverResourceWrapper<R> observerResourceWrapper) {
            this.srw = observerResourceWrapper;
        }

        @Override
        public void accept(Disposable disposable) {
            this.srw.setResource(disposable);
        }
    }

    static final class InnerDisposable<T>
    extends AtomicInteger
    implements Disposable {
        private static final long serialVersionUID = 2728361546769921047L;
        volatile boolean cancelled;
        final Observer<? super T> child;
        Object index;
        final ReplayObserver<T> parent;

        InnerDisposable(ReplayObserver<T> replayObserver, Observer<? super T> observer) {
            this.parent = replayObserver;
            this.child = observer;
        }

        @Override
        public void dispose() {
            if (!this.cancelled) {
                this.cancelled = true;
                this.parent.remove(this);
            }
        }

        <U> U index() {
            return (U)this.index;
        }

        @Override
        public boolean isDisposed() {
            return this.cancelled;
        }
    }

    static final class MulticastReplay<R, U>
    extends Observable<R> {
        private final Callable<? extends ConnectableObservable<U>> connectableFactory;
        private final Function<? super Observable<U>, ? extends ObservableSource<R>> selector;

        MulticastReplay(Callable<? extends ConnectableObservable<U>> callable, Function<? super Observable<U>, ? extends ObservableSource<R>> function) {
            this.connectableFactory = callable;
            this.selector = function;
        }

        @Override
        protected void subscribeActual(Observer<? super R> observer) {
            try {
                ConnectableObservable<U> connectableObservable = ObjectHelper.requireNonNull(this.connectableFactory.call(), "The connectableFactory returned a null ConnectableObservable");
                ObservableSource<R> observableSource = ObjectHelper.requireNonNull(this.selector.apply(connectableObservable), "The selector returned a null ObservableSource");
                observer = new ObserverResourceWrapper<R>(observer);
                observableSource.subscribe(observer);
                connectableObservable.connect(new DisposeConsumer<R>((ObserverResourceWrapper<? super R>)observer));
                return;
            }
            catch (Throwable throwable) {
                Exceptions.throwIfFatal(throwable);
                EmptyDisposable.error(throwable, observer);
                return;
            }
        }
    }

    static final class Node
    extends AtomicReference<Node> {
        private static final long serialVersionUID = 245354315435971818L;
        final Object value;

        Node(Object object) {
            this.value = object;
        }
    }

    static final class Replay<T>
    extends ConnectableObservable<T> {
        private final ConnectableObservable<T> co;
        private final Observable<T> observable;

        Replay(ConnectableObservable<T> connectableObservable, Observable<T> observable) {
            this.co = connectableObservable;
            this.observable = observable;
        }

        @Override
        public void connect(Consumer<? super Disposable> consumer) {
            this.co.connect(consumer);
        }

        @Override
        protected void subscribeActual(Observer<? super T> observer) {
            this.observable.subscribe(observer);
        }
    }

    static interface ReplayBuffer<T> {
        public void complete();

        public void error(Throwable var1);

        public void next(T var1);

        public void replay(InnerDisposable<T> var1);
    }

    static final class ReplayBufferSupplier<T>
    implements BufferSupplier<T> {
        private final int bufferSize;

        ReplayBufferSupplier(int n) {
            this.bufferSize = n;
        }

        @Override
        public ReplayBuffer<T> call() {
            return new SizeBoundReplayBuffer(this.bufferSize);
        }
    }

    static final class ReplayObserver<T>
    extends AtomicReference<Disposable>
    implements Observer<T>,
    Disposable {
        static final InnerDisposable[] EMPTY = new InnerDisposable[0];
        static final InnerDisposable[] TERMINATED = new InnerDisposable[0];
        private static final long serialVersionUID = -533785617179540163L;
        final ReplayBuffer<T> buffer;
        boolean done;
        final AtomicReference<InnerDisposable[]> observers;
        final AtomicBoolean shouldConnect;

        ReplayObserver(ReplayBuffer<T> replayBuffer) {
            this.buffer = replayBuffer;
            this.observers = new AtomicReference<InnerDisposable[]>(EMPTY);
            this.shouldConnect = new AtomicBoolean();
        }

        boolean add(InnerDisposable<T> innerDisposable) {
            InnerDisposable[] arrinnerDisposable;
            InnerDisposable[] arrinnerDisposable2;
            do {
                if ((arrinnerDisposable = this.observers.get()) == TERMINATED) {
                    return false;
                }
                int n = arrinnerDisposable.length;
                arrinnerDisposable2 = new InnerDisposable[n + 1];
                System.arraycopy(arrinnerDisposable, 0, arrinnerDisposable2, 0, n);
                arrinnerDisposable2[n] = innerDisposable;
            } while (!this.observers.compareAndSet(arrinnerDisposable, arrinnerDisposable2));
            return true;
        }

        @Override
        public void dispose() {
            this.observers.set(TERMINATED);
            DisposableHelper.dispose(this);
        }

        @Override
        public boolean isDisposed() {
            if (this.observers.get() == TERMINATED) {
                return true;
            }
            return false;
        }

        @Override
        public void onComplete() {
            if (!this.done) {
                this.done = true;
                this.buffer.complete();
                this.replayFinal();
            }
        }

        @Override
        public void onError(Throwable throwable) {
            if (!this.done) {
                this.done = true;
                this.buffer.error(throwable);
                this.replayFinal();
                return;
            }
            RxJavaPlugins.onError(throwable);
        }

        @Override
        public void onNext(T t) {
            if (!this.done) {
                this.buffer.next(t);
                this.replay();
            }
        }

        @Override
        public void onSubscribe(Disposable disposable) {
            if (DisposableHelper.setOnce(this, disposable)) {
                this.replay();
            }
        }

        void remove(InnerDisposable<T> innerDisposable) {
            InnerDisposable[] arrinnerDisposable;
            InnerDisposable[] arrinnerDisposable2;
            do {
                int n;
                int n2;
                if ((n2 = (arrinnerDisposable2 = this.observers.get()).length) == 0) {
                    return;
                }
                int n3 = -1;
                int n4 = 0;
                do {
                    n = n3;
                    if (n4 >= n2) break;
                    if (arrinnerDisposable2[n4].equals(innerDisposable)) {
                        n = n4;
                        break;
                    }
                    ++n4;
                } while (true);
                if (n < 0) {
                    return;
                }
                if (n2 == 1) {
                    arrinnerDisposable = EMPTY;
                    continue;
                }
                arrinnerDisposable = new InnerDisposable[n2 - 1];
                System.arraycopy(arrinnerDisposable2, 0, arrinnerDisposable, 0, n);
                System.arraycopy(arrinnerDisposable2, n + 1, arrinnerDisposable, n, n2 - n - 1);
            } while (!this.observers.compareAndSet(arrinnerDisposable2, arrinnerDisposable));
        }

        void replay() {
            for (InnerDisposable innerDisposable : this.observers.get()) {
                this.buffer.replay(innerDisposable);
            }
        }

        void replayFinal() {
            for (InnerDisposable innerDisposable : this.observers.getAndSet(TERMINATED)) {
                this.buffer.replay(innerDisposable);
            }
        }
    }

    static final class ReplaySource<T>
    implements ObservableSource<T> {
        private final BufferSupplier<T> bufferFactory;
        private final AtomicReference<ReplayObserver<T>> curr;

        ReplaySource(AtomicReference<ReplayObserver<T>> atomicReference, BufferSupplier<T> bufferSupplier) {
            this.curr = atomicReference;
            this.bufferFactory = bufferSupplier;
        }

        @Override
        public void subscribe(Observer<? super T> observer) {
            ReplayObserver<T> replayObserver;
            Disposable disposable;
            do {
                disposable = this.curr.get();
                replayObserver = disposable;
            } while (disposable == null && !this.curr.compareAndSet(null, replayObserver = new ReplayObserver<T>(this.bufferFactory.call())));
            disposable = new InnerDisposable<T>(replayObserver, observer);
            observer.onSubscribe(disposable);
            replayObserver.add((InnerDisposable<T>)disposable);
            if (disposable.isDisposed()) {
                replayObserver.remove((InnerDisposable<T>)disposable);
                return;
            }
            replayObserver.buffer.replay(disposable);
        }
    }

    static final class ScheduledReplaySupplier<T>
    implements BufferSupplier<T> {
        private final int bufferSize;
        private final long maxAge;
        private final Scheduler scheduler;
        private final TimeUnit unit;

        ScheduledReplaySupplier(int n, long l, TimeUnit timeUnit, Scheduler scheduler) {
            this.bufferSize = n;
            this.maxAge = l;
            this.unit = timeUnit;
            this.scheduler = scheduler;
        }

        @Override
        public ReplayBuffer<T> call() {
            return new SizeAndTimeBoundReplayBuffer(this.bufferSize, this.maxAge, this.unit, this.scheduler);
        }
    }

    static final class SizeAndTimeBoundReplayBuffer<T>
    extends BoundedReplayBuffer<T> {
        private static final long serialVersionUID = 3457957419649567404L;
        final int limit;
        final long maxAge;
        final Scheduler scheduler;
        final TimeUnit unit;

        SizeAndTimeBoundReplayBuffer(int n, long l, TimeUnit timeUnit, Scheduler scheduler) {
            this.scheduler = scheduler;
            this.limit = n;
            this.maxAge = l;
            this.unit = timeUnit;
        }

        @Override
        Object enterTransform(Object object) {
            return new Timed<Object>(object, this.scheduler.now(this.unit), this.unit);
        }

        @Override
        Node getHead() {
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            Node node = (Node)this.get();
            Object object = (Node)node.get();
            do {
                if (object == null) {
                    return node;
                }
                Object object2 = (Timed)object.value;
                if (NotificationLite.isComplete(object2.value())) break;
                if (NotificationLite.isError(object2.value())) {
                    return node;
                }
                if (object2.time() > l - l2) break;
                object2 = (Node)object.get();
                node = object;
                object = object2;
            } while (true);
            return node;
        }

        @Override
        Object leaveTransform(Object object) {
            return ((Timed)object).value();
        }

        @Override
        void truncate() {
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            Node node = (Node)this.get();
            Node node2 = (Node)node.get();
            int n = 0;
            while (node2 != null) {
                Node node3;
                if (this.size > this.limit) {
                    ++n;
                    --this.size;
                    node3 = (Node)node2.get();
                    node = node2;
                    node2 = node3;
                    continue;
                }
                if (((Timed)node2.value).time() > l - l2) break;
                ++n;
                --this.size;
                node3 = (Node)node2.get();
                node = node2;
                node2 = node3;
            }
            if (n != 0) {
                this.setFirst(node);
            }
        }

        @Override
        void truncateFinal() {
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            Node node = (Node)this.get();
            Node node2 = (Node)node.get();
            int n = 0;
            while (node2 != null && this.size > 1 && ((Timed)node2.value).time() <= l - l2) {
                ++n;
                --this.size;
                Node node3 = (Node)node2.get();
                node = node2;
                node2 = node3;
            }
            if (n != 0) {
                this.setFirst(node);
            }
        }
    }

    static final class SizeBoundReplayBuffer<T>
    extends BoundedReplayBuffer<T> {
        private static final long serialVersionUID = -5898283885385201806L;
        final int limit;

        SizeBoundReplayBuffer(int n) {
            this.limit = n;
        }

        @Override
        void truncate() {
            if (this.size > this.limit) {
                this.removeFirst();
            }
        }
    }

    static final class UnBoundedFactory
    implements BufferSupplier<Object> {
        UnBoundedFactory() {
        }

        @Override
        public ReplayBuffer<Object> call() {
            return new UnboundedReplayBuffer<Object>(16);
        }
    }

    static final class UnboundedReplayBuffer<T>
    extends ArrayList<Object>
    implements ReplayBuffer<T> {
        private static final long serialVersionUID = 7063189396499112664L;
        volatile int size;

        UnboundedReplayBuffer(int n) {
            super(n);
        }

        @Override
        public void complete() {
            this.add(NotificationLite.complete());
            ++this.size;
        }

        @Override
        public void error(Throwable throwable) {
            this.add(NotificationLite.error(throwable));
            ++this.size;
        }

        @Override
        public void next(T t) {
            this.add(NotificationLite.next(t));
            ++this.size;
        }

        @Override
        public void replay(InnerDisposable<T> innerDisposable) {
            int n;
            if (innerDisposable.getAndIncrement() != 0) {
                return;
            }
            Observer observer = innerDisposable.child;
            int n2 = 1;
            do {
                if (innerDisposable.isDisposed()) {
                    return;
                }
                int n3 = this.size;
                Integer n4 = (Integer)innerDisposable.index();
                n = n4 != null ? n4 : 0;
                while (n < n3) {
                    if (NotificationLite.accept(this.get(n), observer)) {
                        return;
                    }
                    if (innerDisposable.isDisposed()) {
                        return;
                    }
                    ++n;
                }
                innerDisposable.index = n;
                n2 = n = innerDisposable.addAndGet(- n2);
            } while (n != 0);
        }
    }

}

