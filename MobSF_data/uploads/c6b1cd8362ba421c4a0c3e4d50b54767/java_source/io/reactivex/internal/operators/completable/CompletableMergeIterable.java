/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.operators.completable;

import io.reactivex.Completable;
import io.reactivex.CompletableObserver;
import io.reactivex.CompletableSource;
import io.reactivex.disposables.CompositeDisposable;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.Exceptions;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.plugins.RxJavaPlugins;
import java.util.Iterator;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

public final class CompletableMergeIterable
extends Completable {
    final Iterable<? extends CompletableSource> sources;

    public CompletableMergeIterable(Iterable<? extends CompletableSource> iterable) {
        this.sources = iterable;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    @Override
    public void subscribeActual(CompletableObserver var1_1) {
        var3_2 = new CompositeDisposable();
        var1_1.onSubscribe(var3_2);
        try {
            var4_4 = ObjectHelper.requireNonNull(this.sources.iterator(), "The source iterator returned is null");
            var5_7 = new AtomicInteger(1);
            var1_1 = new MergeCompletableObserver(var1_1, var3_2, var5_7);
        }
        catch (Throwable var3_3) {
            Exceptions.throwIfFatal(var3_3);
            var1_1.onError(var3_3);
            return;
        }
        do lbl-1000: // 2 sources:
        {
            if (var3_2.isDisposed()) {
                return;
            }
            var2_8 = var4_4.hasNext();
            if (!var2_8) {
                var1_1.onComplete();
                return;
            }
            if (!var3_2.isDisposed()) ** break block10
            return;
            break;
        } while (true);
        catch (Throwable var4_6) {
            Exceptions.throwIfFatal(var4_6);
            var3_2.dispose();
            var1_1.onError(var4_6);
            return;
        }
        {
            
            try {
                var6_9 = ObjectHelper.requireNonNull(var4_4.next(), "The iterator returned a null CompletableSource");
                if (var3_2.isDisposed()) {
                    return;
                }
                var5_7.getAndIncrement();
                var6_9.subscribe(var1_1);
                continue;
            }
            catch (Throwable var4_5) {
                Exceptions.throwIfFatal(var4_5);
                var3_2.dispose();
                var1_1.onError(var4_5);
                return;
            }
            ** while (true)
        }
    }

    static final class MergeCompletableObserver
    extends AtomicBoolean
    implements CompletableObserver {
        private static final long serialVersionUID = -7730517613164279224L;
        final CompletableObserver actual;
        final CompositeDisposable set;
        final AtomicInteger wip;

        MergeCompletableObserver(CompletableObserver completableObserver, CompositeDisposable compositeDisposable, AtomicInteger atomicInteger) {
            this.actual = completableObserver;
            this.set = compositeDisposable;
            this.wip = atomicInteger;
        }

        @Override
        public void onComplete() {
            if (this.wip.decrementAndGet() == 0 && this.compareAndSet(false, true)) {
                this.actual.onComplete();
            }
        }

        @Override
        public void onError(Throwable throwable) {
            this.set.dispose();
            if (this.compareAndSet(false, true)) {
                this.actual.onError(throwable);
                return;
            }
            RxJavaPlugins.onError(throwable);
        }

        @Override
        public void onSubscribe(Disposable disposable) {
            this.set.add(disposable);
        }
    }

}

