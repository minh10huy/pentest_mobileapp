/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.internal.util;

import io.reactivex.internal.util.Pow2;

public final class OpenHashSet<T> {
    private static final int INT_PHI = -1640531527;
    T[] keys;
    final float loadFactor;
    int mask;
    int maxSize;
    int size;

    public OpenHashSet() {
        this(16, 0.75f);
    }

    public OpenHashSet(int n) {
        this(n, 0.75f);
    }

    public OpenHashSet(int n, float f) {
        this.loadFactor = f;
        n = Pow2.roundToPowerOfTwo(n);
        this.mask = n - 1;
        this.maxSize = (int)(f * (float)n);
        this.keys = new Object[n];
    }

    static int mix(int n) {
        return n ^ (n *= -1640531527) >>> 16;
    }

    public boolean add(T t) {
        int n;
        block4 : {
            T[] arrT = this.keys;
            int n2 = this.mask;
            n = OpenHashSet.mix(t.hashCode()) & n2;
            T t2 = arrT[n];
            int n3 = n;
            if (t2 != null) {
                if (t2.equals(t)) {
                    return false;
                }
                do {
                    if ((t2 = arrT[n = n + 1 & n2]) != null) continue;
                    n3 = n;
                    break block4;
                } while (!t2.equals(t));
                return false;
            }
        }
        arrT[n3] = t;
        this.size = n = this.size + 1;
        if (n >= this.maxSize) {
            this.rehash();
        }
        return true;
    }

    public Object[] keys() {
        return this.keys;
    }

    void rehash() {
        T[] arrT = this.keys;
        int n = arrT.length;
        int n2 = n << 1;
        int n3 = n2 - 1;
        Object[] arrobject = new Object[n2];
        for (int i = this.size; i != 0; --i) {
            int n4;
            while (arrT[--n] == null) {
            }
            int n5 = n4 = OpenHashSet.mix(arrT[n].hashCode()) & n3;
            if (arrobject[n4] != null) {
                do {
                    n4 = n5 = n4 + 1 & n3;
                } while (arrobject[n5] != null);
            }
            arrobject[n5] = arrT[n];
        }
        this.mask = n3;
        this.maxSize = (int)((float)n2 * this.loadFactor);
        this.keys = arrobject;
    }

    public boolean remove(T t) {
        T[] arrT = this.keys;
        int n = this.mask;
        int n2 = OpenHashSet.mix(t.hashCode()) & n;
        T t2 = arrT[n2];
        if (t2 == null) {
            return false;
        }
        int n3 = n2;
        if (t2.equals(t)) {
            return this.removeEntry(n2, arrT, n);
        }
        do {
            if ((t2 = arrT[n2 = n3 + 1 & n]) == null) {
                return false;
            }
            n3 = n2;
        } while (!t2.equals(t));
        return this.removeEntry(n2, arrT, n);
    }

    boolean removeEntry(int n, T[] arrT, int n2) {
        --this.size;
        int n3 = n;
        block0 : do {
            n = n3 + 1 & n2;
            do {
                T t;
                if ((t = arrT[n]) == null) {
                    arrT[n3] = null;
                    return true;
                }
                int n4 = OpenHashSet.mix(t.hashCode()) & n2;
                if (n3 <= n ? n3 >= n4 || n4 > n : n3 >= n4 && n4 > n) {
                    arrT[n3] = t;
                    n3 = n;
                    continue block0;
                }
                n = n + 1 & n2;
            } while (true);
            break;
        } while (true);
    }

    public int size() {
        return this.size;
    }
}

