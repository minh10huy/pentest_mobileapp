/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.subjects;

import io.reactivex.Observer;
import io.reactivex.annotations.CheckReturnValue;
import io.reactivex.disposables.Disposable;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.subjects.Subject;
import java.io.Serializable;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public final class PublishSubject<T>
extends Subject<T> {
    static final PublishDisposable[] EMPTY;
    static final PublishDisposable[] TERMINATED;
    Throwable error;
    final AtomicReference<PublishDisposable<T>[]> subscribers = new AtomicReference<PublishDisposable[]>(EMPTY);

    static {
        TERMINATED = new PublishDisposable[0];
        EMPTY = new PublishDisposable[0];
    }

    PublishSubject() {
    }

    @CheckReturnValue
    public static <T> PublishSubject<T> create() {
        return new PublishSubject<T>();
    }

    boolean add(PublishDisposable<T> publishDisposable) {
        PublishDisposable[] arrpublishDisposable;
        PublishDisposable<T>[] arrpublishDisposable2;
        do {
            if ((arrpublishDisposable2 = this.subscribers.get()) == TERMINATED) {
                return false;
            }
            int n = arrpublishDisposable2.length;
            arrpublishDisposable = new PublishDisposable[n + 1];
            System.arraycopy(arrpublishDisposable2, 0, arrpublishDisposable, 0, n);
            arrpublishDisposable[n] = publishDisposable;
        } while (!this.subscribers.compareAndSet(arrpublishDisposable2, arrpublishDisposable));
        return true;
    }

    @Override
    public Throwable getThrowable() {
        if (this.subscribers.get() == TERMINATED) {
            return this.error;
        }
        return null;
    }

    @Override
    public boolean hasComplete() {
        if (this.subscribers.get() == TERMINATED && this.error == null) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasObservers() {
        if (this.subscribers.get().length != 0) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasThrowable() {
        if (this.subscribers.get() == TERMINATED && this.error != null) {
            return true;
        }
        return false;
    }

    @Override
    public void onComplete() {
        if (this.subscribers.get() == TERMINATED) {
            return;
        }
        PublishDisposable[] arrpublishDisposable = this.subscribers.getAndSet(TERMINATED);
        int n = arrpublishDisposable.length;
        for (int i = 0; i < n; ++i) {
            arrpublishDisposable[i].onComplete();
        }
    }

    @Override
    public void onError(Throwable arrpublishDisposable) {
        if (this.subscribers.get() == TERMINATED) {
            RxJavaPlugins.onError((Throwable)arrpublishDisposable);
            return;
        }
        PublishDisposable[] arrpublishDisposable2 = arrpublishDisposable;
        if (arrpublishDisposable == null) {
            arrpublishDisposable2 = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
        }
        this.error = arrpublishDisposable2;
        arrpublishDisposable = this.subscribers.getAndSet(TERMINATED);
        int n = arrpublishDisposable.length;
        for (int i = 0; i < n; ++i) {
            arrpublishDisposable[i].onError((Throwable)arrpublishDisposable2);
        }
    }

    @Override
    public void onNext(T t) {
        if (this.subscribers.get() == TERMINATED) {
            return;
        }
        if (t == null) {
            this.onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
            return;
        }
        PublishDisposable<T>[] arrpublishDisposable = this.subscribers.get();
        int n = arrpublishDisposable.length;
        for (int i = 0; i < n; ++i) {
            arrpublishDisposable[i].onNext(t);
        }
    }

    @Override
    public void onSubscribe(Disposable disposable) {
        if (this.subscribers.get() == TERMINATED) {
            disposable.dispose();
        }
    }

    void remove(PublishDisposable<T> publishDisposable) {
        PublishDisposable<T>[] arrpublishDisposable;
        while ((arrpublishDisposable = this.subscribers.get()) != TERMINATED) {
            int n;
            PublishDisposable[] arrpublishDisposable2;
            if (arrpublishDisposable == EMPTY) {
                return;
            }
            int n2 = arrpublishDisposable.length;
            int n3 = -1;
            int n4 = 0;
            do {
                n = n3;
                if (n4 >= n2) break;
                if (arrpublishDisposable[n4] == publishDisposable) {
                    n = n4;
                    break;
                }
                ++n4;
            } while (true);
            if (n < 0) {
                return;
            }
            if (n2 == 1) {
                arrpublishDisposable2 = EMPTY;
            } else {
                arrpublishDisposable2 = new PublishDisposable[n2 - 1];
                System.arraycopy(arrpublishDisposable, 0, arrpublishDisposable2, 0, n);
                System.arraycopy(arrpublishDisposable, n + 1, arrpublishDisposable2, n, n2 - n - 1);
            }
            if (!this.subscribers.compareAndSet(arrpublishDisposable, arrpublishDisposable2)) continue;
            return;
        }
    }

    @Override
    public void subscribeActual(Observer<? super T> observer) {
        Serializable serializable = new PublishDisposable<T>(observer, this);
        observer.onSubscribe((Disposable)((Object)serializable));
        if (this.add((PublishDisposable<T>)serializable)) {
            if (serializable.isDisposed()) {
                this.remove((PublishDisposable<T>)serializable);
                return;
            }
        } else {
            serializable = this.error;
            if (serializable != null) {
                observer.onError((Throwable)serializable);
                return;
            }
            observer.onComplete();
        }
    }

    static final class PublishDisposable<T>
    extends AtomicBoolean
    implements Disposable {
        private static final long serialVersionUID = 3562861878281475070L;
        final Observer<? super T> actual;
        final PublishSubject<T> parent;

        PublishDisposable(Observer<? super T> observer, PublishSubject<T> publishSubject) {
            this.actual = observer;
            this.parent = publishSubject;
        }

        @Override
        public void dispose() {
            if (this.compareAndSet(false, true)) {
                this.parent.remove(this);
            }
        }

        @Override
        public boolean isDisposed() {
            return this.get();
        }

        public void onComplete() {
            if (!this.get()) {
                this.actual.onComplete();
            }
        }

        public void onError(Throwable throwable) {
            if (this.get()) {
                RxJavaPlugins.onError(throwable);
                return;
            }
            this.actual.onError(throwable);
        }

        public void onNext(T t) {
            if (!this.get()) {
                this.actual.onNext(t);
            }
        }
    }

}

