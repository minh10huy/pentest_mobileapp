/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.subjects;

import io.reactivex.Observer;
import io.reactivex.Scheduler;
import io.reactivex.annotations.CheckReturnValue;
import io.reactivex.disposables.Disposable;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.util.NotificationLite;
import io.reactivex.plugins.RxJavaPlugins;
import io.reactivex.subjects.Subject;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;

public final class ReplaySubject<T>
extends Subject<T> {
    static final ReplayDisposable[] EMPTY = new ReplayDisposable[0];
    private static final Object[] EMPTY_ARRAY;
    static final ReplayDisposable[] TERMINATED;
    final ReplayBuffer<T> buffer;
    boolean done;
    final AtomicReference<ReplayDisposable<T>[]> observers;

    static {
        TERMINATED = new ReplayDisposable[0];
        EMPTY_ARRAY = new Object[0];
    }

    ReplaySubject(ReplayBuffer<T> replayBuffer) {
        this.buffer = replayBuffer;
        this.observers = new AtomicReference<ReplayDisposable[]>(EMPTY);
    }

    @CheckReturnValue
    public static <T> ReplaySubject<T> create() {
        return new ReplaySubject(new UnboundedReplayBuffer(16));
    }

    @CheckReturnValue
    public static <T> ReplaySubject<T> create(int n) {
        return new ReplaySubject(new UnboundedReplayBuffer(n));
    }

    static <T> ReplaySubject<T> createUnbounded() {
        return new ReplaySubject(new SizeBoundReplayBuffer(Integer.MAX_VALUE));
    }

    @CheckReturnValue
    public static <T> ReplaySubject<T> createWithSize(int n) {
        return new ReplaySubject(new SizeBoundReplayBuffer(n));
    }

    @CheckReturnValue
    public static <T> ReplaySubject<T> createWithTime(long l, TimeUnit timeUnit, Scheduler scheduler) {
        return new ReplaySubject(new SizeAndTimeBoundReplayBuffer(Integer.MAX_VALUE, l, timeUnit, scheduler));
    }

    @CheckReturnValue
    public static <T> ReplaySubject<T> createWithTimeAndSize(long l, TimeUnit timeUnit, Scheduler scheduler, int n) {
        return new ReplaySubject(new SizeAndTimeBoundReplayBuffer(n, l, timeUnit, scheduler));
    }

    boolean add(ReplayDisposable<T> replayDisposable) {
        ReplayDisposable<T>[] arrreplayDisposable;
        ReplayDisposable[] arrreplayDisposable2;
        do {
            if ((arrreplayDisposable = this.observers.get()) == TERMINATED) {
                return false;
            }
            int n = arrreplayDisposable.length;
            arrreplayDisposable2 = new ReplayDisposable[n + 1];
            System.arraycopy(arrreplayDisposable, 0, arrreplayDisposable2, 0, n);
            arrreplayDisposable2[n] = replayDisposable;
        } while (!this.observers.compareAndSet(arrreplayDisposable, arrreplayDisposable2));
        return true;
    }

    @Override
    public Throwable getThrowable() {
        Object object = this.buffer.get();
        if (NotificationLite.isError(object)) {
            return NotificationLite.getError(object);
        }
        return null;
    }

    public T getValue() {
        return this.buffer.getValue();
    }

    public Object[] getValues() {
        Object[] arrobject = this.getValues(EMPTY_ARRAY);
        if (arrobject == EMPTY_ARRAY) {
            return new Object[0];
        }
        return arrobject;
    }

    public T[] getValues(T[] arrT) {
        return this.buffer.getValues(arrT);
    }

    @Override
    public boolean hasComplete() {
        return NotificationLite.isComplete(this.buffer.get());
    }

    @Override
    public boolean hasObservers() {
        if (this.observers.get().length != 0) {
            return true;
        }
        return false;
    }

    @Override
    public boolean hasThrowable() {
        return NotificationLite.isError(this.buffer.get());
    }

    public boolean hasValue() {
        if (this.buffer.size() != 0) {
            return true;
        }
        return false;
    }

    int observerCount() {
        return this.observers.get().length;
    }

    @Override
    public void onComplete() {
        if (this.done) {
            return;
        }
        this.done = true;
        ReplayDisposable<T>[] arrreplayDisposable = NotificationLite.complete();
        ReplayBuffer<T> replayBuffer = this.buffer;
        replayBuffer.addFinal(arrreplayDisposable);
        arrreplayDisposable = this.terminate(arrreplayDisposable);
        int n = arrreplayDisposable.length;
        for (int i = 0; i < n; ++i) {
            replayBuffer.replay(arrreplayDisposable[i]);
        }
    }

    @Override
    public void onError(Throwable object) {
        ReplayDisposable<T>[] arrreplayDisposable = object;
        if (object == null) {
            arrreplayDisposable = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
        }
        if (this.done) {
            RxJavaPlugins.onError((Throwable)arrreplayDisposable);
            return;
        }
        this.done = true;
        arrreplayDisposable = NotificationLite.error((Throwable)arrreplayDisposable);
        object = this.buffer;
        object.addFinal(arrreplayDisposable);
        arrreplayDisposable = this.terminate(arrreplayDisposable);
        int n = arrreplayDisposable.length;
        for (int i = 0; i < n; ++i) {
            object.replay(arrreplayDisposable[i]);
        }
    }

    @Override
    public void onNext(T object) {
        if (object == null) {
            this.onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources."));
            return;
        }
        if (this.done) {
            return;
        }
        ReplayBuffer<T> replayBuffer = this.buffer;
        replayBuffer.add(object);
        object = this.observers.get();
        int n = ((T)object).length;
        for (int i = 0; i < n; ++i) {
            replayBuffer.replay((ReplayDisposable<T>)object[i]);
        }
    }

    @Override
    public void onSubscribe(Disposable disposable) {
        if (this.done) {
            disposable.dispose();
        }
    }

    void remove(ReplayDisposable<T> replayDisposable) {
        ReplayDisposable<T>[] arrreplayDisposable;
        while ((arrreplayDisposable = this.observers.get()) != TERMINATED) {
            int n;
            ReplayDisposable[] arrreplayDisposable2;
            if (arrreplayDisposable == EMPTY) {
                return;
            }
            int n2 = arrreplayDisposable.length;
            int n3 = -1;
            int n4 = 0;
            do {
                n = n3;
                if (n4 >= n2) break;
                if (arrreplayDisposable[n4] == replayDisposable) {
                    n = n4;
                    break;
                }
                ++n4;
            } while (true);
            if (n < 0) {
                return;
            }
            if (n2 == 1) {
                arrreplayDisposable2 = EMPTY;
            } else {
                arrreplayDisposable2 = new ReplayDisposable[n2 - 1];
                System.arraycopy(arrreplayDisposable, 0, arrreplayDisposable2, 0, n);
                System.arraycopy(arrreplayDisposable, n + 1, arrreplayDisposable2, n, n2 - n - 1);
            }
            if (!this.observers.compareAndSet(arrreplayDisposable, arrreplayDisposable2)) continue;
            return;
        }
    }

    int size() {
        return this.buffer.size();
    }

    @Override
    protected void subscribeActual(Observer<? super T> observer) {
        ReplayDisposable<? super T> replayDisposable = new ReplayDisposable<T>(observer, this);
        observer.onSubscribe(replayDisposable);
        if (!replayDisposable.cancelled) {
            if (this.add(replayDisposable) && replayDisposable.cancelled) {
                this.remove(replayDisposable);
                return;
            }
            this.buffer.replay(replayDisposable);
        }
    }

    ReplayDisposable<T>[] terminate(Object object) {
        if (this.buffer.compareAndSet(null, object)) {
            return this.observers.getAndSet(TERMINATED);
        }
        return TERMINATED;
    }

    static final class Node<T>
    extends AtomicReference<Node<T>> {
        private static final long serialVersionUID = 6404226426336033100L;
        final T value;

        Node(T t) {
            this.value = t;
        }
    }

    static interface ReplayBuffer<T> {
        public void add(T var1);

        public void addFinal(Object var1);

        public boolean compareAndSet(Object var1, Object var2);

        public Object get();

        public T getValue();

        public T[] getValues(T[] var1);

        public void replay(ReplayDisposable<T> var1);

        public int size();
    }

    static final class ReplayDisposable<T>
    extends AtomicInteger
    implements Disposable {
        private static final long serialVersionUID = 466549804534799122L;
        final Observer<? super T> actual;
        volatile boolean cancelled;
        Object index;
        final ReplaySubject<T> state;

        ReplayDisposable(Observer<? super T> observer, ReplaySubject<T> replaySubject) {
            this.actual = observer;
            this.state = replaySubject;
        }

        @Override
        public void dispose() {
            if (!this.cancelled) {
                this.cancelled = true;
                this.state.remove(this);
            }
        }

        @Override
        public boolean isDisposed() {
            return this.cancelled;
        }
    }

    static final class SizeAndTimeBoundReplayBuffer<T>
    extends AtomicReference<Object>
    implements ReplayBuffer<T> {
        private static final long serialVersionUID = -8056260896137901749L;
        volatile boolean done;
        volatile TimedNode<Object> head;
        final long maxAge;
        final int maxSize;
        final Scheduler scheduler;
        int size;
        TimedNode<Object> tail;
        final TimeUnit unit;

        SizeAndTimeBoundReplayBuffer(int n, long l, TimeUnit object, Scheduler scheduler) {
            this.maxSize = ObjectHelper.verifyPositive(n, "maxSize");
            this.maxAge = ObjectHelper.verifyPositive(l, "maxAge");
            this.unit = ObjectHelper.requireNonNull(object, "unit is null");
            this.scheduler = ObjectHelper.requireNonNull(scheduler, "scheduler is null");
            object = new TimedNode<Object>(null, 0L);
            this.tail = object;
            this.head = object;
        }

        @Override
        public void add(T object) {
            object = new TimedNode<T>(object, this.scheduler.now(this.unit));
            TimedNode<Object> timedNode = this.tail;
            this.tail = object;
            ++this.size;
            timedNode.set(object);
            this.trim();
        }

        @Override
        public void addFinal(Object timedNode) {
            timedNode = new TimedNode<Object>(timedNode, Long.MAX_VALUE);
            TimedNode<Object> timedNode2 = this.tail;
            this.tail = timedNode;
            ++this.size;
            timedNode2.lazySet(timedNode);
            this.trimFinal();
            this.done = true;
        }

        TimedNode<Object> getHead() {
            TimedNode timedNode = this.head;
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            TimedNode timedNode2 = (TimedNode)timedNode.get();
            while (timedNode2 != null) {
                if (timedNode2.time > l - l2) {
                    return timedNode;
                }
                TimedNode timedNode3 = (TimedNode)timedNode2.get();
                timedNode = timedNode2;
                timedNode2 = timedNode3;
            }
            return timedNode;
        }

        @Override
        public T getValue() {
            TimedNode timedNode = this.head;
            TimedNode timedNode2 = null;
            do {
                TimedNode timedNode3;
                if ((timedNode3 = (TimedNode)timedNode.get()) == null) {
                    long l;
                    long l2 = this.scheduler.now(this.unit);
                    if (timedNode.time < l2 - (l = this.maxAge)) {
                        return null;
                    }
                    timedNode = timedNode.value;
                    if (timedNode == null) {
                        return null;
                    }
                    if (!NotificationLite.isComplete(timedNode) && !NotificationLite.isError(timedNode)) {
                        return (T)timedNode;
                    }
                    return timedNode2.value;
                }
                timedNode2 = timedNode;
                timedNode = timedNode3;
            } while (true);
        }

        @Override
        public T[] getValues(T[] arrT) {
            Object object;
            TimedNode<Object> timedNode = this.getHead();
            int n = this.size(timedNode);
            int n2 = 0;
            if (n == 0) {
                object = arrT;
                if (arrT.length != 0) {
                    arrT[0] = null;
                    return arrT;
                }
            } else {
                object = timedNode;
                int n3 = n2;
                Object[] arrobject = arrT;
                if (arrT.length < n) {
                    arrobject = (Object[])Array.newInstance(arrT.getClass().getComponentType(), n);
                    n3 = n2;
                    object = timedNode;
                }
                while (n3 != n) {
                    object = (TimedNode)object.get();
                    arrobject[n3] = object.value;
                    ++n3;
                }
                object = arrobject;
                if (arrobject.length > n) {
                    arrobject[n] = null;
                    object = arrobject;
                }
            }
            return object;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        @Override
        public void replay(ReplayDisposable<T> var1_1) {
            if (var1_1.getAndIncrement() != 0) {
                return;
            }
            var6_2 = var1_1.actual;
            var4_4 = var5_3 = (TimedNode)var1_1.index;
            if (var5_3 == null) {
                var4_5 = this.getHead();
            }
            var2_10 = 1;
            block0 : do lbl-1000: // 3 sources:
            {
                if (var1_1.cancelled) {
                    var1_1.index = null;
                    return;
                }
                do {
                    block9 : {
                        if (var1_1.cancelled) {
                            var1_1.index = null;
                            return;
                        }
                        var5_3 = (TimedNode)var4_7.get();
                        if (var5_3 != null) break block9;
                        if (var4_7.get() != null) ** GOTO lbl-1000
                        var1_1.index = var4_7;
                        var2_10 = var3_11 = var1_1.addAndGet(- var2_10);
                        if (var3_11 != 0) continue block0;
                        return;
                    }
                    var4_8 = var5_3.value;
                    if (this.done && var5_3.get() == null) {
                        if (NotificationLite.isComplete(var4_8)) {
                            var6_2.onComplete();
                        } else {
                            var6_2.onError(NotificationLite.getError(var4_8));
                        }
                        var1_1.index = null;
                        var1_1.cancelled = true;
                        return;
                    }
                    var6_2.onNext(var4_8);
                    var4_9 = var5_3;
                } while (true);
                break;
            } while (true);
        }

        @Override
        public int size() {
            return this.size(this.getHead());
        }

        int size(TimedNode<Object> timedNode) {
            int n;
            for (n = 0; n != Integer.MAX_VALUE; ++n) {
                TimedNode timedNode2 = (TimedNode)timedNode.get();
                if (timedNode2 == null) {
                    timedNode = timedNode.value;
                    if (!NotificationLite.isComplete(timedNode) && !NotificationLite.isError(timedNode)) break;
                    return n - 1;
                }
                timedNode = timedNode2;
            }
            return n;
        }

        void trim() {
            if (this.size > this.maxSize) {
                --this.size;
                this.head = (TimedNode)this.head.get();
            }
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            TimedNode timedNode = this.head;
            do {
                TimedNode timedNode2;
                if ((timedNode2 = (TimedNode)timedNode.get()) == null) {
                    this.head = timedNode;
                    return;
                }
                if (timedNode2.time > l - l2) {
                    this.head = timedNode;
                    return;
                }
                timedNode = timedNode2;
            } while (true);
        }

        void trimFinal() {
            long l = this.scheduler.now(this.unit);
            long l2 = this.maxAge;
            TimedNode timedNode = this.head;
            do {
                TimedNode timedNode2;
                if ((timedNode2 = (TimedNode)timedNode.get()).get() == null) {
                    this.head = timedNode;
                    return;
                }
                if (timedNode2.time > l - l2) {
                    this.head = timedNode;
                    return;
                }
                timedNode = timedNode2;
            } while (true);
        }
    }

    static final class SizeBoundReplayBuffer<T>
    extends AtomicReference<Object>
    implements ReplayBuffer<T> {
        private static final long serialVersionUID = 1107649250281456395L;
        volatile boolean done;
        volatile Node<Object> head;
        final int maxSize;
        int size;
        Node<Object> tail;

        SizeBoundReplayBuffer(int n) {
            this.maxSize = ObjectHelper.verifyPositive(n, "maxSize");
            Node<Object> node = new Node<Object>(null);
            this.tail = node;
            this.head = node;
        }

        @Override
        public void add(T object) {
            object = new Node<T>(object);
            Node<Object> node = this.tail;
            this.tail = object;
            ++this.size;
            node.set(object);
            this.trim();
        }

        @Override
        public void addFinal(Object node) {
            node = new Node<Object>(node);
            Node<Object> node2 = this.tail;
            this.tail = node;
            ++this.size;
            node2.lazySet(node);
            this.done = true;
        }

        @Override
        public T getValue() {
            Node node = this.head;
            Node<Object> node2 = null;
            do {
                Node node3;
                if ((node3 = (Node)node.get()) == null) {
                    node = node.value;
                    if (node == null) {
                        return null;
                    }
                    if (!NotificationLite.isComplete(node) && !NotificationLite.isError(node)) {
                        return (T)node;
                    }
                    return node2.value;
                }
                node2 = node;
                node = node3;
            } while (true);
        }

        @Override
        public T[] getValues(T[] arrT) {
            Object object;
            Node<Object> node = this.head;
            int n = this.size();
            int n2 = 0;
            if (n == 0) {
                object = arrT;
                if (arrT.length != 0) {
                    arrT[0] = null;
                    return arrT;
                }
            } else {
                object = node;
                int n3 = n2;
                Object[] arrobject = arrT;
                if (arrT.length < n) {
                    arrobject = (Object[])Array.newInstance(arrT.getClass().getComponentType(), n);
                    n3 = n2;
                    object = node;
                }
                while (n3 != n) {
                    object = (Node)object.get();
                    arrobject[n3] = object.value;
                    ++n3;
                }
                object = arrobject;
                if (arrobject.length > n) {
                    arrobject[n] = null;
                    object = arrobject;
                }
            }
            return object;
        }

        @Override
        public void replay(ReplayDisposable<T> replayDisposable) {
            Node node;
            if (replayDisposable.getAndIncrement() != 0) {
                return;
            }
            Observer<Node> observer = replayDisposable.actual;
            Node node2 = node = (Node)replayDisposable.index;
            if (node == null) {
                node2 = this.head;
            }
            int n = 1;
            do {
                if (replayDisposable.cancelled) {
                    replayDisposable.index = null;
                    return;
                }
                node = (Node)node2.get();
                if (node == null) {
                    int n2;
                    if (node2.get() != null) continue;
                    replayDisposable.index = node2;
                    n = n2 = replayDisposable.addAndGet(- n);
                    if (n2 != 0) continue;
                    return;
                }
                node2 = node.value;
                if (this.done && node.get() == null) {
                    if (NotificationLite.isComplete(node2)) {
                        observer.onComplete();
                    } else {
                        observer.onError(NotificationLite.getError(node2));
                    }
                    replayDisposable.index = null;
                    replayDisposable.cancelled = true;
                    return;
                }
                observer.onNext(node2);
                node2 = node;
            } while (true);
        }

        @Override
        public int size() {
            int n;
            Node node = this.head;
            for (n = 0; n != Integer.MAX_VALUE; ++n) {
                Node node2 = (Node)node.get();
                if (node2 == null) {
                    node = node.value;
                    if (!NotificationLite.isComplete(node) && !NotificationLite.isError(node)) break;
                    return n - 1;
                }
                node = node2;
            }
            return n;
        }

        void trim() {
            if (this.size > this.maxSize) {
                --this.size;
                this.head = (Node)this.head.get();
            }
        }
    }

    static final class TimedNode<T>
    extends AtomicReference<TimedNode<T>> {
        private static final long serialVersionUID = 6404226426336033100L;
        final long time;
        final T value;

        TimedNode(T t, long l) {
            this.value = t;
            this.time = l;
        }
    }

    static final class UnboundedReplayBuffer<T>
    extends AtomicReference<Object>
    implements ReplayBuffer<T> {
        private static final long serialVersionUID = -733876083048047795L;
        final List<Object> buffer;
        volatile boolean done;
        volatile int size;

        UnboundedReplayBuffer(int n) {
            this.buffer = new ArrayList<Object>(ObjectHelper.verifyPositive(n, "capacityHint"));
        }

        @Override
        public void add(T t) {
            this.buffer.add(t);
            ++this.size;
        }

        @Override
        public void addFinal(Object object) {
            this.buffer.add(object);
            ++this.size;
            this.done = true;
        }

        @Override
        public T getValue() {
            int n = this.size;
            if (n != 0) {
                List<Object> list = this.buffer;
                Object object = list.get(n - 1);
                if (!NotificationLite.isComplete(object) && !NotificationLite.isError(object)) {
                    return (T)object;
                }
                if (n == 1) {
                    return null;
                }
                return (T)list.get(n - 2);
            }
            return null;
        }

        @Override
        public T[] getValues(T[] arrT) {
            int n;
            int n2;
            List<Object> list;
            int n3;
            Object[] arrobject;
            block11 : {
                block10 : {
                    n = this.size;
                    n3 = 0;
                    if (n == 0) {
                        if (arrT.length != 0) {
                            arrT[0] = null;
                        }
                        return arrT;
                    }
                    list = this.buffer;
                    arrobject = list.get(n - 1);
                    if (NotificationLite.isComplete(arrobject)) break block10;
                    n2 = n;
                    if (!NotificationLite.isError(arrobject)) break block11;
                }
                n2 = --n;
                if (n == 0) {
                    if (arrT.length != 0) {
                        arrT[0] = null;
                    }
                    return arrT;
                }
            }
            n = n3;
            arrobject = arrT;
            if (arrT.length < n2) {
                arrobject = (Object[])Array.newInstance(arrT.getClass().getComponentType(), n2);
                n = n3;
            }
            while (n < n2) {
                arrobject[n] = list.get(n);
                ++n;
            }
            if (arrobject.length > n2) {
                arrobject[n2] = null;
            }
            return arrobject;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        @Override
        public void replay(ReplayDisposable<T> var1_1) {
            if (var1_1.getAndIncrement() != 0) {
                return;
            }
            var7_2 = this.buffer;
            var8_3 = var1_1.actual;
            var9_4 = (Integer)var1_1.index;
            var2_5 = 0;
            if (var9_4 != null) {
                var2_5 = var9_4.intValue();
            } else {
                var1_1.index = 0;
            }
            var3_6 = 1;
            do lbl-1000: // 3 sources:
            {
                if (var1_1.cancelled) {
                    var1_1.index = null;
                    return;
                }
                var5_8 = this.size;
                while (var5_8 != var2_5) {
                    if (var1_1.cancelled) {
                        var1_1.index = null;
                        return;
                    }
                    var9_4 = var7_2.get(var2_5);
                    var4_7 = var5_8;
                    if (this.done) {
                        var6_9 = var2_5 + 1;
                        var4_7 = var5_8;
                        if (var6_9 == var5_8) {
                            var4_7 = var5_8 = this.size;
                            if (var6_9 == var5_8) {
                                if (NotificationLite.isComplete(var9_4)) {
                                    var8_3.onComplete();
                                } else {
                                    var8_3.onError(NotificationLite.getError(var9_4));
                                }
                                var1_1.index = null;
                                var1_1.cancelled = true;
                                return;
                            }
                        }
                    }
                    var8_3.onNext(var9_4);
                    ++var2_5;
                    var5_8 = var4_7;
                }
                if (var2_5 != this.size) ** GOTO lbl-1000
                var1_1.index = var2_5;
                var3_6 = var4_7 = var1_1.addAndGet(- var3_6);
            } while (var4_7 != 0);
        }

        @Override
        public int size() {
            int n = this.size;
            if (n != 0) {
                Object object = this.buffer;
                int n2 = n - 1;
                if (!NotificationLite.isComplete(object = object.get(n2))) {
                    if (NotificationLite.isError(object)) {
                        return n2;
                    }
                    return n;
                }
                return n2;
            }
            return 0;
        }
    }

}

