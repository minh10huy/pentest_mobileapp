/*
 * Decompiled with CFR 0_132.
 */
package io.reactivex.observers;

import io.reactivex.Notification;
import io.reactivex.annotations.Experimental;
import io.reactivex.disposables.Disposable;
import io.reactivex.exceptions.CompositeException;
import io.reactivex.functions.Predicate;
import io.reactivex.internal.functions.Functions;
import io.reactivex.internal.functions.ObjectHelper;
import io.reactivex.internal.util.ExceptionHelper;
import io.reactivex.internal.util.VolatileSizeArrayList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public abstract class BaseTestConsumer<T, U extends BaseTestConsumer<T, U>>
implements Disposable {
    protected boolean checkSubscriptionOnce;
    protected long completions;
    protected final CountDownLatch done = new CountDownLatch(1);
    protected final List<Throwable> errors = new VolatileSizeArrayList<Throwable>();
    protected int establishedFusionMode;
    protected int initialFusionMode;
    protected Thread lastThread;
    protected CharSequence tag;
    protected boolean timeout;
    protected final List<T> values = new VolatileSizeArrayList();

    public static String valueAndClass(Object object) {
        if (object != null) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(object);
            stringBuilder.append(" (class: ");
            stringBuilder.append(object.getClass().getSimpleName());
            stringBuilder.append(")");
            return stringBuilder.toString();
        }
        return "null";
    }

    public final U assertComplete() {
        long l = this.completions;
        if (l == 0L) {
            throw this.fail("Not completed");
        }
        if (l > 1L) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Multiple completions: ");
            stringBuilder.append(l);
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public final U assertEmpty() {
        return this.assertSubscribed().assertNoValues().assertNoErrors().assertNotComplete();
    }

    /*
     * Exception decompiling
     */
    public final U assertError(Predicate<Throwable> var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [2[DOLOOP]], but top level block is 0[TRYBLOCK]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public final U assertError(Class<? extends Throwable> class_) {
        return this.assertError(Functions.isInstanceOf(class_));
    }

    public final U assertError(Throwable throwable) {
        return this.assertError(Functions.equalsWith(throwable));
    }

    public final U assertErrorMessage(String string2) {
        int n = this.errors.size();
        if (n == 0) {
            throw this.fail("No errors");
        }
        if (n == 1) {
            String string3 = this.errors.get(0).getMessage();
            if (!ObjectHelper.equals(string2, string3)) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Error message differs; Expected: ");
                stringBuilder.append(string2);
                stringBuilder.append(", Actual: ");
                stringBuilder.append(string3);
                throw this.fail(stringBuilder.toString());
            }
            return (U)this;
        }
        throw this.fail("Multiple errors");
    }

    public final /* varargs */ U assertFailure(Predicate<Throwable> predicate, T ... arrT) {
        return this.assertSubscribed().assertValues(arrT).assertError(predicate).assertNotComplete();
    }

    public final /* varargs */ U assertFailure(Class<? extends Throwable> class_, T ... arrT) {
        return this.assertSubscribed().assertValues(arrT).assertError(class_).assertNotComplete();
    }

    public final /* varargs */ U assertFailureAndMessage(Class<? extends Throwable> class_, String string2, T ... arrT) {
        return this.assertSubscribed().assertValues(arrT).assertError(class_).assertErrorMessage(string2).assertNotComplete();
    }

    public final U assertNever(Predicate<? super T> predicate) {
        int n = this.values.size();
        for (int i = 0; i < n; ++i) {
            Object object = this.values.get(i);
            try {
                if (!predicate.test(object)) continue;
                object = new StringBuilder();
                object.append("Value at position ");
                object.append(i);
                object.append(" matches predicate ");
                object.append(predicate.toString());
                object.append(", which was not expected.");
                throw this.fail(object.toString());
            }
            catch (Exception exception) {
                throw ExceptionHelper.wrapOrThrow(exception);
            }
        }
        return (U)this;
    }

    public final U assertNever(T t) {
        int n = this.values.size();
        for (int i = 0; i < n; ++i) {
            if (!ObjectHelper.equals(this.values.get(i), t)) continue;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Value at position ");
            stringBuilder.append(i);
            stringBuilder.append(" is equal to ");
            stringBuilder.append(BaseTestConsumer.valueAndClass(t));
            stringBuilder.append("; Expected them to be different");
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public final U assertNoErrors() {
        if (this.errors.size() != 0) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Error(s) present: ");
            stringBuilder.append(this.errors);
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public final U assertNoTimeout() {
        if (this.timeout) {
            throw this.fail("Timeout?!");
        }
        return (U)this;
    }

    public final U assertNoValues() {
        return this.assertValueCount(0);
    }

    public final U assertNotComplete() {
        long l = this.completions;
        if (l == 1L) {
            throw this.fail("Completed!");
        }
        if (l > 1L) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Multiple completions: ");
            stringBuilder.append(l);
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public abstract U assertNotSubscribed();

    public final U assertNotTerminated() {
        if (this.done.getCount() == 0L) {
            throw this.fail("Subscriber terminated!");
        }
        return (U)this;
    }

    public final /* varargs */ U assertResult(T ... arrT) {
        return this.assertSubscribed().assertValues(arrT).assertNoErrors().assertComplete();
    }

    public abstract U assertSubscribed();

    public final U assertTerminated() {
        if (this.done.getCount() != 0L) {
            throw this.fail("Subscriber still running!");
        }
        long l = this.completions;
        if (l > 1L) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Terminated with multiple completions: ");
            stringBuilder.append(l);
            throw this.fail(stringBuilder.toString());
        }
        int n = this.errors.size();
        if (n > 1) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Terminated with multiple errors: ");
            stringBuilder.append(n);
            throw this.fail(stringBuilder.toString());
        }
        if (l != 0L && n != 0) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Terminated with multiple completions and errors: ");
            stringBuilder.append(l);
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public final U assertTimeout() {
        if (!this.timeout) {
            throw this.fail("No timeout?!");
        }
        return (U)this;
    }

    public final U assertValue(Predicate<T> predicate) {
        this.assertValueAt(0, (T)predicate);
        if (this.values.size() > 1) {
            throw this.fail("Value present but other values as well");
        }
        return (U)this;
    }

    public final U assertValue(T t) {
        if (this.values.size() != 1) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Expected: ");
            stringBuilder.append(BaseTestConsumer.valueAndClass(t));
            stringBuilder.append(", Actual: ");
            stringBuilder.append(this.values);
            throw this.fail(stringBuilder.toString());
        }
        T t2 = this.values.get(0);
        if (!ObjectHelper.equals(t, t2)) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Expected: ");
            stringBuilder.append(BaseTestConsumer.valueAndClass(t));
            stringBuilder.append(", Actual: ");
            stringBuilder.append(BaseTestConsumer.valueAndClass(t2));
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public final U assertValueAt(int n, Predicate<T> object) {
        block4 : {
            if (this.values.size() == 0) {
                throw this.fail("No values");
            }
            if (n >= this.values.size()) {
                object = new StringBuilder();
                object.append("Invalid index: ");
                object.append(n);
                throw this.fail(object.toString());
            }
            try {
                boolean bl = object.test(this.values.get(n));
                if (bl) break block4;
            }
            catch (Exception exception) {
                throw ExceptionHelper.wrapOrThrow(exception);
            }
            throw this.fail("Value not present");
        }
        return (U)this;
    }

    @Experimental
    public final U assertValueAt(int n, T object) {
        int n2 = this.values.size();
        if (n2 == 0) {
            throw this.fail("No values");
        }
        if (n >= n2) {
            object = new StringBuilder();
            object.append("Invalid index: ");
            object.append(n);
            throw this.fail(object.toString());
        }
        T t = this.values.get(n);
        if (!ObjectHelper.equals(object, t)) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Expected: ");
            stringBuilder.append(BaseTestConsumer.valueAndClass(object));
            stringBuilder.append(", Actual: ");
            stringBuilder.append(BaseTestConsumer.valueAndClass(t));
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public final U assertValueCount(int n) {
        int n2 = this.values.size();
        if (n2 != n) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Value counts differ; Expected: ");
            stringBuilder.append(n);
            stringBuilder.append(", Actual: ");
            stringBuilder.append(n2);
            throw this.fail(stringBuilder.toString());
        }
        return (U)this;
    }

    public final U assertValueSequence(Iterable<? extends T> object) {
        boolean bl;
        boolean bl2;
        Object object2 = this.values.iterator();
        Iterator<T> iterator = object.iterator();
        int n = 0;
        do {
            T t;
            bl = iterator.hasNext();
            bl2 = object2.hasNext();
            if (!bl2 || !bl) break;
            object = iterator.next();
            if (!ObjectHelper.equals(object, t = object2.next())) {
                object2 = new StringBuilder();
                object2.append("Values at position ");
                object2.append(n);
                object2.append(" differ; Expected: ");
                object2.append(BaseTestConsumer.valueAndClass(object));
                object2.append(", Actual: ");
                object2.append(BaseTestConsumer.valueAndClass(t));
                throw this.fail(object2.toString());
            }
            ++n;
        } while (true);
        if (bl2) {
            object = new StringBuilder();
            object.append("More values received than expected (");
            object.append(n);
            object.append(")");
            throw this.fail(object.toString());
        }
        if (bl) {
            object = new StringBuilder();
            object.append("Fewer values received than expected (");
            object.append(n);
            object.append(")");
            throw this.fail(object.toString());
        }
        return (U)this;
    }

    public final U assertValueSet(Collection<? extends T> object) {
        if (object.isEmpty()) {
            this.assertNoValues();
            return (U)this;
        }
        for (T t : this.values) {
            if (object.contains(t)) continue;
            object = new StringBuilder();
            object.append("Value not in the expected collection: ");
            object.append(BaseTestConsumer.valueAndClass(t));
            throw this.fail(object.toString());
        }
        return (U)this;
    }

    public final /* varargs */ U assertValues(T ... object) {
        int n = this.values.size();
        if (n != ((T[])object).length) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Value count differs; Expected: ");
            stringBuilder.append(((T[])object).length);
            stringBuilder.append(" ");
            stringBuilder.append(Arrays.toString((Object[])object));
            stringBuilder.append(", Actual: ");
            stringBuilder.append(n);
            stringBuilder.append(" ");
            stringBuilder.append(this.values);
            throw this.fail(stringBuilder.toString());
        }
        for (int i = 0; i < n; ++i) {
            T t = object[i];
            T t2 = this.values.get(i);
            if (ObjectHelper.equals(t, t2)) continue;
            object = new StringBuilder();
            object.append("Values at position ");
            object.append(i);
            object.append(" differ; Expected: ");
            object.append(BaseTestConsumer.valueAndClass(t));
            object.append(", Actual: ");
            object.append(BaseTestConsumer.valueAndClass(t2));
            throw this.fail(object.toString());
        }
        return (U)this;
    }

    @Experimental
    public final /* varargs */ U assertValuesOnly(T ... arrT) {
        return this.assertSubscribed().assertValues(arrT).assertNoErrors().assertNotComplete();
    }

    public final U await() throws InterruptedException {
        if (this.done.getCount() == 0L) {
            return (U)this;
        }
        this.done.await();
        return (U)this;
    }

    public final boolean await(long l, TimeUnit timeUnit) throws InterruptedException {
        boolean bl = this.done.getCount() == 0L || this.done.await(l, timeUnit);
        this.timeout = bl ^ true;
        return bl;
    }

    public final U awaitCount(int n) {
        return this.awaitCount(n, TestWaitStrategy.SLEEP_10MS, 5000L);
    }

    public final U awaitCount(int n, Runnable runnable) {
        return this.awaitCount(n, runnable, 5000L);
    }

    public final U awaitCount(int n, Runnable runnable, long l) {
        long l2 = System.currentTimeMillis();
        do {
            if (l > 0L && System.currentTimeMillis() - l2 >= l) {
                this.timeout = true;
                return (U)this;
            }
            if (this.done.getCount() == 0L) {
                return (U)this;
            }
            if (this.values.size() >= n) {
                return (U)this;
            }
            runnable.run();
        } while (true);
    }

    public final U awaitDone(long l, TimeUnit timeUnit) {
        block2 : {
            try {
                if (this.done.await(l, timeUnit)) break block2;
                this.timeout = true;
                this.dispose();
            }
            catch (InterruptedException interruptedException) {
                this.dispose();
                throw ExceptionHelper.wrapOrThrow(interruptedException);
            }
        }
        return (U)this;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public final boolean awaitTerminalEvent() {
        try {
            this.await();
            return true;
        }
        catch (InterruptedException interruptedException) {}
        Thread.currentThread().interrupt();
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public final boolean awaitTerminalEvent(long l, TimeUnit timeUnit) {
        try {
            return this.await(l, timeUnit);
        }
        catch (InterruptedException interruptedException) {}
        Thread.currentThread().interrupt();
        return false;
    }

    public final U clearTimeout() {
        this.timeout = false;
        return (U)this;
    }

    public final long completions() {
        return this.completions;
    }

    public final int errorCount() {
        return this.errors.size();
    }

    public final List<Throwable> errors() {
        return this.errors;
    }

    protected final AssertionError fail(String object) {
        StringBuilder stringBuilder = new StringBuilder(object.length() + 64);
        stringBuilder.append((String)object);
        stringBuilder.append(" (");
        stringBuilder.append("latch = ");
        stringBuilder.append(this.done.getCount());
        stringBuilder.append(", ");
        stringBuilder.append("values = ");
        stringBuilder.append(this.values.size());
        stringBuilder.append(", ");
        stringBuilder.append("errors = ");
        stringBuilder.append(this.errors.size());
        stringBuilder.append(", ");
        stringBuilder.append("completions = ");
        stringBuilder.append(this.completions);
        if (this.timeout) {
            stringBuilder.append(", timeout!");
        }
        if (this.isDisposed()) {
            stringBuilder.append(", disposed!");
        }
        if ((object = this.tag) != null) {
            stringBuilder.append(", tag = ");
            stringBuilder.append((CharSequence)object);
        }
        stringBuilder.append(')');
        object = new AssertionError((Object)stringBuilder.toString());
        if (!this.errors.isEmpty()) {
            if (this.errors.size() == 1) {
                object.initCause(this.errors.get(0));
                return object;
            }
            object.initCause(new CompositeException(this.errors));
        }
        return object;
    }

    public final List<List<Object>> getEvents() {
        ArrayList<List<Object>> arrayList = new ArrayList<List<Object>>();
        arrayList.add(this.values());
        arrayList.add(this.errors());
        ArrayList<Notification<T>> arrayList2 = new ArrayList<Notification<T>>();
        for (long i = 0L; i < this.completions; ++i) {
            arrayList2.add(Notification.<T>createOnComplete());
        }
        arrayList.add(arrayList2);
        return arrayList;
    }

    public final boolean isTerminated() {
        if (this.done.getCount() == 0L) {
            return true;
        }
        return false;
    }

    public final boolean isTimeout() {
        return this.timeout;
    }

    public final Thread lastThread() {
        return this.lastThread;
    }

    public final int valueCount() {
        return this.values.size();
    }

    public final List<T> values() {
        return this.values;
    }

    public final U withTag(CharSequence charSequence) {
        this.tag = charSequence;
        return (U)this;
    }

    public static enum TestWaitStrategy implements Runnable
    {
        SPIN{

            @Override
            public void run() {
            }
        }
        ,
        YIELD{

            @Override
            public void run() {
                Thread.yield();
            }
        }
        ,
        SLEEP_1MS{

            @Override
            public void run() {
                TestWaitStrategy.sleep(1);
            }
        }
        ,
        SLEEP_10MS{

            @Override
            public void run() {
                TestWaitStrategy.sleep(10);
            }
        }
        ,
        SLEEP_100MS{

            @Override
            public void run() {
                TestWaitStrategy.sleep(100);
            }
        }
        ,
        SLEEP_1000MS{

            @Override
            public void run() {
                TestWaitStrategy.sleep(1000);
            }
        };
        

        private TestWaitStrategy() {
        }

        static void sleep(int n) {
            long l = n;
            try {
                Thread.sleep(l);
                return;
            }
            catch (InterruptedException interruptedException) {
                throw new RuntimeException(interruptedException);
            }
        }

        @Override
        public abstract void run();

    }

}

