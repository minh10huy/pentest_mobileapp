/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.util.Log
 */
package com.bumptech.glide.load.resource.bitmap;

import android.util.Log;
import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

public class RecyclableBufferedInputStream
extends FilterInputStream {
    private static final String TAG = "BufferedIs";
    private volatile byte[] buf;
    private int count;
    private int marklimit;
    private int markpos = -1;
    private int pos;

    public RecyclableBufferedInputStream(InputStream inputStream, byte[] arrby) {
        super(inputStream);
        if (arrby != null && arrby.length != 0) {
            this.buf = arrby;
            return;
        }
        throw new IllegalArgumentException("buffer is null or empty");
    }

    private int fillbuf(InputStream inputStream, byte[] arrby) throws IOException {
        if (this.markpos != -1 && this.pos - this.markpos < this.marklimit) {
            int n;
            int n2;
            Object object;
            if (this.markpos == 0 && this.marklimit > arrby.length && this.count == arrby.length) {
                n = n2 = arrby.length * 2;
                if (n2 > this.marklimit) {
                    n = this.marklimit;
                }
                if (Log.isLoggable((String)TAG, (int)3)) {
                    object = new StringBuilder();
                    object.append("allocate buffer of length: ");
                    object.append(n);
                    Log.d((String)TAG, (String)object.toString());
                }
                object = new byte[n];
                System.arraycopy(arrby, 0, object, 0, arrby.length);
                this.buf = object;
            } else {
                object = arrby;
                if (this.markpos > 0) {
                    System.arraycopy(arrby, this.markpos, arrby, 0, arrby.length - this.markpos);
                    object = arrby;
                }
            }
            this.pos -= this.markpos;
            this.markpos = 0;
            this.count = 0;
            n2 = inputStream.read((byte[])object, this.pos, ((byte[])object).length - this.pos);
            n = n2 <= 0 ? this.pos : this.pos + n2;
            this.count = n;
            return n2;
        }
        int n = inputStream.read(arrby);
        if (n > 0) {
            this.markpos = -1;
            this.pos = 0;
            this.count = n;
        }
        return n;
    }

    private static IOException streamClosed() throws IOException {
        throw new IOException("BufferedInputStream is closed");
    }

    @Override
    public int available() throws IOException {
        synchronized (this) {
            block5 : {
                InputStream inputStream = this.in;
                if (this.buf == null || inputStream == null) break block5;
                int n = this.count;
                int n2 = this.pos;
                int n3 = inputStream.available();
                return n - n2 + n3;
            }
            throw RecyclableBufferedInputStream.streamClosed();
        }
    }

    @Override
    public void close() throws IOException {
        this.buf = null;
        InputStream inputStream = this.in;
        this.in = null;
        if (inputStream != null) {
            inputStream.close();
        }
    }

    public void fixMarkLimit() {
        synchronized (this) {
            this.marklimit = this.buf.length;
            return;
        }
    }

    @Override
    public void mark(int n) {
        synchronized (this) {
            this.marklimit = Math.max(this.marklimit, n);
            this.markpos = this.pos;
            return;
        }
    }

    @Override
    public boolean markSupported() {
        return true;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public int read() throws IOException {
        synchronized (this) {
            int n;
            byte[] arrby = this.buf;
            byte[] arrby2 = this.in;
            if (arrby == null) throw RecyclableBufferedInputStream.streamClosed();
            if (arrby2 == null) {
                throw RecyclableBufferedInputStream.streamClosed();
            }
            if (this.pos >= this.count && (n = this.fillbuf((InputStream)arrby2, arrby)) == -1) {
                return -1;
            }
            arrby2 = arrby;
            if (arrby != this.buf) {
                arrby2 = arrby = this.buf;
                if (arrby == null) {
                    throw RecyclableBufferedInputStream.streamClosed();
                }
            }
            if (this.count - this.pos <= 0) return -1;
            n = this.pos;
            this.pos = n + 1;
            n = arrby2[n];
            return n & 255;
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    @Override
    public int read(byte[] arrby, int n, int n2) throws IOException {
        int n3;
        int n4;
        int n5;
        int n6;
        // MONITORENTER : this
        byte[] arrby2 = this.buf;
        if (arrby2 == null) {
            throw RecyclableBufferedInputStream.streamClosed();
        }
        if (n3 == 0) {
            // MONITOREXIT : this
            return 0;
        }
        InputStream inputStream = this.in;
        if (inputStream == null) {
            throw RecyclableBufferedInputStream.streamClosed();
        }
        if (this.pos < this.count) {
            n6 = this.count - this.pos >= n3 ? n3 : this.count - this.pos;
            System.arraycopy(arrby2, this.pos, arrby, n5, n6);
            this.pos += n6;
            if (n6 == n3) {
                // MONITOREXIT : this
                return n6;
            }
            n4 = inputStream.available();
            if (n4 == 0) {
                return n6;
            }
            n4 = n5 + n6;
            n5 = n3 - n6;
            n6 = n4;
        } else {
            n4 = n3;
            n6 = n5;
            n5 = n4;
        }
        do {
            byte[] arrby3;
            int n7 = this.markpos;
            n4 = -1;
            if (n7 == -1 && n5 >= arrby2.length) {
                int n8 = inputStream.read(arrby, n6, n5);
                arrby3 = arrby2;
                n7 = n8;
                if (n8 == -1) {
                    if (n5 == n3) {
                        return n4;
                    }
                    n4 = n3 - n5;
                    // MONITOREXIT : this
                    return n4;
                }
            } else {
                n7 = this.fillbuf(inputStream, arrby2);
                if (n7 == -1) {
                    if (n5 == n3) {
                        return n4;
                    }
                    n4 = n3 - n5;
                    // MONITOREXIT : this
                    return n4;
                }
                arrby3 = arrby2;
                if (arrby2 != this.buf) {
                    arrby3 = arrby2 = this.buf;
                    if (arrby2 == null) {
                        throw RecyclableBufferedInputStream.streamClosed();
                    }
                }
                n4 = this.count - this.pos >= n5 ? n5 : this.count - this.pos;
                System.arraycopy(arrby3, this.pos, arrby, n6, n4);
                this.pos += n4;
                n7 = n4;
            }
            if ((n5 -= n7) == 0) {
                // MONITOREXIT : this
                return n3;
            }
            n4 = inputStream.available();
            if (n4 == 0) {
                // MONITOREXIT : this
                return (int)(n3 - n5);
            }
            n6 += n7;
            arrby2 = arrby3;
        } while (true);
    }

    @Override
    public void reset() throws IOException {
        synchronized (this) {
            if (this.buf == null) {
                throw new IOException("Stream is closed");
            }
            if (-1 == this.markpos) {
                throw new InvalidMarkException("Mark has been invalidated");
            }
            this.pos = this.markpos;
            return;
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public long skip(long l) throws IOException {
        synchronized (this) {
            byte[] arrby = this.buf;
            InputStream inputStream = this.in;
            if (arrby == null) {
                throw RecyclableBufferedInputStream.streamClosed();
            }
            if (l < 1L) {
                return 0L;
            }
            if (inputStream == null) {
                throw RecyclableBufferedInputStream.streamClosed();
            }
            if ((long)(this.count - this.pos) >= l) {
                this.pos = (int)((long)this.pos + l);
                return l;
            }
            long l2 = this.count - this.pos;
            this.pos = this.count;
            if (this.markpos != -1 && l <= (long)this.marklimit) {
                int n = this.fillbuf(inputStream, arrby);
                if (n == -1) {
                    return l2;
                }
                long l3 = this.count - this.pos;
                long l4 = l - l2;
                if (l3 >= l4) {
                    this.pos = (int)((long)this.pos + l4);
                    return l;
                }
                l = this.count;
                l3 = this.pos;
                this.pos = this.count;
                return l2 + l - l3;
            }
            l = inputStream.skip(l - l2);
            return l2 + l;
        }
    }

    public static class InvalidMarkException
    extends RuntimeException {
        private static final long serialVersionUID = -4338378848813561757L;

        public InvalidMarkException(String string2) {
            super(string2);
        }
    }

}

