/*
 * Decompiled with CFR 0_132.
 */
package com.bumptech.glide.load.resource.transcode;

import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.load.resource.transcode.UnitTranscoder;
import com.bumptech.glide.util.MultiClassKey;
import java.util.HashMap;
import java.util.Map;

public class TranscoderRegistry {
    private static final MultiClassKey GET_KEY = new MultiClassKey();
    private final Map<MultiClassKey, ResourceTranscoder<?, ?>> factories = new HashMap();

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    public <Z, R> ResourceTranscoder<Z, R> get(Class<Z> class_, Class<R> class_2) {
        if (class_.equals(class_2)) {
            return UnitTranscoder.get();
        }
        Object object = GET_KEY;
        // MONITORENTER : object
        GET_KEY.set(class_, class_2);
        ResourceTranscoder<?, ?> resourceTranscoder = this.factories.get(GET_KEY);
        // MONITOREXIT : object
        if (resourceTranscoder != null) return resourceTranscoder;
        object = new StringBuilder();
        object.append("No transcoder registered for ");
        object.append(class_);
        object.append(" and ");
        object.append(class_2);
        throw new IllegalArgumentException(object.toString());
    }

    public <Z, R> void register(Class<Z> class_, Class<R> class_2, ResourceTranscoder<Z, R> resourceTranscoder) {
        this.factories.put(new MultiClassKey(class_, class_2), resourceTranscoder);
    }
}

