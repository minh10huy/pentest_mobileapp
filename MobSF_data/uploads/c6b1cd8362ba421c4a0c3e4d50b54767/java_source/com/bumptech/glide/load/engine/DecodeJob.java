/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.util.Log
 */
package com.bumptech.glide.load.engine;

import android.util.Log;
import com.bumptech.glide.Priority;
import com.bumptech.glide.load.Encoder;
import com.bumptech.glide.load.Key;
import com.bumptech.glide.load.ResourceDecoder;
import com.bumptech.glide.load.ResourceEncoder;
import com.bumptech.glide.load.Transformation;
import com.bumptech.glide.load.data.DataFetcher;
import com.bumptech.glide.load.engine.DiskCacheStrategy;
import com.bumptech.glide.load.engine.EngineKey;
import com.bumptech.glide.load.engine.Resource;
import com.bumptech.glide.load.engine.cache.DiskCache;
import com.bumptech.glide.load.resource.transcode.ResourceTranscoder;
import com.bumptech.glide.provider.DataLoadProvider;
import com.bumptech.glide.util.LogTime;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

class DecodeJob<A, T, Z> {
    private static final FileOpener DEFAULT_FILE_OPENER = new FileOpener();
    private static final String TAG = "DecodeJob";
    private final DiskCacheProvider diskCacheProvider;
    private final DiskCacheStrategy diskCacheStrategy;
    private final DataFetcher<A> fetcher;
    private final FileOpener fileOpener;
    private final int height;
    private volatile boolean isCancelled;
    private final DataLoadProvider<A, T> loadProvider;
    private final Priority priority;
    private final EngineKey resultKey;
    private final ResourceTranscoder<T, Z> transcoder;
    private final Transformation<T> transformation;
    private final int width;

    public DecodeJob(EngineKey engineKey, int n, int n2, DataFetcher<A> dataFetcher, DataLoadProvider<A, T> dataLoadProvider, Transformation<T> transformation, ResourceTranscoder<T, Z> resourceTranscoder, DiskCacheProvider diskCacheProvider, DiskCacheStrategy diskCacheStrategy, Priority priority) {
        this(engineKey, n, n2, dataFetcher, dataLoadProvider, transformation, resourceTranscoder, diskCacheProvider, diskCacheStrategy, priority, DEFAULT_FILE_OPENER);
    }

    DecodeJob(EngineKey engineKey, int n, int n2, DataFetcher<A> dataFetcher, DataLoadProvider<A, T> dataLoadProvider, Transformation<T> transformation, ResourceTranscoder<T, Z> resourceTranscoder, DiskCacheProvider diskCacheProvider, DiskCacheStrategy diskCacheStrategy, Priority priority, FileOpener fileOpener) {
        this.resultKey = engineKey;
        this.width = n;
        this.height = n2;
        this.fetcher = dataFetcher;
        this.loadProvider = dataLoadProvider;
        this.transformation = transformation;
        this.transcoder = resourceTranscoder;
        this.diskCacheProvider = diskCacheProvider;
        this.diskCacheStrategy = diskCacheStrategy;
        this.priority = priority;
        this.fileOpener = fileOpener;
    }

    private Resource<T> cacheAndDecodeSourceData(A object) throws IOException {
        long l = LogTime.getLogTime();
        object = new SourceWriter<A>(this.loadProvider.getSourceEncoder(), object);
        this.diskCacheProvider.getDiskCache().put(this.resultKey.getOriginalKey(), (DiskCache.Writer)object);
        if (Log.isLoggable((String)TAG, (int)2)) {
            this.logWithTimeAndKey("Wrote source to cache", l);
        }
        l = LogTime.getLogTime();
        object = this.loadFromCache(this.resultKey.getOriginalKey());
        if (Log.isLoggable((String)TAG, (int)2) && object != null) {
            this.logWithTimeAndKey("Decoded source from cache", l);
        }
        return object;
    }

    private Resource<T> decodeFromSourceData(A object) throws IOException {
        if (this.diskCacheStrategy.cacheSource()) {
            return this.cacheAndDecodeSourceData(object);
        }
        long l = LogTime.getLogTime();
        object = this.loadProvider.getSourceDecoder().decode(object, this.width, this.height);
        if (Log.isLoggable((String)TAG, (int)2)) {
            this.logWithTimeAndKey("Decoded from source", l);
        }
        return object;
    }

    private Resource<T> decodeSource() throws Exception {
        Object object;
        block5 : {
            boolean bl;
            long l = LogTime.getLogTime();
            object = this.fetcher.loadData(this.priority);
            if (Log.isLoggable((String)TAG, (int)2)) {
                this.logWithTimeAndKey("Fetched data", l);
            }
            if (!(bl = this.isCancelled)) break block5;
            this.fetcher.cleanup();
            return null;
        }
        try {
            object = this.decodeFromSourceData(object);
            return object;
        }
        finally {
            this.fetcher.cleanup();
        }
    }

    private Resource<T> loadFromCache(Key key) throws IOException {
        Object object = this.diskCacheProvider.getDiskCache().get(key);
        if (object == null) {
            return null;
        }
        try {
            object = this.loadProvider.getCacheDecoder().decode((File)object, this.width, this.height);
            if (object == null) {
                this.diskCacheProvider.getDiskCache().delete(key);
            }
            return object;
        }
        catch (Throwable throwable) {
            this.diskCacheProvider.getDiskCache().delete(key);
            throw throwable;
        }
    }

    private void logWithTimeAndKey(String string2, long l) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(string2);
        stringBuilder.append(" in ");
        stringBuilder.append(LogTime.getElapsedMillis(l));
        stringBuilder.append(", key: ");
        stringBuilder.append(this.resultKey);
        Log.v((String)TAG, (String)stringBuilder.toString());
    }

    private Resource<Z> transcode(Resource<T> resource) {
        if (resource == null) {
            return null;
        }
        return this.transcoder.transcode(resource);
    }

    private Resource<T> transform(Resource<T> resource) {
        if (resource == null) {
            return null;
        }
        Resource<T> resource2 = this.transformation.transform(resource, this.width, this.height);
        if (!resource.equals(resource2)) {
            resource.recycle();
        }
        return resource2;
    }

    private Resource<Z> transformEncodeAndTranscode(Resource<T> resource) {
        long l = LogTime.getLogTime();
        resource = this.transform(resource);
        if (Log.isLoggable((String)TAG, (int)2)) {
            this.logWithTimeAndKey("Transformed resource from source", l);
        }
        this.writeTransformedToCache(resource);
        l = LogTime.getLogTime();
        resource = this.transcode(resource);
        if (Log.isLoggable((String)TAG, (int)2)) {
            this.logWithTimeAndKey("Transcoded transformed from source", l);
        }
        return resource;
    }

    private void writeTransformedToCache(Resource<T> object) {
        if (object != null) {
            if (!this.diskCacheStrategy.cacheResult()) {
                return;
            }
            long l = LogTime.getLogTime();
            object = new SourceWriter<Resource<T>>(this.loadProvider.getEncoder(), (Resource<T>)object);
            this.diskCacheProvider.getDiskCache().put(this.resultKey, (DiskCache.Writer)object);
            if (Log.isLoggable((String)TAG, (int)2)) {
                this.logWithTimeAndKey("Wrote transformed from source to cache", l);
            }
            return;
        }
    }

    public void cancel() {
        this.isCancelled = true;
        this.fetcher.cancel();
    }

    public Resource<Z> decodeFromSource() throws Exception {
        return this.transformEncodeAndTranscode(this.decodeSource());
    }

    public Resource<Z> decodeResultFromCache() throws Exception {
        if (!this.diskCacheStrategy.cacheResult()) {
            return null;
        }
        long l = LogTime.getLogTime();
        Resource<Object> resource = this.loadFromCache(this.resultKey);
        if (Log.isLoggable((String)TAG, (int)2)) {
            this.logWithTimeAndKey("Decoded transformed from cache", l);
        }
        l = LogTime.getLogTime();
        resource = this.transcode(resource);
        if (Log.isLoggable((String)TAG, (int)2)) {
            this.logWithTimeAndKey("Transcoded transformed from cache", l);
        }
        return resource;
    }

    public Resource<Z> decodeSourceFromCache() throws Exception {
        if (!this.diskCacheStrategy.cacheSource()) {
            return null;
        }
        long l = LogTime.getLogTime();
        Resource<T> resource = this.loadFromCache(this.resultKey.getOriginalKey());
        if (Log.isLoggable((String)TAG, (int)2)) {
            this.logWithTimeAndKey("Decoded source from cache", l);
        }
        return this.transformEncodeAndTranscode(resource);
    }

    static interface DiskCacheProvider {
        public DiskCache getDiskCache();
    }

    static class FileOpener {
        FileOpener() {
        }

        public OutputStream open(File file) throws FileNotFoundException {
            return new BufferedOutputStream(new FileOutputStream(file));
        }
    }

    class SourceWriter<DataType>
    implements DiskCache.Writer {
        private final DataType data;
        private final Encoder<DataType> encoder;

        public SourceWriter(Encoder<DataType> encoder, DataType DataType) {
            this.encoder = encoder;
            this.data = DataType;
        }

        /*
         * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
         * Loose catch block
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         * Lifted jumps to return sites
         */
        @Override
        public boolean write(File object) {
            Object object2;
            void var5_14;
            block14 : {
                block15 : {
                    boolean bl;
                    Object var6_5 = null;
                    object2 = null;
                    object = DecodeJob.this.fileOpener.open((File)object);
                    boolean bl2 = bl = this.encoder.encode(this.data, (OutputStream)object);
                    if (object == null) return bl2;
                    try {
                        object.close();
                        return bl;
                    }
                    catch (IOException iOException) {
                        return bl;
                    }
                    catch (Throwable throwable) {
                        object2 = object;
                        break block14;
                    }
                    catch (FileNotFoundException fileNotFoundException) {
                        break block15;
                    }
                    catch (Throwable throwable) {
                        break block14;
                    }
                    catch (FileNotFoundException fileNotFoundException) {
                        object = var6_5;
                    }
                }
                object2 = object;
                {
                    if (Log.isLoggable((String)DecodeJob.TAG, (int)3)) {
                        void var5_13;
                        object2 = object;
                        Log.d((String)DecodeJob.TAG, (String)"Failed to find file to write to disk cache", (Throwable)var5_13);
                    }
                    if (object == null) return false;
                }
                try {
                    object.close();
                    return false;
                }
                catch (IOException iOException) {}
            }
            if (object2 == null) throw var5_14;
            try {
                object2.close();
            }
            catch (IOException iOException) {
                throw var5_14;
            }
            throw var5_14;
            return false;
        }
    }

}

