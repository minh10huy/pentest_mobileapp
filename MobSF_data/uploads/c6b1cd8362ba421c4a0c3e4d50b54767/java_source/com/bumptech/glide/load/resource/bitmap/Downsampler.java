/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.annotation.TargetApi
 *  android.graphics.Bitmap
 *  android.graphics.Bitmap$Config
 *  android.graphics.BitmapFactory
 *  android.graphics.BitmapFactory$Options
 *  android.os.Build
 *  android.os.Build$VERSION
 *  android.util.Log
 */
package com.bumptech.glide.load.resource.bitmap;

import android.annotation.TargetApi;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.util.Log;
import com.bumptech.glide.load.DecodeFormat;
import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;
import com.bumptech.glide.load.resource.bitmap.BitmapDecoder;
import com.bumptech.glide.load.resource.bitmap.ImageHeaderParser;
import com.bumptech.glide.load.resource.bitmap.RecyclableBufferedInputStream;
import com.bumptech.glide.util.MarkEnforcingInputStream;
import com.bumptech.glide.util.Util;
import java.io.IOException;
import java.io.InputStream;
import java.util.EnumSet;
import java.util.Queue;
import java.util.Set;

public abstract class Downsampler
implements BitmapDecoder<InputStream> {
    public static final Downsampler AT_LEAST;
    public static final Downsampler AT_MOST;
    private static final int MARK_POSITION = 5242880;
    public static final Downsampler NONE;
    private static final Queue<BitmapFactory.Options> OPTIONS_QUEUE;
    private static final String TAG = "Downsampler";
    private static final Set<ImageHeaderParser.ImageType> TYPES_THAT_USE_POOL;

    static {
        TYPES_THAT_USE_POOL = EnumSet.of(ImageHeaderParser.ImageType.JPEG, ImageHeaderParser.ImageType.PNG_A, ImageHeaderParser.ImageType.PNG);
        OPTIONS_QUEUE = Util.createQueue(0);
        AT_LEAST = new Downsampler(){

            @Override
            public String getId() {
                return "AT_LEAST.com.bumptech.glide.load.data.bitmap";
            }

            @Override
            protected int getSampleSize(int n, int n2, int n3, int n4) {
                return Math.min(n2 / n4, n / n3);
            }
        };
        AT_MOST = new Downsampler(){

            @Override
            public String getId() {
                return "AT_MOST.com.bumptech.glide.load.data.bitmap";
            }

            @Override
            protected int getSampleSize(int n, int n2, int n3, int n4) {
                n3 = (int)Math.ceil(Math.max((float)n2 / (float)n4, (float)n / (float)n3));
                n2 = Integer.highestOneBit(n3);
                n = 1;
                if ((n2 = Math.max(1, n2)) >= n3) {
                    n = 0;
                }
                return n2 << n;
            }
        };
        NONE = new Downsampler(){

            @Override
            public String getId() {
                return "NONE.com.bumptech.glide.load.data.bitmap";
            }

            @Override
            protected int getSampleSize(int n, int n2, int n3, int n4) {
                return 0;
            }
        };
    }

    private static Bitmap decodeStream(MarkEnforcingInputStream markEnforcingInputStream, RecyclableBufferedInputStream recyclableBufferedInputStream, BitmapFactory.Options options) {
        block5 : {
            if (options.inJustDecodeBounds) {
                markEnforcingInputStream.mark(5242880);
            } else {
                recyclableBufferedInputStream.fixMarkLimit();
            }
            recyclableBufferedInputStream = BitmapFactory.decodeStream((InputStream)markEnforcingInputStream, null, (BitmapFactory.Options)options);
            try {
                if (options.inJustDecodeBounds) {
                    markEnforcingInputStream.reset();
                    return recyclableBufferedInputStream;
                }
            }
            catch (IOException iOException) {
                if (!Log.isLoggable((String)TAG, (int)6)) break block5;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Exception loading inDecodeBounds=");
                stringBuilder.append(options.inJustDecodeBounds);
                stringBuilder.append(" sample=");
                stringBuilder.append(options.inSampleSize);
                Log.e((String)TAG, (String)stringBuilder.toString(), (Throwable)iOException);
            }
        }
        return recyclableBufferedInputStream;
    }

    private Bitmap downsampleWithSize(MarkEnforcingInputStream markEnforcingInputStream, RecyclableBufferedInputStream recyclableBufferedInputStream, BitmapFactory.Options options, BitmapPool bitmapPool, int n, int n2, int n3, DecodeFormat decodeFormat) {
        decodeFormat = Downsampler.getConfig(markEnforcingInputStream, decodeFormat);
        options.inSampleSize = n3;
        options.inPreferredConfig = decodeFormat;
        if ((options.inSampleSize == 1 || 19 <= Build.VERSION.SDK_INT) && Downsampler.shouldUsePool(markEnforcingInputStream)) {
            double d = n;
            double d2 = n3;
            Downsampler.setInBitmap(options, bitmapPool.getDirty((int)Math.ceil(d / d2), (int)Math.ceil((double)n2 / d2), (Bitmap.Config)decodeFormat));
        }
        return Downsampler.decodeStream(markEnforcingInputStream, recyclableBufferedInputStream, options);
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private static Bitmap.Config getConfig(InputStream inputStream, DecodeFormat decodeFormat) {
        Throwable throwable2222;
        block13 : {
            boolean bl;
            block12 : {
                if (decodeFormat == DecodeFormat.ALWAYS_ARGB_8888) return Bitmap.Config.ARGB_8888;
                if (decodeFormat == DecodeFormat.PREFER_ARGB_8888) return Bitmap.Config.ARGB_8888;
                if (Build.VERSION.SDK_INT == 16) {
                    return Bitmap.Config.ARGB_8888;
                }
                boolean bl2 = false;
                inputStream.mark(1024);
                bl = new ImageHeaderParser(inputStream).hasAlpha();
                try {
                    inputStream.reset();
                }
                catch (IOException iOException) {
                    if (Log.isLoggable((String)TAG, (int)5)) {
                        Log.w((String)TAG, (String)"Cannot reset the input stream", (Throwable)iOException);
                    }
                    break block12;
                }
                {
                    block14 : {
                        catch (Throwable throwable2222) {
                            break block13;
                        }
                        catch (IOException iOException) {}
                        {
                            if (!Log.isLoggable((String)TAG, (int)5)) break block14;
                            StringBuilder stringBuilder = new StringBuilder();
                            stringBuilder.append("Cannot determine whether the image has alpha or not from header for format ");
                            stringBuilder.append((Object)decodeFormat);
                            Log.w((String)TAG, (String)stringBuilder.toString(), (Throwable)iOException);
                        }
                    }
                    try {
                        inputStream.reset();
                        bl = bl2;
                    }
                    catch (IOException iOException) {
                        bl = bl2;
                        if (!Log.isLoggable((String)TAG, (int)5)) break block12;
                        Log.w((String)TAG, (String)"Cannot reset the input stream", (Throwable)iOException);
                        bl = bl2;
                    }
                }
            }
            if (!bl) return Bitmap.Config.RGB_565;
            return Bitmap.Config.ARGB_8888;
        }
        try {
            inputStream.reset();
            throw throwable2222;
        }
        catch (IOException iOException) {
            if (!Log.isLoggable((String)TAG, (int)5)) throw throwable2222;
            Log.w((String)TAG, (String)"Cannot reset the input stream", (Throwable)iOException);
        }
        throw throwable2222;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @TargetApi(value=11)
    private static BitmapFactory.Options getDefaultOptions() {
        synchronized (Downsampler.class) {
            BitmapFactory.Options options;
            BitmapFactory.Options options2 = OPTIONS_QUEUE;
            synchronized (options2) {
                options = OPTIONS_QUEUE.poll();
            }
            options2 = options;
            if (options == null) {
                options2 = new BitmapFactory.Options();
                Downsampler.resetOptions(options2);
            }
            return options2;
        }
    }

    private int getRoundedSampleSize(int n, int n2, int n3, int n4, int n5) {
        int n6 = n5;
        if (n5 == Integer.MIN_VALUE) {
            n6 = n3;
        }
        n5 = n4;
        if (n4 == Integer.MIN_VALUE) {
            n5 = n2;
        }
        n = n != 90 && n != 270 ? this.getSampleSize(n2, n3, n5, n6) : this.getSampleSize(n3, n2, n5, n6);
        n = n == 0 ? 0 : Integer.highestOneBit(n);
        return Math.max(1, n);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private static void releaseOptions(BitmapFactory.Options options) {
        Downsampler.resetOptions(options);
        Queue<BitmapFactory.Options> queue = OPTIONS_QUEUE;
        synchronized (queue) {
            OPTIONS_QUEUE.offer(options);
            return;
        }
    }

    @TargetApi(value=11)
    private static void resetOptions(BitmapFactory.Options options) {
        options.inTempStorage = null;
        options.inDither = false;
        options.inScaled = false;
        options.inSampleSize = 1;
        options.inPreferredConfig = null;
        options.inJustDecodeBounds = false;
        options.outWidth = 0;
        options.outHeight = 0;
        options.outMimeType = null;
        if (11 <= Build.VERSION.SDK_INT) {
            options.inBitmap = null;
            options.inMutable = true;
        }
    }

    @TargetApi(value=11)
    private static void setInBitmap(BitmapFactory.Options options, Bitmap bitmap) {
        if (11 <= Build.VERSION.SDK_INT) {
            options.inBitmap = bitmap;
        }
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private static boolean shouldUsePool(InputStream inputStream) {
        Throwable throwable2222;
        if (19 <= Build.VERSION.SDK_INT) {
            return true;
        }
        inputStream.mark(1024);
        ImageHeaderParser.ImageType imageType = new ImageHeaderParser(inputStream).getType();
        boolean bl = TYPES_THAT_USE_POOL.contains((Object)imageType);
        try {
            inputStream.reset();
            return bl;
        }
        catch (IOException iOException) {
            if (!Log.isLoggable((String)TAG, (int)5)) return bl;
            Log.w((String)TAG, (String)"Cannot reset the input stream", (Throwable)iOException);
            return bl;
        }
        {
            block11 : {
                catch (Throwable throwable2222) {
                }
                catch (IOException iOException) {}
                {
                    if (!Log.isLoggable((String)TAG, (int)5)) break block11;
                    Log.w((String)TAG, (String)"Cannot determine the image type from header", (Throwable)iOException);
                }
            }
            try {
                inputStream.reset();
                return false;
            }
            catch (IOException iOException) {
                if (!Log.isLoggable((String)TAG, (int)5)) return false;
                Log.w((String)TAG, (String)"Cannot reset the input stream", (Throwable)iOException);
            }
            return false;
        }
        try {
            inputStream.reset();
            throw throwable2222;
        }
        catch (IOException iOException) {
            if (!Log.isLoggable((String)TAG, (int)5)) throw throwable2222;
            Log.w((String)TAG, (String)"Cannot reset the input stream", (Throwable)iOException);
        }
        throw throwable2222;
    }

    /*
     * Exception decompiling
     */
    @Override
    public Bitmap decode(InputStream var1_1, BitmapPool var2_11, int var3_13, int var4_14, DecodeFormat var5_15) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Started 2 blocks at once
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.getStartingBlocks(Op04StructuredStatement.java:393)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:471)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public int[] getDimensions(MarkEnforcingInputStream markEnforcingInputStream, RecyclableBufferedInputStream recyclableBufferedInputStream, BitmapFactory.Options options) {
        options.inJustDecodeBounds = true;
        Downsampler.decodeStream(markEnforcingInputStream, recyclableBufferedInputStream, options);
        options.inJustDecodeBounds = false;
        return new int[]{options.outWidth, options.outHeight};
    }

    protected abstract int getSampleSize(int var1, int var2, int var3, int var4);

}

