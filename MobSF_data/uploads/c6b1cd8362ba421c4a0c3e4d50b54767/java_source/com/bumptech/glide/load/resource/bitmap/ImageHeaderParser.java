/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.util.Log
 */
package com.bumptech.glide.load.resource.bitmap;

import android.util.Log;
import java.io.IOException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public class ImageHeaderParser {
    private static final int[] BYTES_PER_FORMAT;
    private static final int EXIF_MAGIC_NUMBER = 65496;
    private static final int EXIF_SEGMENT_TYPE = 225;
    private static final int GIF_HEADER = 4671814;
    private static final int INTEL_TIFF_MAGIC_NUMBER = 18761;
    private static final String JPEG_EXIF_SEGMENT_PREAMBLE = "Exif\u0000\u0000";
    private static final byte[] JPEG_EXIF_SEGMENT_PREAMBLE_BYTES;
    private static final int MARKER_EOI = 217;
    private static final int MOTOROLA_TIFF_MAGIC_NUMBER = 19789;
    private static final int ORIENTATION_TAG_TYPE = 274;
    private static final int PNG_HEADER = -1991225785;
    private static final int SEGMENT_SOS = 218;
    private static final int SEGMENT_START_ID = 255;
    private static final String TAG = "ImageHeaderParser";
    private final StreamReader streamReader;

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    static {
        byte[] arrby;
        BYTES_PER_FORMAT = new int[]{0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};
        arrby = new byte[]{};
        try {
            byte[] arrby2 = JPEG_EXIF_SEGMENT_PREAMBLE.getBytes("UTF-8");
            arrby = arrby2;
        }
        catch (UnsupportedEncodingException unsupportedEncodingException) {}
        JPEG_EXIF_SEGMENT_PREAMBLE_BYTES = arrby;
    }

    public ImageHeaderParser(InputStream inputStream) {
        this.streamReader = new StreamReader(inputStream);
    }

    private static int calcTagOffset(int n, int n2) {
        return n + 2 + n2 * 12;
    }

    private byte[] getExifSegment() throws IOException {
        Object object;
        int n;
        short s;
        block9 : {
            long l;
            long l2;
            do {
                if ((s = this.streamReader.getUInt8()) != 255) {
                    if (Log.isLoggable((String)TAG, (int)3)) {
                        object = new StringBuilder();
                        object.append("Unknown segmentId=");
                        object.append(s);
                        Log.d((String)TAG, (String)object.toString());
                    }
                    return null;
                }
                s = this.streamReader.getUInt8();
                if (s == 218) {
                    return null;
                }
                if (s == 217) {
                    if (Log.isLoggable((String)TAG, (int)3)) {
                        Log.d((String)TAG, (String)"Found MARKER_EOI in exif segment");
                    }
                    return null;
                }
                n = this.streamReader.getUInt16() - 2;
                if (s == 225) break block9;
            } while ((l2 = (object = this.streamReader).skip(l = (long)n)) == l);
            if (Log.isLoggable((String)TAG, (int)3)) {
                object = new StringBuilder();
                object.append("Unable to skip enough data, type: ");
                object.append(s);
                object.append(", wanted to skip: ");
                object.append(n);
                object.append(", but actually skipped: ");
                object.append(l2);
                Log.d((String)TAG, (String)object.toString());
            }
            return null;
        }
        object = new byte[n];
        int n2 = this.streamReader.read((byte[])object);
        if (n2 != n) {
            if (Log.isLoggable((String)TAG, (int)3)) {
                object = new StringBuilder();
                object.append("Unable to read segment data, type: ");
                object.append(s);
                object.append(", length: ");
                object.append(n);
                object.append(", actually read: ");
                object.append(n2);
                Log.d((String)TAG, (String)object.toString());
            }
            return null;
        }
        return object;
    }

    private static boolean handles(int n) {
        if ((n & 65496) != 65496 && n != 19789 && n != 18761) {
            return false;
        }
        return true;
    }

    private static int parseExifSegment(RandomAccessReader randomAccessReader) {
        Object object;
        int n = JPEG_EXIF_SEGMENT_PREAMBLE.length();
        int n2 = randomAccessReader.getInt16(n);
        if (n2 == 19789) {
            object = ByteOrder.BIG_ENDIAN;
        } else if (n2 == 18761) {
            object = ByteOrder.LITTLE_ENDIAN;
        } else {
            if (Log.isLoggable((String)TAG, (int)3)) {
                object = new StringBuilder();
                object.append("Unknown endianness = ");
                object.append(n2);
                Log.d((String)TAG, (String)object.toString());
            }
            object = ByteOrder.BIG_ENDIAN;
        }
        randomAccessReader.order((ByteOrder)object);
        n2 = randomAccessReader.getInt32(n + 4) + n;
        int n3 = randomAccessReader.getInt16(n2);
        for (n = 0; n < n3; ++n) {
            int n4 = ImageHeaderParser.calcTagOffset(n2, n);
            short s = randomAccessReader.getInt16(n4);
            if (s != 274) continue;
            short s2 = randomAccessReader.getInt16(n4 + 2);
            if (s2 >= 1 && s2 <= 12) {
                int n5 = randomAccessReader.getInt32(n4 + 4);
                if (n5 < 0) {
                    if (!Log.isLoggable((String)TAG, (int)3)) continue;
                    Log.d((String)TAG, (String)"Negative tiff component count");
                    continue;
                }
                if (Log.isLoggable((String)TAG, (int)3)) {
                    object = new StringBuilder();
                    object.append("Got tagIndex=");
                    object.append(n);
                    object.append(" tagType=");
                    object.append(s);
                    object.append(" formatCode=");
                    object.append(s2);
                    object.append(" componentCount=");
                    object.append(n5);
                    Log.d((String)TAG, (String)object.toString());
                }
                if ((n5 += BYTES_PER_FORMAT[s2]) > 4) {
                    if (!Log.isLoggable((String)TAG, (int)3)) continue;
                    object = new StringBuilder();
                    object.append("Got byte count > 4, not orientation, continuing, formatCode=");
                    object.append(s2);
                    Log.d((String)TAG, (String)object.toString());
                    continue;
                }
                if ((n4 += 8) >= 0 && n4 <= randomAccessReader.length()) {
                    if (n5 >= 0 && n5 + n4 <= randomAccessReader.length()) {
                        return randomAccessReader.getInt16(n4);
                    }
                    if (!Log.isLoggable((String)TAG, (int)3)) continue;
                    object = new StringBuilder();
                    object.append("Illegal number of bytes for TI tag data tagType=");
                    object.append(s);
                    Log.d((String)TAG, (String)object.toString());
                    continue;
                }
                if (!Log.isLoggable((String)TAG, (int)3)) continue;
                object = new StringBuilder();
                object.append("Illegal tagValueOffset=");
                object.append(n4);
                object.append(" tagType=");
                object.append(s);
                Log.d((String)TAG, (String)object.toString());
                continue;
            }
            if (!Log.isLoggable((String)TAG, (int)3)) continue;
            object = new StringBuilder();
            object.append("Got invalid format code=");
            object.append(s2);
            Log.d((String)TAG, (String)object.toString());
        }
        return -1;
    }

    public int getOrientation() throws IOException {
        if (!ImageHeaderParser.handles(this.streamReader.getUInt16())) {
            return -1;
        }
        byte[] arrby = this.getExifSegment();
        boolean bl = false;
        boolean bl2 = arrby != null && arrby.length > JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length;
        if (bl2) {
            for (int i = 0; i < JPEG_EXIF_SEGMENT_PREAMBLE_BYTES.length; ++i) {
                if (arrby[i] == JPEG_EXIF_SEGMENT_PREAMBLE_BYTES[i]) continue;
                bl2 = bl;
                break;
            }
        }
        if (bl2) {
            return ImageHeaderParser.parseExifSegment(new RandomAccessReader(arrby));
        }
        return -1;
    }

    public ImageType getType() throws IOException {
        int n = this.streamReader.getUInt16();
        if (n == 65496) {
            return ImageType.JPEG;
        }
        if ((n = n << 16 & -65536 | this.streamReader.getUInt16() & 65535) == -1991225785) {
            this.streamReader.skip(21L);
            if (this.streamReader.getByte() >= 3) {
                return ImageType.PNG_A;
            }
            return ImageType.PNG;
        }
        if (n >> 8 == 4671814) {
            return ImageType.GIF;
        }
        return ImageType.UNKNOWN;
    }

    public boolean hasAlpha() throws IOException {
        return this.getType().hasAlpha();
    }

    public static enum ImageType {
        GIF(true),
        JPEG(false),
        PNG_A(true),
        PNG(false),
        UNKNOWN(false);
        
        private final boolean hasAlpha;

        private ImageType(boolean bl) {
            this.hasAlpha = bl;
        }

        public boolean hasAlpha() {
            return this.hasAlpha;
        }
    }

    private static class RandomAccessReader {
        private final ByteBuffer data;

        public RandomAccessReader(byte[] arrby) {
            this.data = ByteBuffer.wrap(arrby);
            this.data.order(ByteOrder.BIG_ENDIAN);
        }

        public short getInt16(int n) {
            return this.data.getShort(n);
        }

        public int getInt32(int n) {
            return this.data.getInt(n);
        }

        public int length() {
            return this.data.array().length;
        }

        public void order(ByteOrder byteOrder) {
            this.data.order(byteOrder);
        }
    }

    private static class StreamReader {
        private final InputStream is;

        public StreamReader(InputStream inputStream) {
            this.is = inputStream;
        }

        public int getByte() throws IOException {
            return this.is.read();
        }

        public int getUInt16() throws IOException {
            return this.is.read() << 8 & 65280 | this.is.read() & 255;
        }

        public short getUInt8() throws IOException {
            return (short)(this.is.read() & 255);
        }

        public int read(byte[] arrby) throws IOException {
            int n;
            int n2;
            for (n2 = arrby.length; n2 > 0 && (n = this.is.read(arrby, arrby.length - n2, n2)) != -1; n2 -= n) {
            }
            return arrby.length - n2;
        }

        public long skip(long l) throws IOException {
            if (l < 0L) {
                return 0L;
            }
            long l2 = l;
            while (l2 > 0L) {
                long l3 = this.is.skip(l2);
                if (l3 > 0L) {
                    l2 -= l3;
                    continue;
                }
                if (this.is.read() == -1) break;
                --l2;
            }
            return l - l2;
        }
    }

}

