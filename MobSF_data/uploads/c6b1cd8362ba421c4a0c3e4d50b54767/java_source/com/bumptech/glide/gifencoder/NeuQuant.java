/*
 * Decompiled with CFR 0_132.
 */
package com.bumptech.glide.gifencoder;

class NeuQuant {
    protected static final int alphabiasshift = 10;
    protected static final int alpharadbias = 262144;
    protected static final int alpharadbshift = 18;
    protected static final int beta = 64;
    protected static final int betagamma = 65536;
    protected static final int betashift = 10;
    protected static final int gamma = 1024;
    protected static final int gammashift = 10;
    protected static final int initalpha = 1024;
    protected static final int initrad = 32;
    protected static final int initradius = 2048;
    protected static final int intbias = 65536;
    protected static final int intbiasshift = 16;
    protected static final int maxnetpos = 255;
    protected static final int minpicturebytes = 1509;
    protected static final int ncycles = 100;
    protected static final int netbiasshift = 4;
    protected static final int netsize = 256;
    protected static final int prime1 = 499;
    protected static final int prime2 = 491;
    protected static final int prime3 = 487;
    protected static final int prime4 = 503;
    protected static final int radbias = 256;
    protected static final int radbiasshift = 8;
    protected static final int radiusbias = 64;
    protected static final int radiusbiasshift = 6;
    protected static final int radiusdec = 30;
    protected int alphadec;
    protected int[] bias = new int[256];
    protected int[] freq = new int[256];
    protected int lengthcount;
    protected int[] netindex = new int[256];
    protected int[][] network;
    protected int[] radpower = new int[32];
    protected int samplefac;
    protected byte[] thepicture;

    public NeuQuant(byte[] arrby, int n, int n2) {
        this.thepicture = arrby;
        this.lengthcount = n;
        this.samplefac = n2;
        this.network = new int[256][];
        for (n = 0; n < 256; ++n) {
            this.network[n] = new int[4];
            arrby = this.network[n];
            arrby[2] = n2 = (n << 12) / 256;
            arrby[1] = n2;
            arrby[0] = n2;
            this.freq[n] = 256;
            this.bias[n] = 0;
        }
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected void alterneigh(int n, int n2, int n3, int n4, int n5) {
        int n6;
        int n7 = n6 = n2 - n;
        if (n6 < -1) {
            n7 = -1;
        }
        n6 = n = n2 + n;
        if (n > 256) {
            n6 = 256;
        }
        int n8 = n2 + 1;
        --n2;
        n = 1;
        do {
            if (n8 >= n6) {
                if (n2 <= n7) return;
            }
            int[] arrn = this.radpower;
            int n9 = n + 1;
            int n10 = arrn[n];
            n = n8;
            if (n8 < n6) {
                arrn = this.network[n8];
                try {
                    arrn[0] = arrn[0] - (arrn[0] - n3) * n10 / 262144;
                    arrn[1] = arrn[1] - (arrn[1] - n4) * n10 / 262144;
                    arrn[2] = arrn[2] - (arrn[2] - n5) * n10 / 262144;
                }
                catch (Exception exception) {}
                n = n8 + 1;
            }
            if (n2 > n7) {
                arrn = this.network[n2];
                arrn[0] = arrn[0] - (arrn[0] - n3) * n10 / 262144;
                arrn[1] = arrn[1] - (arrn[1] - n4) * n10 / 262144;
                arrn[2] = arrn[2] - n10 * (arrn[2] - n5) / 262144;
            } else {
                n8 = n;
                n = n9;
                continue;
                catch (Exception exception) {}
            }
            --n2;
            n8 = n;
            n = n9;
        } while (true);
    }

    protected void altersingle(int n, int n2, int n3, int n4, int n5) {
        int[] arrn = this.network[n2];
        arrn[0] = arrn[0] - (arrn[0] - n3) * n / 1024;
        arrn[1] = arrn[1] - (arrn[1] - n4) * n / 1024;
        arrn[2] = arrn[2] - n * (arrn[2] - n5) / 1024;
    }

    public byte[] colorMap() {
        byte[] arrby = new byte[768];
        int[] arrn = new int[256];
        int n = 0;
        while (n < 256) {
            arrn[this.network[n][3]] = n++;
        }
        n = 0;
        int n2 = 0;
        while (n < 256) {
            int n3 = arrn[n];
            int n4 = n2 + 1;
            arrby[n2] = (byte)this.network[n3][0];
            n2 = n4 + 1;
            arrby[n4] = (byte)this.network[n3][1];
            arrby[n2] = (byte)this.network[n3][2];
            ++n;
            ++n2;
        }
        return arrby;
    }

    protected int contest(int n, int n2, int n3) {
        int[] arrn;
        int n4 = -1;
        int n5 = -1;
        int n6 = Integer.MAX_VALUE;
        int n7 = Integer.MAX_VALUE;
        for (int i = 0; i < 256; ++i) {
            int n8;
            int n9;
            int n10;
            arrn = this.network[i];
            int n11 = n9 = arrn[0] - n;
            if (n9 < 0) {
                n11 = - n9;
            }
            n9 = n10 = arrn[1] - n2;
            if (n10 < 0) {
                n9 = - n10;
            }
            n10 = n8 = arrn[2] - n3;
            if (n8 < 0) {
                n10 = - n8;
            }
            n9 = n11 + n9 + n10;
            n11 = n6;
            if (n9 < n6) {
                n4 = i;
                n11 = n9;
            }
            n6 = n9 - (this.bias[i] >> 12);
            n9 = n7;
            if (n6 < n7) {
                n5 = i;
                n9 = n6;
            }
            n7 = this.freq[i] >> 10;
            arrn = this.freq;
            arrn[i] = arrn[i] - n7;
            arrn = this.bias;
            arrn[i] = arrn[i] + (n7 << 10);
            n6 = n11;
            n7 = n9;
        }
        arrn = this.freq;
        arrn[n4] = arrn[n4] + 64;
        arrn = this.bias;
        arrn[n4] = arrn[n4] - 65536;
        return n5;
    }

    public void inxbuild() {
        int n = 0;
        int n2 = 0;
        int n3 = 0;
        while (n < 256) {
            int[] arrn;
            int n4;
            int[] arrn2 = this.network[n];
            int n5 = arrn2[1];
            int n6 = n + 1;
            int n7 = n;
            for (n4 = n6; n4 < 256; ++n4) {
                arrn = this.network[n4];
                int n8 = n5;
                if (arrn[1] < n5) {
                    n8 = arrn[1];
                    n7 = n4;
                }
                n5 = n8;
            }
            arrn = this.network[n7];
            if (n != n7) {
                n4 = arrn[0];
                arrn[0] = arrn2[0];
                arrn2[0] = n4;
                n4 = arrn[1];
                arrn[1] = arrn2[1];
                arrn2[1] = n4;
                n4 = arrn[2];
                arrn[2] = arrn2[2];
                arrn2[2] = n4;
                n4 = arrn[3];
                arrn[3] = arrn2[3];
                arrn2[3] = n4;
            }
            n7 = n2;
            n4 = n3;
            if (n5 != n2) {
                this.netindex[n2] = n3 + n >> 1;
                while (++n2 < n5) {
                    this.netindex[n2] = n;
                }
                n4 = n;
                n7 = n5;
            }
            n = n6;
            n2 = n7;
            n3 = n4;
        }
        this.netindex[n2] = n3 + 255 >> 1;
        for (n = n2 + 1; n < 256; ++n) {
            this.netindex[n] = 255;
        }
    }

    public void learn() {
        int n;
        if (this.lengthcount < 1509) {
            this.samplefac = 1;
        }
        this.alphadec = (this.samplefac - 1) / 3 + 30;
        byte[] arrby = this.thepicture;
        int n2 = this.lengthcount;
        int n3 = this.lengthcount / (this.samplefac * 3);
        int n4 = n3 / 100;
        for (n = 0; n < 32; ++n) {
            this.radpower[n] = 1024 * ((1024 - n * n) * 256 / 1024);
        }
        n = this.lengthcount < 1509 ? 3 : (this.lengthcount % 499 != 0 ? 1497 : (this.lengthcount % 491 != 0 ? 1473 : (this.lengthcount % 487 != 0 ? 1461 : 1509)));
        int n5 = 0;
        int n6 = 0;
        int n7 = 1024;
        int n8 = 32;
        int n9 = 2048;
        while (n5 < n3) {
            int n10 = (arrby[n6 + 0] & 255) << 4;
            int n11 = (arrby[n6 + 1] & 255) << 4;
            int n12 = (arrby[n6 + 2] & 255) << 4;
            int n13 = this.contest(n10, n11, n12);
            this.altersingle(n7, n13, n10, n11, n12);
            if (n8 != 0) {
                this.alterneigh(n8, n13, n10, n11, n12);
            }
            n10 = n11 = n6 + n;
            if (n11 >= n2) {
                n10 = n11 - this.lengthcount;
            }
            n12 = n5 + 1;
            n11 = n4;
            if (n4 == 0) {
                n11 = 1;
            }
            n5 = n12;
            n6 = n10;
            n4 = n11;
            if (n12 % n11 != 0) continue;
            n8 = n7 - n7 / this.alphadec;
            n13 = n9 - n9 / 30;
            n9 = n7 = n13 >> 6;
            if (n7 <= 1) {
                n9 = 0;
            }
            for (n7 = 0; n7 < n9; ++n7) {
                int[] arrn = this.radpower;
                n4 = n9 * n9;
                arrn[n7] = (n4 - n7 * n7) * 256 / n4 * n8;
            }
            n5 = n12;
            n6 = n10;
            n7 = n8;
            n8 = n9;
            n4 = n11;
            n9 = n13;
        }
    }

    public int map(int n, int n2, int n3) {
        int n4 = this.netindex[n2];
        int n5 = n4 - 1;
        int n6 = -1;
        int n7 = 1000;
        while (n4 < 256 || n5 >= 0) {
            int n8;
            int[] arrn;
            int n9 = n4;
            int n10 = n6;
            int n11 = n7;
            if (n4 < 256) {
                arrn = this.network[n4];
                n11 = arrn[1] - n2;
                if (n11 >= n7) {
                    n9 = 256;
                    n10 = n6;
                    n11 = n7;
                } else {
                    ++n4;
                    n9 = n11;
                    if (n11 < 0) {
                        n9 = - n11;
                    }
                    n11 = n10 = arrn[0] - n;
                    if (n10 < 0) {
                        n11 = - n10;
                    }
                    n8 = n9 + n11;
                    n9 = n4;
                    n10 = n6;
                    n11 = n7;
                    if (n8 < n7) {
                        n9 = n11 = arrn[2] - n3;
                        if (n11 < 0) {
                            n9 = - n11;
                        }
                        n9 = n4;
                        n10 = n6;
                        n11 = n7;
                        if ((n8 += n9) < n7) {
                            n10 = arrn[3];
                            n11 = n8;
                            n9 = n4;
                        }
                    }
                }
            }
            n4 = n9;
            n6 = n10;
            n7 = n11;
            if (n5 < 0) continue;
            arrn = this.network[n5];
            n6 = n2 - arrn[1];
            if (n6 >= n11) {
                n5 = -1;
                n4 = n9;
                n6 = n10;
                n7 = n11;
                continue;
            }
            n8 = n5 - 1;
            n5 = n6;
            if (n6 < 0) {
                n5 = - n6;
            }
            n6 = n7 = arrn[0] - n;
            if (n7 < 0) {
                n6 = - n7;
            }
            int n12 = n5 + n6;
            n4 = n9;
            n5 = n8;
            n6 = n10;
            n7 = n11;
            if (n12 >= n11) continue;
            n5 = n6 = arrn[2] - n3;
            if (n6 < 0) {
                n5 = - n6;
            }
            n12 = n5 + n12;
            n4 = n9;
            n5 = n8;
            n6 = n10;
            n7 = n11;
            if (n12 >= n11) continue;
            n6 = arrn[3];
            n7 = n12;
            n4 = n9;
            n5 = n8;
        }
        return n6;
    }

    public byte[] process() {
        this.learn();
        this.unbiasnet();
        this.inxbuild();
        return this.colorMap();
    }

    public void unbiasnet() {
        int n = 0;
        while (n < 256) {
            int[] arrn = this.network[n];
            arrn[0] = arrn[0] >> 4;
            arrn = this.network[n];
            arrn[1] = arrn[1] >> 4;
            arrn = this.network[n];
            arrn[2] = arrn[2] >> 4;
            this.network[n][3] = n++;
        }
    }
}

