/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.annotation.TargetApi
 *  android.graphics.Bitmap
 *  android.graphics.Bitmap$Config
 *  android.os.Build
 *  android.os.Build$VERSION
 *  android.util.Log
 */
package com.bumptech.glide.gifdecoder;

import android.annotation.TargetApi;
import android.graphics.Bitmap;
import android.os.Build;
import android.util.Log;
import com.bumptech.glide.gifdecoder.GifFrame;
import com.bumptech.glide.gifdecoder.GifHeader;
import com.bumptech.glide.gifdecoder.GifHeaderParser;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

public class GifDecoder {
    private static final Bitmap.Config BITMAP_CONFIG = Bitmap.Config.ARGB_8888;
    private static final int DISPOSAL_BACKGROUND = 2;
    private static final int DISPOSAL_NONE = 1;
    private static final int DISPOSAL_PREVIOUS = 3;
    private static final int DISPOSAL_UNSPECIFIED = 0;
    private static final int INITIAL_FRAME_POINTER = -1;
    private static final int MAX_STACK_SIZE = 4096;
    private static final int NULL_CODE = -1;
    public static final int STATUS_FORMAT_ERROR = 1;
    public static final int STATUS_OK = 0;
    public static final int STATUS_OPEN_ERROR = 2;
    public static final int STATUS_PARTIAL_DECODE = 3;
    private static final String TAG = "GifDecoder";
    public static final int TOTAL_ITERATION_COUNT_FOREVER = 0;
    private int[] act;
    private BitmapProvider bitmapProvider;
    private final byte[] block = new byte[256];
    private byte[] data;
    private int framePointer;
    private GifHeader header;
    private byte[] mainPixels;
    private int[] mainScratch;
    private GifHeaderParser parser;
    private final int[] pct = new int[256];
    private byte[] pixelStack;
    private short[] prefix;
    private Bitmap previousImage;
    private ByteBuffer rawData;
    private boolean savePrevious;
    private int status;
    private byte[] suffix;

    public GifDecoder(BitmapProvider bitmapProvider) {
        this.bitmapProvider = bitmapProvider;
        this.header = new GifHeader();
    }

    /*
     * Enabled aggressive block sorting
     */
    private void decodeBitmapData(GifFrame arrby) {
        int n;
        int n2;
        if (arrby != null) {
            this.rawData.position(arrby.bufferFrameStart);
        }
        if (arrby == null) {
            n2 = this.header.width * this.header.height;
        } else {
            n = arrby.iw;
            n2 = arrby.ih * n;
        }
        if (this.mainPixels == null || this.mainPixels.length < n2) {
            this.mainPixels = new byte[n2];
        }
        if (this.prefix == null) {
            this.prefix = new short[4096];
        }
        if (this.suffix == null) {
            this.suffix = new byte[4096];
        }
        if (this.pixelStack == null) {
            this.pixelStack = new byte[4097];
        }
        n = this.read();
        int n3 = 1 << n;
        int n4 = n3 + 2;
        int n5 = n + 1;
        int n6 = (1 << n5) - 1;
        for (n = 0; n < n3; ++n) {
            this.prefix[n] = 0;
            this.suffix[n] = (byte)n;
        }
        int n7 = -1;
        int n8 = n5;
        int n9 = n4;
        int n10 = n6;
        int n11 = 0;
        int n12 = 0;
        n = 0;
        int n13 = 0;
        int n14 = 0;
        int n15 = 0;
        int n16 = 0;
        int n17 = 0;
        int n18 = -1;
        int n19 = n3;
        do {
            int n20;
            int n21;
            int n22;
            int n23;
            block29 : {
                block26 : {
                    block27 : {
                        block28 : {
                            n20 = n;
                            if (n11 >= n2) break block26;
                            n23 = 3;
                            n20 = n12;
                            if (n12 != 0) break block27;
                            n20 = this.readBlock();
                            if (n20 > 0) break block28;
                            this.status = 3;
                            n20 = n;
                            break block26;
                        }
                        n14 = 0;
                    }
                    n13 += (this.block[n14] & 255) << n15;
                    n21 = n14 + 1;
                    n22 = n20 + n7;
                    n15 += 8;
                    n14 = n16;
                    n16 = n18;
                    n12 = n;
                    n = n9;
                    n18 = n8;
                    n9 = n12;
                    n8 = n11;
                    n11 = n;
                    n12 = n7;
                    n20 = n23;
                    n7 = n19;
                    n = n5;
                    break block29;
                }
                do {
                    if (n20 >= n2) {
                        return;
                    }
                    this.mainPixels[n20] = 0;
                    ++n20;
                } while (true);
            }
            while (n15 >= n18) {
                block31 : {
                    block34 : {
                        block33 : {
                            block32 : {
                                block30 : {
                                    n12 = n13 & n10;
                                    n19 = n13 >> n18;
                                    n5 = n15 - n18;
                                    if (n12 != n7) break block30;
                                    n18 = n;
                                    n11 = n4;
                                    n10 = n6;
                                    n16 = -1;
                                    n12 = n7;
                                    n7 = n16;
                                    break block31;
                                }
                                if (n12 <= n11) break block32;
                                this.status = n20;
                                break block33;
                            }
                            if (n12 != n3 + 1) break block34;
                        }
                        n12 = -1;
                        n13 = n19;
                        n15 = n5;
                        break;
                    }
                    if (n16 == -1) {
                        this.pixelStack[n17] = this.suffix[n12];
                        n16 = n12;
                        ++n17;
                        n15 = n7;
                        n7 = n5;
                    } else {
                        byte by;
                        if (n12 >= n11) {
                            this.pixelStack[n17] = (byte)n14;
                            n14 = n16;
                            n15 = n17 + 1;
                            n17 = n5;
                        } else {
                            n14 = n12;
                            n15 = n17;
                            n17 = n5;
                        }
                        while (n14 >= n7) {
                            this.pixelStack[n15] = this.suffix[n14];
                            n14 = this.prefix[n14];
                            ++n15;
                        }
                        n20 = this.suffix[n14] & 255;
                        arrby = this.pixelStack;
                        arrby[n15] = by = (byte)n20;
                        n13 = n18;
                        n14 = n11;
                        n5 = n10;
                        if (n11 < 4096) {
                            this.prefix[n11] = (short)n16;
                            this.suffix[n11] = by;
                            if ((++n11 & n10) == 0) {
                                n13 = n18;
                                n14 = n11;
                                n5 = n10;
                                if (n11 < 4096) {
                                    n13 = n18 + 1;
                                    n5 = n10 + n11;
                                    n14 = n11;
                                }
                            } else {
                                n5 = n10;
                                n14 = n11;
                                n13 = n18;
                            }
                        }
                        n10 = n15 + 1;
                        while (n10 > 0) {
                            this.mainPixels[n9] = this.pixelStack[--n10];
                            ++n8;
                            ++n9;
                        }
                        n16 = n20;
                        n15 = n7;
                        n7 = n17;
                        n18 = n13;
                        n11 = n14;
                        n17 = n10;
                        n10 = n5;
                    }
                    n20 = 3;
                    n5 = n7;
                    n7 = n12;
                    n12 = n15;
                    n14 = n16;
                }
                n13 = -1;
                n15 = n5;
                n16 = n7;
                n7 = n12;
                n12 = n13;
                n13 = n19;
            }
            n20 = n16;
            n23 = n11;
            n16 = n14;
            n5 = n;
            n19 = n7;
            n7 = n12;
            n11 = n8;
            n12 = n22;
            n = n9;
            n14 = n21;
            n9 = n23;
            n8 = n18;
            n18 = n20;
        } while (true);
    }

    private GifHeaderParser getHeaderParser() {
        if (this.parser == null) {
            this.parser = new GifHeaderParser();
        }
        return this.parser;
    }

    private Bitmap getNextBitmap() {
        Bitmap bitmap;
        Bitmap bitmap2 = bitmap = this.bitmapProvider.obtain(this.header.width, this.header.height, BITMAP_CONFIG);
        if (bitmap == null) {
            bitmap2 = Bitmap.createBitmap((int)this.header.width, (int)this.header.height, (Bitmap.Config)BITMAP_CONFIG);
        }
        GifDecoder.setAlpha(bitmap2);
        return bitmap2;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private int read() {
        byte by;
        try {
            by = this.rawData.get();
        }
        catch (Exception exception) {}
        return by & 255;
        this.status = 1;
        return 0;
    }

    /*
     * Loose catch block
     * Enabled aggressive exception aggregation
     */
    private int readBlock() {
        int n;
        block4 : {
            int n2 = this.read();
            n = 0;
            int n3 = 0;
            if (n2 > 0) {
                do {
                    n = n3;
                    if (n3 >= n2) break block4;
                    n = n2 - n3;
                    this.rawData.get(this.block, n3, n);
                    n3 += n;
                } while (true);
                catch (Exception exception) {
                    Log.w((String)TAG, (String)"Error Reading Block", (Throwable)exception);
                    this.status = 1;
                    n = n3;
                }
            }
        }
        return n;
    }

    @TargetApi(value=12)
    private static void setAlpha(Bitmap bitmap) {
        if (Build.VERSION.SDK_INT >= 12) {
            bitmap.setHasAlpha(true);
        }
    }

    private Bitmap setPixels(GifFrame gifFrame, GifFrame gifFrame2) {
        int n;
        int[] arrn;
        int n2;
        int n3;
        int n4;
        int n5;
        int n6;
        int n7;
        int n8;
        int n9;
        block22 : {
            block23 : {
                block25 : {
                    block24 : {
                        n8 = this.header.width;
                        n6 = this.header.height;
                        arrn = this.mainScratch;
                        n5 = 0;
                        if (gifFrame2 == null) {
                            Arrays.fill(arrn, 0);
                        }
                        if (gifFrame2 == null || gifFrame2.dispose <= 0) break block22;
                        if (gifFrame2.dispose != 2) break block23;
                        if (gifFrame.transparency) break block24;
                        n2 = n9 = this.header.bgColor;
                        if (gifFrame.lct == null) break block25;
                        n2 = n9;
                        if (this.header.bgIndex != gifFrame.transIndex) break block25;
                    }
                    n2 = 0;
                }
                n4 = gifFrame2.iy * n8 + gifFrame2.ix;
                n7 = gifFrame2.ih;
                for (n9 = n4; n9 < n7 * n8 + n4; n9 += n8) {
                    n = gifFrame2.iw;
                    for (n3 = n9; n3 < n + n9; ++n3) {
                        arrn[n3] = n2;
                    }
                }
                break block22;
            }
            if (gifFrame2.dispose == 3 && this.previousImage != null) {
                this.previousImage.getPixels(arrn, 0, n8, 0, 0, n8, n6);
            }
        }
        this.decodeBitmapData(gifFrame);
        n3 = 0;
        n7 = 1;
        n4 = 8;
        while (n5 < gifFrame.ih) {
            if (gifFrame.interlace) {
                n = n7;
                n2 = n4;
                n9 = n3;
                if (n3 >= gifFrame.ih) {
                    n = n7 + 1;
                    switch (n) {
                        default: {
                            n2 = n4;
                            n9 = n3;
                            break;
                        }
                        case 4: {
                            n9 = 1;
                            n2 = 2;
                            break;
                        }
                        case 3: {
                            n9 = 2;
                            n2 = 4;
                            break;
                        }
                        case 2: {
                            n9 = 4;
                            n2 = n4;
                        }
                    }
                }
                n3 = n9 + n2;
                n7 = n;
                n4 = n2;
                n2 = n3;
            } else {
                n2 = n3;
                n9 = n5;
            }
            if ((n9 += gifFrame.iy) < this.header.height) {
                int n10 = n9 * this.header.width;
                n = gifFrame.ix + n10;
                n9 = n3 = gifFrame.iw + n;
                if (this.header.width + n10 < n3) {
                    n9 = this.header.width + n10;
                }
                n3 = gifFrame.iw * n5;
                while (n < n9) {
                    n10 = this.mainPixels[n3];
                    if ((n10 = this.act[n10 & 255]) != 0) {
                        arrn[n] = n10;
                    }
                    ++n;
                    ++n3;
                }
            }
            ++n5;
            n3 = n2;
        }
        if (this.savePrevious && (gifFrame.dispose == 0 || gifFrame.dispose == 1)) {
            if (this.previousImage == null) {
                this.previousImage = this.getNextBitmap();
            }
            this.previousImage.setPixels(arrn, 0, n8, 0, 0, n8, n6);
        }
        gifFrame = this.getNextBitmap();
        gifFrame.setPixels(arrn, 0, n8, 0, 0, n8, n6);
        return gifFrame;
    }

    public void advance() {
        this.framePointer = (this.framePointer + 1) % this.header.frameCount;
    }

    public void clear() {
        this.header = null;
        this.data = null;
        this.mainPixels = null;
        this.mainScratch = null;
        if (this.previousImage != null) {
            this.bitmapProvider.release(this.previousImage);
        }
        this.previousImage = null;
        this.rawData = null;
    }

    public int getCurrentFrameIndex() {
        return this.framePointer;
    }

    public byte[] getData() {
        return this.data;
    }

    public int getDelay(int n) {
        if (n >= 0 && n < this.header.frameCount) {
            return this.header.frames.get((int)n).delay;
        }
        return -1;
    }

    public int getFrameCount() {
        return this.header.frameCount;
    }

    public int getHeight() {
        return this.header.height;
    }

    @Deprecated
    public int getLoopCount() {
        if (this.header.loopCount == -1) {
            return 1;
        }
        return this.header.loopCount;
    }

    public int getNetscapeLoopCount() {
        return this.header.loopCount;
    }

    public int getNextDelay() {
        if (this.header.frameCount > 0 && this.framePointer >= 0) {
            return this.getDelay(this.framePointer);
        }
        return -1;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public Bitmap getNextFrame() {
        synchronized (this) {
            int[] arrn;
            Object object;
            if (this.header.frameCount <= 0 || this.framePointer < 0) {
                if (Log.isLoggable((String)TAG, (int)3)) {
                    object = TAG;
                    arrn = new int[]();
                    arrn.append("unable to decode frame, frameCount=");
                    arrn.append(this.header.frameCount);
                    arrn.append(" framePointer=");
                    arrn.append(this.framePointer);
                    Log.d((String)object, (String)arrn.toString());
                }
                this.status = 1;
            }
            if (this.status != 1 && this.status != 2) {
                this.status = 0;
                GifFrame gifFrame = this.header.frames.get(this.framePointer);
                int n = this.framePointer - 1;
                object = n >= 0 ? this.header.frames.get(n) : null;
                arrn = gifFrame.lct != null ? gifFrame.lct : this.header.gct;
                this.act = arrn;
                if (this.act == null) {
                    if (Log.isLoggable((String)TAG, (int)3)) {
                        Log.d((String)TAG, (String)"No Valid Color Table");
                    }
                    this.status = 1;
                    return null;
                }
                if (!gifFrame.transparency) return this.setPixels(gifFrame, (GifFrame)object);
                System.arraycopy(this.act, 0, this.pct, 0, this.act.length);
                this.act = this.pct;
                this.act[gifFrame.transIndex] = 0;
                return this.setPixels(gifFrame, (GifFrame)object);
            }
            if (!Log.isLoggable((String)TAG, (int)3)) return null;
            object = TAG;
            arrn = new StringBuilder();
            arrn.append("Unable to decode frame, status=");
            arrn.append(this.status);
            Log.d((String)object, (String)arrn.toString());
            return null;
        }
    }

    public int getStatus() {
        return this.status;
    }

    public int getTotalIterationCount() {
        if (this.header.loopCount == -1) {
            return 1;
        }
        if (this.header.loopCount == 0) {
            return 0;
        }
        return this.header.loopCount + 1;
    }

    public int getWidth() {
        return this.header.width;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public int read(InputStream inputStream, int n) {
        if (inputStream != null) {
            n = n > 0 ? (n += 4096) : 16384;
            try {
                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(n);
                byte[] arrby = new byte[16384];
                while ((n = inputStream.read(arrby, 0, arrby.length)) != -1) {
                    byteArrayOutputStream.write(arrby, 0, n);
                }
                byteArrayOutputStream.flush();
                this.read(byteArrayOutputStream.toByteArray());
            }
            catch (IOException iOException) {
                Log.w((String)TAG, (String)"Error reading data from stream", (Throwable)iOException);
            }
        } else {
            this.status = 2;
        }
        if (inputStream == null) return this.status;
        try {
            inputStream.close();
            return this.status;
        }
        catch (IOException iOException) {
            Log.w((String)TAG, (String)"Error closing stream", (Throwable)iOException);
        }
        return this.status;
    }

    public int read(byte[] object) {
        this.data = object;
        this.header = this.getHeaderParser().setData((byte[])object).parseHeader();
        if (object != null) {
            this.rawData = ByteBuffer.wrap((byte[])object);
            this.rawData.rewind();
            this.rawData.order(ByteOrder.LITTLE_ENDIAN);
            this.mainPixels = new byte[this.header.width * this.header.height];
            this.mainScratch = new int[this.header.width * this.header.height];
            this.savePrevious = false;
            object = this.header.frames.iterator();
            while (object.hasNext()) {
                if (((GifFrame)object.next()).dispose != 3) continue;
                this.savePrevious = true;
                break;
            }
        }
        return this.status;
    }

    public void resetFrameIndex() {
        this.framePointer = -1;
    }

    public void setData(GifHeader gifHeader, byte[] object) {
        this.header = gifHeader;
        this.data = object;
        this.status = 0;
        this.framePointer = -1;
        this.rawData = ByteBuffer.wrap((byte[])object);
        this.rawData.rewind();
        this.rawData.order(ByteOrder.LITTLE_ENDIAN);
        this.savePrevious = false;
        object = gifHeader.frames.iterator();
        while (object.hasNext()) {
            if (((GifFrame)object.next()).dispose != 3) continue;
            this.savePrevious = true;
            break;
        }
        this.mainPixels = new byte[gifHeader.width * gifHeader.height];
        this.mainScratch = new int[gifHeader.width * gifHeader.height];
    }

    public static interface BitmapProvider {
        public Bitmap obtain(int var1, int var2, Bitmap.Config var3);

        public void release(Bitmap var1);
    }

}

