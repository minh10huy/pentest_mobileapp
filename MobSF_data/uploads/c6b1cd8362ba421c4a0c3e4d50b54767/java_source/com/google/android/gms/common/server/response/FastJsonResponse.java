/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.os.Parcel
 *  android.util.Log
 */
package com.google.android.gms.common.server.response;

import android.os.Parcel;
import android.util.Log;
import com.google.android.gms.common.internal.Objects;
import com.google.android.gms.common.internal.Preconditions;
import com.google.android.gms.common.internal.safeparcel.AbstractSafeParcelable;
import com.google.android.gms.common.internal.safeparcel.SafeParcelWriter;
import com.google.android.gms.common.internal.safeparcel.SafeParcelable;
import com.google.android.gms.common.server.converter.ConverterWrapper;
import com.google.android.gms.common.server.response.FastParser;
import com.google.android.gms.common.server.response.FieldCreator;
import com.google.android.gms.common.server.response.FieldMappingDictionary;
import com.google.android.gms.common.server.response.PostProcessor;
import com.google.android.gms.common.server.response.SafeParcelResponse;
import com.google.android.gms.common.util.Base64Utils;
import com.google.android.gms.common.util.IOUtils;
import com.google.android.gms.common.util.JsonUtils;
import com.google.android.gms.common.util.MapUtils;
import com.google.android.gms.common.util.VisibleForTesting;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.zip.GZIPInputStream;

public abstract class FastJsonResponse {
    protected static final String QUOTE = "\"";
    private int zzwk;
    private byte[] zzwl;
    private boolean zzwm;

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static InputStream getUnzippedStream(byte[] object) {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream((byte[])object);
        if (!IOUtils.isGzipByteBuffer((byte[])object)) return byteArrayInputStream;
        try {
            return new GZIPInputStream(byteArrayInputStream);
        }
        catch (IOException iOException) {
            return byteArrayInputStream;
        }
    }

    private final <I, O> void zza(Field<I, O> object, I object2) {
        String string2 = object.getOutputFieldName();
        object2 = object.convert(object2);
        switch (object.getTypeOut()) {
            default: {
                int n = object.getTypeOut();
                object = new StringBuilder(44);
                object.append("Unsupported type for conversion: ");
                object.append(n);
                throw new IllegalStateException(object.toString());
            }
            case 8: 
            case 9: {
                if (!FastJsonResponse.zzb(string2, object2)) break;
                this.setDecodedBytesInternal((Field<?, ?>)object, string2, (byte[])object2);
                return;
            }
            case 7: {
                this.setStringInternal((Field<?, ?>)object, string2, (String)object2);
                return;
            }
            case 6: {
                if (!FastJsonResponse.zzb(string2, object2)) break;
                this.setBooleanInternal((Field<?, ?>)object, string2, (Boolean)object2);
                return;
            }
            case 5: {
                this.setBigDecimalInternal((Field<?, ?>)object, string2, (BigDecimal)object2);
                return;
            }
            case 4: {
                if (!FastJsonResponse.zzb(string2, object2)) break;
                this.setDoubleInternal((Field<?, ?>)object, string2, (Double)object2);
                return;
            }
            case 2: {
                if (!FastJsonResponse.zzb(string2, object2)) break;
                this.setLongInternal((Field<?, ?>)object, string2, (Long)object2);
                return;
            }
            case 1: {
                this.setBigIntegerInternal((Field<?, ?>)object, string2, (BigInteger)object2);
                return;
            }
            case 0: {
                if (!FastJsonResponse.zzb(string2, object2)) break;
                this.setIntegerInternal((Field<?, ?>)object, string2, (Integer)object2);
            }
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    private static void zza(StringBuilder stringBuilder, Field object, Object object2) {
        if (object.getTypeIn() == 11) {
            object = object.getConcreteType().cast(object2).toString();
        } else {
            if (object.getTypeIn() != 7) {
                stringBuilder.append(object2);
                return;
            }
            stringBuilder.append(QUOTE);
            stringBuilder.append(JsonUtils.escapeString((String)object2));
            object = QUOTE;
        }
        stringBuilder.append((String)object);
    }

    private static <O> boolean zzb(String string2, O object) {
        if (object == null) {
            if (Log.isLoggable((String)"FastJsonResponse", (int)6)) {
                object = new StringBuilder(String.valueOf(string2).length() + 58);
                object.append("Output field (");
                object.append(string2);
                object.append(") has a null value, but expected a primitive");
                Log.e((String)"FastJsonResponse", (String)object.toString());
            }
            return false;
        }
        return true;
    }

    public <T extends FastJsonResponse> void addConcreteType(String string2, T t) {
        throw new UnsupportedOperationException("Concrete type not supported");
    }

    public <T extends FastJsonResponse> void addConcreteTypeArray(String string2, ArrayList<T> arrayList) {
        throw new UnsupportedOperationException("Concrete type array not supported");
    }

    public <T extends FastJsonResponse> void addConcreteTypeArrayInternal(Field<?, ?> field, String string2, ArrayList<T> arrayList) {
        this.addConcreteTypeArray(string2, arrayList);
    }

    public <T extends FastJsonResponse> void addConcreteTypeInternal(Field<?, ?> field, String string2, T t) {
        this.addConcreteType(string2, t);
    }

    public HashMap<String, Object> getConcreteTypeArrays() {
        return null;
    }

    public HashMap<String, Object> getConcreteTypes() {
        return null;
    }

    public abstract Map<String, Field<?, ?>> getFieldMappings();

    protected Object getFieldValue(Field hashMap) {
        CharSequence charSequence = hashMap.getOutputFieldName();
        if (hashMap.getConcreteType() != null) {
            boolean bl = this.getValueObject(hashMap.getOutputFieldName()) == null;
            Preconditions.checkState(bl, "Concrete field shouldn't be value object: %s", hashMap.getOutputFieldName());
            hashMap = hashMap.isTypeOutArray() ? this.getConcreteTypeArrays() : this.getConcreteTypes();
            if (hashMap != null) {
                return hashMap.get(charSequence);
            }
            try {
                char c = Character.toUpperCase(charSequence.charAt(0));
                hashMap = charSequence.substring(1);
                charSequence = new StringBuilder(String.valueOf(hashMap).length() + 4);
                charSequence.append("get");
                charSequence.append(c);
                charSequence.append((String)((Object)hashMap));
                hashMap = charSequence.toString();
                hashMap = this.getClass().getMethod((String)((Object)hashMap), new Class[0]).invoke(this, new Object[0]);
                return hashMap;
            }
            catch (Exception exception) {
                throw new RuntimeException(exception);
            }
        }
        return this.getValueObject(hashMap.getOutputFieldName());
    }

    protected <O, I> I getOriginalValue(Field<I, O> field, Object object) {
        if (field.zzwo != null) {
            return field.convertBack(object);
        }
        return (I)object;
    }

    public PostProcessor<? extends FastJsonResponse> getPostProcessor() {
        return null;
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public byte[] getResponseBody() {
        Object object;
        Object object2;
        byte[] arrby;
        block15 : {
            block14 : {
                int n;
                Preconditions.checkState(this.zzwm);
                object2 = null;
                arrby = null;
                object = new GZIPInputStream(new ByteArrayInputStream(this.zzwl));
                arrby = new byte[4096];
                object2 = new ByteArrayOutputStream();
                while ((n = object.read(arrby, 0, 4096)) != -1) {
                    object2.write(arrby, 0, n);
                }
                object2.flush();
                arrby = object2.toByteArray();
                try {
                    object.close();
                    return arrby;
                }
                catch (IOException iOException) {
                    return arrby;
                }
                catch (Throwable throwable) {
                    break block14;
                }
                catch (IOException iOException) {
                    break block15;
                }
                catch (Throwable object3) {
                    object = arrby;
                    arrby = object3;
                }
            }
            if (object == null) throw arrby;
            try {
                object.close();
            }
            catch (IOException iOException) {
                throw arrby;
            }
            throw arrby;
            catch (IOException iOException) {
                object = object2;
            }
        }
        arrby = object;
        {
            object2 = this.zzwl;
            if (object == null) return object2;
        }
        try {
            object.close();
            return object2;
        }
        catch (IOException iOException) {
            return object2;
        }
    }

    public int getResponseCode() {
        Preconditions.checkState(this.zzwm);
        return this.zzwk;
    }

    protected abstract Object getValueObject(String var1);

    protected boolean isConcreteTypeArrayFieldSet(String string2) {
        throw new UnsupportedOperationException("Concrete type arrays not supported");
    }

    protected boolean isConcreteTypeFieldSet(String string2) {
        throw new UnsupportedOperationException("Concrete types not supported");
    }

    protected boolean isFieldSet(Field field) {
        if (field.getTypeOut() == 11) {
            if (field.isTypeOutArray()) {
                return this.isConcreteTypeArrayFieldSet(field.getOutputFieldName());
            }
            return this.isConcreteTypeFieldSet(field.getOutputFieldName());
        }
        return this.isPrimitiveFieldSet(field.getOutputFieldName());
    }

    protected abstract boolean isPrimitiveFieldSet(String var1);

    public <T extends FastJsonResponse> void parseNetworkResponse(int n, byte[] arrby) throws FastParser.ParseException {
        this.zzwk = n;
        this.zzwl = arrby;
        this.zzwm = true;
        InputStream inputStream = FastJsonResponse.getUnzippedStream(arrby);
        try {
            new FastParser<FastJsonResponse>().parse(inputStream, this);
            return;
        }
        finally {
            inputStream.close();
        }
    }

    public final <O> void setBigDecimal(Field<BigDecimal, O> field, BigDecimal bigDecimal) {
        if (field.zzwo != null) {
            this.zza(field, bigDecimal);
            return;
        }
        this.setBigDecimalInternal(field, field.getOutputFieldName(), bigDecimal);
    }

    protected void setBigDecimal(String string2, BigDecimal bigDecimal) {
        throw new UnsupportedOperationException("BigDecimal not supported");
    }

    protected void setBigDecimalInternal(Field<?, ?> field, String string2, BigDecimal bigDecimal) {
        this.setBigDecimal(string2, bigDecimal);
    }

    public final <O> void setBigDecimals(Field<ArrayList<BigDecimal>, O> field, ArrayList<BigDecimal> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setBigDecimalsInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setBigDecimals(String string2, ArrayList<BigDecimal> arrayList) {
        throw new UnsupportedOperationException("BigDecimal list not supported");
    }

    protected void setBigDecimalsInternal(Field<?, ?> field, String string2, ArrayList<BigDecimal> arrayList) {
        this.setBigDecimals(string2, arrayList);
    }

    public final <O> void setBigInteger(Field<BigInteger, O> field, BigInteger bigInteger) {
        if (field.zzwo != null) {
            this.zza(field, bigInteger);
            return;
        }
        this.setBigIntegerInternal(field, field.getOutputFieldName(), bigInteger);
    }

    protected void setBigInteger(String string2, BigInteger bigInteger) {
        throw new UnsupportedOperationException("BigInteger not supported");
    }

    protected void setBigIntegerInternal(Field<?, ?> field, String string2, BigInteger bigInteger) {
        this.setBigInteger(string2, bigInteger);
    }

    public final <O> void setBigIntegers(Field<ArrayList<BigInteger>, O> field, ArrayList<BigInteger> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setBigIntegersInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setBigIntegers(String string2, ArrayList<BigInteger> arrayList) {
        throw new UnsupportedOperationException("BigInteger list not supported");
    }

    protected void setBigIntegersInternal(Field<?, ?> field, String string2, ArrayList<BigInteger> arrayList) {
        this.setBigIntegers(string2, arrayList);
    }

    public final <O> void setBoolean(Field<Boolean, O> field, boolean bl) {
        if (field.zzwo != null) {
            this.zza(field, bl);
            return;
        }
        this.setBooleanInternal(field, field.getOutputFieldName(), bl);
    }

    protected void setBoolean(String string2, boolean bl) {
        throw new UnsupportedOperationException("Boolean not supported");
    }

    protected void setBooleanInternal(Field<?, ?> field, String string2, boolean bl) {
        this.setBoolean(string2, bl);
    }

    public final <O> void setBooleans(Field<ArrayList<Boolean>, O> field, ArrayList<Boolean> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setBooleansInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setBooleans(String string2, ArrayList<Boolean> arrayList) {
        throw new UnsupportedOperationException("Boolean list not supported");
    }

    protected void setBooleansInternal(Field<?, ?> field, String string2, ArrayList<Boolean> arrayList) {
        this.setBooleans(string2, arrayList);
    }

    public final <O> void setDecodedBytes(Field<byte[], O> field, byte[] arrby) {
        if (field.zzwo != null) {
            this.zza(field, arrby);
            return;
        }
        this.setDecodedBytesInternal(field, field.getOutputFieldName(), arrby);
    }

    protected void setDecodedBytes(String string2, byte[] arrby) {
        throw new UnsupportedOperationException("byte[] not supported");
    }

    protected void setDecodedBytesInternal(Field<?, ?> field, String string2, byte[] arrby) {
        this.setDecodedBytes(string2, arrby);
    }

    public final <O> void setDouble(Field<Double, O> field, double d) {
        if (field.zzwo != null) {
            this.zza(field, d);
            return;
        }
        this.setDoubleInternal(field, field.getOutputFieldName(), d);
    }

    protected void setDouble(String string2, double d) {
        throw new UnsupportedOperationException("Double not supported");
    }

    protected void setDoubleInternal(Field<?, ?> field, String string2, double d) {
        this.setDouble(string2, d);
    }

    public final <O> void setDoubles(Field<ArrayList<Double>, O> field, ArrayList<Double> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setDoublesInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setDoubles(String string2, ArrayList<Double> arrayList) {
        throw new UnsupportedOperationException("Double list not supported");
    }

    protected void setDoublesInternal(Field<?, ?> field, String string2, ArrayList<Double> arrayList) {
        this.setDoubles(string2, arrayList);
    }

    public final <O> void setFloat(Field<Float, O> field, float f) {
        if (field.zzwo != null) {
            this.zza(field, Float.valueOf(f));
            return;
        }
        this.setFloatInternal(field, field.getOutputFieldName(), f);
    }

    protected void setFloat(String string2, float f) {
        throw new UnsupportedOperationException("Float not supported");
    }

    protected void setFloatInternal(Field<?, ?> field, String string2, float f) {
        this.setFloat(string2, f);
    }

    public final <O> void setFloats(Field<ArrayList<Float>, O> field, ArrayList<Float> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setFloatsInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setFloats(String string2, ArrayList<Float> arrayList) {
        throw new UnsupportedOperationException("Float list not supported");
    }

    protected void setFloatsInternal(Field<?, ?> field, String string2, ArrayList<Float> arrayList) {
        this.setFloats(string2, arrayList);
    }

    public final <O> void setInteger(Field<Integer, O> field, int n) {
        if (field.zzwo != null) {
            this.zza(field, n);
            return;
        }
        this.setIntegerInternal(field, field.getOutputFieldName(), n);
    }

    protected void setInteger(String string2, int n) {
        throw new UnsupportedOperationException("Integer not supported");
    }

    protected void setIntegerInternal(Field<?, ?> field, String string2, int n) {
        this.setInteger(string2, n);
    }

    public final <O> void setIntegers(Field<ArrayList<Integer>, O> field, ArrayList<Integer> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setIntegersInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setIntegers(String string2, ArrayList<Integer> arrayList) {
        throw new UnsupportedOperationException("Integer list not supported");
    }

    protected void setIntegersInternal(Field<?, ?> field, String string2, ArrayList<Integer> arrayList) {
        this.setIntegers(string2, arrayList);
    }

    public final <O> void setLong(Field<Long, O> field, long l) {
        if (field.zzwo != null) {
            this.zza(field, l);
            return;
        }
        this.setLongInternal(field, field.getOutputFieldName(), l);
    }

    protected void setLong(String string2, long l) {
        throw new UnsupportedOperationException("Long not supported");
    }

    protected void setLongInternal(Field<?, ?> field, String string2, long l) {
        this.setLong(string2, l);
    }

    public final <O> void setLongs(Field<ArrayList<Long>, O> field, ArrayList<Long> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setLongsInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setLongs(String string2, ArrayList<Long> arrayList) {
        throw new UnsupportedOperationException("Long list not supported");
    }

    protected void setLongsInternal(Field<?, ?> field, String string2, ArrayList<Long> arrayList) {
        this.setLongs(string2, arrayList);
    }

    public final <O> void setString(Field<String, O> field, String string2) {
        if (field.zzwo != null) {
            this.zza(field, string2);
            return;
        }
        this.setStringInternal(field, field.getOutputFieldName(), string2);
    }

    protected void setString(String string2, String string3) {
        throw new UnsupportedOperationException("String not supported");
    }

    protected void setStringInternal(Field<?, ?> field, String string2, String string3) {
        this.setString(string2, string3);
    }

    public final <O> void setStringMap(Field<Map<String, String>, O> field, Map<String, String> map) {
        if (field.zzwo != null) {
            this.zza(field, map);
            return;
        }
        this.setStringMapInternal(field, field.getOutputFieldName(), map);
    }

    protected void setStringMap(String string2, Map<String, String> map) {
        throw new UnsupportedOperationException("String map not supported");
    }

    protected void setStringMapInternal(Field<?, ?> field, String string2, Map<String, String> map) {
        this.setStringMap(string2, map);
    }

    public final <O> void setStrings(Field<ArrayList<String>, O> field, ArrayList<String> arrayList) {
        if (field.zzwo != null) {
            this.zza(field, arrayList);
            return;
        }
        this.setStringsInternal(field, field.getOutputFieldName(), arrayList);
    }

    protected void setStrings(String string2, ArrayList<String> arrayList) {
        throw new UnsupportedOperationException("String list not supported");
    }

    protected void setStringsInternal(Field<?, ?> field, String string2, ArrayList<String> arrayList) {
        this.setStrings(string2, arrayList);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public String toString() {
        var5_1 = this.getFieldMappings();
        var4_2 = new StringBuilder(100);
        block5 : for (String var8_9 : var5_1.keySet()) {
            block11 : {
                block10 : {
                    block9 : {
                        var7_7 = var5_1.get(var8_9);
                        if (!this.isFieldSet(var7_7)) continue;
                        var9_11 = this.getOriginalValue(var7_7, this.getFieldValue(var7_7));
                        var3_6 = var4_2.length() == 0 ? "{" : ",";
                        var4_2.append((String)var3_6);
                        var4_2.append("\"");
                        var4_2.append(var8_9);
                        var4_2.append("\":");
                        if (var9_11 != null) break block9;
                        var3_6 = "null";
                        break block10;
                    }
                    switch (var7_7.getTypeOut()) {
                        default: {
                            if (var7_7.isTypeInArray()) {
                                var3_6 = (ArrayList)var9_11;
                                var4_2.append("[");
                                var2_5 = var3_6.size();
                                break;
                            }
                            break block11;
                        }
                        case 10: {
                            MapUtils.writeStringMapToJson(var4_2, (HashMap)var9_11);
                            continue block5;
                        }
                        case 9: {
                            var4_2.append("\"");
                            var3_6 = Base64Utils.encodeUrlSafe((byte[])var9_11);
                            ** break;
                        }
                        case 8: {
                            var4_2.append("\"");
                            var3_6 = Base64Utils.encode((byte[])var9_11);
lbl34: // 2 sources:
                            var4_2.append((String)var3_6);
                            var3_6 = "\"";
                            break block10;
                        }
                    }
                    for (var1_4 = 0; var1_4 < var2_5; ++var1_4) {
                        if (var1_4 > 0) {
                            var4_2.append(",");
                        }
                        if ((var8_10 = var3_6.get(var1_4)) == null) continue;
                        FastJsonResponse.zza(var4_2, var7_7, var8_10);
                    }
                    var3_6 = "]";
                }
                var4_2.append((String)var3_6);
                continue;
            }
            FastJsonResponse.zza(var4_2, var7_7, var9_11);
        }
        var3_6 = var4_2.length() > 0 ? "}" : "{}";
        var4_2.append((String)var3_6);
        return var4_2.toString();
    }

    @SafeParcelable.Class(creator="FieldCreator")
    @VisibleForTesting
    public static class Field<I, O>
    extends AbstractSafeParcelable {
        public static final FieldCreator CREATOR = new FieldCreator();
        protected final Class<? extends FastJsonResponse> mConcreteType;
        @SafeParcelable.Field(getter="getConcreteTypeName", id=8)
        protected final String mConcreteTypeName;
        @SafeParcelable.Field(getter="getOutputFieldName", id=6)
        protected final String mOutputFieldName;
        @SafeParcelable.Field(getter="getSafeParcelableFieldId", id=7)
        protected final int mSafeParcelableFieldId;
        @SafeParcelable.Field(getter="getTypeIn", id=2)
        protected final int mTypeIn;
        @SafeParcelable.Field(getter="isTypeInArray", id=3)
        protected final boolean mTypeInArray;
        @SafeParcelable.Field(getter="getTypeOut", id=4)
        protected final int mTypeOut;
        @SafeParcelable.Field(getter="isTypeOutArray", id=5)
        protected final boolean mTypeOutArray;
        @SafeParcelable.VersionField(getter="getVersionCode", id=1)
        private final int zzal;
        private FieldMappingDictionary zzwn;
        @SafeParcelable.Field(getter="getWrappedConverter", id=9, type="com.google.android.gms.common.server.converter.ConverterWrapper")
        private FieldConverter<I, O> zzwo;

        @SafeParcelable.Constructor
        Field(@SafeParcelable.Param(id=1) int n, @SafeParcelable.Param(id=2) int n2, @SafeParcelable.Param(id=3) boolean bl, @SafeParcelable.Param(id=4) int n3, @SafeParcelable.Param(id=5) boolean bl2, @SafeParcelable.Param(id=6) String string2, @SafeParcelable.Param(id=7) int n4, @SafeParcelable.Param(id=8) String string3, @SafeParcelable.Param(id=9) ConverterWrapper converterWrapper) {
            this.zzal = n;
            this.mTypeIn = n2;
            this.mTypeInArray = bl;
            this.mTypeOut = n3;
            this.mTypeOutArray = bl2;
            this.mOutputFieldName = string2;
            this.mSafeParcelableFieldId = n4;
            if (string3 == null) {
                this.mConcreteType = null;
                this.mConcreteTypeName = null;
            } else {
                this.mConcreteType = SafeParcelResponse.class;
                this.mConcreteTypeName = string3;
            }
            if (converterWrapper == null) {
                this.zzwo = null;
                return;
            }
            this.zzwo = converterWrapper.unwrap();
        }

        /*
         * Enabled aggressive block sorting
         */
        protected Field(int n, boolean bl, int n2, boolean bl2, String string2, int n3, Class<? extends FastJsonResponse> class_, FieldConverter<I, O> fieldConverter) {
            this.zzal = 1;
            this.mTypeIn = n;
            this.mTypeInArray = bl;
            this.mTypeOut = n2;
            this.mTypeOutArray = bl2;
            this.mOutputFieldName = string2;
            this.mSafeParcelableFieldId = n3;
            this.mConcreteType = class_;
            string2 = class_ == null ? null : class_.getCanonicalName();
            this.mConcreteTypeName = string2;
            this.zzwo = fieldConverter;
        }

        public static Field<byte[], byte[]> forBase64(String string2) {
            return new Field<byte[], byte[]>(8, false, 8, false, string2, -1, null, null);
        }

        @VisibleForTesting
        public static Field<byte[], byte[]> forBase64(String string2, int n) {
            return new Field<byte[], byte[]>(8, false, 8, false, string2, n, null, null);
        }

        @VisibleForTesting
        public static Field<byte[], byte[]> forBase64UrlSafe(String string2) {
            return new Field<byte[], byte[]>(9, false, 9, false, string2, -1, null, null);
        }

        @VisibleForTesting
        public static Field<byte[], byte[]> forBase64UrlSafe(String string2, int n) {
            return new Field<byte[], byte[]>(9, false, 9, false, string2, n, null, null);
        }

        public static Field<BigDecimal, BigDecimal> forBigDecimal(String string2) {
            return new Field<BigDecimal, BigDecimal>(5, false, 5, false, string2, -1, null, null);
        }

        @VisibleForTesting
        public static Field<BigDecimal, BigDecimal> forBigDecimal(String string2, int n) {
            return new Field<BigDecimal, BigDecimal>(5, false, 5, false, string2, n, null, null);
        }

        public static Field<ArrayList<BigDecimal>, ArrayList<BigDecimal>> forBigDecimals(String string2) {
            return new Field<ArrayList<BigDecimal>, ArrayList<BigDecimal>>(5, true, 5, true, string2, -1, null, null);
        }

        public static Field<ArrayList<BigDecimal>, ArrayList<BigDecimal>> forBigDecimals(String string2, int n) {
            return new Field<ArrayList<BigDecimal>, ArrayList<BigDecimal>>(5, true, 5, true, string2, n, null, null);
        }

        public static Field<BigInteger, BigInteger> forBigInteger(String string2) {
            return new Field<BigInteger, BigInteger>(1, false, 1, false, string2, -1, null, null);
        }

        public static Field<BigInteger, BigInteger> forBigInteger(String string2, int n) {
            return new Field<BigInteger, BigInteger>(1, false, 1, false, string2, n, null, null);
        }

        public static Field<ArrayList<BigInteger>, ArrayList<BigInteger>> forBigIntegers(String string2) {
            return new Field<ArrayList<BigInteger>, ArrayList<BigInteger>>(0, true, 1, true, string2, -1, null, null);
        }

        public static Field<ArrayList<BigInteger>, ArrayList<BigInteger>> forBigIntegers(String string2, int n) {
            return new Field<ArrayList<BigInteger>, ArrayList<BigInteger>>(0, true, 1, true, string2, n, null, null);
        }

        public static Field<Boolean, Boolean> forBoolean(String string2) {
            return new Field<Boolean, Boolean>(6, false, 6, false, string2, -1, null, null);
        }

        public static Field<Boolean, Boolean> forBoolean(String string2, int n) {
            return new Field<Boolean, Boolean>(6, false, 6, false, string2, n, null, null);
        }

        public static Field<ArrayList<Boolean>, ArrayList<Boolean>> forBooleans(String string2) {
            return new Field<ArrayList<Boolean>, ArrayList<Boolean>>(6, true, 6, true, string2, -1, null, null);
        }

        public static Field<ArrayList<Boolean>, ArrayList<Boolean>> forBooleans(String string2, int n) {
            return new Field<ArrayList<Boolean>, ArrayList<Boolean>>(6, true, 6, true, string2, n, null, null);
        }

        public static <T extends FastJsonResponse> Field<T, T> forConcreteType(String string2, int n, Class<T> class_) {
            return new Field<I, O>(11, false, 11, false, string2, n, class_, null);
        }

        public static <T extends FastJsonResponse> Field<T, T> forConcreteType(String string2, Class<T> class_) {
            return new Field<I, O>(11, false, 11, false, string2, -1, class_, null);
        }

        public static <T extends FastJsonResponse> Field<ArrayList<T>, ArrayList<T>> forConcreteTypeArray(String string2, int n, Class<T> class_) {
            return new Field<ArrayList<T>, ArrayList<T>>(11, true, 11, true, string2, n, class_, null);
        }

        public static <T extends FastJsonResponse> Field<ArrayList<T>, ArrayList<T>> forConcreteTypeArray(String string2, Class<T> class_) {
            return new Field<ArrayList<T>, ArrayList<T>>(11, true, 11, true, string2, -1, class_, null);
        }

        public static Field<Double, Double> forDouble(String string2) {
            return new Field<Double, Double>(4, false, 4, false, string2, -1, null, null);
        }

        public static Field<Double, Double> forDouble(String string2, int n) {
            return new Field<Double, Double>(4, false, 4, false, string2, n, null, null);
        }

        public static Field<ArrayList<Double>, ArrayList<Double>> forDoubles(String string2) {
            return new Field<ArrayList<Double>, ArrayList<Double>>(4, true, 4, true, string2, -1, null, null);
        }

        public static Field<ArrayList<Double>, ArrayList<Double>> forDoubles(String string2, int n) {
            return new Field<ArrayList<Double>, ArrayList<Double>>(4, true, 4, true, string2, n, null, null);
        }

        public static Field<Float, Float> forFloat(String string2) {
            return new Field<Float, Float>(3, false, 3, false, string2, -1, null, null);
        }

        public static Field<Float, Float> forFloat(String string2, int n) {
            return new Field<Float, Float>(3, false, 3, false, string2, n, null, null);
        }

        public static Field<ArrayList<Float>, ArrayList<Float>> forFloats(String string2) {
            return new Field<ArrayList<Float>, ArrayList<Float>>(3, true, 3, true, string2, -1, null, null);
        }

        public static Field<ArrayList<Float>, ArrayList<Float>> forFloats(String string2, int n) {
            return new Field<ArrayList<Float>, ArrayList<Float>>(3, true, 3, true, string2, n, null, null);
        }

        public static Field<Integer, Integer> forInteger(String string2) {
            return new Field<Integer, Integer>(0, false, 0, false, string2, -1, null, null);
        }

        @VisibleForTesting
        public static Field<Integer, Integer> forInteger(String string2, int n) {
            return new Field<Integer, Integer>(0, false, 0, false, string2, n, null, null);
        }

        public static Field<ArrayList<Integer>, ArrayList<Integer>> forIntegers(String string2) {
            return new Field<ArrayList<Integer>, ArrayList<Integer>>(0, true, 0, true, string2, -1, null, null);
        }

        @VisibleForTesting
        public static Field<ArrayList<Integer>, ArrayList<Integer>> forIntegers(String string2, int n) {
            return new Field<ArrayList<Integer>, ArrayList<Integer>>(0, true, 0, true, string2, n, null, null);
        }

        @VisibleForTesting
        public static Field<Long, Long> forLong(String string2) {
            return new Field<Long, Long>(2, false, 2, false, string2, -1, null, null);
        }

        public static Field<Long, Long> forLong(String string2, int n) {
            return new Field<Long, Long>(2, false, 2, false, string2, n, null, null);
        }

        @VisibleForTesting
        public static Field<ArrayList<Long>, ArrayList<Long>> forLongs(String string2) {
            return new Field<ArrayList<Long>, ArrayList<Long>>(2, true, 2, true, string2, -1, null, null);
        }

        public static Field<ArrayList<Long>, ArrayList<Long>> forLongs(String string2, int n) {
            return new Field<ArrayList<Long>, ArrayList<Long>>(2, true, 2, true, string2, n, null, null);
        }

        public static Field<String, String> forString(String string2) {
            return new Field<String, String>(7, false, 7, false, string2, -1, null, null);
        }

        public static Field<String, String> forString(String string2, int n) {
            return new Field<String, String>(7, false, 7, false, string2, n, null, null);
        }

        public static Field<HashMap<String, String>, HashMap<String, String>> forStringMap(String string2) {
            return new Field<HashMap<String, String>, HashMap<String, String>>(10, false, 10, false, string2, -1, null, null);
        }

        public static Field<HashMap<String, String>, HashMap<String, String>> forStringMap(String string2, int n) {
            return new Field<HashMap<String, String>, HashMap<String, String>>(10, false, 10, false, string2, n, null, null);
        }

        public static Field<ArrayList<String>, ArrayList<String>> forStrings(String string2) {
            return new Field<ArrayList<String>, ArrayList<String>>(7, true, 7, true, string2, -1, null, null);
        }

        public static Field<ArrayList<String>, ArrayList<String>> forStrings(String string2, int n) {
            return new Field<ArrayList<String>, ArrayList<String>>(7, true, 7, true, string2, n, null, null);
        }

        public static Field withConverter(String string2, int n, FieldConverter<?, ?> fieldConverter, boolean bl) {
            return new Field(fieldConverter.getTypeIn(), bl, fieldConverter.getTypeOut(), false, string2, n, null, fieldConverter);
        }

        public static <T extends FieldConverter> Field withConverter(String object, int n, Class<T> class_, boolean bl) {
            try {
                object = Field.withConverter((String)object, n, (FieldConverter)class_.newInstance(), bl);
                return object;
            }
            catch (IllegalAccessException illegalAccessException) {
                throw new RuntimeException(illegalAccessException);
            }
            catch (InstantiationException instantiationException) {
                throw new RuntimeException(instantiationException);
            }
        }

        public static Field withConverter(String string2, FieldConverter<?, ?> fieldConverter, boolean bl) {
            return Field.withConverter(string2, -1, fieldConverter, bl);
        }

        public static <T extends FieldConverter> Field withConverter(String string2, Class<T> class_, boolean bl) {
            return Field.withConverter(string2, -1, class_, bl);
        }

        private final String zzcz() {
            if (this.mConcreteTypeName == null) {
                return null;
            }
            return this.mConcreteTypeName;
        }

        private final ConverterWrapper zzda() {
            if (this.zzwo == null) {
                return null;
            }
            return ConverterWrapper.wrap(this.zzwo);
        }

        public O convert(I i) {
            return this.zzwo.convert(i);
        }

        public I convertBack(O o) {
            return this.zzwo.convertBack(o);
        }

        public Field<I, O> copyForDictionary() {
            return new Field<I, O>(this.zzal, this.mTypeIn, this.mTypeInArray, this.mTypeOut, this.mTypeOutArray, this.mOutputFieldName, this.mSafeParcelableFieldId, this.mConcreteTypeName, this.zzda());
        }

        public Class<? extends FastJsonResponse> getConcreteType() {
            return this.mConcreteType;
        }

        public Map<String, Field<?, ?>> getConcreteTypeFieldMappingFromDictionary() {
            Preconditions.checkNotNull(this.mConcreteTypeName);
            Preconditions.checkNotNull(this.zzwn);
            return this.zzwn.getFieldMapping(this.mConcreteTypeName);
        }

        public String getOutputFieldName() {
            return this.mOutputFieldName;
        }

        public int getSafeParcelableFieldId() {
            return this.mSafeParcelableFieldId;
        }

        public int getTypeIn() {
            return this.mTypeIn;
        }

        public int getTypeOut() {
            return this.mTypeOut;
        }

        public int getVersionCode() {
            return this.zzal;
        }

        public boolean hasConverter() {
            if (this.zzwo != null) {
                return true;
            }
            return false;
        }

        public boolean isTypeInArray() {
            return this.mTypeInArray;
        }

        public boolean isTypeOutArray() {
            return this.mTypeOutArray;
        }

        public boolean isValidSafeParcelableFieldId() {
            if (this.mSafeParcelableFieldId != -1) {
                return true;
            }
            return false;
        }

        public FastJsonResponse newConcreteTypeInstance() throws InstantiationException, IllegalAccessException {
            if (this.mConcreteType == SafeParcelResponse.class) {
                Preconditions.checkNotNull(this.zzwn, "The field mapping dictionary must be set if the concrete type is a SafeParcelResponse object.");
                return new SafeParcelResponse(this.zzwn, this.mConcreteTypeName);
            }
            return this.mConcreteType.newInstance();
        }

        public void setFieldMappingDictionary(FieldMappingDictionary fieldMappingDictionary) {
            this.zzwn = fieldMappingDictionary;
        }

        public String toString() {
            Objects.ToStringHelper toStringHelper = Objects.toStringHelper(this).add("versionCode", this.zzal).add("typeIn", this.mTypeIn).add("typeInArray", this.mTypeInArray).add("typeOut", this.mTypeOut).add("typeOutArray", this.mTypeOutArray).add("outputFieldName", this.mOutputFieldName).add("safeParcelFieldId", this.mSafeParcelableFieldId).add("concreteTypeName", this.zzcz());
            Class<FastJsonResponse> class_ = this.getConcreteType();
            if (class_ != null) {
                toStringHelper.add("concreteType.class", class_.getCanonicalName());
            }
            if (this.zzwo != null) {
                toStringHelper.add("converterName", this.zzwo.getClass().getCanonicalName());
            }
            return toStringHelper.toString();
        }

        public void writeToParcel(Parcel parcel, int n) {
            int n2 = SafeParcelWriter.beginObjectHeader(parcel);
            SafeParcelWriter.writeInt(parcel, 1, this.getVersionCode());
            SafeParcelWriter.writeInt(parcel, 2, this.getTypeIn());
            SafeParcelWriter.writeBoolean(parcel, 3, this.isTypeInArray());
            SafeParcelWriter.writeInt(parcel, 4, this.getTypeOut());
            SafeParcelWriter.writeBoolean(parcel, 5, this.isTypeOutArray());
            SafeParcelWriter.writeString(parcel, 6, this.getOutputFieldName(), false);
            SafeParcelWriter.writeInt(parcel, 7, this.getSafeParcelableFieldId());
            SafeParcelWriter.writeString(parcel, 8, this.zzcz(), false);
            SafeParcelWriter.writeParcelable(parcel, 9, this.zzda(), n, false);
            SafeParcelWriter.finishObjectHeader(parcel, n2);
        }
    }

    public static interface FieldConverter<I, O> {
        public O convert(I var1);

        public I convertBack(O var1);

        public int getTypeIn();

        public int getTypeOut();
    }

    public static interface FieldType {
        public static final int BASE64 = 8;
        public static final int BASE64_URL_SAFE = 9;
        public static final int BIG_DECIMAL = 5;
        public static final int BIG_INTEGER = 1;
        public static final int BOOLEAN = 6;
        public static final int CONCRETE_TYPE = 11;
        public static final int DOUBLE = 4;
        public static final int FLOAT = 3;
        public static final int INT = 0;
        public static final int LONG = 2;
        public static final int STRING = 7;
        public static final int STRING_MAP = 10;
    }

}

