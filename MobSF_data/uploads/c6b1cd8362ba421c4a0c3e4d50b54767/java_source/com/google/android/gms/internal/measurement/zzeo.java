/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.database.Cursor
 *  android.database.sqlite.SQLiteDatabase
 *  android.database.sqlite.SQLiteException
 *  android.text.TextUtils
 */
package com.google.android.gms.internal.measurement;

import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.support.annotation.WorkerThread;
import android.text.TextUtils;
import com.google.android.gms.internal.measurement.zzfi;
import com.google.android.gms.internal.measurement.zzfk;
import java.io.File;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public final class zzeo {
    static void zza(zzfi zzfi2, SQLiteDatabase object) {
        if (zzfi2 == null) {
            throw new IllegalArgumentException("Monitor must not be null");
        }
        if (!(object = new File(object.getPath())).setReadable(false, false)) {
            zzfi2.zziy().log("Failed to turn off database read permission");
        }
        if (!object.setWritable(false, false)) {
            zzfi2.zziy().log("Failed to turn off database write permission");
        }
        if (!object.setReadable(true, true)) {
            zzfi2.zziy().log("Failed to turn on database read permission for owner");
        }
        if (!object.setWritable(true, true)) {
            zzfi2.zziy().log("Failed to turn on database write permission for owner");
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    @WorkerThread
    static void zza(zzfi var0, SQLiteDatabase var1_1, String var2_3, String var3_4, String var4_5, String[] var5_6) throws SQLiteException {
        if (var0 == null) {
            throw new IllegalArgumentException("Monitor must not be null");
        }
        if (!zzeo.zza(var0, (SQLiteDatabase)var1_1, var2_3)) {
            var1_1.execSQL(var3_4);
        }
        if (var0 != null) ** GOTO lbl8
        throw new IllegalArgumentException("Monitor must not be null");
lbl8: // 1 sources:
        var3_4 = zzeo.zzb((SQLiteDatabase)var1_1, var2_3);
        var9_7 = var4_5.split(",");
        var8_8 = var9_7.length;
        var7_9 = 0;
        for (var6_10 = 0; var6_10 < var8_8; ++var6_10) {
            var4_5 = var9_7[var6_10];
            try {
                if (var3_4.remove(var4_5)) continue;
                var1_1 = new StringBuilder(String.valueOf(var2_3).length() + 35 + String.valueOf(var4_5).length());
                var1_1.append("Table ");
                var1_1.append(var2_3);
                var1_1.append(" is missing required column: ");
                var1_1.append(var4_5);
                throw new SQLiteException(var1_1.toString());
            }
            catch (SQLiteException var1_2) {}
            var0.zziv().zzg("Failed to verify columns on table that was just created", var2_3);
            throw var1_2;
        }
        if (var5_6 == null) ** GOTO lbl-1000
        var6_10 = var7_9;
        do {
            if (var6_10 < var5_6.length) {
                if (!var3_4.remove(var5_6[var6_10])) {
                    var1_1.execSQL(var5_6[var6_10 + 1]);
                }
            } else lbl-1000: // 2 sources:
            {
                if (var3_4.isEmpty() != false) return;
                var0.zziy().zze("Table has extra columns. table, columns", var2_3, TextUtils.join((CharSequence)", ", var3_4));
                return;
            }
            var6_10 += 2;
        } while (true);
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    @WorkerThread
    private static boolean zza(zzfi zzfi2, SQLiteDatabase sQLiteDatabase, String string2) {
        void var0_3;
        SQLiteDatabase sQLiteDatabase2;
        block8 : {
            block9 : {
                boolean bl;
                if (zzfi2 == null) {
                    throw new IllegalArgumentException("Monitor must not be null");
                }
                Object var6_6 = null;
                sQLiteDatabase2 = null;
                sQLiteDatabase = sQLiteDatabase.query("SQLITE_MASTER", new String[]{"name"}, "name=?", new String[]{string2}, null, null, null);
                try {
                    bl = sQLiteDatabase.moveToFirst();
                    if (sQLiteDatabase == null) return bl;
                }
                catch (Throwable throwable) {
                    sQLiteDatabase2 = sQLiteDatabase;
                    break block8;
                }
                catch (SQLiteException sQLiteException) {
                    break block9;
                }
                sQLiteDatabase.close();
                return bl;
                catch (Throwable throwable) {
                    break block8;
                }
                catch (SQLiteException sQLiteException) {
                    sQLiteDatabase = var6_6;
                }
            }
            sQLiteDatabase2 = sQLiteDatabase;
            {
                void var5_11;
                zzfi2.zziy().zze("Error querying for table", string2, var5_11);
                if (sQLiteDatabase == null) return false;
            }
            sQLiteDatabase.close();
            return false;
        }
        if (sQLiteDatabase2 == null) throw var0_3;
        sQLiteDatabase2.close();
        throw var0_3;
    }

    @WorkerThread
    private static Set<String> zzb(SQLiteDatabase sQLiteDatabase, String string2) {
        HashSet<String> hashSet = new HashSet<String>();
        StringBuilder stringBuilder = new StringBuilder(String.valueOf(string2).length() + 22);
        stringBuilder.append("SELECT * FROM ");
        stringBuilder.append(string2);
        stringBuilder.append(" LIMIT 0");
        sQLiteDatabase = sQLiteDatabase.rawQuery(stringBuilder.toString(), null);
        try {
            Collections.addAll(hashSet, sQLiteDatabase.getColumnNames());
            return hashSet;
        }
        finally {
            sQLiteDatabase.close();
        }
    }
}

