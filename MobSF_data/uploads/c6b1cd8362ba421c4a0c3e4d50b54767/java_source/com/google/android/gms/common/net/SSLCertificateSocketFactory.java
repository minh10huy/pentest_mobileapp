/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.content.Context
 *  android.util.Log
 */
package com.google.android.gms.common.net;

import android.content.Context;
import android.util.Log;
import com.google.android.gms.common.net.SocketFactoryCreator;
import com.google.android.gms.common.net.zza;
import com.google.android.gms.common.util.VisibleForTesting;
import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.InetAddress;
import java.net.Socket;
import java.net.SocketException;
import java.security.PrivateKey;
import javax.net.SocketFactory;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.KeyManager;
import javax.net.ssl.SSLException;
import javax.net.ssl.SSLPeerUnverifiedException;
import javax.net.ssl.SSLSession;
import javax.net.ssl.SSLSocket;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;

public class SSLCertificateSocketFactory
extends SSLSocketFactory {
    private static final TrustManager[] zzvf = new TrustManager[]{new zza()};
    @VisibleForTesting
    private final Context mContext;
    @VisibleForTesting
    private SSLSocketFactory zzvg = null;
    @VisibleForTesting
    private SSLSocketFactory zzvh = null;
    @VisibleForTesting
    private TrustManager[] zzvi = null;
    @VisibleForTesting
    private KeyManager[] zzvj = null;
    @VisibleForTesting
    private byte[] zzvk = null;
    @VisibleForTesting
    private byte[] zzvl = null;
    @VisibleForTesting
    private PrivateKey zzvm = null;
    @VisibleForTesting
    private final int zzvn;
    @VisibleForTesting
    private final boolean zzvo;
    @VisibleForTesting
    private final boolean zzvp;
    @VisibleForTesting
    private final String zzvq;

    private SSLCertificateSocketFactory(Context context, int n, boolean bl, boolean bl2, String string2) {
        this.mContext = context.getApplicationContext();
        this.zzvn = n;
        this.zzvo = bl;
        this.zzvp = bl2;
        this.zzvq = string2;
    }

    public static SocketFactory getDefault(Context context, int n) {
        return new SSLCertificateSocketFactory(context, n, false, true, null);
    }

    public static SSLSocketFactory getDefaultWithCacheDir(int n, Context context, String string2) {
        return new SSLCertificateSocketFactory(context, n, true, true, string2);
    }

    public static SSLSocketFactory getDefaultWithSessionCache(int n, Context context) {
        return new SSLCertificateSocketFactory(context, n, true, true, null);
    }

    public static SSLSocketFactory getInsecure(Context context, int n, boolean bl) {
        return new SSLCertificateSocketFactory(context, n, bl, false, null);
    }

    public static void verifyHostname(Socket object, String string2) throws IOException {
        if (!(object instanceof SSLSocket)) {
            throw new IllegalArgumentException("Attempt to verify non-SSL socket");
        }
        object = (SSLSocket)object;
        object.startHandshake();
        object = object.getSession();
        if (object == null) {
            throw new SSLException("Cannot verify SSL socket without session");
        }
        if (!HttpsURLConnection.getDefaultHostnameVerifier().verify(string2, (SSLSession)object)) {
            object = String.valueOf(string2);
            object = object.length() != 0 ? "Cannot verify hostname: ".concat((String)object) : new String("Cannot verify hostname: ");
            throw new SSLPeerUnverifiedException((String)object);
        }
    }

    @VisibleForTesting
    private static void zza(Socket object, int n) {
        if (object != null) {
            try {
                object.getClass().getMethod("setHandshakeTimeout", Integer.TYPE).invoke(object, n);
                return;
            }
            catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
                object = String.valueOf(object.getClass());
                StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 45);
                stringBuilder.append((String)object);
                stringBuilder.append(" does not implement setSocketHandshakeTimeout");
                throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
            }
            catch (InvocationTargetException invocationTargetException) {
                Serializable serializable = invocationTargetException.getCause();
                if (serializable instanceof RuntimeException) {
                    throw (RuntimeException)serializable;
                }
                object = String.valueOf(object.getClass());
                serializable = new StringBuilder(String.valueOf(object).length() + 46);
                serializable.append("Failed to invoke setSocketHandshakeTimeout on ");
                serializable.append((String)object);
                throw new RuntimeException(serializable.toString(), invocationTargetException);
            }
        }
    }

    @VisibleForTesting
    private static void zza(Socket object, PrivateKey privateKey) {
        if (object != null) {
            try {
                object.getClass().getMethod("setChannelIdPrivateKey", PrivateKey.class).invoke(object, privateKey);
                return;
            }
            catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
                object = String.valueOf(object.getClass());
                StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 42);
                stringBuilder.append((String)object);
                stringBuilder.append(" does not implement setChannelIdPrivateKey");
                throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
            }
            catch (InvocationTargetException invocationTargetException) {
                Serializable serializable = invocationTargetException.getCause();
                if (serializable instanceof RuntimeException) {
                    throw (RuntimeException)serializable;
                }
                object = String.valueOf(object.getClass());
                serializable = new StringBuilder(String.valueOf(object).length() + 43);
                serializable.append("Failed to invoke setChannelIdPrivateKey on ");
                serializable.append((String)object);
                throw new RuntimeException(serializable.toString(), invocationTargetException);
            }
        }
    }

    @VisibleForTesting
    private static void zza(Socket object, byte[] arrby) {
        if (object != null) {
            try {
                object.getClass().getMethod("setNpnProtocols", byte[].class).invoke(object, new Object[]{arrby});
                return;
            }
            catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
                object = String.valueOf(object.getClass());
                StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 35);
                stringBuilder.append((String)object);
                stringBuilder.append(" does not implement setNpnProtocols");
                throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
            }
            catch (InvocationTargetException invocationTargetException) {
                Serializable serializable = invocationTargetException.getCause();
                if (serializable instanceof RuntimeException) {
                    throw (RuntimeException)serializable;
                }
                object = String.valueOf(object.getClass());
                serializable = new StringBuilder(String.valueOf(object).length() + 36);
                serializable.append("Failed to invoke setNpnProtocols on ");
                serializable.append((String)object);
                throw new RuntimeException(serializable.toString(), invocationTargetException);
            }
        }
    }

    private static /* varargs */ byte[] zza(byte[] ... object) {
        int n;
        byte[] arrby;
        if (((byte[][])object).length == 0) {
            throw new IllegalArgumentException("items.length == 0");
        }
        int n2 = ((byte[][])object).length;
        int n3 = 0;
        for (n = 0; n < n2; ++n) {
            arrby = object[n];
            if (arrby.length != 0 && arrby.length <= 255) {
                n3 += arrby.length + 1;
                continue;
            }
            n = arrby.length;
            object = new StringBuilder(44);
            object.append("s.length == 0 || s.length > 255: ");
            object.append(n);
            throw new IllegalArgumentException(object.toString());
        }
        arrby = new byte[n3];
        int n4 = ((byte[][])object).length;
        n = 0;
        for (n3 = 0; n3 < n4; ++n3) {
            byte[] arrby2 = object[n3];
            arrby[n] = (byte)arrby2.length;
            int n5 = arrby2.length;
            ++n;
            n2 = 0;
            while (n2 < n5) {
                arrby[n] = arrby2[n2];
                ++n2;
                ++n;
            }
        }
        return arrby;
    }

    @VisibleForTesting
    private static void zzb(Socket object, byte[] arrby) {
        if (object != null) {
            try {
                object.getClass().getMethod("setAlpnProtocols", byte[].class).invoke(object, new Object[]{arrby});
                return;
            }
            catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
                object = String.valueOf(object.getClass());
                StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 36);
                stringBuilder.append((String)object);
                stringBuilder.append(" does not implement setAlpnProtocols");
                throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
            }
            catch (InvocationTargetException invocationTargetException) {
                Serializable serializable = invocationTargetException.getCause();
                if (serializable instanceof RuntimeException) {
                    throw (RuntimeException)serializable;
                }
                object = String.valueOf(object.getClass());
                serializable = new StringBuilder(String.valueOf(object).length() + 37);
                serializable.append("Failed to invoke setAlpnProtocols on ");
                serializable.append((String)object);
                throw new RuntimeException(serializable.toString(), invocationTargetException);
            }
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @VisibleForTesting
    private final SSLSocketFactory zzcx() {
        synchronized (this) {
            SSLSocketFactory sSLSocketFactory;
            if (!this.zzvp) {
                if (this.zzvg != null) return this.zzvg;
                Log.w((String)"SSLCertificateSocketFactory", (String)"Bypassing SSL security checks at caller's request");
                this.zzvg = SocketFactoryCreator.getInstance().makeSocketFactory(this.mContext, this.zzvj, zzvf, this.zzvo);
                return this.zzvg;
            }
            if (this.zzvq != null) {
                if (this.zzvh != null) return this.zzvh;
                sSLSocketFactory = SocketFactoryCreator.getInstance().makeSocketFactoryWithCacheDir(this.mContext, this.zzvj, this.zzvi, this.zzvq);
            } else {
                if (this.zzvh != null) return this.zzvh;
                sSLSocketFactory = SocketFactoryCreator.getInstance().makeSocketFactory(this.mContext, this.zzvj, this.zzvi, this.zzvo);
            }
            this.zzvh = sSLSocketFactory;
            return this.zzvh;
        }
    }

    @Override
    public Socket createSocket() throws IOException {
        Socket socket = this.zzcx().createSocket();
        SSLCertificateSocketFactory.zza(socket, this.zzvk);
        SSLCertificateSocketFactory.zzb(socket, this.zzvl);
        SSLCertificateSocketFactory.zza(socket, this.zzvn);
        SSLCertificateSocketFactory.zza(socket, this.zzvm);
        return socket;
    }

    @Override
    public Socket createSocket(String string2, int n) throws IOException {
        Socket socket = this.zzcx().createSocket(string2, n);
        SSLCertificateSocketFactory.zza(socket, this.zzvk);
        SSLCertificateSocketFactory.zzb(socket, this.zzvl);
        SSLCertificateSocketFactory.zza(socket, this.zzvn);
        SSLCertificateSocketFactory.zza(socket, this.zzvm);
        if (this.zzvp) {
            SSLCertificateSocketFactory.verifyHostname(socket, string2);
        }
        return socket;
    }

    @Override
    public Socket createSocket(String string2, int n, InetAddress object, int n2) throws IOException {
        object = this.zzcx().createSocket(string2, n, (InetAddress)object, n2);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvk);
        SSLCertificateSocketFactory.zzb((Socket)object, this.zzvl);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvn);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvm);
        if (this.zzvp) {
            SSLCertificateSocketFactory.verifyHostname((Socket)object, string2);
        }
        return object;
    }

    @Override
    public Socket createSocket(InetAddress object, int n) throws IOException {
        object = this.zzcx().createSocket((InetAddress)object, n);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvk);
        SSLCertificateSocketFactory.zzb((Socket)object, this.zzvl);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvn);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvm);
        return object;
    }

    @Override
    public Socket createSocket(InetAddress object, int n, InetAddress inetAddress, int n2) throws IOException {
        object = this.zzcx().createSocket((InetAddress)object, n, inetAddress, n2);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvk);
        SSLCertificateSocketFactory.zzb((Socket)object, this.zzvl);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvn);
        SSLCertificateSocketFactory.zza((Socket)object, this.zzvm);
        return object;
    }

    @Override
    public Socket createSocket(Socket socket, String string2, int n, boolean bl) throws IOException {
        socket = this.zzcx().createSocket(socket, string2, n, bl);
        SSLCertificateSocketFactory.zza(socket, this.zzvk);
        SSLCertificateSocketFactory.zzb(socket, this.zzvl);
        SSLCertificateSocketFactory.zza(socket, this.zzvn);
        SSLCertificateSocketFactory.zza(socket, this.zzvm);
        if (this.zzvp) {
            SSLCertificateSocketFactory.verifyHostname(socket, string2);
        }
        return socket;
    }

    public byte[] getAlpnSelectedProtocol(Socket object) {
        try {
            byte[] arrby = (byte[])object.getClass().getMethod("getAlpnSelectedProtocol", new Class[0]).invoke(object, new Object[0]);
            return arrby;
        }
        catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
            object = String.valueOf(object.getClass());
            StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 43);
            stringBuilder.append((String)object);
            stringBuilder.append(" does not implement getAlpnSelectedProtocol");
            throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
        }
        catch (InvocationTargetException invocationTargetException) {
            Serializable serializable = invocationTargetException.getCause();
            if (serializable instanceof RuntimeException) {
                throw (RuntimeException)serializable;
            }
            object = String.valueOf(object.getClass());
            serializable = new StringBuilder(String.valueOf(object).length() + 44);
            serializable.append("Failed to invoke getAlpnSelectedProtocol on ");
            serializable.append((String)object);
            throw new RuntimeException(serializable.toString(), invocationTargetException);
        }
    }

    @Override
    public String[] getDefaultCipherSuites() {
        return this.zzcx().getDefaultCipherSuites();
    }

    public byte[] getNpnSelectedProtocol(Socket object) {
        try {
            byte[] arrby = (byte[])object.getClass().getMethod("getNpnSelectedProtocol", new Class[0]).invoke(object, new Object[0]);
            return arrby;
        }
        catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
            object = String.valueOf(object.getClass());
            StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 42);
            stringBuilder.append((String)object);
            stringBuilder.append(" does not implement getNpnSelectedProtocol");
            throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
        }
        catch (InvocationTargetException invocationTargetException) {
            Serializable serializable = invocationTargetException.getCause();
            if (serializable instanceof RuntimeException) {
                throw (RuntimeException)serializable;
            }
            object = String.valueOf(object.getClass());
            serializable = new StringBuilder(String.valueOf(object).length() + 43);
            serializable.append("Failed to invoke getNpnSelectedProtocol on ");
            serializable.append((String)object);
            throw new RuntimeException(serializable.toString(), invocationTargetException);
        }
    }

    @Override
    public String[] getSupportedCipherSuites() {
        return this.zzcx().getSupportedCipherSuites();
    }

    public void setAlpnProtocols(byte[][] arrby) {
        this.zzvl = SSLCertificateSocketFactory.zza(arrby);
    }

    public void setChannelIdPrivateKey(PrivateKey privateKey) {
        this.zzvm = privateKey;
    }

    public void setHostname(Socket object, String string2) {
        try {
            object.getClass().getMethod("setHostname", String.class).invoke(object, string2);
            return;
        }
        catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
            object = String.valueOf(object.getClass());
            StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 31);
            stringBuilder.append((String)object);
            stringBuilder.append(" does not implement setHostname");
            throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
        }
        catch (InvocationTargetException invocationTargetException) {
            Serializable serializable = invocationTargetException.getCause();
            if (serializable instanceof RuntimeException) {
                throw (RuntimeException)serializable;
            }
            object = String.valueOf(object.getClass());
            serializable = new StringBuilder(String.valueOf(object).length() + 32);
            serializable.append("Failed to invoke setHostname on ");
            serializable.append((String)object);
            throw new RuntimeException(serializable.toString(), invocationTargetException);
        }
    }

    public void setKeyManagers(KeyManager[] arrkeyManager) {
        this.zzvj = arrkeyManager;
        this.zzvh = null;
        this.zzvg = null;
    }

    public void setNpnProtocols(byte[][] arrby) {
        this.zzvk = SSLCertificateSocketFactory.zza(arrby);
    }

    public void setSoWriteTimeout(Socket object, int n) throws SocketException {
        try {
            object.getClass().getMethod("setSoWriteTimeout", Integer.TYPE).invoke(object, n);
            return;
        }
        catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
            object = String.valueOf(object.getClass());
            StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 37);
            stringBuilder.append((String)object);
            stringBuilder.append(" does not implement setSoWriteTimeout");
            throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
        }
        catch (InvocationTargetException invocationTargetException) {
            Serializable serializable = invocationTargetException.getCause();
            if (serializable instanceof SocketException) {
                throw (SocketException)serializable;
            }
            if (serializable instanceof RuntimeException) {
                throw (RuntimeException)serializable;
            }
            object = String.valueOf(object.getClass());
            serializable = new StringBuilder(String.valueOf(object).length() + 38);
            serializable.append("Failed to invoke setSoWriteTimeout on ");
            serializable.append((String)object);
            throw new RuntimeException(serializable.toString(), invocationTargetException);
        }
    }

    public void setTrustManagers(TrustManager[] arrtrustManager) {
        this.zzvi = arrtrustManager;
        this.zzvh = null;
    }

    public void setUseSessionTickets(Socket object, boolean bl) {
        try {
            object.getClass().getMethod("setUseSessionTickets", Boolean.TYPE).invoke(object, bl);
            return;
        }
        catch (IllegalAccessException | NoSuchMethodException reflectiveOperationException) {
            object = String.valueOf(object.getClass());
            StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 40);
            stringBuilder.append((String)object);
            stringBuilder.append(" does not implement setUseSessionTickets");
            throw new IllegalArgumentException(stringBuilder.toString(), reflectiveOperationException);
        }
        catch (InvocationTargetException invocationTargetException) {
            Serializable serializable = invocationTargetException.getCause();
            if (serializable instanceof RuntimeException) {
                throw (RuntimeException)serializable;
            }
            object = String.valueOf(object.getClass());
            serializable = new StringBuilder(String.valueOf(object).length() + 41);
            serializable.append("Failed to invoke setUseSessionTickets on ");
            serializable.append((String)object);
            throw new RuntimeException(serializable.toString(), invocationTargetException);
        }
    }
}

