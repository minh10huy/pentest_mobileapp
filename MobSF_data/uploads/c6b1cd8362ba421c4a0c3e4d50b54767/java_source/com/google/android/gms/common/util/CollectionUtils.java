/*
 * Decompiled with CFR 0_132.
 */
package com.google.android.gms.common.util;

import android.support.annotation.Nullable;
import android.support.v4.util.ArrayMap;
import android.support.v4.util.ArraySet;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public final class CollectionUtils {
    private CollectionUtils() {
    }

    public static <K, V> Map<K, V> inOrderMapOf() {
        return CollectionUtils.mapOf();
    }

    public static <K, V> Map<K, V> inOrderMapOf(K k, V v) {
        return CollectionUtils.mapOf(k, v);
    }

    public static <K, V> Map<K, V> inOrderMapOf(K k, V v, K k2, V v2) {
        Map<K, V> map = CollectionUtils.zzg(2, false);
        map.put(k, v);
        map.put(k2, v2);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> inOrderMapOf(K k, V v, K k2, V v2, K k3, V v3) {
        Map<K, V> map = CollectionUtils.zzg(3, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> inOrderMapOf(K k, V v, K k2, V v2, K k3, V v3, K k4, V v4) {
        Map<K, V> map = CollectionUtils.zzg(4, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> inOrderMapOf(K k, V v, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
        Map<K, V> map = CollectionUtils.zzg(5, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> inOrderMapOf(K k, V v, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
        Map<K, V> map = CollectionUtils.zzg(6, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        map.put(k6, v6);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> inOrderMapOfKeyValueArrays(K[] arrK, V[] arrV) {
        CollectionUtils.zza(arrK, arrV);
        int n = arrK.length;
        switch (n) {
            default: {
                return Collections.unmodifiableMap(CollectionUtils.zzb(n, false, arrK, arrV));
            }
            case 1: {
                return CollectionUtils.inOrderMapOf(arrK[0], arrV[0]);
            }
            case 0: 
        }
        return CollectionUtils.inOrderMapOf();
    }

    public static <T> Set<T> inOrderSetOf() {
        return CollectionUtils.setOf();
    }

    public static <T> Set<T> inOrderSetOf(T t) {
        return CollectionUtils.setOf(t);
    }

    public static <T> Set<T> inOrderSetOf(T t, T t2) {
        Set<T> set = CollectionUtils.zze(2, false);
        set.add(t);
        set.add(t2);
        return Collections.unmodifiableSet(set);
    }

    public static <T> Set<T> inOrderSetOf(T t, T t2, T t3) {
        Set<T> set = CollectionUtils.zze(3, false);
        set.add(t);
        set.add(t2);
        set.add(t3);
        return Collections.unmodifiableSet(set);
    }

    public static <T> Set<T> inOrderSetOf(T t, T t2, T t3, T t4) {
        Set<T> set = CollectionUtils.zze(4, false);
        set.add(t);
        set.add(t2);
        set.add(t3);
        set.add(t4);
        return Collections.unmodifiableSet(set);
    }

    public static /* varargs */ <T> Set<T> inOrderSetOf(T ... arrT) {
        switch (arrT.length) {
            default: {
                return Collections.unmodifiableSet(CollectionUtils.zzb(arrT.length, false, arrT));
            }
            case 4: {
                return CollectionUtils.inOrderSetOf(arrT[0], arrT[1], arrT[2], arrT[3]);
            }
            case 3: {
                return CollectionUtils.inOrderSetOf(arrT[0], arrT[1], arrT[2]);
            }
            case 2: {
                return CollectionUtils.inOrderSetOf(arrT[0], arrT[1]);
            }
            case 1: {
                return CollectionUtils.inOrderSetOf(arrT[0]);
            }
            case 0: 
        }
        return CollectionUtils.inOrderSetOf();
    }

    public static boolean isEmpty(@Nullable Collection<?> collection) {
        if (collection == null) {
            return true;
        }
        return collection.isEmpty();
    }

    public static boolean isEmpty(@Nullable Map<?, ?> map) {
        if (map == null) {
            return true;
        }
        return map.isEmpty();
    }

    @Deprecated
    public static <T> List<T> listOf() {
        return Collections.emptyList();
    }

    @Deprecated
    public static <T> List<T> listOf(T t) {
        return Collections.singletonList(t);
    }

    @Deprecated
    public static /* varargs */ <T> List<T> listOf(T ... arrT) {
        switch (arrT.length) {
            default: {
                return Collections.unmodifiableList(Arrays.asList(arrT));
            }
            case 1: {
                return CollectionUtils.listOf(arrT[0]);
            }
            case 0: 
        }
        return CollectionUtils.listOf();
    }

    public static <K, V> Map<K, V> mapOf() {
        return Collections.emptyMap();
    }

    public static <K, V> Map<K, V> mapOf(K k, V v) {
        return Collections.singletonMap(k, v);
    }

    public static <K, V> Map<K, V> mapOf(K k, V v, K k2, V v2) {
        Map<K, V> map = CollectionUtils.zzf(2, false);
        map.put(k, v);
        map.put(k2, v2);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> mapOf(K k, V v, K k2, V v2, K k3, V v3) {
        Map<K, V> map = CollectionUtils.zzf(3, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> mapOf(K k, V v, K k2, V v2, K k3, V v3, K k4, V v4) {
        Map<K, V> map = CollectionUtils.zzf(4, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> mapOf(K k, V v, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5) {
        Map<K, V> map = CollectionUtils.zzf(5, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> mapOf(K k, V v, K k2, V v2, K k3, V v3, K k4, V v4, K k5, V v5, K k6, V v6) {
        Map<K, V> map = CollectionUtils.zzf(6, false);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        map.put(k4, v4);
        map.put(k5, v5);
        map.put(k6, v6);
        return Collections.unmodifiableMap(map);
    }

    public static <K, V> Map<K, V> mapOfKeyValueArrays(K[] arrK, V[] arrV) {
        CollectionUtils.zza(arrK, arrV);
        switch (arrK.length) {
            default: {
                return Collections.unmodifiableMap(CollectionUtils.zza(arrK.length, false, arrK, arrV));
            }
            case 1: {
                return CollectionUtils.mapOf(arrK[0], arrV[0]);
            }
            case 0: 
        }
        return CollectionUtils.mapOf();
    }

    public static <K, V> Map<K, V> mutableInOrderMapOf() {
        return new LinkedHashMap();
    }

    public static <K, V> Map<K, V> mutableInOrderMapOf(K k, V v) {
        return CollectionUtils.mutableInOrderMapOfWithSize(1, k, v);
    }

    public static <K, V> Map<K, V> mutableInOrderMapOf(K k, V v, K k2, V v2) {
        return CollectionUtils.mutableInOrderMapOfWithSize(2, k, v, k2, v2);
    }

    public static <K, V> Map<K, V> mutableInOrderMapOf(K k, V v, K k2, V v2, K k3, V v3) {
        return CollectionUtils.mutableInOrderMapOfWithSize(3, k, v, k2, v2, k3, v3);
    }

    public static <K, V> Map<K, V> mutableInOrderMapOfKeyValueArrays(K[] arrK, V[] arrV) {
        CollectionUtils.zza(arrK, arrV);
        int n = arrK.length;
        if (n == 0) {
            return CollectionUtils.mutableInOrderMapOf();
        }
        return CollectionUtils.zzb(n, true, arrK, arrV);
    }

    public static <K, V> Map<K, V> mutableInOrderMapOfKeyValueArraysWithSize(int n, K[] arrK, V[] arrV) {
        CollectionUtils.zza(arrK, arrV);
        int n2 = Math.max(n, arrK.length);
        if (n2 == 0) {
            return CollectionUtils.mutableInOrderMapOf();
        }
        if (arrK.length == 0) {
            return CollectionUtils.mutableInOrderMapOfWithSize(n2);
        }
        return CollectionUtils.zzb(n, true, arrK, arrV);
    }

    public static <K, V> Map<K, V> mutableInOrderMapOfWithSize(int n) {
        if (n == 0) {
            return CollectionUtils.mutableInOrderMapOf();
        }
        return CollectionUtils.zzg(n, true);
    }

    public static <K, V> Map<K, V> mutableInOrderMapOfWithSize(int n, K k, V v) {
        Map<K, V> map = CollectionUtils.zzg(Math.max(n, 1), true);
        map.put(k, v);
        return map;
    }

    public static <K, V> Map<K, V> mutableInOrderMapOfWithSize(int n, K k, V v, K k2, V v2) {
        Map<K, V> map = CollectionUtils.zzg(Math.max(n, 2), true);
        map.put(k, v);
        map.put(k2, v2);
        return map;
    }

    public static <K, V> Map<K, V> mutableInOrderMapOfWithSize(int n, K k, V v, K k2, V v2, K k3, V v3) {
        Map<K, V> map = CollectionUtils.zzg(Math.max(n, 3), true);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        return map;
    }

    public static <T> Set<T> mutableInOrderSetOf() {
        return new LinkedHashSet();
    }

    public static <T> Set<T> mutableInOrderSetOf(T t) {
        return CollectionUtils.mutableInOrderSetOfWithSize(1, t);
    }

    public static <T> Set<T> mutableInOrderSetOf(T t, T t2) {
        return CollectionUtils.mutableInOrderSetOfWithSize(2, t, t2);
    }

    public static /* varargs */ <T> Set<T> mutableInOrderSetOf(T ... arrT) {
        if (arrT.length == 0) {
            return CollectionUtils.mutableInOrderSetOf();
        }
        return CollectionUtils.zzb(arrT.length, true, arrT);
    }

    public static <T> Set<T> mutableInOrderSetOfWithSize(int n) {
        if (n == 0) {
            return CollectionUtils.mutableInOrderSetOf();
        }
        return CollectionUtils.zze(n, true);
    }

    public static <T> Set<T> mutableInOrderSetOfWithSize(int n, T t) {
        Set<T> set = CollectionUtils.zze(Math.max(n, 1), true);
        set.add(t);
        return set;
    }

    public static <T> Set<T> mutableInOrderSetOfWithSize(int n, T t, T t2) {
        Set<T> set = CollectionUtils.zze(Math.max(n, 2), true);
        set.add(t);
        set.add(t2);
        return set;
    }

    public static /* varargs */ <T> Set<T> mutableInOrderSetOfWithSize(int n, T ... arrT) {
        int n2 = Math.max(n, arrT.length);
        if (n2 == 0) {
            return CollectionUtils.mutableSetOf();
        }
        if (arrT.length == 0) {
            return CollectionUtils.mutableInOrderSetOfWithSize(n);
        }
        return CollectionUtils.zzb(n2, true, arrT);
    }

    public static <T> List<T> mutableListOf() {
        return new ArrayList();
    }

    public static <T> List<T> mutableListOf(T t) {
        return CollectionUtils.mutableListOfWithSize(1, t);
    }

    public static <T> List<T> mutableListOf(T t, T t2) {
        return CollectionUtils.mutableListOfWithSize(2, t, t2);
    }

    public static /* varargs */ <T> List<T> mutableListOf(T ... arrT) {
        if (arrT.length == 0) {
            return CollectionUtils.mutableListOf();
        }
        return new ArrayList<T>(Arrays.asList(arrT));
    }

    public static <T> List<T> mutableListOfWithSize(int n) {
        if (n == 0) {
            return CollectionUtils.mutableListOf();
        }
        return CollectionUtils.zzc(n, true);
    }

    public static <T> List<T> mutableListOfWithSize(int n, T t) {
        List<T> list = CollectionUtils.zzc(Math.max(n, 1), true);
        list.add(t);
        return list;
    }

    public static <T> List<T> mutableListOfWithSize(int n, T t, T t2) {
        List<T> list = CollectionUtils.zzc(Math.max(n, 2), true);
        list.add(t);
        list.add(t2);
        return list;
    }

    public static /* varargs */ <T> List<T> mutableListOfWithSize(int n, T ... arrT) {
        int n2 = Math.max(n, arrT.length);
        if (n2 == 0) {
            return CollectionUtils.mutableListOf();
        }
        if (arrT.length == 0) {
            return CollectionUtils.mutableListOfWithSize(n);
        }
        if (arrT.length == n2) {
            return new ArrayList<T>(Arrays.asList(arrT));
        }
        List<T> list = CollectionUtils.zzc(n2, true);
        list.addAll(Arrays.asList(arrT));
        return list;
    }

    public static <K, V> Map<K, V> mutableMapOf() {
        return new ArrayMap();
    }

    public static <K, V> Map<K, V> mutableMapOf(K k, V v) {
        return CollectionUtils.mutableMapOfWithSize(1, k, v);
    }

    public static <K, V> Map<K, V> mutableMapOf(K k, V v, K k2, V v2) {
        return CollectionUtils.mutableMapOfWithSize(2, k, v, k2, v2);
    }

    public static <K, V> Map<K, V> mutableMapOf(K k, V v, K k2, V v2, K k3, V v3) {
        return CollectionUtils.mutableMapOfWithSize(3, k, v, k2, v2, k3, v3);
    }

    public static <K, V> Map<K, V> mutableMapOfKeyValueArrays(K[] arrK, V[] arrV) {
        CollectionUtils.zza(arrK, arrV);
        int n = arrK.length;
        if (n == 0) {
            return CollectionUtils.mutableMapOf();
        }
        return CollectionUtils.zza(n, true, arrK, arrV);
    }

    public static <K, V> Map<K, V> mutableMapOfKeyValueArraysWithSize(int n, K[] arrK, V[] arrV) {
        CollectionUtils.zza(arrK, arrV);
        int n2 = Math.max(n, arrK.length);
        if (n2 == 0) {
            return CollectionUtils.mutableMapOf();
        }
        if (arrK.length == 0) {
            return CollectionUtils.mutableMapOfWithSize(n);
        }
        return CollectionUtils.zza(n2, true, arrK, arrV);
    }

    public static <K, V> Map<K, V> mutableMapOfWithSize(int n) {
        if (n == 0) {
            return CollectionUtils.mutableMapOf();
        }
        return CollectionUtils.zzf(n, true);
    }

    public static <K, V> Map<K, V> mutableMapOfWithSize(int n, K k, V v) {
        Map<K, V> map = CollectionUtils.zzf(Math.max(n, 1), true);
        map.put(k, v);
        return map;
    }

    public static <K, V> Map<K, V> mutableMapOfWithSize(int n, K k, V v, K k2, V v2) {
        Map<K, V> map = CollectionUtils.zzf(Math.max(n, 2), true);
        map.put(k, v);
        map.put(k2, v2);
        return map;
    }

    public static <K, V> Map<K, V> mutableMapOfWithSize(int n, K k, V v, K k2, V v2, K k3, V v3) {
        Map<K, V> map = CollectionUtils.zzf(Math.max(n, 3), true);
        map.put(k, v);
        map.put(k2, v2);
        map.put(k3, v3);
        return map;
    }

    public static <T> Set<T> mutableSetOf() {
        return new ArraySet();
    }

    public static <T> Set<T> mutableSetOf(T t) {
        return CollectionUtils.mutableSetOfWithSize(1, t);
    }

    public static <T> Set<T> mutableSetOf(T t, T t2) {
        return CollectionUtils.mutableSetOfWithSize(2, t, t2);
    }

    public static /* varargs */ <T> Set<T> mutableSetOf(T ... arrT) {
        if (arrT.length == 0) {
            return CollectionUtils.mutableSetOf();
        }
        return CollectionUtils.zza(arrT.length, true, arrT);
    }

    public static <T> Set<T> mutableSetOfWithSize(int n) {
        if (n == 0) {
            return CollectionUtils.mutableSetOf();
        }
        return CollectionUtils.zzd(n, true);
    }

    public static <T> Set<T> mutableSetOfWithSize(int n, T t) {
        Set<T> set = CollectionUtils.zzd(Math.max(n, 1), true);
        set.add(t);
        return set;
    }

    public static <T> Set<T> mutableSetOfWithSize(int n, T t, T t2) {
        Set<T> set = CollectionUtils.zzd(Math.max(n, 2), true);
        set.add(t);
        set.add(t2);
        return set;
    }

    public static /* varargs */ <T> Set<T> mutableSetOfWithSize(int n, T ... arrT) {
        int n2 = Math.max(n, arrT.length);
        if (n2 == 0) {
            return CollectionUtils.mutableSetOf();
        }
        if (arrT.length == 0) {
            return CollectionUtils.mutableSetOfWithSize(n);
        }
        return CollectionUtils.zza(n2, true, arrT);
    }

    @Deprecated
    public static <T> Set<T> setOf() {
        return Collections.emptySet();
    }

    @Deprecated
    public static <T> Set<T> setOf(T t) {
        return Collections.singleton(t);
    }

    @Deprecated
    public static <T> Set<T> setOf(T t, T t2) {
        Set<T> set = CollectionUtils.zzd(2, false);
        set.add(t);
        set.add(t2);
        return Collections.unmodifiableSet(set);
    }

    @Deprecated
    public static <T> Set<T> setOf(T t, T t2, T t3) {
        Set<T> set = CollectionUtils.zzd(3, false);
        set.add(t);
        set.add(t2);
        set.add(t3);
        return Collections.unmodifiableSet(set);
    }

    @Deprecated
    public static <T> Set<T> setOf(T t, T t2, T t3, T t4) {
        Set<T> set = CollectionUtils.zzd(4, false);
        set.add(t);
        set.add(t2);
        set.add(t3);
        set.add(t4);
        return Collections.unmodifiableSet(set);
    }

    @Deprecated
    public static /* varargs */ <T> Set<T> setOf(T ... arrT) {
        switch (arrT.length) {
            default: {
                return Collections.unmodifiableSet(CollectionUtils.zza(arrT.length, false, arrT));
            }
            case 4: {
                return CollectionUtils.setOf(arrT[0], arrT[1], arrT[2], arrT[3]);
            }
            case 3: {
                return CollectionUtils.setOf(arrT[0], arrT[1], arrT[2]);
            }
            case 2: {
                return CollectionUtils.setOf(arrT[0], arrT[1]);
            }
            case 1: {
                return CollectionUtils.setOf(arrT[0]);
            }
            case 0: 
        }
        return CollectionUtils.setOf();
    }

    private static <K, V> Map<K, V> zza(int n, boolean bl, K[] arrK, V[] arrV) {
        Map<K, V> map = CollectionUtils.zzf(n, bl);
        CollectionUtils.zza(map, arrK, arrV);
        return map;
    }

    private static <T> Set<T> zza(int n, boolean bl, T[] arrT) {
        Set<T> set = CollectionUtils.zzd(n, bl);
        Collections.addAll(set, arrT);
        return set;
    }

    private static <K, V> void zza(Map<K, V> map, K[] arrK, V[] arrV) {
        for (int i = 0; i < arrK.length; ++i) {
            map.put(arrK[i], arrV[i]);
        }
    }

    private static <K, V> void zza(K[] object, V[] arrV) {
        if (((K[])object).length != arrV.length) {
            int n = ((K[])object).length;
            int n2 = arrV.length;
            object = new StringBuilder(66);
            object.append("Key and values array lengths not equal: ");
            object.append(n);
            object.append(" != ");
            object.append(n2);
            throw new IllegalArgumentException(object.toString());
        }
    }

    private static <K, V> Map<K, V> zzb(int n, boolean bl, K[] arrK, V[] arrV) {
        Map<K, V> map = CollectionUtils.zzg(n, bl);
        CollectionUtils.zza(map, arrK, arrV);
        return map;
    }

    private static <T> Set<T> zzb(int n, boolean bl, T[] arrT) {
        Set<T> set = CollectionUtils.zze(n, bl);
        Collections.addAll(set, arrT);
        return set;
    }

    private static <T> List<T> zzc(int n, boolean bl) {
        return new ArrayList(n);
    }

    private static <T> Set<T> zzd(int n, boolean bl) {
        float f = bl ? 0.75f : 1.0f;
        int n2 = bl ? 128 : 256;
        if (n <= n2) {
            return new ArraySet(n);
        }
        return new HashSet(n, f);
    }

    private static <T> Set<T> zze(int n, boolean bl) {
        float f = bl ? 0.75f : 1.0f;
        return new LinkedHashSet(n, f);
    }

    private static <K, V> Map<K, V> zzf(int n, boolean bl) {
        float f = bl ? 0.75f : 1.0f;
        int n2 = bl ? 128 : 256;
        if (n <= n2) {
            return new ArrayMap(n);
        }
        return new HashMap(n, f);
    }

    private static <K, V> Map<K, V> zzg(int n, boolean bl) {
        float f = bl ? 0.75f : 1.0f;
        return new LinkedHashMap(n, f);
    }
}

