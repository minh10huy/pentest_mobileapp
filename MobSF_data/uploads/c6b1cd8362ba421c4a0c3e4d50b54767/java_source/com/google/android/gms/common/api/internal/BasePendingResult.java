/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.os.Handler
 *  android.os.Looper
 *  android.os.Message
 *  android.os.RemoteException
 *  android.util.Log
 *  android.util.Pair
 */
package com.google.android.gms.common.api.internal;

import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.RemoteException;
import android.support.annotation.NonNull;
import android.util.Log;
import android.util.Pair;
import com.google.android.gms.common.annotation.KeepForSdk;
import com.google.android.gms.common.annotation.KeepName;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.common.api.PendingResult;
import com.google.android.gms.common.api.Releasable;
import com.google.android.gms.common.api.Result;
import com.google.android.gms.common.api.ResultCallback;
import com.google.android.gms.common.api.ResultTransform;
import com.google.android.gms.common.api.Status;
import com.google.android.gms.common.api.TransformedResult;
import com.google.android.gms.common.api.internal.zzch;
import com.google.android.gms.common.api.internal.zzcn;
import com.google.android.gms.common.api.internal.zzo;
import com.google.android.gms.common.internal.ICancelToken;
import com.google.android.gms.common.internal.Preconditions;
import com.google.android.gms.common.util.VisibleForTesting;
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

@KeepForSdk
@KeepName
public abstract class BasePendingResult<R extends Result>
extends PendingResult<R> {
    static final ThreadLocal<Boolean> zzez = new zzo();
    @KeepName
    private zza mResultGuardian;
    private Status mStatus;
    private R zzdm;
    private final Object zzfa = new Object();
    private final CallbackHandler<R> zzfb;
    private final WeakReference<GoogleApiClient> zzfc;
    private final CountDownLatch zzfd = new CountDownLatch(1);
    private final ArrayList<PendingResult.StatusListener> zzfe = new ArrayList();
    private ResultCallback<? super R> zzff;
    private final AtomicReference<zzcn> zzfg = new AtomicReference();
    private volatile boolean zzfh;
    private boolean zzfi;
    private boolean zzfj;
    private ICancelToken zzfk;
    private volatile zzch<R> zzfl;
    private boolean zzfm = false;

    @Deprecated
    BasePendingResult() {
        this.zzfb = new CallbackHandler(Looper.getMainLooper());
        this.zzfc = new WeakReference<Object>(null);
    }

    @Deprecated
    @KeepForSdk
    protected BasePendingResult(Looper looper) {
        this.zzfb = new CallbackHandler(looper);
        this.zzfc = new WeakReference<Object>(null);
    }

    @KeepForSdk
    protected BasePendingResult(GoogleApiClient googleApiClient) {
        Looper looper = googleApiClient != null ? googleApiClient.getLooper() : Looper.getMainLooper();
        this.zzfb = new CallbackHandler(looper);
        this.zzfc = new WeakReference<GoogleApiClient>(googleApiClient);
    }

    @KeepForSdk
    @VisibleForTesting
    protected BasePendingResult(@NonNull CallbackHandler<R> callbackHandler) {
        this.zzfb = Preconditions.checkNotNull(callbackHandler, "CallbackHandler must not be null");
        this.zzfc = new WeakReference<Object>(null);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private final R get() {
        R r;
        Object object = this.zzfa;
        synchronized (object) {
            Preconditions.checkState(this.zzfh ^ true, "Result has already been consumed.");
            Preconditions.checkState(this.isReady(), "Result is not ready.");
            r = this.zzdm;
            this.zzdm = null;
            this.zzff = null;
            this.zzfh = true;
        }
        object = this.zzfg.getAndSet(null);
        if (object != null) {
            object.zzc(this);
        }
        return r;
    }

    private final void zza(R object) {
        this.zzdm = object;
        this.zzfk = null;
        this.zzfd.countDown();
        this.mStatus = this.zzdm.getStatus();
        if (this.zzfi) {
            this.zzff = null;
        } else if (this.zzff == null) {
            if (this.zzdm instanceof Releasable) {
                this.mResultGuardian = new zza(null);
            }
        } else {
            this.zzfb.removeMessages(2);
            this.zzfb.zza(this.zzff, (R)this.get());
        }
        object = this.zzfe;
        int n = object.size();
        for (int i = 0; i < n; ++i) {
            Object e = object.get(i);
            ((PendingResult.StatusListener)e).onComplete(this.mStatus);
        }
        this.zzfe.clear();
    }

    public static void zzb(Result object) {
        if (object instanceof Releasable) {
            try {
                ((Releasable)object).release();
                return;
            }
            catch (RuntimeException runtimeException) {
                object = String.valueOf(object);
                StringBuilder stringBuilder = new StringBuilder(String.valueOf(object).length() + 18);
                stringBuilder.append("Unable to release ");
                stringBuilder.append((String)object);
                Log.w((String)"BasePendingResult", (String)stringBuilder.toString(), (Throwable)runtimeException);
            }
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public final void addStatusListener(PendingResult.StatusListener statusListener) {
        boolean bl = statusListener != null;
        Preconditions.checkArgument(bl, "Callback cannot be null.");
        Object object = this.zzfa;
        synchronized (object) {
            if (this.isReady()) {
                statusListener.onComplete(this.mStatus);
            } else {
                this.zzfe.add(statusListener);
            }
            return;
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public final R await() {
        block3 : {
            Preconditions.checkNotMainThread("await must not be called on the UI thread");
            boolean bl = this.zzfh;
            boolean bl2 = true;
            Preconditions.checkState(bl ^ true, "Result has already been consumed");
            if (this.zzfl != null) {
                bl2 = false;
            }
            Preconditions.checkState(bl2, "Cannot await if then() has been called.");
            try {
                this.zzfd.await();
                break block3;
            }
            catch (InterruptedException interruptedException) {}
            this.zzb(Status.RESULT_INTERRUPTED);
        }
        Preconditions.checkState(this.isReady(), "Result is not ready.");
        return this.get();
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public final R await(long l, TimeUnit timeUnit) {
        block5 : {
            if (l > 0L) {
                Preconditions.checkNotMainThread("await must not be called on the UI thread when time is greater than zero.");
            }
            boolean bl = this.zzfh;
            boolean bl2 = true;
            Preconditions.checkState(bl ^ true, "Result has already been consumed.");
            if (this.zzfl != null) {
                bl2 = false;
            }
            Preconditions.checkState(bl2, "Cannot await if then() has been called.");
            try {
                if (!this.zzfd.await(l, timeUnit)) {
                    this.zzb(Status.RESULT_TIMEOUT);
                }
                break block5;
            }
            catch (InterruptedException interruptedException) {}
            this.zzb(Status.RESULT_INTERRUPTED);
        }
        Preconditions.checkState(this.isReady(), "Result is not ready.");
        return this.get();
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    @KeepForSdk
    @Override
    public void cancel() {
        Object object = this.zzfa;
        // MONITORENTER : object
        if (this.zzfi) {
            // MONITOREXIT : object
            return;
        }
        if (this.zzfh) {
            return;
        }
        ICancelToken iCancelToken = this.zzfk;
        if (iCancelToken != null) {
            try {
                this.zzfk.cancel();
            }
            catch (RemoteException remoteException) {}
        }
        BasePendingResult.zzb(this.zzdm);
        this.zzfi = true;
        this.zza(this.createFailedResult(Status.RESULT_CANCELED));
        // MONITOREXIT : object
    }

    @NonNull
    @KeepForSdk
    protected abstract R createFailedResult(Status var1);

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public boolean isCanceled() {
        Object object = this.zzfa;
        synchronized (object) {
            return this.zzfi;
        }
    }

    @KeepForSdk
    public final boolean isReady() {
        if (this.zzfd.getCount() == 0L) {
            return true;
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @KeepForSdk
    protected final void setCancelToken(ICancelToken iCancelToken) {
        Object object = this.zzfa;
        synchronized (object) {
            this.zzfk = iCancelToken;
            return;
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @KeepForSdk
    public final void setResult(R r) {
        Object object = this.zzfa;
        synchronized (object) {
            if (!this.zzfj && !this.zzfi) {
                this.isReady();
                Preconditions.checkState(this.isReady() ^ true, "Results have already been set");
                Preconditions.checkState(this.zzfh ^ true, "Result has already been consumed");
                this.zza(r);
                return;
            }
            BasePendingResult.zzb(r);
            return;
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    @KeepForSdk
    @Override
    public final void setResultCallback(ResultCallback<? super R> var1_1) {
        block5 : {
            var4_3 = this.zzfa;
            // MONITORENTER : var4_3
            if (var1_1 != null) ** GOTO lbl8
            this.zzff = null;
            // MONITOREXIT : var4_3
            return;
lbl8: // 1 sources:
            var3_4 = this.zzfh;
            var2_5 = true;
            Preconditions.checkState(var3_4 ^ true, "Result has already been consumed.");
            if (this.zzfl == null) break block5;
            var2_5 = false;
        }
        Preconditions.checkState(var2_5, "Cannot set callbacks if then() has been called.");
        if (this.isCanceled()) {
            // MONITOREXIT : var4_3
            return;
        }
        if (this.isReady()) {
            this.zzfb.zza(var1_1, (R)this.get());
            return;
        }
        this.zzff = var1_1;
        // MONITOREXIT : var4_3
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    @KeepForSdk
    @Override
    public final void setResultCallback(ResultCallback<? super R> var1_1, long var2_3, TimeUnit var4_4) {
        block5 : {
            var7_5 = this.zzfa;
            // MONITORENTER : var7_5
            if (var1_1 /* !! */  != null) ** GOTO lbl8
            this.zzff = null;
            // MONITOREXIT : var7_5
            return;
lbl8: // 1 sources:
            var6_6 = this.zzfh;
            var5_7 = true;
            Preconditions.checkState(var6_6 ^ true, "Result has already been consumed.");
            if (this.zzfl == null) break block5;
            var5_7 = false;
        }
        Preconditions.checkState(var5_7, "Cannot set callbacks if then() has been called.");
        if (this.isCanceled()) {
            // MONITOREXIT : var7_5
            return;
        }
        if (this.isReady()) {
            this.zzfb.zza(var1_1 /* !! */ , (R)this.get());
            return;
        }
        this.zzff = var1_1 /* !! */ ;
        var1_1 /* !! */  = this.zzfb;
        var2_3 = var4_4.toMillis(var2_3);
        var1_1 /* !! */ .sendMessageDelayed(var1_1 /* !! */ .obtainMessage(2, (Object)this), var2_3);
        // MONITOREXIT : var7_5
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public <S extends Result> TransformedResult<S> then(ResultTransform<? super R, ? extends S> object) {
        Preconditions.checkState(this.zzfh ^ true, "Result has already been consumed.");
        Object object2 = this.zzfa;
        synchronized (object2) {
            zzch<R> zzch2 = this.zzfl;
            boolean bl = false;
            boolean bl2 = zzch2 == null;
            Preconditions.checkState(bl2, "Cannot call then() twice.");
            bl2 = bl;
            if (this.zzff == null) {
                bl2 = true;
            }
            Preconditions.checkState(bl2, "Cannot call then() if callbacks are set.");
            Preconditions.checkState(this.zzfi ^ true, "Cannot call then() if result was canceled.");
            this.zzfm = true;
            this.zzfl = new zzch<R>(this.zzfc);
            object = this.zzfl.then(object);
            if (this.isReady()) {
                this.zzfb.zza(this.zzfl, this.get());
            } else {
                this.zzff = this.zzfl;
            }
            return object;
        }
    }

    public final void zza(zzcn zzcn2) {
        this.zzfg.set(zzcn2);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public final void zzb(Status status) {
        Object object = this.zzfa;
        synchronized (object) {
            if (!this.isReady()) {
                this.setResult(this.createFailedResult(status));
                this.zzfj = true;
            }
            return;
        }
    }

    @Override
    public final Integer zzo() {
        return null;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public final boolean zzw() {
        Object object = this.zzfa;
        synchronized (object) {
            if (this.zzfc.get() != null) {
                if (this.zzfm) return this.isCanceled();
            }
            this.cancel();
            return this.isCanceled();
        }
    }

    public final void zzx() {
        boolean bl = this.zzfm || zzez.get().booleanValue();
        this.zzfm = bl;
    }

    @VisibleForTesting
    public static class CallbackHandler<R extends Result>
    extends Handler {
        public CallbackHandler() {
            this(Looper.getMainLooper());
        }

        public CallbackHandler(Looper looper) {
            super(looper);
        }

        public void handleMessage(Message object) {
            switch (object.what) {
                default: {
                    int n = object.what;
                    object = new StringBuilder(45);
                    object.append("Don't know how to handle message: ");
                    object.append(n);
                    Log.wtf((String)"BasePendingResult", (String)object.toString(), (Throwable)new Exception());
                    return;
                }
                case 2: {
                    ((BasePendingResult)object.obj).zzb(Status.RESULT_TIMEOUT);
                    return;
                }
                case 1: 
            }
            Object object2 = (Pair)object.obj;
            object = (ResultCallback)object2.first;
            object2 = (Result)object2.second;
            try {
                object.onResult(object2);
                return;
            }
            catch (RuntimeException runtimeException) {
                BasePendingResult.zzb((Result)object2);
                throw runtimeException;
            }
        }

        public final void zza(ResultCallback<? super R> resultCallback, R r) {
            this.sendMessage(this.obtainMessage(1, (Object)new Pair(resultCallback, r)));
        }
    }

    private final class zza {
        private zza() {
        }

        /* synthetic */ zza(zzo zzo2) {
            this();
        }

        protected final void finalize() throws Throwable {
            BasePendingResult.zzb(BasePendingResult.this.zzdm);
            super.finalize();
        }
    }

}

