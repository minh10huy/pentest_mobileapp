/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.awt.geom;

import com.itextpdf.awt.geom.AffineTransform;
import com.itextpdf.awt.geom.FlatteningPathIterator;
import com.itextpdf.awt.geom.IllegalPathStateException;
import com.itextpdf.awt.geom.PathIterator;
import com.itextpdf.awt.geom.Point2D;
import com.itextpdf.awt.geom.Rectangle;
import com.itextpdf.awt.geom.Rectangle2D;
import com.itextpdf.awt.geom.Shape;
import com.itextpdf.awt.geom.gl.Crossing;
import com.itextpdf.awt.geom.misc.Messages;
import java.util.NoSuchElementException;

public final class GeneralPath
implements Shape,
Cloneable {
    private static final int BUFFER_CAPACITY = 10;
    private static final int BUFFER_SIZE = 10;
    public static final int WIND_EVEN_ODD = 0;
    public static final int WIND_NON_ZERO = 1;
    static int[] pointShift = new int[]{2, 2, 4, 6, 0};
    int pointSize;
    float[] points;
    int rule;
    int typeSize;
    byte[] types;

    public GeneralPath() {
        this(1, 10);
    }

    public GeneralPath(int n) {
        this(n, 10);
    }

    public GeneralPath(int n, int n2) {
        this.setWindingRule(n);
        this.types = new byte[n2];
        this.points = new float[n2 * 2];
    }

    public GeneralPath(Shape object) {
        this(1, 10);
        object = object.getPathIterator(null);
        this.setWindingRule(object.getWindingRule());
        this.append((PathIterator)object, false);
    }

    public void append(PathIterator pathIterator, boolean bl) {
        while (!pathIterator.isDone()) {
            block10 : {
                float[] arrf = new float[6];
                switch (pathIterator.currentSegment(arrf)) {
                    default: {
                        break block10;
                    }
                    case 4: {
                        this.closePath();
                        break block10;
                    }
                    case 3: {
                        this.curveTo(arrf[0], arrf[1], arrf[2], arrf[3], arrf[4], arrf[5]);
                        break block10;
                    }
                    case 2: {
                        this.quadTo(arrf[0], arrf[1], arrf[2], arrf[3]);
                        break block10;
                    }
                    case 0: {
                        if (!bl || this.typeSize == 0) break;
                        if (this.types[this.typeSize - 1] != 4 && this.points[this.pointSize - 2] == arrf[0] && this.points[this.pointSize - 1] == arrf[1]) break block10;
                    }
                    case 1: {
                        this.lineTo(arrf[0], arrf[1]);
                    }
                    {
                        break block10;
                    }
                }
                this.moveTo(arrf[0], arrf[1]);
            }
            pathIterator.next();
            bl = false;
        }
    }

    public void append(Shape shape, boolean bl) {
        this.append(shape.getPathIterator(null), bl);
    }

    void checkBuf(int n, boolean bl) {
        byte[] arrby;
        if (bl && this.typeSize == 0) {
            throw new IllegalPathStateException(Messages.getString("awt.20A"));
        }
        if (this.typeSize == this.types.length) {
            arrby = new byte[this.typeSize + 10];
            System.arraycopy(this.types, 0, arrby, 0, this.typeSize);
            this.types = arrby;
        }
        if (this.pointSize + n > this.points.length) {
            arrby = new float[this.pointSize + Math.max(20, n)];
            System.arraycopy(this.points, 0, arrby, 0, this.pointSize);
            this.points = arrby;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public Object clone() {
        try {
            GeneralPath generalPath = (GeneralPath)super.clone();
            generalPath.types = (byte[])this.types.clone();
            generalPath.points = (float[])this.points.clone();
            return generalPath;
        }
        catch (CloneNotSupportedException cloneNotSupportedException) {
            throw new InternalError();
        }
    }

    public void closePath() {
        if (this.typeSize == 0 || this.types[this.typeSize - 1] != 4) {
            this.checkBuf(0, true);
            byte[] arrby = this.types;
            int n = this.typeSize;
            this.typeSize = n + 1;
            arrby[n] = 4;
        }
    }

    @Override
    public boolean contains(double d, double d2) {
        return this.isInside(Crossing.crossShape(this, d, d2));
    }

    @Override
    public boolean contains(double d, double d2, double d3, double d4) {
        int n = Crossing.intersectShape(this, d, d2, d3, d4);
        if (n != 255 && this.isInside(n)) {
            return true;
        }
        return false;
    }

    @Override
    public boolean contains(Point2D point2D) {
        return this.contains(point2D.getX(), point2D.getY());
    }

    @Override
    public boolean contains(Rectangle2D rectangle2D) {
        return this.contains(rectangle2D.getX(), rectangle2D.getY(), rectangle2D.getWidth(), rectangle2D.getHeight());
    }

    public Shape createTransformedShape(AffineTransform affineTransform) {
        GeneralPath generalPath = (GeneralPath)this.clone();
        if (affineTransform != null) {
            generalPath.transform(affineTransform);
        }
        return generalPath;
    }

    public void curveTo(float f, float f2, float f3, float f4, float f5, float f6) {
        this.checkBuf(6, true);
        byte[] arrby = this.types;
        int n = this.typeSize;
        this.typeSize = n + 1;
        arrby[n] = 3;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f2;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f3;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f4;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f5;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f6;
    }

    @Override
    public Rectangle getBounds() {
        return this.getBounds2D().getBounds();
    }

    @Override
    public Rectangle2D getBounds2D() {
        float f;
        float f2;
        float f3;
        float f4;
        if (this.pointSize == 0) {
            f3 = 0.0f;
            f2 = 0.0f;
            f4 = 0.0f;
            f = 0.0f;
        } else {
            float f5;
            int n = this.pointSize - 1;
            float[] arrf = this.points;
            int n2 = n - 1;
            float f6 = arrf[n];
            arrf = this.points;
            n = n2 - 1;
            float f7 = f5 = arrf[n2];
            float f8 = f6;
            do {
                f3 = f7;
                f2 = f8;
                f4 = f5;
                f = f6;
                if (n <= 0) break;
                arrf = this.points;
                n2 = n - 1;
                f3 = arrf[n];
                f = this.points[n2];
                if (f < f7) {
                    f2 = f;
                    f4 = f5;
                } else {
                    f2 = f7;
                    f4 = f5;
                    if (f > f5) {
                        f4 = f;
                        f2 = f7;
                    }
                }
                if (f3 < f8) {
                    f5 = f3;
                    f = f6;
                } else {
                    f5 = f8;
                    f = f6;
                    if (f3 > f6) {
                        f = f3;
                        f5 = f8;
                    }
                }
                n = n2 - 1;
                f7 = f2;
                f8 = f5;
                f5 = f4;
                f6 = f;
            } while (true);
        }
        return new Rectangle2D.Float(f3, f2, f4 - f3, f - f2);
    }

    public Point2D getCurrentPoint() {
        int n;
        if (this.typeSize == 0) {
            return null;
        }
        int n2 = n = this.pointSize - 2;
        if (this.types[this.typeSize - 1] == 4) {
            int n3 = this.typeSize - 2;
            do {
                n2 = n;
                if (n3 <= 0) break;
                n2 = this.types[n3];
                if (n2 == 0) {
                    n2 = n;
                    break;
                }
                n -= pointShift[n2];
                --n3;
            } while (true);
        }
        return new Point2D.Float(this.points[n2], this.points[n2 + 1]);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform) {
        return new Iterator(this, affineTransform);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform, double d) {
        return new FlatteningPathIterator(this.getPathIterator(affineTransform), d);
    }

    public int getWindingRule() {
        return this.rule;
    }

    @Override
    public boolean intersects(double d, double d2, double d3, double d4) {
        int n = Crossing.intersectShape(this, d, d2, d3, d4);
        if (n != 255 && !this.isInside(n)) {
            return false;
        }
        return true;
    }

    @Override
    public boolean intersects(Rectangle2D rectangle2D) {
        return this.intersects(rectangle2D.getX(), rectangle2D.getY(), rectangle2D.getWidth(), rectangle2D.getHeight());
    }

    boolean isInside(int n) {
        if (this.rule == 1) {
            return Crossing.isInsideNonZero(n);
        }
        return Crossing.isInsideEvenOdd(n);
    }

    public void lineTo(float f, float f2) {
        this.checkBuf(2, true);
        byte[] arrby = this.types;
        int n = this.typeSize;
        this.typeSize = n + 1;
        arrby[n] = 1;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f2;
    }

    public void moveTo(float f, float f2) {
        if (this.typeSize > 0 && this.types[this.typeSize - 1] == 0) {
            this.points[this.pointSize - 2] = f;
            this.points[this.pointSize - 1] = f2;
            return;
        }
        this.checkBuf(2, false);
        byte[] arrby = this.types;
        int n = this.typeSize;
        this.typeSize = n + 1;
        arrby[n] = 0;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f2;
    }

    public void quadTo(float f, float f2, float f3, float f4) {
        this.checkBuf(4, true);
        byte[] arrby = this.types;
        int n = this.typeSize;
        this.typeSize = n + 1;
        arrby[n] = 2;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f2;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f3;
        arrby = this.points;
        n = this.pointSize;
        this.pointSize = n + 1;
        arrby[n] = (byte)f4;
    }

    public void reset() {
        this.typeSize = 0;
        this.pointSize = 0;
    }

    public void setWindingRule(int n) {
        if (n != 0 && n != 1) {
            throw new IllegalArgumentException(Messages.getString("awt.209"));
        }
        this.rule = n;
    }

    public void transform(AffineTransform affineTransform) {
        affineTransform.transform(this.points, 0, this.points, 0, this.pointSize / 2);
    }

    class Iterator
    implements PathIterator {
        GeneralPath p;
        int pointIndex;
        AffineTransform t;
        int typeIndex;

        Iterator(GeneralPath generalPath2) {
            this(generalPath2, null);
        }

        Iterator(GeneralPath generalPath2, AffineTransform affineTransform) {
            this.p = generalPath2;
            this.t = affineTransform;
        }

        @Override
        public int currentSegment(double[] arrd) {
            if (this.isDone()) {
                throw new NoSuchElementException(Messages.getString("awt.4B"));
            }
            byte by = this.p.types[this.typeIndex];
            int n = GeneralPath.pointShift[by];
            for (int i = 0; i < n; ++i) {
                arrd[i] = this.p.points[this.pointIndex + i];
            }
            if (this.t != null) {
                this.t.transform(arrd, 0, arrd, 0, n / 2);
            }
            this.pointIndex += n;
            return by;
        }

        @Override
        public int currentSegment(float[] arrf) {
            if (this.isDone()) {
                throw new NoSuchElementException(Messages.getString("awt.4B"));
            }
            byte by = this.p.types[this.typeIndex];
            int n = GeneralPath.pointShift[by];
            System.arraycopy(this.p.points, this.pointIndex, arrf, 0, n);
            if (this.t != null) {
                this.t.transform(arrf, 0, arrf, 0, n / 2);
            }
            this.pointIndex += n;
            return by;
        }

        @Override
        public int getWindingRule() {
            return this.p.getWindingRule();
        }

        @Override
        public boolean isDone() {
            if (this.typeIndex >= this.p.typeSize) {
                return true;
            }
            return false;
        }

        @Override
        public void next() {
            ++this.typeIndex;
        }
    }

}

