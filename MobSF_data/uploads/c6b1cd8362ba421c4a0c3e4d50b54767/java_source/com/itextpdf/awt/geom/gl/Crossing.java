/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.awt.geom.gl;

import com.itextpdf.awt.geom.AffineTransform;
import com.itextpdf.awt.geom.PathIterator;
import com.itextpdf.awt.geom.Rectangle2D;
import com.itextpdf.awt.geom.Shape;

public class Crossing {
    public static final int CROSSING = 255;
    static final double DELTA = 1.0E-5;
    static final double ROOT_DELTA = 1.0E-10;
    static final int UNKNOWN = 254;

    static int crossBound(double[] arrd, int n, double d, double d2) {
        int n2;
        if (n == 0) {
            return 0;
        }
        int n3 = 0;
        int n4 = 0;
        for (n2 = 2; n2 < n; n2 += 4) {
            if (arrd[n2] < d) {
                ++n4;
                continue;
            }
            if (arrd[n2] > d2) {
                ++n3;
                continue;
            }
            return 255;
        }
        if (n3 == 0) {
            return 0;
        }
        if (n4 != 0) {
            Crossing.sortBound(arrd, n);
            n2 = arrd[2] > d2 ? 1 : 0;
            n4 = n2;
            for (n3 = 6; n3 < n; n3 += 4) {
                n2 = arrd[n3] > d2 ? 1 : 0;
                if (n4 != n2 && arrd[n3 + 1] != arrd[n3 - 3]) {
                    return 255;
                }
                n4 = n2;
            }
        }
        return 254;
    }

    public static int crossCubic(double d, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10) {
        int n = 0;
        int n2 = 0;
        if (d9 < d && d9 < d3 && d9 < d5 && d9 < d7 || d9 > d && d9 > d3 && d9 > d5 && d9 > d7 || d10 > d2 && d10 > d4 && d10 > d6 && d10 > d8 || d == d3 && d3 == d5 && d5 == d7) {
            return 0;
        }
        if (d10 < d2 && d10 < d4 && d10 < d6 && d10 < d8 && d9 != d && d9 != d7) {
            if (d < d7) {
                int n3 = n2;
                if (d < d9) {
                    n3 = n2;
                    if (d9 < d7) {
                        n3 = 1;
                    }
                }
                return n3;
            }
            int n4 = n;
            if (d7 < d9) {
                n4 = n;
                if (d9 < d) {
                    n4 = -1;
                }
            }
            return n4;
        }
        CubicCurve cubicCurve = new CubicCurve(d, d2, d3, d4, d5, d6, d7, d8);
        d2 = d10 - d2;
        double[] arrd = new double[3];
        return cubicCurve.cross(arrd, cubicCurve.solvePoint(arrd, d9 - d), d2, d2);
    }

    public static int crossLine(double d, double d2, double d3, double d4, double d5, double d6) {
        if (d5 < d && d5 < d3 || d5 > d && d5 > d3 || d6 > d2 && d6 > d4 || d == d3) {
            return 0;
        }
        if ((d6 >= d2 || d6 >= d4) && (d4 - d2) * (d5 - d) / (d3 - d) <= d6 - d2) {
            return 0;
        }
        int n = -1;
        if (d5 == d) {
            if (d < d3) {
                n = 0;
            }
            return n;
        }
        if (d5 == d3) {
            if (d < d3) {
                return 1;
            }
            return 0;
        }
        if (d < d3) {
            n = 1;
        }
        return n;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public static int crossPath(PathIterator var0, double var1_1, double var3_2) {
        block14 : {
            var28_3 = new double[6];
            var27_4 = 0;
            var11_5 = 0.0;
            var9_8 = var15_7 = (var13_6 = 0.0);
            var26_9 = 0;
            while (!var0.isDone()) {
                switch (var0.currentSegment(var28_3)) {
                    default: {
                        var17_12 = var11_5;
                        var5_10 = var13_6;
                        var7_11 = var15_7;
                        var25_16 = var26_9;
                        var19_13 = var9_8;
                        break;
                    }
                    case 4: {
                        if (var15_7 == var9_8) {
                            var17_12 = var11_5;
                            var5_10 = var13_6;
                            var7_11 = var15_7;
                            var25_16 = var26_9;
                            var19_13 = var9_8;
                            if (var13_6 == var11_5) break;
                        }
                        var25_16 = var26_9 + Crossing.crossLine(var13_6, var15_7, var11_5, var9_8, var1_1, var3_2);
                        var5_10 = var11_5;
                        var7_11 = var9_8;
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 3: {
                        var17_12 = var28_3[0];
                        var19_13 = var28_3[1];
                        var21_14 = var28_3[2];
                        var23_15 = var28_3[3];
                        var5_10 = var28_3[4];
                        var7_11 = var28_3[5];
                        var25_16 = var26_9 + Crossing.crossCubic(var13_6, var15_7, var17_12, var19_13, var21_14, var23_15, var5_10, var7_11, var1_1, var3_2);
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 2: {
                        var17_12 = var28_3[0];
                        var19_13 = var28_3[1];
                        var5_10 = var28_3[2];
                        var7_11 = var28_3[3];
                        var25_16 = var26_9 + Crossing.crossQuad(var13_6, var15_7, var17_12, var19_13, var5_10, var7_11, var1_1, var3_2);
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 1: {
                        var5_10 = var28_3[0];
                        var7_11 = var28_3[1];
                        var25_16 = var26_9 + Crossing.crossLine(var13_6, var15_7, var5_10, var7_11, var1_1, var3_2);
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 0: {
                        if (var13_6 != var11_5) ** GOTO lbl60
                        var25_16 = var26_9;
                        if (var15_7 == var9_8) ** GOTO lbl61
lbl60: // 2 sources:
                        var25_16 = var26_9 + Crossing.crossLine(var13_6, var15_7, var11_5, var9_8, var1_1, var3_2);
lbl61: // 2 sources:
                        var17_12 = var28_3[0];
                        var19_13 = var7_11 = var28_3[1];
                        var5_10 = var17_12;
                    }
                }
                if (var1_1 == var5_10 && var3_2 == var7_11) {
                    var13_6 = var5_10;
                    var5_10 = var19_13;
                    var25_16 = var27_4;
                    var15_7 = var19_13;
                    var11_5 = var17_12;
                    break block14;
                }
                var0.next();
                var11_5 = var17_12;
                var13_6 = var5_10;
                var15_7 = var7_11;
                var26_9 = var25_16;
                var9_8 = var19_13;
            }
            var25_16 = var26_9;
            var5_10 = var9_8;
        }
        var26_9 = var25_16;
        if (var15_7 == var5_10) return var26_9;
        return var25_16 + Crossing.crossLine(var13_6, var15_7, var11_5, var5_10, var1_1, var3_2);
    }

    public static int crossQuad(double d, double d2, double d3, double d4, double d5, double d6, double d7, double d8) {
        int n = 0;
        int n2 = 0;
        if (d7 < d && d7 < d3 && d7 < d5 || d7 > d && d7 > d3 && d7 > d5 || d8 > d2 && d8 > d4 && d8 > d6 || d == d3 && d3 == d5) {
            return 0;
        }
        if (d8 < d2 && d8 < d4 && d8 < d6 && d7 != d && d7 != d5) {
            if (d < d5) {
                int n3 = n2;
                if (d < d7) {
                    n3 = n2;
                    if (d7 < d5) {
                        n3 = 1;
                    }
                }
                return n3;
            }
            int n4 = n;
            if (d5 < d7) {
                n4 = n;
                if (d7 < d) {
                    n4 = -1;
                }
            }
            return n4;
        }
        QuadCurve quadCurve = new QuadCurve(d, d2, d3, d4, d5, d6);
        d2 = d8 - d2;
        double[] arrd = new double[3];
        return quadCurve.cross(arrd, quadCurve.solvePoint(arrd, d7 - d), d2, d2);
    }

    public static int crossShape(Shape shape, double d, double d2) {
        if (!shape.getBounds2D().contains(d, d2)) {
            return 0;
        }
        return Crossing.crossPath(shape.getPathIterator(null), d, d2);
    }

    static int fixRoots(double[] arrd, int n) {
        int n2 = 0;
        int n3 = 0;
        while (n2 < n) {
            int n4;
            block3 : {
                for (int i = n4 = n2 + 1; i < n; ++i) {
                    if (!Crossing.isZero(arrd[n2] - arrd[i])) {
                        continue;
                    }
                    break block3;
                }
                arrd[n3] = arrd[n2];
                ++n3;
            }
            n2 = n4;
        }
        return n3;
    }

    public static int intersectCubic(double d, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10, double d11, double d12) {
        int n;
        int n2 = 0;
        int n3 = 0;
        if (d11 < d && d11 < d3 && d11 < d5 && d11 < d7 || d9 > d && d9 > d3 && d9 > d5 && d9 > d7 || d10 > d2 && d10 > d4 && d10 > d6 && d10 > d8) {
            return 0;
        }
        if (d12 < d2 && d12 < d4 && d12 < d6 && d12 < d8 && d9 != d && d9 != d7) {
            if (d < d7) {
                int n4 = n3;
                if (d < d9) {
                    n4 = n3;
                    if (d9 < d7) {
                        n4 = 1;
                    }
                }
                return n4;
            }
            int n5 = n2;
            if (d7 < d9) {
                n5 = n2;
                if (d9 < d) {
                    n5 = -1;
                }
            }
            return n5;
        }
        CubicCurve cubicCurve = new CubicCurve(d, d2, d3, d4, d5, d6, d7, d8);
        d4 = d9 - d;
        d3 = d10 - d2;
        d5 = d11 - d;
        d2 = d12 - d2;
        double[] arrd = new double[3];
        double[] arrd2 = new double[3];
        n2 = cubicCurve.solvePoint(arrd, d4);
        int n6 = cubicCurve.solvePoint(arrd2, d5);
        if (n2 == 0 && n6 == 0) {
            return 0;
        }
        double[] arrd3 = new double[40];
        n6 = n3 = cubicCurve.addBound(arrd3, cubicCurve.addBound(arrd3, cubicCurve.addBound(arrd3, cubicCurve.addBound(arrd3, 0, arrd, n2, d4, d5, false, 0), arrd2, n6, d4, d5, false, 1), arrd2, cubicCurve.solveExtremX(arrd2), d4, d5, true, 2), arrd2, cubicCurve.solveExtremY(arrd2), d4 -= 1.0E-5, d5 += 1.0E-5, true, 4);
        if (d9 < d) {
            n6 = n3;
            if (d < d11) {
                n6 = n3 + 1;
                arrd3[n3] = 0.0;
                n3 = n6 + 1;
                arrd3[n6] = 0.0;
                n = n3 + 1;
                arrd3[n3] = 0.0;
                n6 = n + 1;
                arrd3[n] = 6.0;
            }
        }
        n3 = n6;
        if (d9 < d7) {
            n3 = n6;
            if (d7 < d11) {
                n3 = n6 + 1;
                arrd3[n6] = 1.0;
                n6 = n3 + 1;
                arrd3[n3] = cubicCurve.ax;
                n = n6 + 1;
                arrd3[n6] = cubicCurve.ay;
                n3 = n + 1;
                arrd3[n] = 7.0;
            }
        }
        if ((n6 = Crossing.crossBound(arrd3, n3, d3, d2)) != 254) {
            return n6;
        }
        return cubicCurve.cross(arrd, n2, d3, d2);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public static int intersectLine(double var0, double var2_1, double var4_2, double var6_3, double var8_4, double var10_5, double var12_6, double var14_7) {
        block11 : {
            block13 : {
                block12 : {
                    var21_8 = 0;
                    var22_9 = 0;
                    var20_10 = 0;
                    if (var12_6 < var0) {
                        if (var12_6 < var4_2) return 0;
                    }
                    if (var8_4 > var0) {
                        if (var8_4 > var4_2) return 0;
                    }
                    if (var10_5 > var2_1 && var10_5 > var6_3) {
                        return 0;
                    }
                    if (var14_7 < var2_1 && var14_7 < var6_3) break block11;
                    if (var0 == var4_2) {
                        return 255;
                    }
                    if (var0 >= var4_2) break block12;
                    var16_11 = var0 < var8_4 ? var8_4 : var0;
                    var18_12 = var16_11;
                    if (var4_2 >= var12_6) ** GOTO lbl-1000
                    var12_6 = var4_2;
                    break block13;
                }
                var16_11 = var4_2 < var8_4 ? var8_4 : var4_2;
                var18_12 = var16_11;
                if (var0 < var12_6) {
                    var12_6 = var0;
                } else lbl-1000: // 2 sources:
                {
                    var16_11 = var18_12;
                }
            }
            var6_3 = (var6_3 - var2_1) / (var4_2 - var0);
            var16_11 = (var16_11 - var0) * var6_3 + var2_1;
            var2_1 = var6_3 * (var12_6 - var0) + var2_1;
            if (var16_11 < var10_5 && var2_1 < var10_5) {
                return 0;
            }
            if (var16_11 <= var14_7) return 255;
            if (var2_1 <= var14_7) return 255;
        }
        if (var0 == var4_2) {
            return 0;
        }
        if (var8_4 == var0) {
            if (var0 >= var4_2) return -1;
            return 0;
        }
        if (var8_4 == var4_2) {
            if (var0 >= var4_2) return var20_10;
            return 1;
        }
        if (var0 < var4_2) {
            var20_10 = var21_8;
            if (var0 >= var8_4) return var20_10;
            var20_10 = var21_8;
            if (var8_4 >= var4_2) return var20_10;
            return 1;
        }
        var20_10 = var22_9;
        if (var4_2 >= var8_4) return var20_10;
        var20_10 = var22_9;
        if (var8_4 >= var0) return var20_10;
        return -1;
    }

    public static int intersectPath(PathIterator pathIterator, double d, double d2, double d3, double d4) {
        double d5;
        int n;
        double[] arrd = new double[6];
        double d6 = d + d3;
        double d7 = d2 + d4;
        d3 = 0.0;
        double d8 = d5 = (d4 = 0.0);
        int n2 = 0;
        while (!pathIterator.isDone()) {
            switch (pathIterator.currentSegment(arrd)) {
                double d9;
                double d10;
                double d11;
                double d12;
                default: {
                    n = 0;
                    break;
                }
                case 4: {
                    n = d4 == d5 && d3 == d8 ? 0 : Crossing.intersectLine(d3, d4, d8, d5, d, d2, d6, d7);
                    d4 = d5;
                    d3 = d8;
                    break;
                }
                case 3: {
                    d11 = arrd[0];
                    d9 = arrd[1];
                    double d13 = arrd[2];
                    double d14 = arrd[3];
                    d10 = arrd[4];
                    d12 = arrd[5];
                    n = Crossing.intersectCubic(d3, d4, d11, d9, d13, d14, d10, d12, d, d2, d6, d7);
                    d3 = d10;
                    d4 = d12;
                    break;
                }
                case 2: {
                    d11 = arrd[0];
                    d9 = arrd[1];
                    d12 = arrd[2];
                    d10 = arrd[3];
                    n = Crossing.intersectQuad(d3, d4, d11, d9, d12, d10, d, d2, d6, d7);
                    d4 = d10;
                    d3 = d12;
                    break;
                }
                case 1: {
                    d12 = arrd[0];
                    d10 = arrd[1];
                    n = Crossing.intersectLine(d3, d4, d12, d10, d, d2, d6, d7);
                    d4 = d10;
                    d3 = d12;
                    break;
                }
                case 0: {
                    n = d3 == d8 && d4 == d5 ? 0 : Crossing.intersectLine(d3, d4, d8, d5, d, d2, d6, d7);
                    d3 = arrd[0];
                    d4 = arrd[1];
                    d8 = d3;
                    d12 = d4;
                    d5 = d4;
                    d4 = d12;
                }
            }
            if (n == 255) {
                return 255;
            }
            n2 += n;
            pathIterator.next();
        }
        n = n2;
        if (d4 != d5) {
            n = Crossing.intersectLine(d3, d4, d8, d5, d, d2, d6, d7);
            if (n == 255) {
                return 255;
            }
            n = n2 + n;
        }
        return n;
    }

    public static int intersectQuad(double d, double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10) {
        int n;
        int n2 = 0;
        int n3 = 0;
        if (d9 < d && d9 < d3 && d9 < d5 || d7 > d && d7 > d3 && d7 > d5 || d8 > d2 && d8 > d4 && d8 > d6) {
            return 0;
        }
        if (d10 < d2 && d10 < d4 && d10 < d6 && d7 != d && d7 != d5) {
            if (d < d5) {
                int n4 = n3;
                if (d < d7) {
                    n4 = n3;
                    if (d7 < d5) {
                        n4 = 1;
                    }
                }
                return n4;
            }
            int n5 = n2;
            if (d5 < d7) {
                n5 = n2;
                if (d7 < d) {
                    n5 = -1;
                }
            }
            return n5;
        }
        QuadCurve quadCurve = new QuadCurve(d, d2, d3, d4, d5, d6);
        d4 = d7 - d;
        d3 = d8 - d2;
        d6 = d9 - d;
        d2 = d10 - d2;
        double[] arrd = new double[3];
        double[] arrd2 = new double[3];
        n2 = quadCurve.solvePoint(arrd, d4);
        int n6 = quadCurve.solvePoint(arrd2, d6);
        if (n2 == 0 && n6 == 0) {
            return 0;
        }
        double[] arrd3 = new double[28];
        n6 = n3 = quadCurve.addBound(arrd3, quadCurve.addBound(arrd3, quadCurve.addBound(arrd3, 0, arrd, n2, d4, d6, false, 0), arrd2, n6, d4, d6, false, 1), arrd2, quadCurve.solveExtrem(arrd2), d4 -= 1.0E-5, d6 += 1.0E-5, true, 2);
        if (d7 < d) {
            n6 = n3;
            if (d < d9) {
                n6 = n3 + 1;
                arrd3[n3] = 0.0;
                n3 = n6 + 1;
                arrd3[n6] = 0.0;
                n = n3 + 1;
                arrd3[n3] = 0.0;
                n6 = n + 1;
                arrd3[n] = 4.0;
            }
        }
        n3 = n6;
        if (d7 < d5) {
            n3 = n6;
            if (d5 < d9) {
                n3 = n6 + 1;
                arrd3[n6] = 1.0;
                n6 = n3 + 1;
                arrd3[n3] = quadCurve.ax;
                n = n6 + 1;
                arrd3[n6] = quadCurve.ay;
                n3 = n + 1;
                arrd3[n] = 5.0;
            }
        }
        if ((n6 = Crossing.crossBound(arrd3, n3, d3, d2)) != 254) {
            return n6;
        }
        return quadCurve.cross(arrd, n2, d3, d2);
    }

    public static int intersectShape(Shape shape, double d, double d2, double d3, double d4) {
        if (!shape.getBounds2D().intersects(d, d2, d3, d4)) {
            return 0;
        }
        return Crossing.intersectPath(shape.getPathIterator(null), d, d2, d3, d4);
    }

    public static boolean isInsideEvenOdd(int n) {
        if ((n & 1) != 0) {
            return true;
        }
        return false;
    }

    public static boolean isInsideNonZero(int n) {
        if (n != 0) {
            return true;
        }
        return false;
    }

    public static boolean isZero(double d) {
        if (-1.0E-5 < d && d < 1.0E-5) {
            return true;
        }
        return false;
    }

    public static int solveCubic(double[] arrd, double[] arrd2) {
        int n;
        double d = arrd[3];
        if (d == 0.0) {
            return Crossing.solveQuad(arrd, arrd2);
        }
        double d2 = arrd[2] / d;
        int n2 = 1;
        double d3 = arrd[1] / d;
        double d4 = arrd[0] / d;
        d = (d2 * d2 - d3 * 3.0) / 9.0;
        double d5 = (d2 * 2.0 * d2 * d2 - 9.0 * d2 * d3 + d4 * 27.0) / 54.0;
        d3 = d * d * d;
        double d6 = d5 * d5;
        d4 = (- d2) / 3.0;
        if (d6 < d3) {
            d2 = Math.acos(d5 / Math.sqrt(d3)) / 3.0;
            d3 = Math.sqrt(d) * -2.0;
            arrd2[0] = Math.cos(d2) * d3 + d4;
            arrd2[1] = Math.cos(d2 + 2.0943951023931953) * d3 + d4;
            arrd2[2] = d3 * Math.cos(d2 - 2.0943951023931953) + d4;
            n = 3;
        } else {
            d2 = Math.abs(d5);
            d2 = d3 = Math.pow(d2 + Math.sqrt(d6 -= d3), 0.3333333333333333);
            if (d5 > 0.0) {
                d2 = - d3;
            }
            if (-1.0E-10 < d2 && d2 < 1.0E-10) {
                arrd2[0] = d4;
                n = n2;
            } else {
                d2 += d / d2;
                arrd2[0] = d2 + d4;
                n = n2;
                if (-1.0E-10 < d6) {
                    n = n2;
                    if (d6 < 1.0E-10) {
                        arrd2[1] = (- d2) / 2.0 + d4;
                        n = 2;
                    }
                }
            }
        }
        return Crossing.fixRoots(arrd2, n);
    }

    public static int solveQuad(double[] arrd, double[] arrd2) {
        double d = arrd[2];
        int n = 1;
        double d2 = arrd[1];
        double d3 = arrd[0];
        if (d == 0.0) {
            if (d2 == 0.0) {
                return -1;
            }
            arrd2[0] = (- d3) / d2;
        } else {
            if ((d3 = d2 * d2 - 4.0 * d * d3) < 0.0) {
                return 0;
            }
            d3 = Math.sqrt(d3);
            d2 = - d2;
            arrd2[0] = (d2 + d3) / (d *= 2.0);
            if (d3 != 0.0) {
                arrd2[1] = (d2 - d3) / d;
                n = 2;
            }
        }
        return Crossing.fixRoots(arrd2, n);
    }

    static void sortBound(double[] arrd, int n) {
        int n2 = 0;
        while (n2 < n - 4) {
            int n3;
            int n4;
            int n5 = n2 + 4;
            int n6 = n2;
            for (n4 = n5; n4 < n; n4 += 4) {
                n3 = n6;
                if (arrd[n6] > arrd[n4]) {
                    n3 = n4;
                }
                n6 = n3;
            }
            if (n6 != n2) {
                double d = arrd[n2];
                arrd[n2] = arrd[n6];
                arrd[n6] = d;
                n4 = n2 + 1;
                d = arrd[n4];
                n3 = n6 + 1;
                arrd[n4] = arrd[n3];
                arrd[n3] = d;
                n4 = n2 + 2;
                d = arrd[n4];
                n3 = n6 + 2;
                arrd[n4] = arrd[n3];
                arrd[n3] = d;
                d = arrd[n2 += 3];
                n4 = n6 + 3;
                arrd[n2] = arrd[n4];
                arrd[n4] = d;
            }
            n2 = n5;
        }
    }

    public static class CubicCurve {
        double Ax;
        double Ax3;
        double Ay;
        double Bx;
        double Bx2;
        double By;
        double Cx;
        double Cy;
        double ax;
        double ay;
        double bx;
        double by;
        double cx;
        double cy;

        public CubicCurve(double d, double d2, double d3, double d4, double d5, double d6, double d7, double d8) {
            this.ax = d7 - d;
            this.ay = d8 - d2;
            this.bx = d3 - d;
            this.by = d4 - d2;
            this.cx = d5 - d;
            this.cy = d6 - d2;
            this.Cx = this.bx + this.bx + this.bx;
            this.Bx = this.cx + this.cx + this.cx - this.Cx - this.Cx;
            this.Ax = this.ax - this.Bx - this.Cx;
            this.Cy = this.by + this.by + this.by;
            this.By = this.cy + this.cy + this.cy - this.Cy - this.Cy;
            this.Ay = this.ay - this.By - this.Cy;
            this.Ax3 = this.Ax + this.Ax + this.Ax;
            this.Bx2 = this.Bx + this.Bx;
        }

        int addBound(double[] arrd, int n, double[] arrd2, int n2, double d, double d2, boolean bl, int n3) {
            int n4 = n;
            n = n3;
            for (n3 = 0; n3 < n2; ++n3) {
                double d3 = arrd2[n3];
                int n5 = n4;
                int n6 = n;
                if (d3 > -1.0E-5) {
                    n5 = n4;
                    n6 = n;
                    if (d3 < 1.00001) {
                        double d4 = ((this.Ax * d3 + this.Bx) * d3 + this.Cx) * d3;
                        n5 = n4;
                        n6 = n;
                        if (d <= d4) {
                            n5 = n4;
                            n6 = n;
                            if (d4 <= d2) {
                                n5 = n4 + 1;
                                arrd[n4] = d3;
                                n4 = n5 + 1;
                                arrd[n5] = d4;
                                n5 = n4 + 1;
                                arrd[n4] = d3 * ((this.Ay * d3 + this.By) * d3 + this.Cy);
                                n4 = n5 + 1;
                                arrd[n5] = n;
                                n5 = n4;
                                n6 = n;
                                if (bl) {
                                    n6 = n + 1;
                                    n5 = n4;
                                }
                            }
                        }
                    }
                }
                n4 = n5;
                n = n6;
            }
            return n4;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        int cross(double[] var1_1, int var2_2, double var3_3, double var5_4) {
            var14_5 = 0;
            var15_6 = 0;
            while (var14_5 < var2_2) {
                block17 : {
                    block20 : {
                        block21 : {
                            block19 : {
                                block18 : {
                                    var11_9 = var1_1[var14_5];
                                    var13_10 = var15_6;
                                    if (var11_9 < -1.0E-5) break block17;
                                    if (var11_9 <= 1.00001) break block18;
                                    var13_10 = var15_6;
                                    break block17;
                                }
                                if (var11_9 >= 1.0E-5) break block19;
                                var13_10 = var15_6;
                                if (var3_3 < 0.0) {
                                    if (this.bx != 0.0) {
                                        var7_7 = this.bx;
                                    } else {
                                        if (this.cx != this.bx) {
                                            var7_7 = this.cx;
                                            var9_8 = this.bx;
                                        } else {
                                            var7_7 = this.ax;
                                            var9_8 = this.cx;
                                        }
                                        var7_7 -= var9_8;
                                    }
                                    var13_10 = var15_6;
                                    if (var7_7 < 0.0) {
                                        var13_10 = var15_6 - 1;
                                    }
                                }
                                break block17;
                            }
                            if (var11_9 <= 0.99999) break block20;
                            var13_10 = var15_6;
                            if (var3_3 >= this.ay) break block17;
                            if (this.ax == this.cx) break block21;
                            var7_7 = this.ax;
                            var9_8 = this.cx;
                            ** GOTO lbl40
                        }
                        if (this.cx != this.bx) {
                            var7_7 = this.cx;
                            var9_8 = this.bx;
lbl40: // 2 sources:
                            var7_7 -= var9_8;
                        } else {
                            var7_7 = this.bx;
                        }
                        var13_10 = var15_6;
                        if (var7_7 > 0.0) {
                            var13_10 = var15_6 + 1;
                        }
                        break block17;
                    }
                    var13_10 = var15_6;
                    if (((this.Ay * var11_9 + this.By) * var11_9 + this.Cy) * var11_9 <= var5_4) break block17;
                    var7_7 = var9_8 = (this.Ax3 * var11_9 + this.Bx2) * var11_9 + this.Cx;
                    if (var9_8 <= -1.0E-5) ** GOTO lbl61
                    var7_7 = var9_8;
                    if (var9_8 >= 1.0E-5) ** GOTO lbl61
                    var7_7 = var11_9 * (this.Ax3 + this.Ax3) + this.Bx2;
                    var13_10 = var15_6;
                    if (var7_7 < -1.0E-5) break block17;
                    if (var7_7 > 1.0E-5) {
                        var13_10 = var15_6;
                    } else {
                        var7_7 = this.ax;
lbl61: // 3 sources:
                        var13_10 = var7_7 > 0.0 ? 1 : -1;
                        var13_10 = var15_6 + var13_10;
                    }
                }
                ++var14_5;
                var15_6 = var13_10;
            }
            return var15_6;
        }

        int solveExtremX(double[] arrd) {
            return Crossing.solveQuad(new double[]{this.Cx, this.Bx2, this.Ax3}, arrd);
        }

        int solveExtremY(double[] arrd) {
            return Crossing.solveQuad(new double[]{this.Cy, this.By + this.By, this.Ay + this.Ay + this.Ay}, arrd);
        }

        int solvePoint(double[] arrd, double d) {
            return Crossing.solveCubic(new double[]{- d, this.Cx, this.Bx, this.Ax}, arrd);
        }
    }

    public static class QuadCurve {
        double Ax;
        double Ay;
        double Bx;
        double By;
        double ax;
        double ay;
        double bx;
        double by;

        public QuadCurve(double d, double d2, double d3, double d4, double d5, double d6) {
            this.ax = d5 - d;
            this.ay = d6 - d2;
            this.bx = d3 - d;
            this.by = d4 - d2;
            this.Bx = this.bx + this.bx;
            this.Ax = this.ax - this.Bx;
            this.By = this.by + this.by;
            this.Ay = this.ay - this.By;
        }

        int addBound(double[] arrd, int n, double[] arrd2, int n2, double d, double d2, boolean bl, int n3) {
            int n4 = n;
            n = n3;
            for (n3 = 0; n3 < n2; ++n3) {
                double d3 = arrd2[n3];
                int n5 = n4;
                int n6 = n;
                if (d3 > -1.0E-5) {
                    n5 = n4;
                    n6 = n;
                    if (d3 < 1.00001) {
                        double d4 = (this.Ax * d3 + this.Bx) * d3;
                        n5 = n4;
                        n6 = n;
                        if (d <= d4) {
                            n5 = n4;
                            n6 = n;
                            if (d4 <= d2) {
                                n5 = n4 + 1;
                                arrd[n4] = d3;
                                n4 = n5 + 1;
                                arrd[n5] = d4;
                                n5 = n4 + 1;
                                arrd[n4] = d3 * (this.Ay * d3 + this.By);
                                n4 = n5 + 1;
                                arrd[n5] = n;
                                n5 = n4;
                                n6 = n;
                                if (bl) {
                                    n6 = n + 1;
                                    n5 = n4;
                                }
                            }
                        }
                    }
                }
                n4 = n5;
                n = n6;
            }
            return n4;
        }

        int cross(double[] arrd, int n, double d, double d2) {
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                double d3 = arrd[i];
                int n3 = n2;
                if (d3 >= -1.0E-5) {
                    if (d3 > 1.00001) {
                        n3 = n2;
                    } else if (d3 < 1.0E-5) {
                        n3 = n2;
                        if (d < 0.0) {
                            d3 = this.bx != 0.0 ? this.bx : this.ax - this.bx;
                            n3 = n2;
                            if (d3 < 0.0) {
                                n3 = n2 - 1;
                            }
                        }
                    } else if (d3 > 0.99999) {
                        n3 = n2;
                        if (d < this.ay) {
                            d3 = this.ax != this.bx ? this.ax - this.bx : this.bx;
                            n3 = n2;
                            if (d3 > 0.0) {
                                n3 = n2 + 1;
                            }
                        }
                    } else {
                        n3 = n2;
                        if ((this.Ay * d3 + this.By) * d3 > d2) {
                            if ((d3 = d3 * this.Ax + this.bx) > -1.0E-5 && d3 < 1.0E-5) {
                                n3 = n2;
                            } else {
                                n3 = d3 > 0.0 ? 1 : -1;
                                n3 = n2 + n3;
                            }
                        }
                    }
                }
                n2 = n3;
            }
            return n2;
        }

        int solveExtrem(double[] arrd) {
            double d = this.Ax;
            int n = 0;
            if (d != 0.0) {
                arrd[0] = (- this.Bx) / (this.Ax + this.Ax);
                n = 1;
            }
            int n2 = n;
            if (this.Ay != 0.0) {
                arrd[n] = (- this.By) / (this.Ay + this.Ay);
                n2 = n + 1;
            }
            return n2;
        }

        int solvePoint(double[] arrd, double d) {
            return Crossing.solveQuad(new double[]{- d, this.Bx, this.Ax}, arrd);
        }
    }

}

