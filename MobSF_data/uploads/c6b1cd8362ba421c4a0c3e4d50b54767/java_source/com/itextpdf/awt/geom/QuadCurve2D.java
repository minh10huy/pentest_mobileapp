/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.awt.geom;

import com.itextpdf.awt.geom.AffineTransform;
import com.itextpdf.awt.geom.FlatteningPathIterator;
import com.itextpdf.awt.geom.Line2D;
import com.itextpdf.awt.geom.PathIterator;
import com.itextpdf.awt.geom.Point2D;
import com.itextpdf.awt.geom.Rectangle;
import com.itextpdf.awt.geom.Rectangle2D;
import com.itextpdf.awt.geom.Shape;
import com.itextpdf.awt.geom.gl.Crossing;
import com.itextpdf.awt.geom.misc.Messages;
import java.util.NoSuchElementException;

public abstract class QuadCurve2D
implements Shape,
Cloneable {
    protected QuadCurve2D() {
    }

    public static double getFlatness(double d, double d2, double d3, double d4, double d5, double d6) {
        return Line2D.ptSegDist(d, d2, d5, d6, d3, d4);
    }

    public static double getFlatness(double[] arrd, int n) {
        return Line2D.ptSegDist(arrd[n + 0], arrd[n + 1], arrd[n + 4], arrd[n + 5], arrd[n + 2], arrd[n + 3]);
    }

    public static double getFlatnessSq(double d, double d2, double d3, double d4, double d5, double d6) {
        return Line2D.ptSegDistSq(d, d2, d5, d6, d3, d4);
    }

    public static double getFlatnessSq(double[] arrd, int n) {
        return Line2D.ptSegDistSq(arrd[n + 0], arrd[n + 1], arrd[n + 4], arrd[n + 5], arrd[n + 2], arrd[n + 3]);
    }

    public static int solveQuadratic(double[] arrd) {
        return QuadCurve2D.solveQuadratic(arrd, arrd);
    }

    public static int solveQuadratic(double[] arrd, double[] arrd2) {
        return Crossing.solveQuad(arrd, arrd2);
    }

    public static void subdivide(QuadCurve2D quadCurve2D, QuadCurve2D quadCurve2D2, QuadCurve2D quadCurve2D3) {
        double d = quadCurve2D.getX1();
        double d2 = quadCurve2D.getY1();
        double d3 = quadCurve2D.getCtrlX();
        double d4 = quadCurve2D.getCtrlY();
        double d5 = quadCurve2D.getX2();
        double d6 = quadCurve2D.getY2();
        double d7 = (d + d3) / 2.0;
        double d8 = (d2 + d4) / 2.0;
        d3 = (d5 + d3) / 2.0;
        d4 = (d6 + d4) / 2.0;
        double d9 = (d7 + d3) / 2.0;
        double d10 = (d8 + d4) / 2.0;
        if (quadCurve2D2 != null) {
            quadCurve2D2.setCurve(d, d2, d7, d8, d9, d10);
        }
        if (quadCurve2D3 != null) {
            quadCurve2D3.setCurve(d9, d10, d3, d4, d5, d6);
        }
    }

    public static void subdivide(double[] arrd, int n, double[] arrd2, int n2, double[] arrd3, int n3) {
        double d = arrd[n + 0];
        double d2 = arrd[n + 1];
        double d3 = arrd[n + 2];
        double d4 = arrd[n + 3];
        double d5 = arrd[n + 4];
        double d6 = arrd[n + 5];
        double d7 = (d + d3) / 2.0;
        double d8 = (d2 + d4) / 2.0;
        d3 = (d3 + d5) / 2.0;
        d4 = (d4 + d6) / 2.0;
        double d9 = (d7 + d3) / 2.0;
        double d10 = (d8 + d4) / 2.0;
        if (arrd2 != null) {
            arrd2[n2 + 0] = d;
            arrd2[n2 + 1] = d2;
            arrd2[n2 + 2] = d7;
            arrd2[n2 + 3] = d8;
            arrd2[n2 + 4] = d9;
            arrd2[n2 + 5] = d10;
        }
        if (arrd3 != null) {
            arrd3[n3 + 0] = d9;
            arrd3[n3 + 1] = d10;
            arrd3[n3 + 2] = d3;
            arrd3[n3 + 3] = d4;
            arrd3[n3 + 4] = d5;
            arrd3[n3 + 5] = d6;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public Object clone() {
        try {
            return super.clone();
        }
        catch (CloneNotSupportedException cloneNotSupportedException) {
            throw new InternalError();
        }
    }

    @Override
    public boolean contains(double d, double d2) {
        return Crossing.isInsideEvenOdd(Crossing.crossShape(this, d, d2));
    }

    @Override
    public boolean contains(double d, double d2, double d3, double d4) {
        int n = Crossing.intersectShape(this, d, d2, d3, d4);
        if (n != 255 && Crossing.isInsideEvenOdd(n)) {
            return true;
        }
        return false;
    }

    @Override
    public boolean contains(Point2D point2D) {
        return this.contains(point2D.getX(), point2D.getY());
    }

    @Override
    public boolean contains(Rectangle2D rectangle2D) {
        return this.contains(rectangle2D.getX(), rectangle2D.getY(), rectangle2D.getWidth(), rectangle2D.getHeight());
    }

    @Override
    public Rectangle getBounds() {
        return this.getBounds2D().getBounds();
    }

    public abstract Point2D getCtrlPt();

    public abstract double getCtrlX();

    public abstract double getCtrlY();

    public double getFlatness() {
        return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
    }

    public double getFlatnessSq() {
        return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), this.getCtrlX(), this.getCtrlY());
    }

    public abstract Point2D getP1();

    public abstract Point2D getP2();

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform) {
        return new Iterator(this, affineTransform);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform, double d) {
        return new FlatteningPathIterator(this.getPathIterator(affineTransform), d);
    }

    public abstract double getX1();

    public abstract double getX2();

    public abstract double getY1();

    public abstract double getY2();

    @Override
    public boolean intersects(double d, double d2, double d3, double d4) {
        int n = Crossing.intersectShape(this, d, d2, d3, d4);
        if (n != 255 && !Crossing.isInsideEvenOdd(n)) {
            return false;
        }
        return true;
    }

    @Override
    public boolean intersects(Rectangle2D rectangle2D) {
        return this.intersects(rectangle2D.getX(), rectangle2D.getY(), rectangle2D.getWidth(), rectangle2D.getHeight());
    }

    public abstract void setCurve(double var1, double var3, double var5, double var7, double var9, double var11);

    public void setCurve(Point2D point2D, Point2D point2D2, Point2D point2D3) {
        this.setCurve(point2D.getX(), point2D.getY(), point2D2.getX(), point2D2.getY(), point2D3.getX(), point2D3.getY());
    }

    public void setCurve(QuadCurve2D quadCurve2D) {
        this.setCurve(quadCurve2D.getX1(), quadCurve2D.getY1(), quadCurve2D.getCtrlX(), quadCurve2D.getCtrlY(), quadCurve2D.getX2(), quadCurve2D.getY2());
    }

    public void setCurve(double[] arrd, int n) {
        this.setCurve(arrd[n + 0], arrd[n + 1], arrd[n + 2], arrd[n + 3], arrd[n + 4], arrd[n + 5]);
    }

    public void setCurve(Point2D[] arrpoint2D, int n) {
        int n2 = n + 0;
        double d = arrpoint2D[n2].getX();
        double d2 = arrpoint2D[n2].getY();
        n2 = n + 1;
        double d3 = arrpoint2D[n2].getX();
        double d4 = arrpoint2D[n2].getY();
        this.setCurve(d, d2, d3, d4, arrpoint2D[n].getX(), arrpoint2D[n += 2].getY());
    }

    public void subdivide(QuadCurve2D quadCurve2D, QuadCurve2D quadCurve2D2) {
        QuadCurve2D.subdivide(this, quadCurve2D, quadCurve2D2);
    }

    public static class Double
    extends QuadCurve2D {
        public double ctrlx;
        public double ctrly;
        public double x1;
        public double x2;
        public double y1;
        public double y2;

        public Double() {
        }

        public Double(double d, double d2, double d3, double d4, double d5, double d6) {
            this.setCurve(d, d2, d3, d4, d5, d6);
        }

        @Override
        public Rectangle2D getBounds2D() {
            double d = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
            double d2 = Math.min(Math.min(this.y1, this.y2), this.ctrly);
            return new Rectangle2D.Double(d, d2, Math.max(Math.max(this.x1, this.x2), this.ctrlx) - d, Math.max(Math.max(this.y1, this.y2), this.ctrly) - d2);
        }

        @Override
        public Point2D getCtrlPt() {
            return new Point2D.Double(this.ctrlx, this.ctrly);
        }

        @Override
        public double getCtrlX() {
            return this.ctrlx;
        }

        @Override
        public double getCtrlY() {
            return this.ctrly;
        }

        @Override
        public Point2D getP1() {
            return new Point2D.Double(this.x1, this.y1);
        }

        @Override
        public Point2D getP2() {
            return new Point2D.Double(this.x2, this.y2);
        }

        @Override
        public double getX1() {
            return this.x1;
        }

        @Override
        public double getX2() {
            return this.x2;
        }

        @Override
        public double getY1() {
            return this.y1;
        }

        @Override
        public double getY2() {
            return this.y2;
        }

        @Override
        public void setCurve(double d, double d2, double d3, double d4, double d5, double d6) {
            this.x1 = d;
            this.y1 = d2;
            this.ctrlx = d3;
            this.ctrly = d4;
            this.x2 = d5;
            this.y2 = d6;
        }
    }

    public static class Float
    extends QuadCurve2D {
        public float ctrlx;
        public float ctrly;
        public float x1;
        public float x2;
        public float y1;
        public float y2;

        public Float() {
        }

        public Float(float f, float f2, float f3, float f4, float f5, float f6) {
            this.setCurve(f, f2, f3, f4, f5, f6);
        }

        @Override
        public Rectangle2D getBounds2D() {
            float f = Math.min(Math.min(this.x1, this.x2), this.ctrlx);
            float f2 = Math.min(Math.min(this.y1, this.y2), this.ctrly);
            return new Rectangle2D.Float(f, f2, Math.max(Math.max(this.x1, this.x2), this.ctrlx) - f, Math.max(Math.max(this.y1, this.y2), this.ctrly) - f2);
        }

        @Override
        public Point2D getCtrlPt() {
            return new Point2D.Float(this.ctrlx, this.ctrly);
        }

        @Override
        public double getCtrlX() {
            return this.ctrlx;
        }

        @Override
        public double getCtrlY() {
            return this.ctrly;
        }

        @Override
        public Point2D getP1() {
            return new Point2D.Float(this.x1, this.y1);
        }

        @Override
        public Point2D getP2() {
            return new Point2D.Float(this.x2, this.y2);
        }

        @Override
        public double getX1() {
            return this.x1;
        }

        @Override
        public double getX2() {
            return this.x2;
        }

        @Override
        public double getY1() {
            return this.y1;
        }

        @Override
        public double getY2() {
            return this.y2;
        }

        @Override
        public void setCurve(double d, double d2, double d3, double d4, double d5, double d6) {
            this.x1 = (float)d;
            this.y1 = (float)d2;
            this.ctrlx = (float)d3;
            this.ctrly = (float)d4;
            this.x2 = (float)d5;
            this.y2 = (float)d6;
        }

        public void setCurve(float f, float f2, float f3, float f4, float f5, float f6) {
            this.x1 = f;
            this.y1 = f2;
            this.ctrlx = f3;
            this.ctrly = f4;
            this.x2 = f5;
            this.y2 = f6;
        }
    }

    class Iterator
    implements PathIterator {
        QuadCurve2D c;
        int index;
        AffineTransform t;

        Iterator(QuadCurve2D quadCurve2D2, AffineTransform affineTransform) {
            this.c = quadCurve2D2;
            this.t = affineTransform;
        }

        @Override
        public int currentSegment(double[] arrd) {
            if (this.isDone()) {
                throw new NoSuchElementException(Messages.getString("awt.4B"));
            }
            int n = this.index;
            int n2 = 2;
            if (n == 0) {
                arrd[0] = this.c.getX1();
                arrd[1] = this.c.getY1();
                n2 = 0;
                n = 1;
            } else {
                arrd[0] = this.c.getCtrlX();
                arrd[1] = this.c.getCtrlY();
                arrd[2] = this.c.getX2();
                arrd[3] = this.c.getY2();
                n = 2;
            }
            if (this.t != null) {
                this.t.transform(arrd, 0, arrd, 0, n);
            }
            return n2;
        }

        @Override
        public int currentSegment(float[] arrf) {
            if (this.isDone()) {
                throw new NoSuchElementException(Messages.getString("awt.4B"));
            }
            int n = this.index;
            int n2 = 2;
            if (n == 0) {
                arrf[0] = (float)this.c.getX1();
                arrf[1] = (float)this.c.getY1();
                n2 = 0;
                n = 1;
            } else {
                arrf[0] = (float)this.c.getCtrlX();
                arrf[1] = (float)this.c.getCtrlY();
                arrf[2] = (float)this.c.getX2();
                arrf[3] = (float)this.c.getY2();
                n = 2;
            }
            if (this.t != null) {
                this.t.transform(arrf, 0, arrf, 0, n);
            }
            return n2;
        }

        @Override
        public int getWindingRule() {
            return 1;
        }

        @Override
        public boolean isDone() {
            if (this.index > 1) {
                return true;
            }
            return false;
        }

        @Override
        public void next() {
            ++this.index;
        }
    }

}

