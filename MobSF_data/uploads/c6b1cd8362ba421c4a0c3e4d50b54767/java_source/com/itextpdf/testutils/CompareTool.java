/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.testutils;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfContentParser;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStamper;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.RefKey;
import com.itextpdf.text.pdf.parser.ContentByteUtils;
import com.itextpdf.text.pdf.parser.ImageRenderInfo;
import com.itextpdf.text.pdf.parser.InlineImageUtils;
import com.itextpdf.text.pdf.parser.PdfContentStreamProcessor;
import com.itextpdf.text.pdf.parser.RenderListener;
import com.itextpdf.text.pdf.parser.SimpleTextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TaggedPdfReaderTool;
import com.itextpdf.text.pdf.parser.TextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TextRenderInfo;
import com.itextpdf.text.xml.XMLUtil;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.XMPUtils;
import com.itextpdf.xmp.options.SerializeOptions;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeSet;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.xml.sax.SAXException;

public class CompareTool {
    private static final String cannotOpenTargetDirectory = "Cannot open target directory for <filename>.";
    private static final String differentPages = "File <filename> differs on page <pagenumber>.";
    private static final String gsFailed = "GhostScript failed for <filename>.";
    private static final String ignoredAreasPrefix = "ignored_areas_";
    private static final String undefinedGsPath = "Path to GhostScript is not specified. Please use -DgsExec=<path_to_ghostscript> (e.g. -DgsExec=\"C:/Program Files/gs/gs9.14/bin/gswin32c.exe\")";
    private static final String unexpectedNumberOfPages = "Unexpected number of pages for <filename>.";
    private boolean absoluteError = true;
    private String cmpImage;
    List<PdfDictionary> cmpPages;
    List<RefKey> cmpPagesRef;
    private String cmpPdf;
    private String cmpPdfName;
    private int compareByContentErrorsLimit = 1;
    private String compareExec;
    private final String compareParams = " \"<image1>\" \"<image2>\" \"<difference>\"";
    private double floatComparisonError = 0.0;
    private boolean generateCompareByContentXmlReport = false;
    private String gsExec = System.getProperty("gsExec");
    private final String gsParams = " -dNOPAUSE -dBATCH -sDEVICE=png16m -r150 -sOutputFile=<outputfile> <inputfile>";
    private String outImage;
    List<PdfDictionary> outPages;
    List<RefKey> outPagesRef;
    private String outPdf;
    private String outPdfName;
    private String xmlReportName = "report";

    public CompareTool() {
        if (this.gsExec == null) {
            this.gsExec = System.getenv("gsExec");
        }
        this.compareExec = System.getProperty("compareExec");
        if (this.compareExec == null) {
            this.compareExec = System.getenv("compareExec");
        }
    }

    private void addPagesFromDict(PdfObject object, List<PdfDictionary> list, List<RefKey> list2) {
        PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObject((PdfObject)object);
        if (pdfDictionary.isPages()) {
            object = pdfDictionary.getAsArray(PdfName.KIDS);
            if (object == null) {
                return;
            }
            object = object.iterator();
            while (object.hasNext()) {
                this.addPagesFromDict((PdfObject)object.next(), list, list2);
            }
        } else if (pdfDictionary.isPage()) {
            list.add(pdfDictionary);
            list2.add(new RefKey((PdfIndirectReference)((PRIndirectReference)object)));
        }
    }

    private String compare(String string2, String string3, Map<Integer, List<Rectangle>> map) throws IOException, InterruptedException, DocumentException {
        return this.compare(string2, string3, map, null);
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private String compare(String object, String charSequence, Map<Integer, List<Rectangle>> object2, List<Integer> list) throws IOException, InterruptedException, DocumentException {
        int n;
        block26 : {
            int n2;
            int n3;
            Object object3;
            Object object4;
            Object object5;
            File[] arrfile;
            if (this.gsExec == null) {
                return undefinedGsPath;
            }
            if (!new File(this.gsExec).exists()) {
                object = new StringBuilder();
                object.append(new File(this.gsExec).getAbsolutePath());
                object.append(" does not exist");
                return object.toString();
            }
            Object object6 = object;
            if (!object.endsWith("/")) {
                object6 = new StringBuilder();
                object6.append((String)object);
                object6.append("/");
                object6 = object6.toString();
            }
            object = new File((String)object6);
            boolean bl = object.exists();
            int n4 = 0;
            if (!bl) {
                object.mkdirs();
            } else {
                object3 = object.listFiles(new PngFileFilter());
                n3 = ((File[])object3).length;
                for (n = 0; n < n3; ++n) {
                    object3[n].delete();
                }
                object3 = object.listFiles(new CmpPngFileFilter());
                n3 = ((Object)object3).length;
                for (n = 0; n < n3; ++n) {
                    object3[n].delete();
                }
            }
            object3 = new StringBuilder();
            object3.append((String)object6);
            object3.append((String)charSequence);
            object3 = new File(object3.toString());
            if (object3.exists()) {
                object3.delete();
            }
            if (object2 != null && !object2.isEmpty()) {
                object3 = new PdfReader(this.cmpPdf);
                arrfile = new PdfReader(this.outPdf);
                object4 = new StringBuilder();
                object4.append((String)object6);
                object4.append(ignoredAreasPrefix);
                object4.append(this.outPdfName);
                object4 = new PdfStamper((PdfReader)arrfile, new FileOutputStream(object4.toString()));
                object5 = new StringBuilder();
                object5.append((String)object6);
                object5.append(ignoredAreasPrefix);
                object5.append(this.cmpPdfName);
                object5 = new PdfStamper((PdfReader)object3, new FileOutputStream(object5.toString()));
                for (Map.Entry entry : object2.entrySet()) {
                    n = (Integer)entry.getKey();
                    Object object7 = (List)entry.getValue();
                    if (object7 == null || object7.isEmpty()) continue;
                    PdfContentByte pdfContentByte = object4.getOverContent(n);
                    PdfContentByte pdfContentByte2 = object5.getOverContent(n);
                    object7 = object7.iterator();
                    while (object7.hasNext()) {
                        Rectangle rectangle = (Rectangle)object7.next();
                        rectangle.setBackgroundColor(BaseColor.BLACK);
                        pdfContentByte.rectangle(rectangle);
                        pdfContentByte2.rectangle(rectangle);
                    }
                }
                object4.close();
                object5.close();
                arrfile.close();
                object3.close();
                object2 = new StringBuilder();
                object2.append((String)object6);
                object2.append(ignoredAreasPrefix);
                object2.append(this.outPdfName);
                object2 = object2.toString();
                object3 = new StringBuilder();
                object3.append((String)object6);
                object3.append(ignoredAreasPrefix);
                object3.append(this.cmpPdfName);
                this.init((String)object2, object3.toString());
            }
            if (!object.exists()) return cannotOpenTargetDirectory.replace("<filename>", this.outPdf);
            this.getClass();
            object2 = new StringBuilder();
            object2.append((String)object6);
            object2.append(this.cmpImage);
            object2 = " -dNOPAUSE -dBATCH -sDEVICE=png16m -r150 -sOutputFile=<outputfile> <inputfile>".replace("<outputfile>", object2.toString()).replace("<inputfile>", this.cmpPdf);
            object2 = this.runProcess(this.gsExec, (String)object2);
            arrfile = new BufferedReader(new InputStreamReader(object2.getInputStream()));
            object3 = new BufferedReader(new InputStreamReader(object2.getErrorStream()));
            while ((object4 = arrfile.readLine()) != null) {
                System.out.println((String)object4);
            }
            arrfile.close();
            while ((arrfile = object3.readLine()) != null) {
                System.out.println((String)arrfile);
            }
            object3.close();
            if (object2.waitFor() != 0) return gsFailed.replace("<filename>", this.cmpPdf);
            this.getClass();
            object2 = new StringBuilder();
            object2.append((String)object6);
            object2.append(this.outImage);
            object2 = " -dNOPAUSE -dBATCH -sDEVICE=png16m -r150 -sOutputFile=<outputfile> <inputfile>".replace("<outputfile>", object2.toString()).replace("<inputfile>", this.outPdf);
            object2 = this.runProcess(this.gsExec, (String)object2);
            arrfile = new BufferedReader(new InputStreamReader(object2.getInputStream()));
            object3 = new BufferedReader(new InputStreamReader(object2.getErrorStream()));
            while ((object4 = arrfile.readLine()) != null) {
                System.out.println((String)object4);
            }
            arrfile.close();
            while ((arrfile = object3.readLine()) != null) {
                System.out.println((String)arrfile);
            }
            object3.close();
            if (object2.waitFor() != 0) return gsFailed.replace("<filename>", this.outPdf);
            object3 = object.listFiles(new PngFileFilter());
            n = ((Object)object3).length != (arrfile = object.listFiles(new CmpPngFileFilter())).length ? 1 : 0;
            n3 = Math.min(((Object)object3).length, arrfile.length);
            if (n3 < 1) {
                return "No files for comparing!!!\nThe result or sample pdf file is not processed by GhostScript.";
            }
            Arrays.sort(object3, new ImageNameComparator());
            Arrays.sort(arrfile, new ImageNameComparator());
            object = null;
            do {
                object2 = object;
                if (n4 >= n3) break block26;
                if (list == null || !list.contains(n4)) {
                    object2 = System.out;
                    object4 = new StringBuilder();
                    object4.append("Comparing page ");
                    n2 = n4 + 1;
                    object4.append(Integer.toString(n2));
                    object4.append(" (");
                    object4.append(object3[n4].getAbsolutePath());
                    object4.append(")...");
                    object2.print(object4.toString());
                    object2 = new FileInputStream((File)object3[n4]);
                    object4 = new FileInputStream(arrfile[n4]);
                    bl = this.compareStreams((InputStream)object2, (InputStream)object4);
                    object2.close();
                    object4.close();
                    if (!bl) {
                        if (this.compareExec == null || !new File(this.compareExec).exists()) break;
                        this.getClass();
                        object2 = " \"<image1>\" \"<image2>\" \"<difference>\"".replace("<image1>", object3[n4].getAbsolutePath()).replace("<image2>", arrfile[n4].getAbsolutePath());
                        object4 = new StringBuilder();
                        object4.append((String)object6);
                        object4.append((String)charSequence);
                        object4.append(Integer.toString(n2));
                        object4.append(".png");
                        object2 = object2.replace("<difference>", object4.toString());
                        object2 = this.runProcess(this.compareExec, (String)object2);
                        object4 = new BufferedReader(new InputStreamReader(object2.getErrorStream()));
                        while ((object5 = object4.readLine()) != null) {
                            System.out.println((String)object5);
                        }
                        object4.close();
                        if (object2.waitFor() == 0) {
                            if (object == null) {
                                object = differentPages.replace("<filename>", this.outPdf).replace("<pagenumber>", Integer.toString(n2));
                                object2 = new StringBuilder();
                                object2.append((String)object);
                                object2.append("\nPlease, examine ");
                                object2.append((String)object6);
                                object2.append((String)charSequence);
                                object2.append(Integer.toString(n2));
                                object2.append(".png for more details.");
                                object = object2.toString();
                            } else {
                                object = new StringBuilder();
                                object.append("File ");
                                object.append(this.outPdf);
                                object.append(" differs.\nPlease, examine difference images for more details.");
                                object = object.toString();
                            }
                        } else {
                            object = differentPages.replace("<filename>", this.outPdf).replace("<pagenumber>", Integer.toString(n2));
                        }
                        System.out.println((String)object);
                    } else {
                        System.out.println("done.");
                    }
                }
                ++n4;
            } while (true);
            object = differentPages.replace("<filename>", this.outPdf).replace("<pagenumber>", Integer.toString(n2));
            charSequence = new StringBuilder();
            charSequence.append((String)object);
            charSequence.append("\nYou can optionally specify path to ImageMagick compare tool (e.g. -DcompareExec=\"C:/Program Files/ImageMagick-6.5.4-2/compare.exe\") to visualize differences.");
            object2 = charSequence.toString();
            if (object2 != null) {
                return object2;
            }
        }
        if (n == 0) return null;
        return unexpectedNumberOfPages.replace("<filename>", this.outPdf);
    }

    private boolean compareArraysExtended(PdfArray pdfArray, PdfArray pdfArray2, ObjectPath objectPath, CompareResult compareResult) throws IOException {
        if (pdfArray == null) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, "Found null. Expected PdfArray.");
            }
            return false;
        }
        if (pdfArray.size() != pdfArray2.size()) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, String.format("PdfArrays. Lengths are different. Expected: %s. Found: %s.", pdfArray2.size(), pdfArray.size()));
            }
            return false;
        }
        boolean bl = true;
        for (int i = 0; i < pdfArray2.size(); ++i) {
            if (objectPath != null) {
                objectPath.pushArrayItemToPath(i);
            }
            bl = this.compareObjects(pdfArray.getPdfObject(i), pdfArray2.getPdfObject(i), objectPath, compareResult) && bl;
            if (objectPath != null) {
                objectPath.pop();
            }
            if (bl || objectPath != null && compareResult != null && !compareResult.isMessageLimitReached()) continue;
            return false;
        }
        return bl;
    }

    private boolean compareBooleansExtended(PdfBoolean pdfBoolean, PdfBoolean pdfBoolean2, ObjectPath objectPath, CompareResult compareResult) {
        if (pdfBoolean2.booleanValue() == pdfBoolean.booleanValue()) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfBoolean. Expected: %s. Found: %s.", pdfBoolean2.booleanValue(), pdfBoolean.booleanValue()));
        }
        return false;
    }

    private boolean compareContentStreamsByParsingExtended(PdfObject pdfObject, PdfObject pdfObject2, PdfDictionary object, PdfDictionary object2, ObjectPath objectPath, CompareResult compareResult) throws IOException {
        int n;
        Object object3;
        Object object4;
        if (pdfObject.type() != pdfObject.type()) {
            compareResult.addError(objectPath, String.format("PdfObject. Types are different. Expected: %s. Found: %s", pdfObject2.type(), pdfObject.type()));
            return false;
        }
        if (pdfObject.isArray()) {
            object3 = (PdfArray)pdfObject;
            object4 = (PdfArray)pdfObject2;
            if (object4.size() != object3.size()) {
                compareResult.addError(objectPath, String.format("PdfArray. Sizes are different. Expected: %s. Found: %s", object4.size(), object3.size()));
                return false;
            }
            for (n = 0; n < object4.size(); ++n) {
                if (this.compareContentStreamsByParsingExtended(object3.getPdfObject(n), object4.getPdfObject(n), (PdfDictionary)object, (PdfDictionary)object2, objectPath, compareResult)) continue;
                return false;
            }
        }
        object3 = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(ContentByteUtils.getContentBytesFromContentObject(pdfObject2))));
        object4 = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(ContentByteUtils.getContentBytesFromContentObject(pdfObject))));
        PdfContentParser pdfContentParser = new PdfContentParser((PRTokeniser)object3);
        PdfContentParser pdfContentParser2 = new PdfContentParser((PRTokeniser)object4);
        ArrayList<PdfObject> arrayList = new ArrayList<PdfObject>();
        ArrayList<PdfObject> arrayList2 = new ArrayList<PdfObject>();
        while (pdfContentParser.parse(arrayList).size() > 0) {
            pdfContentParser2.parse(arrayList2);
            if (arrayList.size() != arrayList2.size()) {
                compareResult.addError(objectPath, String.format("PdfObject. Different commands lengths. Expected: %s. Found: %s", arrayList.size(), arrayList2.size()));
                return false;
            }
            if (arrayList.size() == 1 && this.compareLiterals((PdfLiteral)arrayList.get(0), new PdfLiteral("BI")) && this.compareLiterals((PdfLiteral)arrayList2.get(0), new PdfLiteral("BI"))) {
                PRStream pRStream = (PRStream)pdfObject2;
                PRStream pRStream2 = (PRStream)pdfObject;
                object3 = object;
                object4 = object2;
                if (pRStream2.getDirectObject(PdfName.RESOURCES) != null) {
                    object3 = object;
                    object4 = object2;
                    if (pRStream.getDirectObject(PdfName.RESOURCES) != null) {
                        object3 = (PdfDictionary)pRStream2.getDirectObject(PdfName.RESOURCES);
                        object4 = (PdfDictionary)pRStream.getDirectObject(PdfName.RESOURCES);
                    }
                }
                if (!this.compareInlineImagesExtended(pdfContentParser2, pdfContentParser, (PdfDictionary)object3, (PdfDictionary)object4, objectPath, compareResult)) {
                    return false;
                }
                object = object3;
                object2 = object4;
                continue;
            }
            for (n = 0; n < arrayList.size(); ++n) {
                if (this.compareObjects(arrayList2.get(n), arrayList.get(n), objectPath, compareResult)) continue;
                return false;
            }
        }
        return true;
    }

    private boolean compareDictionariesExtended(PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2, ObjectPath objectPath, CompareResult compareResult) throws IOException {
        if (pdfDictionary2 != null && pdfDictionary == null || pdfDictionary != null && pdfDictionary2 == null) {
            compareResult.addError(objectPath, "One of the dictionaries is null, the other is not.");
            return false;
        }
        Object object = new TreeSet<PdfName>(pdfDictionary2.getKeys());
        object.addAll(pdfDictionary.getKeys());
        object = object.iterator();
        int n = 1;
        boolean bl = true;
        while (object.hasNext()) {
            Object object2;
            block13 : {
                block12 : {
                    block10 : {
                        block11 : {
                            Object object3;
                            object2 = (PdfName)object.next();
                            if (object2.compareTo(PdfName.PARENT) == 0 || object2.compareTo(PdfName.P) == 0 || pdfDictionary.isStream() && pdfDictionary2.isStream() && (object2.equals(PdfName.FILTER) || object2.equals(PdfName.LENGTH))) continue;
                            if (object2.compareTo(PdfName.BASEFONT) != 0 && object2.compareTo(PdfName.FONTNAME) != 0 || !(object3 = pdfDictionary2.getDirectObject((PdfName)object2)).isName() || object3.toString().indexOf(43) <= 0) break block10;
                            PdfObject pdfObject = pdfDictionary.getDirectObject((PdfName)object2);
                            if (!pdfObject.isName() || pdfObject.toString().indexOf(43) == -1) {
                                if (compareResult != null && objectPath != null) {
                                    Object[] arrobject = new Object[3];
                                    arrobject[0] = object2.toString();
                                    arrobject[n] = object3.toString();
                                    arrobject[2] = pdfObject.toString();
                                    compareResult.addError(objectPath, String.format("PdfDictionary %s entry: Expected: %s. Found: %s", arrobject));
                                }
                                bl = false;
                            }
                            if (object3.toString().substring(object3.toString().indexOf(43)).equals(pdfObject.toString().substring(pdfObject.toString().indexOf(43)))) break block11;
                            if (compareResult != null && objectPath != null) {
                                object2 = object2.toString();
                                object3 = object3.toString();
                                n = 1;
                                compareResult.addError(objectPath, String.format("PdfDictionary %s entry: Expected: %s. Found: %s", object2, object3, pdfObject.toString()));
                            } else {
                                n = 1;
                            }
                            break block12;
                        }
                        n = 1;
                        continue;
                    }
                    if (this.floatComparisonError != 0.0 && pdfDictionary2.isPage() && pdfDictionary.isPage() && object2.equals(PdfName.CONTENTS)) {
                        if (this.compareContentStreamsByParsingExtended(pdfDictionary.getDirectObject((PdfName)object2), pdfDictionary2.getDirectObject((PdfName)object2), (PdfDictionary)pdfDictionary.getDirectObject(PdfName.RESOURCES), (PdfDictionary)pdfDictionary2.getDirectObject(PdfName.RESOURCES), objectPath, compareResult)) continue;
                    }
                    break block13;
                }
                bl = false;
                continue;
            }
            if (objectPath != null) {
                objectPath.pushDictItemToPath(object2.toString());
            }
            boolean bl2 = this.compareObjects(pdfDictionary.get((PdfName)object2), pdfDictionary2.get((PdfName)object2), objectPath, compareResult) && bl;
            if (objectPath != null) {
                objectPath.pop();
            }
            bl = bl2;
            if (bl2) continue;
            if (objectPath != null && compareResult != null) {
                bl = bl2;
                if (!compareResult.isMessageLimitReached()) continue;
            }
            return false;
        }
        return bl;
    }

    private boolean compareInlineImagesExtended(PdfContentParser object, PdfContentParser object2, PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2, ObjectPath objectPath, CompareResult compareResult) throws IOException {
        object2 = InlineImageUtils.parseInlineImage((PdfContentParser)object2, pdfDictionary2);
        if (this.compareObjects((object = InlineImageUtils.parseInlineImage((PdfContentParser)object, pdfDictionary)).getImageDictionary(), object2.getImageDictionary(), objectPath, compareResult) && Arrays.equals(object.getSamples(), object2.getSamples())) {
            return true;
        }
        return false;
    }

    private boolean compareLiteralsExtended(PdfLiteral pdfLiteral, PdfLiteral pdfLiteral2, ObjectPath objectPath, CompareResult compareResult) {
        if (this.compareLiterals(pdfLiteral, pdfLiteral2)) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfLiteral. Expected: %s. Found: %s", pdfLiteral2, pdfLiteral));
        }
        return false;
    }

    private boolean compareNamesExtended(PdfName pdfName, PdfName pdfName2, ObjectPath objectPath, CompareResult compareResult) {
        if (pdfName2.compareTo(pdfName) == 0) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfName. Expected: %s. Found: %s", pdfName2.toString(), pdfName.toString()));
        }
        return false;
    }

    private boolean compareNumbersExtended(PdfNumber pdfNumber, PdfNumber pdfNumber2, ObjectPath objectPath, CompareResult compareResult) {
        if (this.compareNumbers(pdfNumber, pdfNumber2)) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfNumber. Expected: %s. Found: %s", pdfNumber2, pdfNumber));
        }
        return false;
    }

    private boolean compareObjects(PdfObject object, PdfObject object2, ObjectPath objectPath, CompareResult compareResult) throws IOException {
        block33 : {
            block25 : {
                PdfObject pdfObject;
                PdfObject pdfObject2;
                block32 : {
                    Object object3;
                    block31 : {
                        block30 : {
                            block29 : {
                                block28 : {
                                    block27 : {
                                        block26 : {
                                            block24 : {
                                                pdfObject2 = PdfReader.getPdfObject((PdfObject)object);
                                                pdfObject = PdfReader.getPdfObject((PdfObject)object2);
                                                if (pdfObject == null && pdfObject2 == null) {
                                                    return true;
                                                }
                                                if (pdfObject2 == null) {
                                                    compareResult.addError(objectPath, "Expected object was not found.");
                                                    return false;
                                                }
                                                if (pdfObject == null) {
                                                    compareResult.addError(objectPath, "Found object which was not expected to be found.");
                                                    return false;
                                                }
                                                if (pdfObject.type() != pdfObject2.type()) {
                                                    compareResult.addError(objectPath, String.format("Types do not match. Expected: %s. Found: %s.", pdfObject.getClass().getSimpleName(), pdfObject2.getClass().getSimpleName()));
                                                    return false;
                                                }
                                                object3 = objectPath;
                                                if (object2.isIndirect()) {
                                                    object3 = objectPath;
                                                    if (object.isIndirect()) {
                                                        PdfIndirectReference pdfIndirectReference = (PdfIndirectReference)object2;
                                                        object3 = new RefKey(pdfIndirectReference);
                                                        PdfIndirectReference pdfIndirectReference2 = (PdfIndirectReference)object;
                                                        if (objectPath.isComparing((RefKey)object3, new RefKey(pdfIndirectReference2))) {
                                                            return true;
                                                        }
                                                        object3 = objectPath.resetDirectPath(new RefKey(pdfIndirectReference), new RefKey(pdfIndirectReference2));
                                                    }
                                                }
                                                if (pdfObject.isDictionary() && ((PdfDictionary)pdfObject).isPage()) {
                                                    if (pdfObject2.isDictionary() && ((PdfDictionary)pdfObject2).isPage()) {
                                                        object2 = new RefKey((PdfIndirectReference)((PRIndirectReference)object2));
                                                        object = new RefKey((PdfIndirectReference)((PRIndirectReference)object));
                                                        if (this.cmpPagesRef.contains(object2) && this.cmpPagesRef.indexOf(object2) == this.outPagesRef.indexOf(object)) {
                                                            return true;
                                                        }
                                                        if (compareResult != null && object3 != null) {
                                                            compareResult.addError((ObjectPath)object3, String.format("The dictionaries refer to different pages. Expected page number: %s. Found: %s", this.cmpPagesRef.indexOf(object2), this.outPagesRef.indexOf(object)));
                                                        }
                                                        return false;
                                                    }
                                                    if (compareResult != null && object3 != null) {
                                                        compareResult.addError((ObjectPath)object3, "Expected a page. Found not a page.");
                                                    }
                                                    return false;
                                                }
                                                if (!pdfObject.isDictionary()) break block24;
                                                if (!this.compareDictionariesExtended((PdfDictionary)pdfObject2, (PdfDictionary)pdfObject, (ObjectPath)object3, compareResult)) {
                                                    return false;
                                                }
                                                break block25;
                                            }
                                            if (!pdfObject.isStream()) break block26;
                                            if (!this.compareStreamsExtended((PRStream)pdfObject2, (PRStream)pdfObject, (ObjectPath)object3, compareResult)) {
                                                return false;
                                            }
                                            break block25;
                                        }
                                        if (!pdfObject.isArray()) break block27;
                                        if (!this.compareArraysExtended((PdfArray)pdfObject2, (PdfArray)pdfObject, (ObjectPath)object3, compareResult)) {
                                            return false;
                                        }
                                        break block25;
                                    }
                                    if (!pdfObject.isName()) break block28;
                                    if (!this.compareNamesExtended((PdfName)pdfObject2, (PdfName)pdfObject, (ObjectPath)object3, compareResult)) {
                                        return false;
                                    }
                                    break block25;
                                }
                                if (!pdfObject.isNumber()) break block29;
                                if (!this.compareNumbersExtended((PdfNumber)pdfObject2, (PdfNumber)pdfObject, (ObjectPath)object3, compareResult)) {
                                    return false;
                                }
                                break block25;
                            }
                            if (!pdfObject.isString()) break block30;
                            if (!this.compareStringsExtended((PdfString)pdfObject2, (PdfString)pdfObject, (ObjectPath)object3, compareResult)) {
                                return false;
                            }
                            break block25;
                        }
                        if (!pdfObject.isBoolean()) break block31;
                        if (!this.compareBooleansExtended((PdfBoolean)pdfObject2, (PdfBoolean)pdfObject, (ObjectPath)object3, compareResult)) {
                            return false;
                        }
                        break block25;
                    }
                    if (!(pdfObject instanceof PdfLiteral)) break block32;
                    if (!this.compareLiteralsExtended((PdfLiteral)pdfObject2, (PdfLiteral)pdfObject, (ObjectPath)object3, compareResult)) {
                        return false;
                    }
                    break block25;
                }
                if (!pdfObject2.isNull() || !pdfObject.isNull()) break block33;
            }
            return true;
        }
        throw new UnsupportedOperationException();
    }

    private boolean compareStreams(InputStream inputStream, InputStream inputStream2) throws IOException {
        int n;
        byte[] arrby = new byte[65536];
        byte[] arrby2 = new byte[65536];
        do {
            if ((n = inputStream.read(arrby)) != inputStream2.read(arrby2)) {
                return false;
            }
            if (Arrays.equals(arrby, arrby2)) continue;
            return false;
        } while (n != -1);
        return true;
    }

    private boolean compareStreamsExtended(PRStream object, PRStream pRStream, ObjectPath objectPath, CompareResult compareResult) throws IOException {
        boolean bl = PdfName.FLATEDECODE.equals(object.get(PdfName.FILTER));
        byte[] arrby = PdfReader.getStreamBytesRaw((PRStream)object);
        byte[] arrby2 = PdfReader.getStreamBytesRaw(pRStream);
        byte[] arrby3 = arrby;
        byte[] arrby4 = arrby2;
        if (bl) {
            arrby3 = PdfReader.decodeBytes(arrby, (PdfDictionary)object);
            arrby4 = PdfReader.decodeBytes(arrby2, pRStream);
        }
        if (this.floatComparisonError != 0.0 && PdfName.XOBJECT.equals(pRStream.getDirectObject(PdfName.TYPE)) && PdfName.XOBJECT.equals(object.getDirectObject(PdfName.TYPE)) && PdfName.FORM.equals(pRStream.getDirectObject(PdfName.SUBTYPE)) && PdfName.FORM.equals(object.getDirectObject(PdfName.SUBTYPE))) {
            if (this.compareContentStreamsByParsingExtended((PdfObject)object, pRStream, object.getAsDict(PdfName.RESOURCES), pRStream.getAsDict(PdfName.RESOURCES), objectPath, compareResult) && this.compareDictionariesExtended((PdfDictionary)object, pRStream, objectPath, compareResult)) {
                return true;
            }
            return false;
        }
        if (Arrays.equals(arrby3, arrby4)) {
            return this.compareDictionariesExtended((PdfDictionary)object, pRStream, objectPath, compareResult);
        }
        if (arrby4.length != arrby3.length) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, String.format("PRStream. Lengths are different. Expected: %s. Found: %s", arrby4.length, arrby3.length));
                return false;
            }
        } else {
            for (int i = 0; i < arrby4.length; ++i) {
                if (arrby4[i] == arrby3[i]) continue;
                int n = Math.max(0, i - 10);
                int n2 = Math.min(arrby4.length, i + 10);
                if (compareResult == null || objectPath == null) continue;
                objectPath.pushOffsetToPath(i);
                object = new String(new byte[]{arrby4[i]});
                compareResult.addError(objectPath, String.format("PRStream. The bytes differ at index %s. Expected: %s (%s). Found: %s (%s)", i, object, new String(arrby4, n, n2 -= n).replaceAll("\\n", "\\\\n"), new String(new byte[]{arrby3[i]}), new String(arrby3, n, n2).replaceAll("\\n", "\\\\n")));
                objectPath.pop();
            }
        }
        return false;
    }

    private boolean compareStringsExtended(PdfString object, PdfString object2, ObjectPath objectPath, CompareResult compareResult) {
        if (Arrays.equals(object2.getBytes(), object.getBytes())) {
            return true;
        }
        object2 = object2.toUnicodeString();
        object = object.toUnicodeString();
        if (object2.length() != object.length()) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, String.format("PdfString. Lengths are different. Expected: %s. Found: %s", object2.length(), object.length()));
                return false;
            }
        } else {
            for (int i = 0; i < object2.length(); ++i) {
                if (object2.charAt(i) == object.charAt(i)) continue;
                int n = Math.max(0, i - 10);
                int n2 = Math.min(object2.length(), i + 10);
                if (compareResult == null || objectPath == null) break;
                objectPath.pushOffsetToPath(i);
                compareResult.addError(objectPath, String.format("PdfString. Characters differ at position %s. Expected: %s (%s). Found: %s (%s).", i, Character.toString(object2.charAt(i)), object2.substring(n, n2).replace("\n", "\\n"), Character.toString(object.charAt(i)), object.substring(n, n2).replace("\n", "\\n")));
                objectPath.pop();
                return false;
            }
        }
        return false;
    }

    private String[] convertInfo(HashMap<String, String> object) {
        String[] arrstring = new String[]{"", "", "", ""};
        for (Map.Entry entry : object.entrySet()) {
            if ("title".equalsIgnoreCase((String)entry.getKey())) {
                arrstring[0] = (String)entry.getValue();
                continue;
            }
            if ("author".equalsIgnoreCase((String)entry.getKey())) {
                arrstring[1] = (String)entry.getValue();
                continue;
            }
            if ("subject".equalsIgnoreCase((String)entry.getKey())) {
                arrstring[2] = (String)entry.getValue();
                continue;
            }
            if (!"keywords".equalsIgnoreCase((String)entry.getKey())) continue;
            arrstring[3] = (String)entry.getValue();
        }
        return arrstring;
    }

    private void init(String charSequence, String string2) {
        this.outPdf = charSequence;
        this.cmpPdf = string2;
        this.outPdfName = new File((String)charSequence).getName();
        this.cmpPdfName = new File(string2).getName();
        charSequence = new StringBuilder();
        charSequence.append(this.outPdfName);
        charSequence.append("-%03d.png");
        this.outImage = charSequence.toString();
        if (this.cmpPdfName.startsWith("cmp_")) {
            charSequence = new StringBuilder();
            charSequence.append(this.cmpPdfName);
            charSequence.append("-%03d.png");
            this.cmpImage = charSequence.toString();
            return;
        }
        charSequence = new StringBuilder();
        charSequence.append("cmp_");
        charSequence.append(this.cmpPdfName);
        charSequence.append("-%03d.png");
        this.cmpImage = charSequence.toString();
    }

    private boolean linksAreSame(PdfAnnotation.PdfImportedLink object, PdfAnnotation.PdfImportedLink object2) {
        if (object.getDestinationPage() != object2.getDestinationPage()) {
            return false;
        }
        if (!object.getRect().toString().equals(object2.getRect().toString())) {
            return false;
        }
        Object object3 = object.getParameters();
        object = object2.getParameters();
        if (object3.size() != object.size()) {
            return false;
        }
        block3 : for (Map.Entry<PdfName, PdfObject> entry : object3.entrySet()) {
            object3 = entry.getValue();
            if (!object.containsKey(entry.getKey())) {
                return false;
            }
            PdfObject object4 = object.get(entry.getKey());
            if (object3.type() != object4.type()) {
                return false;
            }
            int n = object3.type();
            if (n != 8) {
                switch (n) {
                    default: {
                        continue block3;
                    }
                    case 1: 
                    case 2: 
                    case 3: 
                    case 4: 
                }
            }
            if (object3.toString().equals(object4.toString())) continue;
            return false;
        }
        return true;
    }

    private void loadPagesFromReader(PdfReader pdfReader, List<PdfDictionary> list, List<RefKey> list2) {
        this.addPagesFromDict(pdfReader.getCatalog().get(PdfName.PAGES), list, list2);
    }

    private Process runProcess(String string2, String object) throws IOException, InterruptedException {
        object = new StringTokenizer((String)object);
        String[] arrstring = new String[object.countTokens() + 1];
        arrstring[0] = string2;
        int n = 1;
        while (object.hasMoreTokens()) {
            arrstring[n] = object.nextToken();
            ++n;
        }
        return Runtime.getRuntime().exec(arrstring);
    }

    public String compare(String string2, String string3, String string4, String string5) throws IOException, InterruptedException, DocumentException {
        return this.compare(string2, string3, string4, string5, null);
    }

    public String compare(String string2, String string3, String string4, String string5, Map<Integer, List<Rectangle>> map) throws IOException, InterruptedException, DocumentException {
        this.init(string2, string3);
        return this.compare(string4, string5, map);
    }

    public boolean compareArrays(PdfArray pdfArray, PdfArray pdfArray2) throws IOException {
        return this.compareArraysExtended(pdfArray, pdfArray2, null, null);
    }

    public boolean compareBooleans(PdfBoolean pdfBoolean, PdfBoolean pdfBoolean2) {
        return Arrays.equals(pdfBoolean2.getBytes(), pdfBoolean.getBytes());
    }

    public String compareByContent(String string2, String string3, String string4, String string5) throws DocumentException, InterruptedException, IOException {
        return this.compareByContent(string2, string3, string4, string5, null);
    }

    public String compareByContent(String string2, String string3, String string4, String string5, Map<Integer, List<Rectangle>> map) throws DocumentException, InterruptedException, IOException {
        this.init(string2, string3);
        return this.compareByContent(string4, string5, map);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected String compareByContent(String string2, String string3, Map<Integer, List<Rectangle>> map) throws DocumentException, InterruptedException, IOException {
        CompareResult compareResult;
        ArrayList<Integer> arrayList;
        Object object;
        System.out.print("[itext] INFO  Comparing by content..........");
        PdfReader pdfReader = new PdfReader(this.outPdf);
        this.outPages = new ArrayList<PdfDictionary>();
        this.outPagesRef = new ArrayList<RefKey>();
        this.loadPagesFromReader(pdfReader, this.outPages, this.outPagesRef);
        PdfReader pdfReader2 = new PdfReader(this.cmpPdf);
        this.cmpPages = new ArrayList<PdfDictionary>();
        this.cmpPagesRef = new ArrayList<RefKey>();
        this.loadPagesFromReader(pdfReader2, this.cmpPages, this.cmpPagesRef);
        if (this.outPages.size() != this.cmpPages.size()) {
            return this.compare(string2, string3, map);
        }
        compareResult = new CompareResult(this.compareByContentErrorsLimit);
        arrayList = new ArrayList<Integer>(this.cmpPages.size());
        for (int i = 0; i < this.cmpPages.size(); ++i) {
            object = new ObjectPath(this.cmpPagesRef.get(i), this.outPagesRef.get(i));
            if (!this.compareDictionariesExtended(this.outPages.get(i), this.cmpPages.get(i), (ObjectPath)object, compareResult)) continue;
            arrayList.add(i);
        }
        PdfObject pdfObject = pdfReader.getCatalog().get(PdfName.STRUCTTREEROOT);
        PdfObject pdfObject2 = pdfReader2.getCatalog().get(PdfName.STRUCTTREEROOT);
        object = pdfObject == null ? null : new RefKey((PdfIndirectReference)pdfObject);
        RefKey refKey = pdfObject2 == null ? null : new RefKey((PdfIndirectReference)pdfObject2);
        this.compareObjects(pdfObject, pdfObject2, new ObjectPath((RefKey)object, refKey), compareResult);
        pdfObject = pdfReader.getCatalog().get(PdfName.OCPROPERTIES);
        pdfObject2 = pdfReader2.getCatalog().get(PdfName.OCPROPERTIES);
        object = pdfObject instanceof PdfIndirectReference ? new RefKey((PdfIndirectReference)pdfObject) : null;
        refKey = pdfObject2 instanceof PdfIndirectReference ? new RefKey((PdfIndirectReference)pdfObject2) : null;
        this.compareObjects(pdfObject, pdfObject2, new ObjectPath((RefKey)object, refKey), compareResult);
        pdfReader.close();
        pdfReader2.close();
        if (this.generateCompareByContentXmlReport) {
            try {
                object = new StringBuilder();
                object.append(string2);
                object.append("/");
                object.append(this.xmlReportName);
                object.append(".xml");
                compareResult.writeReportToXml(new FileOutputStream(object.toString()));
            }
            catch (Exception exception) {}
        }
        if (arrayList.size() == this.cmpPages.size() && compareResult.isOk()) {
            System.out.println("OK");
            System.out.flush();
            return null;
        }
        System.out.println("Fail");
        System.out.flush();
        object = new StringBuilder();
        object.append("Compare by content report:\n");
        object.append(compareResult.getReport());
        object = object.toString();
        System.out.println((String)object);
        System.out.flush();
        string2 = this.compare(string2, string3, map, arrayList);
        if (string2 == null) return "Compare by content fails. No visual differences";
        if (string2.length() != 0) return string2;
        return "Compare by content fails. No visual differences";
    }

    public boolean compareContentStreamsByParsing(PdfObject pdfObject, PdfObject pdfObject2) throws IOException {
        return this.compareContentStreamsByParsingExtended(pdfObject, pdfObject2, null, null, null, null);
    }

    public boolean compareContentStreamsByParsing(PdfObject pdfObject, PdfObject pdfObject2, PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2) throws IOException {
        return this.compareContentStreamsByParsingExtended(pdfObject, pdfObject2, pdfDictionary, pdfDictionary2, null, null);
    }

    public boolean compareDictionaries(PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2) throws IOException {
        return this.compareDictionariesExtended(pdfDictionary, pdfDictionary2, null, null);
    }

    public String compareDocumentInfo(String object, String object2) throws IOException {
        PdfReader pdfReader;
        block3 : {
            System.out.print("[itext] INFO  Comparing document info.......");
            pdfReader = new PdfReader((String)object);
            object2 = new PdfReader((String)object2);
            object = this.convertInfo(object2.getInfo());
            String[] arrstring = this.convertInfo(pdfReader.getInfo());
            for (int i = 0; i < ((String[])object).length; ++i) {
                if (object[i].equals(arrstring[i])) continue;
                object = "Document info fail";
                break block3;
            }
            object = null;
        }
        pdfReader.close();
        object2.close();
        if (object == null) {
            System.out.println("OK");
        } else {
            System.out.println("Fail");
        }
        System.out.flush();
        return object;
    }

    public String compareLinks(String string2, String object) throws IOException {
        System.out.print("[itext] INFO  Comparing link annotations....");
        PdfReader pdfReader = new PdfReader(string2);
        PdfReader pdfReader2 = new PdfReader((String)object);
        string2 = null;
        int n = 0;
        block0 : do {
            object = string2;
            if (n >= pdfReader.getNumberOfPages()) break;
            object = string2;
            if (n >= pdfReader2.getNumberOfPages()) break;
            int n2 = n + 1;
            object = pdfReader.getLinks(n2);
            ArrayList<PdfAnnotation.PdfImportedLink> arrayList = pdfReader2.getLinks(n2);
            if (arrayList.size() != object.size()) {
                object = String.format("Different number of links on page %d.", n2);
                break;
            }
            int n3 = 0;
            do {
                n = n2;
                if (n3 >= arrayList.size()) continue block0;
                if (!this.linksAreSame(arrayList.get(n3), (PdfAnnotation.PdfImportedLink)object.get(n3))) {
                    string2 = String.format("Different links on page %d.\n%s\n%s", n2, arrayList.get(n3).toString(), ((PdfAnnotation.PdfImportedLink)object.get(n3)).toString());
                    n = n2;
                    continue block0;
                }
                ++n3;
            } while (true);
            break;
        } while (true);
        pdfReader.close();
        pdfReader2.close();
        if (object == null) {
            System.out.println("OK");
        } else {
            System.out.println("Fail");
        }
        System.out.flush();
        return object;
    }

    public boolean compareLiterals(PdfLiteral pdfLiteral, PdfLiteral pdfLiteral2) {
        return Arrays.equals(pdfLiteral2.getBytes(), pdfLiteral.getBytes());
    }

    public boolean compareNames(PdfName pdfName, PdfName pdfName2) {
        if (pdfName2.compareTo(pdfName) == 0) {
            return true;
        }
        return false;
    }

    public boolean compareNumbers(PdfNumber pdfNumber, PdfNumber pdfNumber2) {
        double d;
        double d2 = d = Math.abs(pdfNumber.doubleValue() - pdfNumber2.doubleValue());
        if (!this.absoluteError) {
            d2 = d;
            if (pdfNumber2.doubleValue() != 0.0) {
                d2 = d / pdfNumber2.doubleValue();
            }
        }
        if (d2 <= this.floatComparisonError) {
            return true;
        }
        return false;
    }

    public boolean compareStreams(PRStream pRStream, PRStream pRStream2) throws IOException {
        return this.compareStreamsExtended(pRStream, pRStream2, null, null);
    }

    public boolean compareStrings(PdfString pdfString, PdfString pdfString2) {
        return Arrays.equals(pdfString2.getBytes(), pdfString.getBytes());
    }

    public String compareTagStructures(String object, String object2) throws IOException, ParserConfigurationException, SAXException {
        System.out.print("[itext] INFO  Comparing tag structures......");
        String string2 = object.replace(".pdf", ".xml");
        String string3 = object.replace(".pdf", ".cmp.xml");
        object = new PdfReader((String)object);
        FileOutputStream fileOutputStream = new FileOutputStream(string2);
        new CmpTaggedPdfReaderTool().convertToXml((PdfReader)object, fileOutputStream);
        object.close();
        object = new PdfReader((String)object2);
        object2 = new FileOutputStream(string3);
        new CmpTaggedPdfReaderTool().convertToXml((PdfReader)object, (OutputStream)object2);
        object.close();
        object = !this.compareXmls(string2, string3) ? "The tag structures are different." : null;
        fileOutputStream.close();
        object2.close();
        if (object == null) {
            System.out.println("OK");
        } else {
            System.out.println("Fail");
        }
        System.out.flush();
        return object;
    }

    public boolean compareXmls(String object, String object2) throws ParserConfigurationException, SAXException, IOException {
        Object object3 = DocumentBuilderFactory.newInstance();
        object3.setNamespaceAware(true);
        object3.setCoalescing(true);
        object3.setIgnoringElementContentWhitespace(true);
        object3.setIgnoringComments(true);
        object3 = object3.newDocumentBuilder();
        object = object3.parse(new File((String)object));
        object.normalizeDocument();
        object2 = object3.parse(new File((String)object2));
        object2.normalizeDocument();
        return object2.isEqualNode((Node)object);
    }

    public boolean compareXmls(byte[] object, byte[] object2) throws ParserConfigurationException, SAXException, IOException {
        Object object3 = DocumentBuilderFactory.newInstance();
        object3.setNamespaceAware(true);
        object3.setCoalescing(true);
        object3.setIgnoringElementContentWhitespace(true);
        object3.setIgnoringComments(true);
        object3 = object3.newDocumentBuilder();
        object = object3.parse(new ByteArrayInputStream((byte[])object));
        object.normalizeDocument();
        object2 = object3.parse(new ByteArrayInputStream((byte[])object2));
        object2.normalizeDocument();
        return object2.isEqualNode((Node)object);
    }

    public String compareXmp(String string2, String string3) {
        return this.compareXmp(string2, string3, false);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public String compareXmp(String object, String object2, boolean bl) {
        block12 : {
            String string2;
            void var4_10;
            block11 : {
                this.init((String)object, (String)object2);
                object2 = null;
                string2 = null;
                object = new PdfReader(this.cmpPdf);
                object2 = new PdfReader(this.outPdf);
                try {
                    string2 = this.compareXmp(object.getMetadata(), object2.getMetadata(), bl);
                    if (object != null) {
                        object.close();
                    }
                    if (object2 == null) return string2;
                    object2.close();
                    return string2;
                }
                catch (Throwable throwable) {
                    Object object3 = object;
                    object = object2;
                    object2 = object3;
                    break block11;
                }
                catch (Throwable throwable) {
                    Object var5_13 = null;
                    object2 = object;
                    object = var5_13;
                    break block11;
                }
                catch (Throwable throwable) {
                    object = null;
                }
            }
            if (object2 != null) {
                object2.close();
            }
            if (object == null) throw var4_10;
            object.close();
            throw var4_10;
            catch (IOException iOException) {}
            object2 = null;
            object = string2;
            break block12;
            catch (IOException iOException) {}
            object2 = null;
            break block12;
            catch (IOException iOException) {}
        }
        if (object == null) return "XMP parsing failure!";
        object.close();
        if (object2 == null) return "XMP parsing failure!";
        object2.close();
        return "XMP parsing failure!";
    }

    public String compareXmp(byte[] arrby, byte[] arrby2) {
        return this.compareXmp(arrby, arrby2, false);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public String compareXmp(byte[] var1_1, byte[] var2_6, boolean var3_7) {
        var5_10 /* !! */  = var1_1 /* !! */ ;
        var4_11 = var2_8;
        if (var3_9 == false) ** GOTO lbl17
        try {
            var1_2 = XMPMetaFactory.parseFromBuffer(var1_1 /* !! */ );
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/xap/1.0/", "CreateDate", true, true);
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/xap/1.0/", "ModifyDate", true, true);
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/xap/1.0/", "MetadataDate", true, true);
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/pdf/1.3/", "Producer", true, true);
            var5_10 /* !! */  = XMPMetaFactory.serializeToBuffer(var1_2, new SerializeOptions(8192));
            var1_3 = XMPMetaFactory.parseFromBuffer((byte[])var2_8);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/xap/1.0/", "CreateDate", true, true);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/xap/1.0/", "ModifyDate", true, true);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/xap/1.0/", "MetadataDate", true, true);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/pdf/1.3/", "Producer", true, true);
            var4_11 = XMPMetaFactory.serializeToBuffer(var1_3, new SerializeOptions(8192));
lbl17: // 2 sources:
            if (this.compareXmls(var5_10 /* !! */ , var4_11) != false) return null;
            return "The XMP packages different!";
        }
        catch (XMPException var1_4) {
            return "XMP parsing failure!";
        }
        catch (IOException var1_5) {
            return "XMP parsing failure!";
        }
        catch (ParserConfigurationException var1_6) {
            return "XMP parsing failure!";
        }
        catch (SAXException var1_7) {
            return "XMP parsing failure!";
        }
    }

    public String getXmlReportName() {
        return this.xmlReportName;
    }

    public CompareTool setCompareByContentErrorsLimit(int n) {
        this.compareByContentErrorsLimit = n;
        return this;
    }

    public CompareTool setFloatAbsoluteError(float f) {
        this.floatComparisonError = f;
        this.absoluteError = true;
        return this;
    }

    public CompareTool setFloatRelativeError(float f) {
        this.floatComparisonError = f;
        this.absoluteError = false;
        return this;
    }

    public void setGenerateCompareByContentXmlReport(boolean bl) {
        this.generateCompareByContentXmlReport = bl;
    }

    public void setXmlReportName(String string2) {
        this.xmlReportName = string2;
    }

    class CmpMarkedContentRenderFilter
    implements RenderListener {
        Map<Integer, TextExtractionStrategy> tagsByMcid = new HashMap<Integer, TextExtractionStrategy>();

        CmpMarkedContentRenderFilter() {
        }

        @Override
        public void beginTextBlock() {
            Iterator<Integer> iterator = this.tagsByMcid.keySet().iterator();
            while (iterator.hasNext()) {
                int n = iterator.next();
                this.tagsByMcid.get(n).beginTextBlock();
            }
        }

        @Override
        public void endTextBlock() {
            Iterator<Integer> iterator = this.tagsByMcid.keySet().iterator();
            while (iterator.hasNext()) {
                int n = iterator.next();
                this.tagsByMcid.get(n).endTextBlock();
            }
        }

        public Map<Integer, String> getParsedTagContent() {
            HashMap<Integer, String> hashMap = new HashMap<Integer, String>();
            Iterator<Integer> iterator = this.tagsByMcid.keySet().iterator();
            while (iterator.hasNext()) {
                int n = iterator.next();
                hashMap.put(n, this.tagsByMcid.get(n).getResultantText());
            }
            return hashMap;
        }

        @Override
        public void renderImage(ImageRenderInfo imageRenderInfo) {
        }

        @Override
        public void renderText(TextRenderInfo textRenderInfo) {
            Integer n = textRenderInfo.getMcid();
            if (n != null && this.tagsByMcid.containsKey(n)) {
                this.tagsByMcid.get(n).renderText(textRenderInfo);
                return;
            }
            if (n != null) {
                this.tagsByMcid.put(n, new SimpleTextExtractionStrategy());
                this.tagsByMcid.get(n).renderText(textRenderInfo);
            }
        }
    }

    class CmpPngFileFilter
    implements FileFilter {
        CmpPngFileFilter() {
        }

        @Override
        public boolean accept(File object) {
            object = object.getAbsolutePath();
            boolean bl = object.endsWith(".png");
            boolean bl2 = object.contains("cmp_");
            if (bl && bl2 && object.contains(CompareTool.this.cmpPdfName)) {
                return true;
            }
            return false;
        }
    }

    class CmpTaggedPdfReaderTool
    extends TaggedPdfReaderTool {
        Map<PdfDictionary, Map<Integer, String>> parsedTags = new HashMap<PdfDictionary, Map<Integer, String>>();

        CmpTaggedPdfReaderTool() {
        }

        @Override
        public void inspectChildDictionary(PdfDictionary pdfDictionary) throws IOException {
            this.inspectChildDictionary(pdfDictionary, true);
        }

        @Override
        public void parseTag(String object, PdfObject pdfObject, PdfDictionary pdfDictionary) throws IOException {
            if (pdfObject instanceof PdfNumber) {
                if (!this.parsedTags.containsKey(pdfDictionary)) {
                    object = new CmpMarkedContentRenderFilter();
                    new PdfContentStreamProcessor((RenderListener)object).processContent(PdfReader.getPageContent(pdfDictionary), pdfDictionary.getAsDict(PdfName.RESOURCES));
                    this.parsedTags.put(pdfDictionary, object.getParsedTagContent());
                }
                object = "";
                Map<Integer, String> map = this.parsedTags.get(pdfDictionary);
                if (map.containsKey((pdfObject = (PdfNumber)pdfObject).intValue())) {
                    object = this.parsedTags.get(pdfDictionary).get(pdfObject.intValue());
                }
                this.out.print(XMLUtil.escapeXML((String)object, true));
                return;
            }
            super.parseTag((String)object, pdfObject, pdfDictionary);
        }
    }

    protected class CompareResult {
        protected Map<ObjectPath, String> differences = new LinkedHashMap<ObjectPath, String>();
        protected int messageLimit = 1;

        public CompareResult(int n) {
            this.messageLimit = n;
        }

        protected void addError(ObjectPath objectPath, String string2) {
            if (this.differences.size() < this.messageLimit) {
                this.differences.put((ObjectPath)objectPath.clone(), string2);
            }
        }

        public int getErrorCount() {
            return this.differences.size();
        }

        public String getReport() {
            StringBuilder stringBuilder = new StringBuilder();
            Iterator<Map.Entry<ObjectPath, String>> iterator = this.differences.entrySet().iterator();
            boolean bl = true;
            while (iterator.hasNext()) {
                Map.Entry<ObjectPath, String> entry = iterator.next();
                if (!bl) {
                    stringBuilder.append("-----------------------------");
                    stringBuilder.append("\n");
                }
                ObjectPath objectPath = entry.getKey();
                stringBuilder.append(entry.getValue());
                stringBuilder.append("\n");
                stringBuilder.append(objectPath.toString());
                stringBuilder.append("\n");
                bl = false;
            }
            return stringBuilder.toString();
        }

        protected boolean isMessageLimitReached() {
            if (this.differences.size() >= this.messageLimit) {
                return true;
            }
            return false;
        }

        public boolean isOk() {
            if (this.differences.size() == 0) {
                return true;
            }
            return false;
        }

        public void writeReportToXml(OutputStream outputStream) throws ParserConfigurationException, TransformerException {
            Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
            Object object = document.createElement("report");
            Element element = document.createElement("errors");
            element.setAttribute("count", String.valueOf(this.differences.size()));
            object.appendChild(element);
            for (Map.Entry<ObjectPath, String> entry : this.differences.entrySet()) {
                Element element2 = document.createElement("error");
                Element element3 = document.createElement("message");
                element3.appendChild(document.createTextNode(entry.getValue()));
                Node object2 = entry.getKey().toXmlNode(document);
                element2.appendChild(element3);
                element2.appendChild(object2);
                element.appendChild(element2);
            }
            document.appendChild((Node)object);
            object = TransformerFactory.newInstance().newTransformer();
            object.setOutputProperty("indent", "yes");
            object.transform(new DOMSource(document), new StreamResult(outputStream));
        }
    }

    class ImageNameComparator
    implements Comparator<File> {
        ImageNameComparator() {
        }

        @Override
        public int compare(File file, File file2) {
            return file.getAbsolutePath().compareTo(file2.getAbsolutePath());
        }
    }

    private class ObjectPath {
        protected RefKey baseCmpObject;
        protected RefKey baseOutObject;
        protected Stack<Pair<RefKey>> indirects = new Stack();
        protected Stack<PathItem> path = new Stack();

        public ObjectPath() {
        }

        protected ObjectPath(RefKey refKey, RefKey refKey2) {
            this.baseCmpObject = refKey;
            this.baseOutObject = refKey2;
        }

        private ObjectPath(RefKey refKey, RefKey refKey2, Stack<PathItem> stack) {
            this.baseCmpObject = refKey;
            this.baseOutObject = refKey2;
            this.path = stack;
        }

        protected Object clone() {
            return new ObjectPath(this.baseCmpObject, this.baseOutObject, (Stack)this.path.clone());
        }

        public boolean equals(Object object) {
            if (object instanceof ObjectPath) {
                RefKey refKey = this.baseCmpObject;
                object = (ObjectPath)object;
                if (refKey.equals(object.baseCmpObject) && this.baseOutObject.equals(object.baseOutObject) && this.path.equals(object.path)) {
                    return true;
                }
            }
            return false;
        }

        public int hashCode() {
            Object object = this.baseCmpObject;
            int n = 1;
            int n2 = object != null ? this.baseCmpObject.hashCode() : 1;
            if (this.baseOutObject != null) {
                n = this.baseOutObject.hashCode();
            }
            n2 = n2 * 31 + n;
            object = this.path.iterator();
            while (object.hasNext()) {
                n2 = n2 * 31 + ((PathItem)object.next()).hashCode();
            }
            return n2;
        }

        public boolean isComparing(RefKey refKey, RefKey refKey2) {
            return this.indirects.contains(new Pair<RefKey>(refKey, refKey2));
        }

        public void pop() {
            this.path.pop();
        }

        public void pushArrayItemToPath(int n) {
            this.path.add(new ArrayPathItem(n));
        }

        public void pushDictItemToPath(String string2) {
            this.path.add(new DictPathItem(string2));
        }

        public void pushOffsetToPath(int n) {
            this.path.add(new OffsetPathItem(n));
        }

        public ObjectPath resetDirectPath(RefKey refKey, RefKey refKey2) {
            ObjectPath objectPath = new ObjectPath(refKey, refKey2);
            objectPath.indirects = (Stack)this.indirects.clone();
            objectPath.indirects.add(new Pair<RefKey>(refKey, refKey2));
            return objectPath;
        }

        public String toString() {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(String.format("Base cmp object: %s obj. Base out object: %s obj", this.baseCmpObject, this.baseOutObject));
            for (PathItem pathItem : this.path) {
                stringBuilder.append("\n");
                stringBuilder.append(pathItem.toString());
            }
            return stringBuilder.toString();
        }

        public Node toXmlNode(Document document) {
            Element element = document.createElement("path");
            Object object = document.createElement("base");
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(this.baseCmpObject.toString());
            stringBuilder.append(" obj");
            object.setAttribute("cmp", stringBuilder.toString());
            stringBuilder = new StringBuilder();
            stringBuilder.append(this.baseOutObject.toString());
            stringBuilder.append(" obj");
            object.setAttribute("out", stringBuilder.toString());
            element.appendChild((Node)object);
            object = this.path.iterator();
            while (object.hasNext()) {
                element.appendChild(((PathItem)object.next()).toXmlNode(document));
            }
            return element;
        }

        private class ArrayPathItem
        extends PathItem {
            int index;

            public ArrayPathItem(int n) {
                super();
                this.index = n;
            }

            public boolean equals(Object object) {
                if (object instanceof ArrayPathItem && this.index == ((ArrayPathItem)object).index) {
                    return true;
                }
                return false;
            }

            public int hashCode() {
                return this.index;
            }

            public String toString() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Array index: ");
                stringBuilder.append(String.valueOf(this.index));
                return stringBuilder.toString();
            }

            @Override
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("arrayIndex");
                element.appendChild(document.createTextNode(String.valueOf(this.index)));
                return element;
            }
        }

        private class DictPathItem
        extends PathItem {
            String key;

            public DictPathItem(String string2) {
                super();
                this.key = string2;
            }

            public boolean equals(Object object) {
                if (object instanceof DictPathItem && this.key.equals(((DictPathItem)object).key)) {
                    return true;
                }
                return false;
            }

            public int hashCode() {
                return this.key.hashCode();
            }

            public String toString() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Dict key: ");
                stringBuilder.append(this.key);
                return stringBuilder.toString();
            }

            @Override
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("dictKey");
                element.appendChild(document.createTextNode(this.key));
                return element;
            }
        }

        private class OffsetPathItem
        extends PathItem {
            int offset;

            public OffsetPathItem(int n) {
                super();
                this.offset = n;
            }

            public boolean equals(Object object) {
                if (object instanceof OffsetPathItem && this.offset == ((OffsetPathItem)object).offset) {
                    return true;
                }
                return false;
            }

            public int hashCode() {
                return this.offset;
            }

            public String toString() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Offset: ");
                stringBuilder.append(String.valueOf(this.offset));
                return stringBuilder.toString();
            }

            @Override
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("offset");
                element.appendChild(document.createTextNode(String.valueOf(this.offset)));
                return element;
            }
        }

        private class Pair<T> {
            private T first;
            private T second;

            public Pair(T t, T t2) {
                this.first = t;
                this.second = t2;
            }

            public boolean equals(Object object) {
                if (object instanceof Pair) {
                    T t = this.first;
                    object = (Pair)object;
                    if (t.equals(object.first) && this.second.equals(object.second)) {
                        return true;
                    }
                }
                return false;
            }

            public int hashCode() {
                return this.first.hashCode() * 31 + this.second.hashCode();
            }
        }

        private abstract class PathItem {
            private PathItem() {
            }

            protected abstract Node toXmlNode(Document var1);
        }

    }

    class PngFileFilter
    implements FileFilter {
        PngFileFilter() {
        }

        @Override
        public boolean accept(File object) {
            object = object.getAbsolutePath();
            boolean bl = object.endsWith(".png");
            boolean bl2 = object.contains("cmp_");
            if (bl && !bl2 && object.contains(CompareTool.this.outPdfName)) {
                return true;
            }
            return false;
        }
    }

}

