/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.io;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.io.ArrayRandomAccessSource;
import com.itextpdf.text.io.FileChannelRandomAccessSource;
import com.itextpdf.text.io.GetBufferedRandomAccessSource;
import com.itextpdf.text.io.GroupedRandomAccessSource;
import com.itextpdf.text.io.MapFailedException;
import com.itextpdf.text.io.PagedChannelRandomAccessSource;
import com.itextpdf.text.io.RAFRandomAccessSource;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.StreamUtil;
import com.itextpdf.text.io.WindowRandomAccessSource;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.RandomAccessFile;
import java.net.URL;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;

public final class RandomAccessSourceFactory {
    private boolean exclusivelyLockFile = false;
    private boolean forceRead = false;
    private boolean usePlainRandomAccess = false;

    private RandomAccessSource createByReadingToMemory(InputStream inputStream) throws IOException {
        try {
            ArrayRandomAccessSource arrayRandomAccessSource = new ArrayRandomAccessSource(StreamUtil.inputStreamToArray(inputStream));
            return arrayRandomAccessSource;
        }
        finally {
            inputStream.close();
        }
    }

    private RandomAccessSource createByReadingToMemory(String string2) throws IOException {
        InputStream inputStream = StreamUtil.getResourceStream(string2);
        if (inputStream == null) {
            throw new IOException(MessageLocalization.getComposedMessage("1.not.found.as.file.or.resource", string2));
        }
        return this.createByReadingToMemory(inputStream);
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public RandomAccessSource createBestSource(RandomAccessFile randomAccessFile) throws IOException {
        if (this.usePlainRandomAccess) {
            return new RAFRandomAccessSource(randomAccessFile);
        }
        if (randomAccessFile.length() <= 0L) {
            return new RAFRandomAccessSource(randomAccessFile);
        }
        try {
            return this.createBestSource(randomAccessFile.getChannel());
        }
        catch (MapFailedException mapFailedException) {
            return new RAFRandomAccessSource(randomAccessFile);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    public RandomAccessSource createBestSource(String object) throws IOException {
        file = new File((String)object);
        if (!file.canRead()) {
            if (!(object.startsWith("file:/") || object.startsWith("http://") || object.startsWith("https://") || object.startsWith("jar:") || object.startsWith("wsjar:") || object.startsWith("wsjar:") || object.startsWith("vfszip:"))) {
                return this.createByReadingToMemory((String)object);
            }
            return this.createSource(new URL((String)object));
        }
        if (this.forceRead) {
            return this.createByReadingToMemory(new FileInputStream((String)object));
        }
        object = this.exclusivelyLockFile != false ? "rw" : "r";
        object = new RandomAccessFile((File)file, (String)object);
        if (this.exclusivelyLockFile) {
            object.getChannel().lock();
        }
        try {
            file = this.createBestSource((RandomAccessFile)object);
            return file;
        }
        catch (RuntimeException runtimeException) {
            object.close();
lbl18: // 2 sources:
            do {
                throw runtimeException;
                break;
            } while (true);
        }
        catch (IOException iOException) {
            object.close();
lbl23: // 2 sources:
            do {
                throw iOException;
                break;
            } while (true);
        }
        {
            catch (IOException iOException) {
                ** continue;
            }
        }
        {
            catch (IOException iOException) {
                ** continue;
            }
        }
    }

    public RandomAccessSource createBestSource(FileChannel fileChannel) throws IOException {
        if (fileChannel.size() <= 0x4000000L) {
            return new GetBufferedRandomAccessSource(new FileChannelRandomAccessSource(fileChannel));
        }
        return new GetBufferedRandomAccessSource(new PagedChannelRandomAccessSource(fileChannel));
    }

    public RandomAccessSource createRanged(RandomAccessSource randomAccessSource, long[] arrl) throws IOException {
        RandomAccessSource[] arrrandomAccessSource = new RandomAccessSource[arrl.length / 2];
        for (int i = 0; i < arrl.length; i += 2) {
            arrrandomAccessSource[i / 2] = new WindowRandomAccessSource(randomAccessSource, arrl[i], arrl[i + 1]);
        }
        return new GroupedRandomAccessSource(arrrandomAccessSource);
    }

    public RandomAccessSource createSource(InputStream inputStream) throws IOException {
        try {
            RandomAccessSource randomAccessSource = this.createSource(StreamUtil.inputStreamToArray(inputStream));
            return randomAccessSource;
        }
        finally {
            inputStream.close();
        }
    }

    public RandomAccessSource createSource(RandomAccessFile randomAccessFile) throws IOException {
        return new RAFRandomAccessSource(randomAccessFile);
    }

    public RandomAccessSource createSource(URL object) throws IOException {
        object = object.openStream();
        try {
            RandomAccessSource randomAccessSource = this.createSource((InputStream)object);
            return randomAccessSource;
        }
        finally {
            object.close();
        }
    }

    public RandomAccessSource createSource(byte[] arrby) {
        return new ArrayRandomAccessSource(arrby);
    }

    public RandomAccessSourceFactory setExclusivelyLockFile(boolean bl) {
        this.exclusivelyLockFile = bl;
        return this;
    }

    public RandomAccessSourceFactory setForceRead(boolean bl) {
        this.forceRead = bl;
        return this;
    }

    public RandomAccessSourceFactory setUsePlainRandomAccess(boolean bl) {
        this.usePlainRandomAccess = bl;
        return this;
    }
}

