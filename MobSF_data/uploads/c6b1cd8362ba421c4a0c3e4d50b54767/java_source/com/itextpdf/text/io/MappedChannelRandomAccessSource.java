/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.io;

import com.itextpdf.text.io.ByteBufferRandomAccessSource;
import com.itextpdf.text.io.MapFailedException;
import com.itextpdf.text.io.RandomAccessSource;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;

class MappedChannelRandomAccessSource
implements RandomAccessSource {
    private final FileChannel channel;
    private final long length;
    private final long offset;
    private ByteBufferRandomAccessSource source;

    public MappedChannelRandomAccessSource(FileChannel object, long l, long l2) {
        if (l < 0L) {
            object = new StringBuilder();
            object.append(l);
            object.append(" is negative");
            throw new IllegalArgumentException(object.toString());
        }
        if (l2 <= 0L) {
            object = new StringBuilder();
            object.append(l2);
            object.append(" is zero or negative");
            throw new IllegalArgumentException(object.toString());
        }
        this.channel = object;
        this.offset = l;
        this.length = l2;
        this.source = null;
    }

    private static boolean exceptionIsMapFailureException(IOException iOException) {
        if (iOException.getMessage() != null && iOException.getMessage().indexOf("Map failed") >= 0) {
            return true;
        }
        return false;
    }

    @Override
    public void close() throws IOException {
        if (this.source == null) {
            return;
        }
        this.source.close();
        this.source = null;
    }

    @Override
    public int get(long l) throws IOException {
        if (this.source == null) {
            throw new IOException("RandomAccessSource not opened");
        }
        return this.source.get(l);
    }

    @Override
    public int get(long l, byte[] arrby, int n, int n2) throws IOException {
        if (this.source == null) {
            throw new IOException("RandomAccessSource not opened");
        }
        return this.source.get(l, arrby, n, n2);
    }

    @Override
    public long length() {
        return this.length;
    }

    void open() throws IOException {
        if (this.source != null) {
            return;
        }
        if (!this.channel.isOpen()) {
            throw new IllegalStateException("Channel is closed");
        }
        try {
            this.source = new ByteBufferRandomAccessSource(this.channel.map(FileChannel.MapMode.READ_ONLY, this.offset, this.length));
            return;
        }
        catch (IOException iOException) {
            if (MappedChannelRandomAccessSource.exceptionIsMapFailureException(iOException)) {
                throw new MapFailedException(iOException);
            }
            throw iOException;
        }
    }

    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(this.getClass().getName());
        stringBuilder.append(" (");
        stringBuilder.append(this.offset);
        stringBuilder.append(", ");
        stringBuilder.append(this.length);
        stringBuilder.append(")");
        return stringBuilder.toString();
    }
}

