/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.io;

import com.itextpdf.text.io.RandomAccessSource;
import java.io.IOException;
import java.lang.reflect.Method;
import java.nio.Buffer;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.security.AccessController;
import java.security.PrivilegedAction;

class ByteBufferRandomAccessSource
implements RandomAccessSource {
    private final ByteBuffer byteBuffer;

    public ByteBufferRandomAccessSource(ByteBuffer byteBuffer) {
        this.byteBuffer = byteBuffer;
    }

    private static boolean clean(final ByteBuffer byteBuffer) {
        if (byteBuffer != null && byteBuffer.isDirect()) {
            return (Boolean)AccessController.doPrivileged(new PrivilegedAction<Boolean>(){

                @Override
                public Boolean run() {
                    Boolean bl = Boolean.FALSE;
                    try {
                        Object object = byteBuffer.getClass().getMethod("cleaner", null);
                        object.setAccessible(true);
                        object = object.invoke(byteBuffer, null);
                        object.getClass().getMethod("clean", null).invoke(object, null);
                        object = Boolean.TRUE;
                        return object;
                    }
                    catch (Exception exception) {
                        return bl;
                    }
                }
            });
        }
        return false;
    }

    @Override
    public void close() throws IOException {
        ByteBufferRandomAccessSource.clean(this.byteBuffer);
    }

    @Override
    public int get(long l) throws IOException {
        block4 : {
            if (l > Integer.MAX_VALUE) {
                throw new IllegalArgumentException("Position must be less than Integer.MAX_VALUE");
            }
            try {
                if (l < (long)this.byteBuffer.limit()) break block4;
                return -1;
            }
            catch (BufferUnderflowException bufferUnderflowException) {
                return -1;
            }
        }
        byte by = this.byteBuffer.get((int)l);
        return by & 255;
    }

    @Override
    public int get(long l, byte[] arrby, int n, int n2) throws IOException {
        if (l > Integer.MAX_VALUE) {
            throw new IllegalArgumentException("Position must be less than Integer.MAX_VALUE");
        }
        if (l >= (long)this.byteBuffer.limit()) {
            return -1;
        }
        this.byteBuffer.position((int)l);
        n2 = Math.min(n2, this.byteBuffer.remaining());
        this.byteBuffer.get(arrby, n, n2);
        return n2;
    }

    @Override
    public long length() {
        return this.byteBuffer.limit();
    }

}

