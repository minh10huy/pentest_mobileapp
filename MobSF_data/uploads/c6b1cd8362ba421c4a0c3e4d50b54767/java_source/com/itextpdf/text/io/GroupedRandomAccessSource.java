/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.io;

import com.itextpdf.text.io.RandomAccessSource;
import java.io.IOException;

class GroupedRandomAccessSource
implements RandomAccessSource {
    private SourceEntry currentSourceEntry;
    private final long size;
    private final SourceEntry[] sources;

    public GroupedRandomAccessSource(RandomAccessSource[] arrrandomAccessSource) throws IOException {
        this.sources = new SourceEntry[arrrandomAccessSource.length];
        long l = 0L;
        int n = 0;
        while (n < arrrandomAccessSource.length) {
            this.sources[n] = new SourceEntry(n, arrrandomAccessSource[n], l);
            long l2 = arrrandomAccessSource[n].length();
            ++n;
            l += l2;
        }
        this.size = l;
        this.currentSourceEntry = this.sources[arrrandomAccessSource.length - 1];
        this.sourceInUse(this.currentSourceEntry.source);
    }

    private SourceEntry getSourceEntryForOffset(long l) throws IOException {
        if (l >= this.size) {
            return null;
        }
        if (l >= this.currentSourceEntry.firstByte && l <= this.currentSourceEntry.lastByte) {
            return this.currentSourceEntry;
        }
        this.sourceReleased(this.currentSourceEntry.source);
        for (int i = this.getStartingSourceIndex((long)l); i < this.sources.length; ++i) {
            if (l < this.sources[i].firstByte || l > this.sources[i].lastByte) continue;
            this.currentSourceEntry = this.sources[i];
            this.sourceInUse(this.currentSourceEntry.source);
            return this.currentSourceEntry;
        }
        return null;
    }

    @Override
    public void close() throws IOException {
        SourceEntry[] arrsourceEntry = this.sources;
        int n = arrsourceEntry.length;
        for (int i = 0; i < n; ++i) {
            arrsourceEntry[i].source.close();
        }
    }

    @Override
    public int get(long l) throws IOException {
        SourceEntry sourceEntry = this.getSourceEntryForOffset(l);
        if (sourceEntry == null) {
            return -1;
        }
        return sourceEntry.source.get(sourceEntry.offsetN(l));
    }

    @Override
    public int get(long l, byte[] arrby, int n, int n2) throws IOException {
        int n3;
        SourceEntry sourceEntry = this.getSourceEntryForOffset(l);
        if (sourceEntry == null) {
            return -1;
        }
        long l2 = sourceEntry.offsetN(l);
        int n4 = n;
        for (n = n2; n > 0 && sourceEntry != null && l2 <= sourceEntry.source.length() && (n3 = sourceEntry.source.get(l2, arrby, n4, n)) != -1; n -= n3) {
            n4 += n3;
            sourceEntry = this.getSourceEntryForOffset(l += (long)n3);
            l2 = 0L;
        }
        if (n == n2) {
            return -1;
        }
        return n2 - n;
    }

    protected int getStartingSourceIndex(long l) {
        if (l >= this.currentSourceEntry.firstByte) {
            return this.currentSourceEntry.index;
        }
        return 0;
    }

    @Override
    public long length() {
        return this.size;
    }

    protected void sourceInUse(RandomAccessSource randomAccessSource) throws IOException {
    }

    protected void sourceReleased(RandomAccessSource randomAccessSource) throws IOException {
    }

    private static class SourceEntry {
        final long firstByte;
        final int index;
        final long lastByte;
        final RandomAccessSource source;

        public SourceEntry(int n, RandomAccessSource randomAccessSource, long l) {
            this.index = n;
            this.source = randomAccessSource;
            this.firstByte = l;
            this.lastByte = l + randomAccessSource.length() - 1L;
        }

        public long offsetN(long l) {
            return l - this.firstByte;
        }
    }

}

