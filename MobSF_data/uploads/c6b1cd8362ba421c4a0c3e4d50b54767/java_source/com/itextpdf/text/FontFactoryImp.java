/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Font;
import com.itextpdf.text.FontProvider;
import com.itextpdf.text.log.Level;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.BaseFont;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Set;

public class FontFactoryImp
implements FontProvider {
    private static final Logger LOGGER = LoggerFactory.getLogger(FontFactoryImp.class);
    private static String[] TTFamilyOrder = new String[]{"3", "1", "1033", "3", "0", "1033", "1", "0", "0", "0", "3", "0"};
    public boolean defaultEmbedding = false;
    public String defaultEncoding = "Cp1252";
    private final Hashtable<String, ArrayList<String>> fontFamilies = new Hashtable();
    private final Hashtable<String, String> trueTypeFonts = new Hashtable();

    public FontFactoryImp() {
        this.trueTypeFonts.put("Courier".toLowerCase(), "Courier");
        this.trueTypeFonts.put("Courier-Bold".toLowerCase(), "Courier-Bold");
        this.trueTypeFonts.put("Courier-Oblique".toLowerCase(), "Courier-Oblique");
        this.trueTypeFonts.put("Courier-BoldOblique".toLowerCase(), "Courier-BoldOblique");
        this.trueTypeFonts.put("Helvetica".toLowerCase(), "Helvetica");
        this.trueTypeFonts.put("Helvetica-Bold".toLowerCase(), "Helvetica-Bold");
        this.trueTypeFonts.put("Helvetica-Oblique".toLowerCase(), "Helvetica-Oblique");
        this.trueTypeFonts.put("Helvetica-BoldOblique".toLowerCase(), "Helvetica-BoldOblique");
        this.trueTypeFonts.put("Symbol".toLowerCase(), "Symbol");
        this.trueTypeFonts.put("Times-Roman".toLowerCase(), "Times-Roman");
        this.trueTypeFonts.put("Times-Bold".toLowerCase(), "Times-Bold");
        this.trueTypeFonts.put("Times-Italic".toLowerCase(), "Times-Italic");
        this.trueTypeFonts.put("Times-BoldItalic".toLowerCase(), "Times-BoldItalic");
        this.trueTypeFonts.put("ZapfDingbats".toLowerCase(), "ZapfDingbats");
        ArrayList<String> arrayList = new ArrayList<String>();
        arrayList.add("Courier");
        arrayList.add("Courier-Bold");
        arrayList.add("Courier-Oblique");
        arrayList.add("Courier-BoldOblique");
        this.fontFamilies.put("Courier".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("Helvetica");
        arrayList.add("Helvetica-Bold");
        arrayList.add("Helvetica-Oblique");
        arrayList.add("Helvetica-BoldOblique");
        this.fontFamilies.put("Helvetica".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("Symbol");
        this.fontFamilies.put("Symbol".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("Times-Roman");
        arrayList.add("Times-Bold");
        arrayList.add("Times-Italic");
        arrayList.add("Times-BoldItalic");
        this.fontFamilies.put("Times".toLowerCase(), arrayList);
        this.fontFamilies.put("Times-Roman".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("ZapfDingbats");
        this.fontFamilies.put("ZapfDingbats".toLowerCase(), arrayList);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected BaseFont getBaseFont(String string2, String string3, boolean bl, boolean bl2) throws IOException, DocumentException {
        BaseFont baseFont;
        block2 : {
            try {
                baseFont = BaseFont.createFont(string2, string3, bl, bl2, null, null, true);
                break block2;
            }
            catch (DocumentException documentException) {}
            baseFont = null;
        }
        BaseFont baseFont2 = baseFont;
        if (baseFont != null) return baseFont2;
        string2 = this.trueTypeFonts.get(string2.toLowerCase());
        baseFont2 = baseFont;
        if (string2 == null) return baseFont2;
        return BaseFont.createFont(string2, string3, bl, bl2, null, null);
    }

    public Font getFont(String string2) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, -1.0f, -1, null);
    }

    public Font getFont(String string2, float f) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f, -1, null);
    }

    public Font getFont(String string2, float f, int n) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f, n, null);
    }

    public Font getFont(String string2, float f, int n, BaseColor baseColor) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f, n, baseColor);
    }

    public Font getFont(String string2, float f, BaseColor baseColor) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f, -1, baseColor);
    }

    public Font getFont(String string2, String string3) {
        return this.getFont(string2, string3, this.defaultEmbedding, -1.0f, -1, null);
    }

    public Font getFont(String string2, String string3, float f) {
        return this.getFont(string2, string3, this.defaultEmbedding, f, -1, null);
    }

    public Font getFont(String string2, String string3, float f, int n) {
        return this.getFont(string2, string3, this.defaultEmbedding, f, n, null);
    }

    public Font getFont(String string2, String string3, float f, int n, BaseColor baseColor) {
        return this.getFont(string2, string3, this.defaultEmbedding, f, n, baseColor);
    }

    public Font getFont(String string2, String string3, boolean bl) {
        return this.getFont(string2, string3, bl, -1.0f, -1, null);
    }

    public Font getFont(String string2, String string3, boolean bl, float f) {
        return this.getFont(string2, string3, bl, f, -1, null);
    }

    public Font getFont(String string2, String string3, boolean bl, float f, int n) {
        return this.getFont(string2, string3, bl, f, n, null);
    }

    @Override
    public Font getFont(String string2, String string3, boolean bl, float f, int n, BaseColor baseColor) {
        return this.getFont(string2, string3, bl, f, n, baseColor, true);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public Font getFont(String object, String string2, boolean bl, float f, int n, BaseColor baseColor, boolean bl2) {
        if (object == null) {
            return new Font(Font.FontFamily.UNDEFINED, f, n, baseColor);
        }
        String string3 = object.toLowerCase();
        ArrayList<String> arrayList = this.fontFamilies.get(string3);
        if (arrayList != null) {
            int n2;
            synchronized (arrayList) {
                int n3;
                int n4;
                block12 : {
                    int n5 = 0;
                    n4 = n == -1 ? 0 : n;
                    Iterator<String> iterator = arrayList.iterator();
                    n2 = 0;
                    while (iterator.hasNext()) {
                        string3 = iterator.next();
                        String string4 = string3.toLowerCase();
                        n2 = string4.indexOf("bold") != -1 ? 1 : 0;
                        if (string4.indexOf("italic") != -1 || string4.indexOf("oblique") != -1) {
                            n2 |= 2;
                        }
                        if ((n4 & 3) != n2) continue;
                        object = string3;
                        n4 = 1;
                        n3 = n2;
                        break block12;
                    }
                    n3 = n2;
                    n4 = n5;
                }
                n2 = n;
                if (n != -1) {
                    n2 = n;
                    if (n4 != 0) {
                        n2 = n & ~ n3;
                    }
                }
            }
            n = n2;
        }
        try {
            object = this.getBaseFont((String)object, string2, bl, bl2);
            if (object != null) return new Font((BaseFont)object, f, n, baseColor);
            return new Font(Font.FontFamily.UNDEFINED, f, n, baseColor);
        }
        catch (DocumentException documentException) {
            throw new ExceptionConverter(documentException);
        }
        catch (IOException iOException) {
            return new Font(Font.FontFamily.UNDEFINED, f, n, baseColor);
        }
        catch (NullPointerException nullPointerException) {
            return new Font(Font.FontFamily.UNDEFINED, f, n, baseColor);
        }
    }

    public Set<String> getRegisteredFamilies() {
        return this.fontFamilies.keySet();
    }

    public Set<String> getRegisteredFonts() {
        return this.trueTypeFonts.keySet();
    }

    @Override
    public boolean isRegistered(String string2) {
        return this.trueTypeFonts.containsKey(string2.toLowerCase());
    }

    public void register(String string2) {
        this.register(string2, null);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void register(String var1_1, String var2_4) {
        block20 : {
            if (!var1_1.toLowerCase().endsWith(".ttf") && !var1_1.toLowerCase().endsWith(".otf") && var1_1.toLowerCase().indexOf(".ttc,") <= 0) {
                if (var1_1.toLowerCase().endsWith(".ttc")) {
                    if (var2_4 != null) {
                        FontFactoryImp.LOGGER.error("You can't define an alias for a true type collection.");
                    }
                    var2_4 = BaseFont.enumerateTTCNames(var1_1);
                    for (var3_5 = 0; var3_5 < ((Object)var2_4).length; ++var3_5) {
                        var7_7 = new StringBuilder();
                        var7_7.append(var1_1);
                        var7_7.append(",");
                        var7_7.append(var3_5);
                        this.register(var7_7.toString());
                    }
                    break block20;
                }
                if (!var1_1.toLowerCase().endsWith(".afm") && !var1_1.toLowerCase().endsWith(".pfm")) break block20;
                var8_19 = BaseFont.createFont(var1_1, "Cp1252", false);
                var2_4 = var8_19.getFullFontName()[0][3].toLowerCase();
                var7_8 = var8_19.getFamilyFontName()[0][3].toLowerCase();
                var8_19 = var8_19.getPostscriptFontName().toLowerCase();
                this.registerFamily(var7_8, (String)var2_4, null);
                this.trueTypeFonts.put((String)var8_19, var1_1);
                this.trueTypeFonts.put((String)var2_4, var1_1);
                break block20;
            }
            var8_20 = BaseFont.getAllFontNames(var1_1, "Cp1252", null);
            this.trueTypeFonts.put(((String)var8_20[0]).toLowerCase(), var1_1);
            if (var2_4 != null) {
                var2_4 = var2_4.toLowerCase();
                this.trueTypeFonts.put((String)var2_4, var1_1);
                if (var2_4.endsWith("regular")) {
                    this.saveCopyOfRegularFont((String)var2_4, var1_1);
                }
            }
            var2_4 = (String[][])var8_20[2];
            var4_21 = ((Object)var2_4).length;
            var3_6 = 0;
            do {
                if (var3_6 < var4_21) {
                    var7_9 = var2_4[var3_6][3].toLowerCase();
                    this.trueTypeFonts.put(var7_9, var1_1);
                    if (var7_9.endsWith("regular")) {
                        this.saveCopyOfRegularFont(var7_9, var1_1);
                    }
                } else {
                    var9_22 = (String[][])var8_20[1];
                    var2_4 = null;
                    var3_6 = 0;
                    break;
                }
                ++var3_6;
            } while (true);
lbl47: // 2 sources:
            if (var3_6 >= FontFactoryImp.TTFamilyOrder.length) break block20;
            var6_24 = var9_22.length;
            var4_21 = 0;
            do {
                var5_23 = var3_6;
                var7_12 = var2_4;
                if (var4_21 >= var6_24) break;
                var7_13 = var9_22[var4_21];
                try {
                    if (FontFactoryImp.TTFamilyOrder[var3_6].equals(var7_13[0]) && FontFactoryImp.TTFamilyOrder[var3_6 + 1].equals(var7_13[1]) && FontFactoryImp.TTFamilyOrder[var3_6 + 2].equals(var7_13[2])) {
                        var7_14 = var7_13[3].toLowerCase();
                        var5_23 = FontFactoryImp.TTFamilyOrder.length;
                        break;
                    }
                }
                catch (IOException var1_2) {
                    throw new ExceptionConverter(var1_2);
                }
                catch (DocumentException var1_3) {
                    throw new ExceptionConverter(var1_3);
                }
                ++var4_21;
            } while (true);
            var3_6 = var5_23 + 3;
            var2_4 = var7_18;
            ** GOTO lbl47
        }
        if (FontFactoryImp.LOGGER.isLogging(Level.TRACE) == false) return;
        FontFactoryImp.LOGGER.trace(String.format("Registered %s", new Object[]{var1_1}));
    }

    public int registerDirectories() {
        int n;
        String string2 = System.getenv("windir");
        String string3 = System.getProperty("file.separator");
        int n2 = n = 0;
        if (string2 != null) {
            n2 = n;
            if (string3 != null) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append(string3);
                stringBuilder.append("fonts");
                n2 = 0 + this.registerDirectory(stringBuilder.toString());
            }
        }
        return n2 + this.registerDirectory("/usr/share/X11/fonts", true) + this.registerDirectory("/usr/X/lib/X11/fonts", true) + this.registerDirectory("/usr/openwin/lib/X11/fonts", true) + this.registerDirectory("/usr/share/fonts", true) + this.registerDirectory("/usr/X11R6/lib/X11/fonts", true) + this.registerDirectory("/Library/Fonts") + this.registerDirectory("/System/Library/Fonts");
    }

    public int registerDirectory(String string2) {
        return this.registerDirectory(string2, false);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    public int registerDirectory(String var1_1, boolean var2_4) {
        block18 : {
            if (FontFactoryImp.LOGGER.isLogging(Level.DEBUG)) {
                FontFactoryImp.LOGGER.debug(String.format("Registering directory %s, looking for fonts", new Object[]{var1_1}));
            }
            try {
                var7_5 = new File(var1_1);
                if (!var7_5.exists()) break block18;
                if (!var7_5.isDirectory()) {
                    return 0;
                }
                var8_7 = var7_5.list();
                if (var8_7 == null) {
                    return 0;
                }
                var5_8 = 0;
                var4_9 = 0;
            }
            catch (Exception var1_2) {
                ** continue;
            }
            block7 : do {
                var6_11 = var8_7.length;
                var3_10 = var4_9;
                ** if (var5_8 >= var6_11) goto lbl48
lbl-1000: // 1 sources:
                {
                    block19 : {
                        block20 : {
                            var7_5 = new File(var1_1, var8_7[var5_8]);
                            if (var7_5.isDirectory()) {
                                var3_10 = var4_9;
                                if (var2_4) {
                                    var3_10 = var4_9 + this.registerDirectory(var7_5.getAbsolutePath(), true);
                                }
                                break block19;
                            }
                            var9_12 = var7_5.getPath();
                            var7_5 = var9_12.length() < 4 ? null : var9_12.substring(var9_12.length() - 4).toLowerCase();
                            if (".afm".equals(var7_5) || ".pfm".equals(var7_5)) break block20;
                            if (!".ttf".equals(var7_5) && !".otf".equals(var7_5)) {
                                var3_10 = var4_9;
                                if (!".ttc".equals(var7_5)) break block19;
                            }
                            this.register(var9_12, null);
                            var3_10 = var4_9 + 1;
                            {
                                break block19;
                            }
                        }
                        var7_5 = new StringBuilder();
                        var7_5.append(var9_12.substring(0, var9_12.length() - 4));
                        var7_5.append(".pfb");
                        var3_10 = var4_9;
                        if (!new File(var7_5.toString()).exists()) break block19;
                        this.register(var9_12, null);
                        var3_10 = var4_9 + 1;
                    }
lbl44: // 2 sources:
                    do {
                        ++var5_8;
                        var4_9 = var3_10;
                        continue block7;
                        break;
                    } while (true);
                }
lbl48: // 1 sources:
                ** GOTO lbl53
                break;
            } while (true);
        }
        return 0;
lbl51: // 1 sources:
        do {
            var3_10 = 0;
lbl53: // 2 sources:
            return var3_10;
            break;
        } while (true);
        catch (Exception var1_3) {
            return var4_9;
        }
        catch (Exception var7_6) {
            var3_10 = var4_9;
            ** continue;
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void registerFamily(String string2, String string3, String arrayList) {
        if (arrayList != null) {
            this.trueTypeFonts.put(string3, (String)((Object)arrayList));
        }
        Hashtable<String, ArrayList<String>> hashtable = this.fontFamilies;
        synchronized (hashtable) {
            ArrayList<String> arrayList2 = this.fontFamilies.get(string2);
            arrayList = arrayList2;
            if (arrayList2 == null) {
                arrayList = new ArrayList<String>();
                this.fontFamilies.put(string2, arrayList);
            }
        }
        synchronized (arrayList) {
            if (!arrayList.contains(string3)) {
                int n;
                int n2 = string3.length();
                for (n = 0; n < arrayList.size(); ++n) {
                    if (((String)arrayList.get(n)).length() < n2) continue;
                    arrayList.add(n, string3);
                    return;
                }
                n = 0;
                if (n == 0) {
                    arrayList.add(string3);
                    string2 = string3.toLowerCase();
                    if (string2.endsWith("regular")) {
                        arrayList.add(0, string3.substring(0, string2.substring(0, string2.length() - 7).trim().length()));
                    }
                }
            }
            return;
        }
    }

    protected boolean saveCopyOfRegularFont(String string2, String string3) {
        if (!this.trueTypeFonts.containsKey(string2 = string2.substring(0, string2.length() - 7).trim())) {
            this.trueTypeFonts.put(string2, string3);
            return true;
        }
        return false;
    }
}

