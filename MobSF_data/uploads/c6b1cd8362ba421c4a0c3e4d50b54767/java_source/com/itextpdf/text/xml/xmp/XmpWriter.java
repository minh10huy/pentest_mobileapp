/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.xml.xmp;

import com.itextpdf.text.Version;
import com.itextpdf.text.pdf.PdfDate;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.xml.xmp.XmpSchema;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.XMPUtils;
import com.itextpdf.xmp.options.PropertyOptions;
import com.itextpdf.xmp.options.SerializeOptions;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class XmpWriter {
    public static final String UTF16 = "UTF-16";
    public static final String UTF16BE = "UTF-16BE";
    public static final String UTF16LE = "UTF-16LE";
    public static final String UTF8 = "UTF-8";
    protected OutputStream outputStream;
    protected SerializeOptions serializeOptions;
    protected XMPMeta xmpMeta;

    public XmpWriter(OutputStream outputStream) throws IOException {
        this(outputStream, UTF8, 2000);
    }

    public XmpWriter(OutputStream object, PdfDictionary pdfDictionary) throws IOException {
        this((OutputStream)object);
        if (pdfDictionary != null) {
            for (PdfName pdfName : pdfDictionary.getKeys()) {
                Object object2 = pdfDictionary.get(pdfName);
                if (object2 == null || !object2.isString()) continue;
                object2 = ((PdfString)object2).toUnicodeString();
                try {
                    this.addDocInfoProperty(pdfName, (String)object2);
                }
                catch (XMPException xMPException) {
                    throw new IOException(xMPException.getMessage());
                }
            }
        }
    }

    public XmpWriter(OutputStream outputStream, String string2, int n) throws IOException {
        this.outputStream = outputStream;
        this.serializeOptions = new SerializeOptions();
        if (!UTF16BE.equals(string2) && !UTF16.equals(string2)) {
            if (UTF16LE.equals(string2)) {
                this.serializeOptions.setEncodeUTF16LE(true);
            }
        } else {
            this.serializeOptions.setEncodeUTF16BE(true);
        }
        this.serializeOptions.setPadding(n);
        this.xmpMeta = XMPMetaFactory.create();
        this.xmpMeta.setObjectName("xmpmeta");
        this.xmpMeta.setObjectName("");
        try {
            this.xmpMeta.setProperty("http://purl.org/dc/elements/1.1/", "format", "application/pdf");
            this.xmpMeta.setProperty("http://ns.adobe.com/pdf/1.3/", "Producer", Version.getInstance().getVersion());
            return;
        }
        catch (XMPException xMPException) {
            return;
        }
    }

    public XmpWriter(OutputStream object, Map<String, String> object2) throws IOException {
        this((OutputStream)((Object)object));
        if (object2 != null) {
            for (Map.Entry entry : object2.entrySet()) {
                object2 = (String)entry.getKey();
                String object3 = (String)entry.getValue();
                if (object3 == null) continue;
                try {
                    this.addDocInfoProperty(object2, object3);
                }
                catch (XMPException xMPException) {
                    throw new IOException(xMPException.getMessage());
                }
            }
        }
    }

    public void addDocInfoProperty(Object arrstring, String string2) throws XMPException {
        void var5_5;
        String[] object2 = arrstring;
        if (arrstring instanceof String) {
            PdfName pdfName = new PdfName((String)arrstring);
        }
        if (PdfName.TITLE.equals(var5_5)) {
            this.xmpMeta.setLocalizedText("http://purl.org/dc/elements/1.1/", "title", "x-default", "x-default", string2);
            return;
        }
        if (PdfName.AUTHOR.equals(var5_5)) {
            this.xmpMeta.appendArrayItem("http://purl.org/dc/elements/1.1/", "creator", new PropertyOptions(1024), string2, null);
            return;
        }
        if (PdfName.SUBJECT.equals(var5_5)) {
            this.xmpMeta.setLocalizedText("http://purl.org/dc/elements/1.1/", "description", "x-default", "x-default", string2);
            return;
        }
        if (PdfName.KEYWORDS.equals(var5_5)) {
            for (String string3 : string2.split(",|;")) {
                if (string3.trim().length() <= 0) continue;
                this.xmpMeta.appendArrayItem("http://purl.org/dc/elements/1.1/", "subject", new PropertyOptions(512), string3.trim(), null);
            }
            this.xmpMeta.setProperty("http://ns.adobe.com/pdf/1.3/", "Keywords", string2);
            return;
        }
        if (PdfName.PRODUCER.equals(var5_5)) {
            this.xmpMeta.setProperty("http://ns.adobe.com/pdf/1.3/", "Producer", string2);
            return;
        }
        if (PdfName.CREATOR.equals(var5_5)) {
            this.xmpMeta.setProperty("http://ns.adobe.com/xap/1.0/", "CreatorTool", string2);
            return;
        }
        if (PdfName.CREATIONDATE.equals(var5_5)) {
            this.xmpMeta.setProperty("http://ns.adobe.com/xap/1.0/", "CreateDate", PdfDate.getW3CDate(string2));
            return;
        }
        if (PdfName.MODDATE.equals(var5_5)) {
            this.xmpMeta.setProperty("http://ns.adobe.com/xap/1.0/", "ModifyDate", PdfDate.getW3CDate(string2));
        }
    }

    @Deprecated
    public void addRdfDescription(XmpSchema xmpSchema) throws IOException {
        try {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"><rdf:Description rdf:about=\"");
            stringBuilder.append(this.xmpMeta.getObjectName());
            stringBuilder.append("\" ");
            stringBuilder.append(xmpSchema.getXmlns());
            stringBuilder.append(">");
            stringBuilder.append(xmpSchema.toString());
            stringBuilder.append("</rdf:Description></rdf:RDF>\n");
            XMPUtils.appendProperties(XMPMetaFactory.parseFromString(stringBuilder.toString()), this.xmpMeta, true, true);
            return;
        }
        catch (XMPException xMPException) {
            throw new IOException(xMPException.getMessage());
        }
    }

    @Deprecated
    public void addRdfDescription(String string2, String string3) throws IOException {
        try {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"><rdf:Description rdf:about=\"");
            stringBuilder.append(this.xmpMeta.getObjectName());
            stringBuilder.append("\" ");
            stringBuilder.append(string2);
            stringBuilder.append(">");
            stringBuilder.append(string3);
            stringBuilder.append("</rdf:Description></rdf:RDF>\n");
            XMPUtils.appendProperties(XMPMetaFactory.parseFromString(stringBuilder.toString()), this.xmpMeta, true, true);
            return;
        }
        catch (XMPException xMPException) {
            throw new IOException(xMPException.getMessage());
        }
    }

    public void appendAlternateArrayItem(String string2, String string3, String string4) throws XMPException {
        this.xmpMeta.appendArrayItem(string2, string3, new PropertyOptions(2048), string4, null);
    }

    public void appendArrayItem(String string2, String string3, String string4) throws XMPException {
        this.xmpMeta.appendArrayItem(string2, string3, new PropertyOptions(512), string4, null);
    }

    public void appendOrderedArrayItem(String string2, String string3, String string4) throws XMPException {
        this.xmpMeta.appendArrayItem(string2, string3, new PropertyOptions(1024), string4, null);
    }

    public void close() throws IOException {
        if (this.outputStream == null) {
            return;
        }
        try {
            XMPMetaFactory.serialize(this.xmpMeta, this.outputStream, this.serializeOptions);
            this.outputStream = null;
            return;
        }
        catch (XMPException xMPException) {
            throw new IOException(xMPException.getMessage());
        }
    }

    public XMPMeta getXmpMeta() {
        return this.xmpMeta;
    }

    public void serialize(OutputStream outputStream) throws XMPException {
        XMPMetaFactory.serialize(this.xmpMeta, outputStream, this.serializeOptions);
    }

    public void setAbout(String string2) {
        this.xmpMeta.setObjectName(string2);
    }

    public void setProperty(String string2, String string3, Object object) throws XMPException {
        this.xmpMeta.setProperty(string2, string3, object);
    }

    public void setReadOnly() {
        this.serializeOptions.setReadOnlyPacket(true);
    }
}

