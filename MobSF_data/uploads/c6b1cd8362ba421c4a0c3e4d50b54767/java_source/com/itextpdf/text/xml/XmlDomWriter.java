/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.xml;

import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

public class XmlDomWriter {
    protected boolean fCanonical;
    protected PrintWriter fOut;
    protected boolean fXML11;

    public XmlDomWriter() {
    }

    public XmlDomWriter(boolean bl) {
        this.fCanonical = bl;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    protected void normalizeAndPrint(char var1_1, boolean var2_2) {
        if (var1_1 == '\n') ** GOTO lbl21
        if (var1_1 == '\r') {
            this.fOut.print("&#xD;");
            return;
        }
        if (var1_1 != '\"') {
            if (var1_1 == '&') {
                this.fOut.print("&amp;");
                return;
            }
            if (var1_1 == '<') {
                this.fOut.print("&lt;");
                return;
            }
            if (var1_1 == '>') {
                this.fOut.print("&gt;");
                return;
            }
        } else {
            if (var2_2) {
                this.fOut.print("&quot;");
                return;
            }
            this.fOut.print("\"");
            return;
lbl21: // 1 sources:
            if (this.fCanonical) {
                this.fOut.print("&#xA;");
                return;
            }
        }
        if (this.fXML11 != false && (var1_1 >= '\u0001' && var1_1 <= '\u001f' && var1_1 != '\t' && var1_1 != '\n' || var1_1 >= '' && var1_1 <= '\u009f' || var1_1 == '\u2028') || var2_2 && (var1_1 == '\t' || var1_1 == '\n')) {
            this.fOut.print("&#x");
            this.fOut.print(Integer.toHexString(var1_1).toUpperCase());
            this.fOut.print(";");
            return;
        }
        this.fOut.print(var1_1);
    }

    protected void normalizeAndPrint(String string2, boolean bl) {
        int n = string2 != null ? string2.length() : 0;
        for (int i = 0; i < n; ++i) {
            this.normalizeAndPrint(string2.charAt(i), bl);
        }
    }

    public void setCanonical(boolean bl) {
        this.fCanonical = bl;
    }

    public void setOutput(OutputStream outputStream, String string2) throws UnsupportedEncodingException {
        String string3 = string2;
        if (string2 == null) {
            string3 = "UTF8";
        }
        this.fOut = new PrintWriter(new OutputStreamWriter(outputStream, string3));
    }

    public void setOutput(Writer writer) {
        writer = writer instanceof PrintWriter ? (PrintWriter)writer : new PrintWriter(writer);
        this.fOut = writer;
    }

    protected Attr[] sortAttributes(NamedNodeMap object) {
        int n;
        int n2 = 0;
        int n3 = object != null ? object.getLength() : 0;
        Attr[] arrattr = new Attr[n3];
        int n4 = 0;
        do {
            n = n2;
            if (n4 >= n3) break;
            arrattr[n4] = (Attr)object.item(n4);
            ++n4;
        } while (true);
        while (n < n3 - 1) {
            object = arrattr[n].getNodeName();
            n2 = n + 1;
            int n5 = n;
            for (n4 = n2; n4 < n3; ++n4) {
                String string2 = arrattr[n4].getNodeName();
                Object object2 = object;
                if (string2.compareTo((String)object) < 0) {
                    n5 = n4;
                    object2 = string2;
                }
                object = object2;
            }
            if (n5 != n) {
                object = arrattr[n];
                arrattr[n] = arrattr[n5];
                arrattr[n5] = object;
            }
            n = n2;
        }
        return arrattr;
    }

    public void write(Node node) {
        if (node == null) {
            return;
        }
        short s = node.getNodeType();
        switch (s) {
            default: {
                break;
            }
            case 10: {
                Object object = (DocumentType)node;
                this.fOut.print("<!DOCTYPE ");
                this.fOut.print(object.getName());
                String string2 = object.getPublicId();
                String string3 = object.getSystemId();
                if (string2 != null) {
                    this.fOut.print(" PUBLIC '");
                    this.fOut.print(string2);
                    this.fOut.print("' '");
                    this.fOut.print(string3);
                    this.fOut.print('\'');
                } else if (string3 != null) {
                    this.fOut.print(" SYSTEM '");
                    this.fOut.print(string3);
                    this.fOut.print('\'');
                }
                object = object.getInternalSubset();
                if (object != null) {
                    this.fOut.println(" [");
                    this.fOut.print((String)object);
                    this.fOut.print(']');
                }
                this.fOut.println('>');
                break;
            }
            case 9: {
                Document document = (Document)node;
                this.fXML11 = false;
                if (!this.fCanonical) {
                    if (this.fXML11) {
                        this.fOut.println("<?xml version=\"1.1\" encoding=\"UTF-8\"?>");
                    } else {
                        this.fOut.println("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
                    }
                    this.fOut.flush();
                    this.write(document.getDoctype());
                }
                this.write(document.getDocumentElement());
                break;
            }
            case 8: {
                if (this.fCanonical) break;
                this.fOut.print("<!--");
                String string4 = node.getNodeValue();
                if (string4 != null && string4.length() > 0) {
                    this.fOut.print(string4);
                }
                this.fOut.print("-->");
                this.fOut.flush();
                break;
            }
            case 7: {
                this.fOut.print("<?");
                this.fOut.print(node.getNodeName());
                String string5 = node.getNodeValue();
                if (string5 != null && string5.length() > 0) {
                    this.fOut.print(' ');
                    this.fOut.print(string5);
                }
                this.fOut.print("?>");
                this.fOut.flush();
                break;
            }
            case 5: {
                if (this.fCanonical) {
                    for (Node node2 = node.getFirstChild(); node2 != null; node2 = node2.getNextSibling()) {
                        this.write(node2);
                    }
                    break;
                }
                this.fOut.print('&');
                this.fOut.print(node.getNodeName());
                this.fOut.print(';');
                this.fOut.flush();
                break;
            }
            case 4: {
                if (this.fCanonical) {
                    this.normalizeAndPrint(node.getNodeValue(), false);
                } else {
                    this.fOut.print("<![CDATA[");
                    this.fOut.print(node.getNodeValue());
                    this.fOut.print("]]>");
                }
                this.fOut.flush();
                break;
            }
            case 3: {
                this.normalizeAndPrint(node.getNodeValue(), false);
                this.fOut.flush();
                break;
            }
            case 1: {
                this.fOut.print('<');
                this.fOut.print(node.getNodeName());
                Object object = this.sortAttributes(node.getAttributes());
                for (int i = 0; i < ((Attr[])object).length; ++i) {
                    Attr attr2 = object[i];
                    this.fOut.print(' ');
                    this.fOut.print(attr2.getNodeName());
                    this.fOut.print("=\"");
                    this.normalizeAndPrint(attr2.getNodeValue(), true);
                    this.fOut.print('\"');
                }
                this.fOut.print('>');
                this.fOut.flush();
                for (object = node.getFirstChild(); object != null; object = object.getNextSibling()) {
                    this.write((Node)object);
                }
            }
        }
        if (s == 1) {
            this.fOut.print("</");
            this.fOut.print(node.getNodeName());
            this.fOut.print('>');
            this.fOut.flush();
        }
    }
}

