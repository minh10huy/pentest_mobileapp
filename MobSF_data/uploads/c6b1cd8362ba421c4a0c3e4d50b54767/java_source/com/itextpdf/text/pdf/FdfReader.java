/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.HashMap;

public class FdfReader
extends PdfReader {
    protected static Counter COUNTER = CounterFactory.getCounter(FdfReader.class);
    PdfName encoding;
    HashMap<String, PdfDictionary> fields;
    String fileSpec;

    public FdfReader(InputStream inputStream) throws IOException {
        super(inputStream);
    }

    public FdfReader(String string2) throws IOException {
        super(string2);
    }

    public FdfReader(URL uRL) throws IOException {
        super(uRL);
    }

    public FdfReader(byte[] arrby) throws IOException {
        super(arrby);
    }

    public byte[] getAttachedFile(String object) throws IOException {
        if ((object = this.fields.get(object)) != null) {
            return FdfReader.getStreamBytes((PRStream)this.getPdfObject(((PRIndirectReference)((PdfDictionary)this.getPdfObject(((PRIndirectReference)object.get(PdfName.V)).getNumber())).getAsDict(PdfName.EF).get(PdfName.F)).getNumber()));
        }
        return new byte[0];
    }

    @Override
    protected Counter getCounter() {
        return COUNTER;
    }

    public PdfDictionary getField(String string2) {
        return this.fields.get(string2);
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public String getFieldValue(String object) {
        if ((object = this.fields.get(object)) == null) {
            return null;
        }
        if ((object = FdfReader.getPdfObject(object.get(PdfName.V))) == null) {
            return null;
        }
        if (object.isName()) {
            return PdfName.decodeName(((PdfName)object).toString());
        }
        if (!object.isString()) return null;
        object = (PdfString)object;
        if (this.encoding == null) return object.toUnicodeString();
        if (object.getEncoding() != null) return object.toUnicodeString();
        byte[] arrby = object.getBytes();
        if (arrby.length >= 2 && arrby[0] == -2 && arrby[1] == -1) {
            return object.toUnicodeString();
        }
        try {
            if (this.encoding.equals(PdfName.SHIFT_JIS)) {
                return new String(arrby, "SJIS");
            }
            if (this.encoding.equals(PdfName.UHC)) {
                return new String(arrby, "MS949");
            }
            if (this.encoding.equals(PdfName.GBK)) {
                return new String(arrby, "GBK");
            }
            if (this.encoding.equals(PdfName.BIGFIVE)) {
                return new String(arrby, "Big5");
            }
            if (!this.encoding.equals(PdfName.UTF_8)) return object.toUnicodeString();
            return new String(arrby, "UTF8");
        }
        catch (Exception exception) {
            return object.toUnicodeString();
        }
    }

    public HashMap<String, PdfDictionary> getFields() {
        return this.fields;
    }

    public String getFileSpec() {
        return this.fileSpec;
    }

    protected void kidNode(PdfDictionary pdfDictionary, String string2) {
        PdfArray pdfArray = pdfDictionary.getAsArray(PdfName.KIDS);
        if (pdfArray != null && !pdfArray.isEmpty()) {
            pdfDictionary.remove(PdfName.KIDS);
            for (int i = 0; i < pdfArray.size(); ++i) {
                PdfDictionary pdfDictionary2 = new PdfDictionary();
                pdfDictionary2.merge(pdfDictionary);
                PdfDictionary pdfDictionary3 = pdfArray.getAsDict(i);
                Object object = pdfDictionary3.getAsString(PdfName.T);
                if (object != null) {
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append(string2);
                    stringBuilder.append(".");
                    stringBuilder.append(object.toUnicodeString());
                    object = stringBuilder.toString();
                } else {
                    object = string2;
                }
                pdfDictionary2.merge(pdfDictionary3);
                pdfDictionary2.remove(PdfName.T);
                this.kidNode(pdfDictionary2, (String)object);
            }
        } else {
            String string3 = string2;
            if (string2.length() > 0) {
                string3 = string2.substring(1);
            }
            this.fields.put(string3, pdfDictionary);
        }
    }

    protected void readFields() {
        this.catalog = this.trailer.getAsDict(PdfName.ROOT);
        PdfDictionary pdfDictionary = this.catalog.getAsDict(PdfName.FDF);
        if (pdfDictionary == null) {
            return;
        }
        PdfObject pdfObject = pdfDictionary.getAsString(PdfName.F);
        if (pdfObject != null) {
            this.fileSpec = pdfObject.toUnicodeString();
        }
        if ((pdfObject = pdfDictionary.getAsArray(PdfName.FIELDS)) == null) {
            return;
        }
        this.encoding = pdfDictionary.getAsName(PdfName.ENCODING);
        pdfDictionary = new PdfDictionary();
        pdfDictionary.put(PdfName.KIDS, pdfObject);
        this.kidNode(pdfDictionary, "");
    }

    @Override
    protected void readPdf() throws IOException {
        this.fields = new HashMap();
        this.tokens.checkFdfHeader();
        this.rebuildXref();
        this.readDocObj();
        this.readFields();
    }
}

