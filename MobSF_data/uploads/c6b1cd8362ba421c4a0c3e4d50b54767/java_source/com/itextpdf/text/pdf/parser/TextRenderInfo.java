/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.pdf.CMapAwareDocumentFont;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.parser.GraphicsState;
import com.itextpdf.text.pdf.parser.LineSegment;
import com.itextpdf.text.pdf.parser.MarkedContentInfo;
import com.itextpdf.text.pdf.parser.Matrix;
import com.itextpdf.text.pdf.parser.Vector;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

public class TextRenderInfo {
    private double[] fontMatrix = null;
    private final GraphicsState gs;
    private final Collection<MarkedContentInfo> markedContentInfos;
    private final PdfString string;
    private String text = null;
    private final Matrix textToUserSpaceTransformMatrix;
    private Float unscaledWidth = null;

    TextRenderInfo(PdfString pdfString, GraphicsState graphicsState, Matrix matrix, Collection<MarkedContentInfo> collection) {
        this.string = pdfString;
        this.textToUserSpaceTransformMatrix = matrix.multiply(graphicsState.ctm);
        this.gs = graphicsState;
        this.markedContentInfos = new ArrayList<MarkedContentInfo>(collection);
        this.fontMatrix = graphicsState.font.getFontMatrix();
    }

    private TextRenderInfo(TextRenderInfo textRenderInfo, PdfString pdfString, float f) {
        this.string = pdfString;
        this.textToUserSpaceTransformMatrix = new Matrix(f, 0.0f).multiply(textRenderInfo.textToUserSpaceTransformMatrix);
        this.gs = textRenderInfo.gs;
        this.markedContentInfos = textRenderInfo.markedContentInfos;
        this.fontMatrix = this.gs.font.getFontMatrix();
    }

    private float convertHeightFromTextSpaceToUserSpace(float f) {
        return new LineSegment(new Vector(0.0f, 0.0f, 1.0f), new Vector(0.0f, f, 1.0f)).transformBy(this.textToUserSpaceTransformMatrix).getLength();
    }

    private float convertWidthFromTextSpaceToUserSpace(float f) {
        return new LineSegment(new Vector(0.0f, 0.0f, 1.0f), new Vector(f, 0.0f, 1.0f)).transformBy(this.textToUserSpaceTransformMatrix).getLength();
    }

    private String decode(PdfString arrby) {
        arrby = arrby.getBytes();
        return this.gs.font.decode(arrby, 0, arrby.length);
    }

    private int getCharCode(String arrby) {
        arrby = arrby.getBytes("UTF-16BE");
        int n = 0;
        int n2 = 0;
        do {
            if (n >= arrby.length - 1) break;
            n2 = n2 + (arrby[n] & 255) << 8;
            ++n;
        } while (true);
        n = n2;
        try {
            if (arrby.length > 0) {
                n = arrby[arrby.length - 1];
                n = n2 + (n & 255);
            }
            return n;
        }
        catch (UnsupportedEncodingException unsupportedEncodingException) {
            return 0;
        }
    }

    private float getPdfStringWidth(PdfString arrobject, boolean bl) {
        if (bl) {
            arrobject = this.getWidthAndWordSpacing((PdfString)arrobject, bl);
            return (arrobject[0] * this.gs.fontSize + this.gs.characterSpacing + arrobject[1]) * this.gs.horizontalScaling;
        }
        float f = 0.0f;
        arrobject = this.splitString((PdfString)arrobject);
        int n = arrobject.length;
        for (int i = 0; i < n; ++i) {
            f += this.getPdfStringWidth((PdfString)arrobject[i], true);
        }
        return f;
    }

    private float getStringWidth(String string2) {
        float f = 0.0f;
        for (int i = 0; i < string2.length(); ++i) {
            char c = string2.charAt(i);
            float f2 = (float)this.gs.font.getWidth(c) / 1000.0f;
            float f3 = c == ' ' ? this.gs.wordSpacing : 0.0f;
            f += (f2 * this.gs.fontSize + this.gs.characterSpacing + f3) * this.gs.horizontalScaling;
        }
        return f;
    }

    private LineSegment getUnscaledBaselineWithOffset(float f) {
        String string2 = this.string.toUnicodeString();
        float f2 = this.getUnscaledWidth();
        float f3 = this.gs.characterSpacing;
        float f4 = string2.length() > 0 && string2.charAt(string2.length() - 1) == ' ' ? this.gs.wordSpacing : 0.0f;
        float f5 = this.gs.horizontalScaling;
        return new LineSegment(new Vector(0.0f, f, 1.0f), new Vector(f2 - (f3 + f4) * f5, f, 1.0f));
    }

    private float getUnscaledFontSpaceWidth() {
        CMapAwareDocumentFont cMapAwareDocumentFont = this.gs.font;
        char c = ' ';
        if (cMapAwareDocumentFont.getWidth(32) == 0) {
            c = '\u00a0';
        }
        return this.getStringWidth(String.valueOf(c));
    }

    private float[] getWidthAndWordSpacing(PdfString object, boolean bl) {
        if (!bl) {
            throw new UnsupportedOperationException();
        }
        object = this.decode((PdfString)object);
        float f = (float)((double)this.gs.font.getWidth(this.getCharCode((String)object)) * this.fontMatrix[0]);
        float f2 = object.equals(" ") ? this.gs.wordSpacing : 0.0f;
        return new float[]{f, f2};
    }

    private PdfString[] splitString(PdfString pdfString) {
        ArrayList<PdfString> arrayList = new ArrayList<PdfString>();
        String string2 = pdfString.toString();
        int n = 0;
        while (n < string2.length()) {
            int n2 = n + 1;
            PdfString pdfString2 = new PdfString(string2.substring(n, n2), pdfString.getEncoding());
            int n3 = n;
            PdfString pdfString3 = pdfString2;
            if (this.decode(pdfString2).length() == 0) {
                n3 = n;
                pdfString3 = pdfString2;
                if (n < string2.length() - 1) {
                    pdfString3 = new PdfString(string2.substring(n, n + 2), pdfString.getEncoding());
                    n3 = n2;
                }
            }
            arrayList.add(pdfString3);
            n = n3 + 1;
        }
        return arrayList.toArray(new PdfString[arrayList.size()]);
    }

    public LineSegment getAscentLine() {
        return this.getUnscaledBaselineWithOffset(this.gs.getFont().getFontDescriptor(1, this.gs.getFontSize()) + this.gs.rise).transformBy(this.textToUserSpaceTransformMatrix);
    }

    public LineSegment getBaseline() {
        return this.getUnscaledBaselineWithOffset(this.gs.rise + 0.0f).transformBy(this.textToUserSpaceTransformMatrix);
    }

    public List<TextRenderInfo> getCharacterRenderInfos() {
        ArrayList<TextRenderInfo> arrayList = new ArrayList<TextRenderInfo>(this.string.length());
        Object object = this.splitString(this.string);
        float f = 0.0f;
        for (int i = 0; i < ((PdfString[])object).length; ++i) {
            float[] arrf = this.getWidthAndWordSpacing(object[i], true);
            arrayList.add(new TextRenderInfo(this, (PdfString)object[i], f));
            f += (arrf[0] * this.gs.fontSize + this.gs.characterSpacing + arrf[1]) * this.gs.horizontalScaling;
        }
        object = arrayList.iterator();
        while (object.hasNext()) {
            ((TextRenderInfo)object.next()).getUnscaledWidth();
        }
        return arrayList;
    }

    public LineSegment getDescentLine() {
        return this.getUnscaledBaselineWithOffset(this.gs.getFont().getFontDescriptor(3, this.gs.getFontSize()) + this.gs.rise).transformBy(this.textToUserSpaceTransformMatrix);
    }

    public BaseColor getFillColor() {
        return this.gs.fillColor;
    }

    public DocumentFont getFont() {
        return this.gs.getFont();
    }

    public Integer getMcid() {
        boolean bl = this.markedContentInfos instanceof ArrayList;
        Integer n = null;
        if (bl) {
            Object object = (ArrayList)this.markedContentInfos;
            object = object.size() > 0 ? (MarkedContentInfo)object.get(object.size() - 1) : null;
            Integer n2 = n;
            if (object != null) {
                n2 = n;
                if (object.hasMcid()) {
                    n2 = object.getMcid();
                }
            }
            return n2;
        }
        return null;
    }

    public PdfString getPdfString() {
        return this.string;
    }

    public float getRise() {
        if (this.gs.rise == 0.0f) {
            return 0.0f;
        }
        return this.convertHeightFromTextSpaceToUserSpace(this.gs.rise);
    }

    public float getSingleSpaceWidth() {
        return this.convertWidthFromTextSpaceToUserSpace(this.getUnscaledFontSpaceWidth());
    }

    public BaseColor getStrokeColor() {
        return this.gs.strokeColor;
    }

    public String getText() {
        if (this.text == null) {
            this.text = this.decode(this.string);
        }
        return this.text;
    }

    public int getTextRenderMode() {
        return this.gs.renderMode;
    }

    public LineSegment getUnscaledBaseline() {
        return this.getUnscaledBaselineWithOffset(this.gs.rise + 0.0f);
    }

    float getUnscaledWidth() {
        if (this.unscaledWidth == null) {
            this.unscaledWidth = Float.valueOf(this.getPdfStringWidth(this.string, false));
        }
        return this.unscaledWidth.floatValue();
    }

    public boolean hasMcid(int n) {
        return this.hasMcid(n, false);
    }

    public boolean hasMcid(int n, boolean bl) {
        boolean bl2 = false;
        if (bl) {
            if (this.markedContentInfos instanceof ArrayList) {
                Integer n2 = this.getMcid();
                bl = bl2;
                if (n2 != null) {
                    bl = bl2;
                    if (n2 == n) {
                        bl = true;
                    }
                }
                return bl;
            }
        } else {
            for (MarkedContentInfo markedContentInfo : this.markedContentInfos) {
                if (!markedContentInfo.hasMcid() || markedContentInfo.getMcid() != n) continue;
                return true;
            }
        }
        return false;
    }
}

