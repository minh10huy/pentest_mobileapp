/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Point;
import com.itextpdf.text.pdf.parser.clipper.PolyNode;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

public class Path
extends ArrayList<Point.LongPoint> {
    private static final long serialVersionUID = -7120161578077546673L;

    public Path() {
    }

    public Path(int n) {
        super(n);
    }

    public Path(Collection<? extends Point.LongPoint> collection) {
        super(collection);
    }

    public Path(Point.LongPoint[] arrlongPoint) {
        this();
        int n = arrlongPoint.length;
        for (int i = 0; i < n; ++i) {
            this.add(arrlongPoint[i]);
        }
    }

    private static OutPt excludeOp(OutPt outPt) {
        OutPt outPt2 = outPt.prev;
        outPt2.next = outPt.next;
        outPt.next.prev = outPt2;
        outPt2.idx = 0;
        return outPt2;
    }

    public Path TranslatePath(Point.LongPoint longPoint) {
        Path path = new Path(this.size());
        for (int i = 0; i < this.size(); ++i) {
            path.add(new Point.LongPoint(((Point.LongPoint)this.get(i)).getX() + longPoint.getX(), ((Point.LongPoint)this.get(i)).getY() + longPoint.getY()));
        }
        return path;
    }

    public double area() {
        int n = this.size();
        double d = 0.0;
        if (n < 3) {
            return 0.0;
        }
        int n2 = n - 1;
        int n3 = 0;
        while (n3 < n) {
            d += ((double)((Point.LongPoint)this.get(n2)).getX() + (double)((Point.LongPoint)this.get(n3)).getX()) * ((double)((Point.LongPoint)this.get(n2)).getY() - (double)((Point.LongPoint)this.get(n3)).getY());
            int n4 = n3 + 1;
            n2 = n3;
            n3 = n4;
        }
        return (- d) * 0.5;
    }

    public Path cleanPolygon() {
        return this.cleanPolygon(1.415);
    }

    public Path cleanPolygon(double d) {
        int n;
        Object object;
        int n2 = this.size();
        if (n2 == 0) {
            return new Path();
        }
        Object object2 = new OutPt[n2];
        int n3 = 0;
        for (n = 0; n < n2; ++n) {
            object2[n] = new OutPt();
        }
        n = 0;
        while (n < n2) {
            object2[n].pt = (Point.LongPoint)this.get(n);
            object = object2[n];
            int n4 = n + 1;
            object.next = object2[n4 % n2];
            object2[n].next.prev = object2[n];
            object2[n].idx = 0;
            n = n4;
        }
        d *= d;
        object2 = object2[0];
        n = n2;
        while (object2.idx == 0 && object2.next != object2.prev) {
            if (Point.arePointsClose(object2.pt, object2.prev.pt, d)) {
                object2 = Path.excludeOp((OutPt)object2);
                --n;
                continue;
            }
            if (Point.arePointsClose(object2.prev.pt, object2.next.pt, d)) {
                Path.excludeOp(object2.next);
                object2 = Path.excludeOp((OutPt)object2);
                n -= 2;
                continue;
            }
            if (Point.slopesNearCollinear(object2.prev.pt, object2.pt, object2.next.pt, d)) {
                object2 = Path.excludeOp((OutPt)object2);
                --n;
                continue;
            }
            object2.idx = 1;
            object2 = object2.next;
        }
        n2 = n;
        if (n < 3) {
            n2 = 0;
        }
        object = new Path(n2);
        for (n = n3; n < n2; ++n) {
            object.add(object2.pt);
            object2 = object2.next;
        }
        return object;
    }

    /*
     * Enabled aggressive block sorting
     */
    public int isPointInPolygon(Point.LongPoint longPoint) {
        int n = this.size();
        if (n < 3) {
            return 0;
        }
        Object object = (Point.LongPoint)this.get(0);
        int n2 = 1;
        int n3 = 0;
        do {
            int n4;
            int n5;
            Object object2;
            block17 : {
                block18 : {
                    if (n2 > n) {
                        return n3;
                    }
                    object2 = n2 == n ? this.get(0) : this.get(n2);
                    object2 = (Point.LongPoint)object2;
                    if (object2.getY() != longPoint.getY()) break block17;
                    if (object2.getX() == longPoint.getX()) break block18;
                    if (object.getY() != longPoint.getY()) break block17;
                    n5 = object2.getX() > longPoint.getX() ? 1 : 0;
                    if (object.getX() >= longPoint.getX()) return -1;
                    n4 = 1;
                    if (n5 != n4) break block17;
                }
                return -1;
            }
            n5 = object.getY() < longPoint.getY() ? 1 : 0;
            n4 = object2.getY() < longPoint.getY() ? 1 : 0;
            if (n5 != n4) {
                double d;
                if (object.getX() >= longPoint.getX()) {
                    if (object2.getX() > longPoint.getX()) {
                        n3 = 1 - n3;
                    } else {
                        d = object.getX() - longPoint.getX();
                        long l = object2.getY();
                        long l2 = longPoint.getY();
                        n5 = n3;
                        if ((d = d * (double)(l - l2) - (double)(object2.getX() - longPoint.getX()) * (double)(object.getY() - longPoint.getY())) == 0.0) {
                            return -1;
                        }
                        n4 = d > 0.0 ? 1 : 0;
                        int n6 = object2.getY() > object.getY() ? 1 : 0;
                        n3 = n5;
                        if (n4 == n6) {
                            n3 = 1 - n5;
                        }
                    }
                } else if (object2.getX() > longPoint.getX()) {
                    d = (double)(object.getX() - longPoint.getX()) * (double)(object2.getY() - longPoint.getY()) - (double)(object2.getX() - longPoint.getX()) * (double)(object.getY() - longPoint.getY());
                    if (d == 0.0) {
                        return -1;
                    }
                    n5 = d > 0.0 ? 1 : 0;
                    n4 = object2.getY() > object.getY() ? 1 : 0;
                    if (n5 == n4) {
                        n3 = 1 - n3;
                    }
                }
            }
            ++n2;
            object = object2;
        } while (true);
    }

    public boolean orientation() {
        if (this.area() >= 0.0) {
            return true;
        }
        return false;
    }

    public void reverse() {
        Collections.reverse(this);
    }

    static class Join {
        private Point.LongPoint offPt;
        OutPt outPt1;
        OutPt outPt2;

        Join() {
        }

        public Point.LongPoint getOffPt() {
            return this.offPt;
        }

        public void setOffPt(Point.LongPoint longPoint) {
            this.offPt = longPoint;
        }
    }

    protected static class Maxima {
        protected Maxima Next;
        protected Maxima Prev;
        protected long X;

        protected Maxima() {
        }
    }

    static class OutPt {
        int idx;
        OutPt next;
        OutPt prev;
        protected Point.LongPoint pt;

        OutPt() {
        }

        public static OutRec getLowerMostRec(OutRec outRec, OutRec outRec2) {
            if (outRec.bottomPt == null) {
                outRec.bottomPt = outRec.pts.getBottomPt();
            }
            if (outRec2.bottomPt == null) {
                outRec2.bottomPt = outRec2.pts.getBottomPt();
            }
            OutPt outPt = outRec.bottomPt;
            OutPt outPt2 = outRec2.bottomPt;
            if (outPt.getPt().getY() > outPt2.getPt().getY()) {
                return outRec;
            }
            if (outPt.getPt().getY() < outPt2.getPt().getY()) {
                return outRec2;
            }
            if (outPt.getPt().getX() < outPt2.getPt().getX()) {
                return outRec;
            }
            if (outPt.getPt().getX() > outPt2.getPt().getX()) {
                return outRec2;
            }
            if (outPt.next == outPt) {
                return outRec2;
            }
            if (outPt2.next == outPt2) {
                return outRec;
            }
            if (OutPt.isFirstBottomPt(outPt, outPt2)) {
                return outRec;
            }
            return outRec2;
        }

        private static boolean isFirstBottomPt(OutPt outPt, OutPt outPt2) {
            OutPt outPt3 = outPt.prev;
            while (outPt3.getPt().equals(outPt.getPt()) && !outPt3.equals(outPt)) {
                outPt3 = outPt3.prev;
            }
            double d = Math.abs(Point.LongPoint.getDeltaX(outPt.getPt(), outPt3.getPt()));
            outPt3 = outPt.next;
            while (outPt3.getPt().equals(outPt.getPt()) && !outPt3.equals(outPt)) {
                outPt3 = outPt3.next;
            }
            double d2 = Math.abs(Point.LongPoint.getDeltaX(outPt.getPt(), outPt3.getPt()));
            outPt = outPt2.prev;
            while (outPt.getPt().equals(outPt2.getPt()) && !outPt.equals(outPt2)) {
                outPt = outPt.prev;
            }
            double d3 = Math.abs(Point.LongPoint.getDeltaX(outPt2.getPt(), outPt.getPt()));
            outPt = outPt2.next;
            while (outPt.getPt().equals(outPt2.getPt()) && outPt.equals(outPt2)) {
                outPt = outPt.next;
            }
            double d4 = Math.abs(Point.LongPoint.getDeltaX(outPt2.getPt(), outPt.getPt()));
            if (d >= d3 && d >= d4 || d2 >= d3 && d2 >= d4) {
                return true;
            }
            return false;
        }

        public OutPt duplicate(boolean bl) {
            OutPt outPt = new OutPt();
            outPt.setPt(new Point.LongPoint(this.getPt()));
            outPt.idx = this.idx;
            if (bl) {
                outPt.next = this.next;
                outPt.prev = this;
                this.next.prev = outPt;
                this.next = outPt;
                return outPt;
            }
            outPt.prev = this.prev;
            outPt.next = this;
            this.prev.next = outPt;
            this.prev = outPt;
            return outPt;
        }

        /*
         * Unable to fully structure code
         * Enabled force condition propagation
         * Lifted jumps to return sites
         */
        OutPt getBottomPt() {
            var1_1 = this.next;
            var2_2 = this;
            var3_3 = null;
            while (var1_1 != var2_2) {
                if (var1_1.getPt().getY() > var2_2.getPt().getY()) {
                    do {
                        var5_5 = var1_1;
                        var4_4 = null;
                        break;
                    } while (true);
                } else {
                    var5_5 = var2_2;
                    var4_4 = var3_3;
                    if (var1_1.getPt().getY() == var2_2.getPt().getY()) {
                        var5_5 = var2_2;
                        var4_4 = var3_3;
                        if (var1_1.getPt().getX() <= var2_2.getPt().getX()) {
                            if (var1_1.getPt().getX() < var2_2.getPt().getX()) ** continue;
                            var5_5 = var2_2;
                            var4_4 = var3_3;
                            if (var1_1.next != var2_2) {
                                var5_5 = var2_2;
                                var4_4 = var3_3;
                                if (var1_1.prev != var2_2) {
                                    var4_4 = var1_1;
                                    var5_5 = var2_2;
                                }
                            }
                        }
                    }
                }
                var1_1 = var1_1.next;
                var2_2 = var5_5;
                var3_3 = var4_4;
            }
            var4_4 = var2_2;
            if (var3_3 == null) return var4_4;
            block2 : do {
                var4_4 = var2_2;
                if (var3_3 == var1_1) return var4_4;
                var5_5 = var2_2;
                if (!OutPt.isFirstBottomPt(var1_1, var3_3)) {
                    var5_5 = var3_3;
                }
                var4_4 = var3_3.next;
                do {
                    var2_2 = var5_5;
                    var3_3 = var4_4;
                    if (var4_4.getPt().equals(var5_5.getPt())) continue block2;
                    var4_4 = var4_4.next;
                } while (true);
                break;
            } while (true);
        }

        public int getPointCount() {
            OutPt outPt;
            int n;
            int n2 = 0;
            OutPt outPt2 = this;
            do {
                n = n2 + 1;
                outPt = outPt2.next;
                if (outPt == this) break;
                n2 = n;
                outPt2 = outPt;
            } while (outPt != null);
            return n;
        }

        public Point.LongPoint getPt() {
            return this.pt;
        }

        public void reversePolyPtLinks() {
            OutPt outPt = this;
            do {
                OutPt outPt2 = outPt.next;
                outPt.next = outPt.prev;
                outPt.prev = outPt2;
                if (outPt2 == this) {
                    return;
                }
                outPt = outPt2;
            } while (true);
        }

        public void setPt(Point.LongPoint longPoint) {
            this.pt = longPoint;
        }
    }

    static class OutRec {
        int Idx;
        OutPt bottomPt;
        OutRec firstLeft;
        boolean isHole;
        boolean isOpen;
        PolyNode polyNode;
        protected OutPt pts;

        OutRec() {
        }

        public double area() {
            double d;
            OutPt outPt = this.pts;
            double d2 = 0.0;
            OutPt outPt2 = outPt;
            if (outPt == null) {
                return 0.0;
            }
            do {
                d = d2 + (double)(outPt2.prev.getPt().getX() + outPt2.getPt().getX()) * (double)(outPt2.prev.getPt().getY() - outPt2.getPt().getY());
                outPt2 = outPt = outPt2.next;
                d2 = d;
            } while (outPt != this.pts);
            return d * 0.5;
        }

        public void fixHoleLinkage() {
            if (this.firstLeft != null) {
                if (this.isHole != this.firstLeft.isHole && this.firstLeft.pts != null) {
                    return;
                }
                OutRec outRec = this.firstLeft;
                while (outRec != null && (outRec.isHole == this.isHole || outRec.pts == null)) {
                    outRec = outRec.firstLeft;
                }
                this.firstLeft = outRec;
                return;
            }
        }

        public OutPt getPoints() {
            return this.pts;
        }

        public void setPoints(OutPt outPt) {
            this.pts = outPt;
        }
    }

}

