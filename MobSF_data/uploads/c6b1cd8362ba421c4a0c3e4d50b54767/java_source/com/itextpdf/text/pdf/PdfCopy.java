/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocListener;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.BadPasswordException;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.BadPdfFormatException;
import com.itextpdf.text.pdf.BaseField;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PageResources;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfAppearance;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfContents;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfDocument;
import com.itextpdf.text.pdf.PdfException;
import com.itextpdf.text.pdf.PdfFormField;
import com.itextpdf.text.pdf.PdfImportedPage;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNull;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfOutline;
import com.itextpdf.text.pdf.PdfPage;
import com.itextpdf.text.pdf.PdfPageEvent;
import com.itextpdf.text.pdf.PdfPages;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfReaderInstance;
import com.itextpdf.text.pdf.PdfRectangle;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfStructTreeController;
import com.itextpdf.text.pdf.PdfStructureTreeRoot;
import com.itextpdf.text.pdf.PdfTemplate;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RefKey;
import com.itextpdf.text.pdf.TextField;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.TreeSet;

public class PdfCopy
extends PdfWriter {
    protected static Counter COUNTER;
    private static final Logger LOGGER;
    private static final PdfName annotId;
    private static int annotIdCnt;
    protected static final HashSet<PdfName> fieldKeys;
    private static final PdfName iTextTag;
    protected static final HashSet<PdfName> widgetKeys;
    private static final Integer zero;
    private PdfIndirectReference acroForm;
    private ArrayList<String> calculationOrder;
    private ArrayList<Object> calculationOrderRefs;
    private int currentStructArrayNumber = 0;
    protected HashSet<PdfObject> disableIndirects;
    protected PdfArray fieldArray;
    protected HashSet<PdfTemplate> fieldTemplates;
    private HashMap<String, Object> fieldTree;
    protected ArrayList<AcroFields> fields;
    private boolean hasSignature;
    protected ArrayList<ImportedPage> importedPages;
    protected HashMap<PdfReader, HashMap<RefKey, IndirectReferences>> indirectMap;
    protected LinkedHashMap<RefKey, PdfIndirectObject> indirectObjects;
    protected HashMap<RefKey, IndirectReferences> indirects;
    protected boolean mergeFields = false;
    private boolean mergeFieldsInternalCall = false;
    private HashMap<Integer, PdfIndirectObject> mergedMap;
    private HashSet<Object> mergedRadioButtons = new HashSet();
    private HashSet<PdfIndirectObject> mergedSet;
    private HashMap<Object, PdfString> mergedTextFields = new HashMap();
    protected int[] namePtr = new int[]{0};
    private boolean needAppearances = false;
    protected HashMap<PdfObject, PdfObject> parentObjects;
    protected PdfReader reader;
    private HashSet<PdfReader> readersWithImportedStructureTreeRootKids = new HashSet();
    private PdfDictionary resources;
    private boolean rotateContents = true;
    protected ArrayList<PdfIndirectObject> savedObjects;
    private PdfStructTreeController structTreeController = null;
    protected PRIndirectReference structTreeRootReference;
    private HashMap<PdfArray, ArrayList<Integer>> tabOrder;
    private HashMap<RefKey, PdfIndirectObject> unmergedIndirectRefsMap;
    private HashMap<Integer, PdfIndirectObject> unmergedMap;
    protected boolean updateRootKids = false;

    static {
        LOGGER = LoggerFactory.getLogger(PdfCopy.class);
        COUNTER = CounterFactory.getCounter(PdfCopy.class);
        annotId = new PdfName("iTextAnnotId");
        iTextTag = new PdfName("_iTextTag_");
        zero = 0;
        widgetKeys = new HashSet();
        fieldKeys = new HashSet();
        widgetKeys.add(PdfName.SUBTYPE);
        widgetKeys.add(PdfName.CONTENTS);
        widgetKeys.add(PdfName.RECT);
        widgetKeys.add(PdfName.NM);
        widgetKeys.add(PdfName.M);
        widgetKeys.add(PdfName.F);
        widgetKeys.add(PdfName.BS);
        widgetKeys.add(PdfName.BORDER);
        widgetKeys.add(PdfName.AP);
        widgetKeys.add(PdfName.AS);
        widgetKeys.add(PdfName.C);
        widgetKeys.add(PdfName.A);
        widgetKeys.add(PdfName.STRUCTPARENT);
        widgetKeys.add(PdfName.OC);
        widgetKeys.add(PdfName.H);
        widgetKeys.add(PdfName.MK);
        widgetKeys.add(PdfName.DA);
        widgetKeys.add(PdfName.Q);
        widgetKeys.add(PdfName.P);
        widgetKeys.add(PdfName.TYPE);
        widgetKeys.add(annotId);
        fieldKeys.add(PdfName.AA);
        fieldKeys.add(PdfName.FT);
        fieldKeys.add(PdfName.TU);
        fieldKeys.add(PdfName.TM);
        fieldKeys.add(PdfName.FF);
        fieldKeys.add(PdfName.V);
        fieldKeys.add(PdfName.DV);
        fieldKeys.add(PdfName.DS);
        fieldKeys.add(PdfName.RV);
        fieldKeys.add(PdfName.OPT);
        fieldKeys.add(PdfName.MAXLEN);
        fieldKeys.add(PdfName.TI);
        fieldKeys.add(PdfName.I);
        fieldKeys.add(PdfName.LOCK);
        fieldKeys.add(PdfName.SV);
    }

    public PdfCopy(Document document, OutputStream outputStream) throws DocumentException {
        super(new PdfDocument(), outputStream);
        document.addDocListener(this.pdf);
        this.pdf.addWriter(this);
        this.indirectMap = new HashMap();
        this.parentObjects = new HashMap();
        this.disableIndirects = new HashSet();
        this.indirectObjects = new LinkedHashMap();
        this.savedObjects = new ArrayList();
        this.importedPages = new ArrayList();
    }

    private void addFieldResources(PdfDictionary object) throws IOException {
        if (this.fieldArray == null) {
            return;
        }
        PdfDictionary pdfDictionary = new PdfDictionary();
        object.put(PdfName.ACROFORM, pdfDictionary);
        pdfDictionary.put(PdfName.FIELDS, this.fieldArray);
        pdfDictionary.put(PdfName.DA, new PdfString("/Helv 0 Tf 0 g "));
        if (this.fieldTemplates.isEmpty()) {
            return;
        }
        PdfDictionary pdfDictionary2 = new PdfDictionary();
        pdfDictionary.put(PdfName.DR, pdfDictionary2);
        object = this.fieldTemplates.iterator();
        while (object.hasNext()) {
            PdfFormField.mergeResources(pdfDictionary2, (PdfDictionary)((PdfTemplate)object.next()).getResources());
        }
        pdfDictionary = pdfDictionary2.getAsDict(PdfName.FONT);
        object = pdfDictionary;
        if (pdfDictionary == null) {
            object = new PdfDictionary();
            pdfDictionary2.put(PdfName.FONT, (PdfObject)object);
        }
        if (!object.contains(PdfName.HELV)) {
            pdfDictionary = new PdfDictionary(PdfName.FONT);
            pdfDictionary.put(PdfName.BASEFONT, PdfName.HELVETICA);
            pdfDictionary.put(PdfName.ENCODING, PdfName.WIN_ANSI_ENCODING);
            pdfDictionary.put(PdfName.NAME, PdfName.HELV);
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.TYPE1);
            object.put(PdfName.HELV, this.addToBody(pdfDictionary).getIndirectReference());
        }
        if (!object.contains(PdfName.ZADB)) {
            pdfDictionary = new PdfDictionary(PdfName.FONT);
            pdfDictionary.put(PdfName.BASEFONT, PdfName.ZAPFDINGBATS);
            pdfDictionary.put(PdfName.NAME, PdfName.ZADB);
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.TYPE1);
            object.put(PdfName.ZADB, this.addToBody(pdfDictionary).getIndirectReference());
        }
    }

    private void addPageOffsetToField(Map<String, AcroFields.Item> object, int n) {
        if (n == 0) {
            return;
        }
        for (AcroFields.Item item : object.values()) {
            for (int i = 0; i < item.size(); ++i) {
                item.forcePage(i, item.getPage(i) + n);
            }
        }
    }

    private void adjustTabOrder(PdfArray pdfArray, PdfIndirectReference pdfIndirectReference, PdfNumber serializable) {
        int n;
        int n2;
        int n3 = serializable.intValue();
        serializable = this.tabOrder.get(pdfArray);
        if (serializable == null) {
            serializable = new ArrayList();
            int n4 = pdfArray.size();
            for (n = 0; n < n4 - 1; ++n) {
                serializable.add(zero);
            }
            serializable.add(n3);
            this.tabOrder.put(pdfArray, (ArrayList<Integer>)serializable);
            pdfArray.add(pdfIndirectReference);
            return;
        }
        int n5 = n = serializable.size() - 1;
        do {
            n2 = n;
            if (n5 < 0) break;
            if ((Integer)serializable.get(n5) <= n3) {
                n = n5 + 1;
                serializable.add(n, n3);
                pdfArray.add(n, pdfIndirectReference);
                n2 = -2;
                break;
            }
            --n5;
        } while (true);
        if (n2 != -2) {
            serializable.add(0, n3);
            pdfArray.add(0, pdfIndirectReference);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private PdfArray branchForm(HashMap<String, Object> var1_1, PdfIndirectReference var2_2, String var3_3) throws IOException, BadPdfFormatException {
        var8_4 = new PdfArray();
        var1_1 = var1_1.entrySet().iterator();
        block4 : do {
            block22 : {
                var6_7 = var2_2;
                if (var1_1.hasNext() == false) return var8_4;
                var9_11 = var1_1.next();
                var7_10 = (String)var9_11.getKey();
                var11_13 = var9_11.getValue();
                var9_11 = this.getPdfIndirectReference();
                var10_12 = new PdfDictionary();
                if (var6_7 != null) {
                    var10_12.put(PdfName.PARENT, (PdfObject)var6_7);
                }
                var10_12.put(PdfName.T, new PdfString((String)var7_10, "UnicodeBig"));
                var6_7 = new StringBuilder();
                var6_7.append(var3_3);
                var6_7.append(".");
                var6_7.append((String)var7_10);
                var6_7 = var6_7.toString();
                var4_5 = this.calculationOrder.indexOf(var6_7);
                if (var4_5 >= 0) {
                    this.calculationOrderRefs.set(var4_5, var9_11);
                }
                if (var11_13 instanceof HashMap) {
                    var10_12.put(PdfName.KIDS, this.branchForm((HashMap)var11_13, (PdfIndirectReference)var9_11, (String)var6_7));
                    var8_4.add((PdfObject)var9_11);
                    this.addToBody(var10_12, (PdfIndirectReference)var9_11, true);
                    continue;
                }
                var12_14 = (ArrayList)var11_13;
                var10_12.mergeDifferent((PdfDictionary)var12_14.get(0));
                if (var12_14.size() != 3) break block22;
                var10_12.mergeDifferent((PdfDictionary)var12_14.get(2));
                var4_5 = (Integer)var12_14.get(1);
                var6_7 = this.importedPages.get((int)(var4_5 - 1)).mergedFields;
                var7_10 = (PdfNumber)var10_12.get(PdfCopy.iTextTag);
                var10_12.remove(PdfCopy.iTextTag);
                var10_12.put(PdfName.TYPE, PdfName.ANNOT);
                this.adjustTabOrder((PdfArray)var6_7, (PdfIndirectReference)var9_11, (PdfNumber)var7_10);
                ** GOTO lbl97
            }
            var13_15 = (PdfDictionary)var12_14.get(0);
            var11_13 = new PdfArray();
            var4_5 = 1;
            do {
                block25 : {
                    block23 : {
                        block24 : {
                            block26 : {
                                if (var4_5 >= var12_14.size()) break block23;
                                var5_6 = (Integer)var12_14.get(var4_5);
                                var14_16 = this.importedPages.get((int)(var5_6 - 1)).mergedFields;
                                var16_18 = new PdfDictionary();
                                var16_18.merge((PdfDictionary)var12_14.get(var4_5 + 1));
                                var16_18.put(PdfName.PARENT, (PdfObject)var9_11);
                                var15_17 = (PdfNumber)var16_18.get(PdfCopy.iTextTag);
                                var16_18.remove(PdfCopy.iTextTag);
                                if (!PdfCopy.isTextField(var13_15)) break block24;
                                var6_7 = var13_15.getAsString(PdfName.V);
                                var17_19 = var16_18.getDirectObject(PdfName.AP);
                                if (var6_7 == null || var17_19 == null) break block25;
                                if (this.mergedTextFields.containsKey(var12_14)) break block26;
                                this.mergedTextFields.put(var12_14, (PdfString)var6_7);
                                break block25;
                            }
                            try {
                                var18_20 = new TextField(this, null, null);
                                var6_7 = this.fields;
                            }
                            catch (DocumentException var6_8) {}
                            try {
                                block28 : {
                                    block27 : {
                                        var6_7.get(0).decodeGenericDictionary(var16_18, var18_20);
                                        var7_10 = PdfReader.getNormalizedRectangle(var16_18.getAsArray(PdfName.RECT));
                                        if (var18_20.getRotation() == 90) break block27;
                                        var6_7 = var7_10;
                                        if (var18_20.getRotation() != 270) break block28;
                                    }
                                    var6_7 = var7_10.rotate();
                                }
                                var18_20.setBox((Rectangle)var6_7);
                                var18_20.setText(this.mergedTextFields.get(var12_14).toUnicodeString());
                                var6_7 = var18_20.getAppearance();
                                ((PdfDictionary)var17_19).put(PdfName.N, var6_7.getIndirectReference());
                            }
                            catch (DocumentException var6_9) {}
                        }
                        if (PdfCopy.isCheckButton(var13_15)) {
                            var6_7 = var13_15.getAsName(PdfName.V);
                            var7_10 = var16_18.getAsName(PdfName.AS);
                            if (var6_7 != null && var7_10 != null) {
                                var16_18.put(PdfName.AS, (PdfObject)var6_7);
                            }
                        } else if (PdfCopy.isRadioButton(var13_15)) {
                            var6_7 = var13_15.getAsName(PdfName.V);
                            var7_10 = var16_18.getAsName(PdfName.AS);
                            if (var6_7 != null && var7_10 != null && !var7_10.equals(this.getOffStateName(var16_18))) {
                                if (!this.mergedRadioButtons.contains(var12_14)) {
                                    this.mergedRadioButtons.add(var12_14);
                                    var16_18.put(PdfName.AS, (PdfObject)var6_7);
                                } else {
                                    var16_18.put(PdfName.AS, this.getOffStateName(var16_18));
                                }
                            }
                        }
                        break block25;
                    }
                    var10_12.put(PdfName.KIDS, (PdfObject)var11_13);
lbl97: // 2 sources:
                    var8_4.add((PdfObject)var9_11);
                    this.addToBody(var10_12, (PdfIndirectReference)var9_11, true);
                    continue block4;
                }
                var16_18.put(PdfName.TYPE, PdfName.ANNOT);
                var6_7 = this.addToBody(var16_18, this.getPdfIndirectReference(), true).getIndirectReference();
                this.adjustTabOrder(var14_16, (PdfIndirectReference)var6_7, var15_17);
                var11_13.add((PdfObject)var6_7);
                var4_5 += 2;
            } while (true);
            break;
        } while (true);
    }

    private int checkStructureTreeRootKids(ImportedPage importedPage) {
        boolean bl;
        Object object;
        block5 : {
            if (this.importedPages.size() == 0) {
                return 1;
            }
            object = this.importedPages.iterator();
            while (object.hasNext()) {
                if (!object.next().reader.equals(importedPage.reader)) continue;
                bl = true;
                break block5;
            }
            bl = false;
        }
        if (!bl) {
            return 1;
        }
        object = this.importedPages.get(this.importedPages.size() - 1);
        if (object.reader.equals(importedPage.reader) && importedPage.pageNumber > object.pageNumber) {
            if (this.readersWithImportedStructureTreeRootKids.contains(importedPage.reader)) {
                return 0;
            }
            return 1;
        }
        return -1;
    }

    private void clearIndirects(PdfReader object) {
        object = this.indirectMap.get(object);
        Object object2 = new ArrayList();
        for (Map.Entry entry : object.entrySet()) {
            Object object3 = new RefKey(((IndirectReferences)entry.getValue()).theRef);
            if ((object3 = this.indirectObjects.get(object3)) == null) {
                object2.add(entry.getKey());
                continue;
            }
            if (!object3.object.isArray() && !object3.object.isDictionary() && !object3.object.isStream()) continue;
            object2.add(entry.getKey());
        }
        object2 = object2.iterator();
        while (object2.hasNext()) {
            object.remove((RefKey)object2.next());
        }
    }

    private boolean containsInactivePg(PdfDictionary pdfObject, HashSet<RefKey> hashSet) {
        if ((pdfObject = pdfObject.get(PdfName.PG)) != null && !hashSet.contains(new RefKey((PdfIndirectReference)pdfObject))) {
            return true;
        }
        return false;
    }

    private void createAcroForms() throws IOException, BadPdfFormatException {
        if (this.fieldTree.isEmpty()) {
            for (ImportedPage importedPage : this.importedPages) {
                if (importedPage.mergedFields.size() <= 0) continue;
                this.addToBody(importedPage.mergedFields, importedPage.annotsIndirectReference);
            }
            return;
        }
        PdfDictionary pdfDictionary = new PdfDictionary();
        pdfDictionary.put(PdfName.DR, this.propagate(this.resources));
        if (this.needAppearances) {
            pdfDictionary.put(PdfName.NEEDAPPEARANCES, PdfBoolean.PDFTRUE);
        }
        pdfDictionary.put(PdfName.DA, new PdfString("/Helv 0 Tf 0 g "));
        this.tabOrder = new HashMap();
        this.calculationOrderRefs = new ArrayList<String>(this.calculationOrder);
        pdfDictionary.put(PdfName.FIELDS, this.branchForm(this.fieldTree, null, ""));
        if (this.hasSignature) {
            pdfDictionary.put(PdfName.SIGFLAGS, new PdfNumber(3));
        }
        PdfArray object3 = new PdfArray();
        for (int i = 0; i < this.calculationOrderRefs.size(); ++i) {
            Object object = this.calculationOrderRefs.get(i);
            if (!(object instanceof PdfIndirectReference)) continue;
            object3.add((PdfIndirectReference)object);
        }
        if (object3.size() > 0) {
            pdfDictionary.put(PdfName.CO, object3);
        }
        this.acroForm = this.addToBody(pdfDictionary).getIndirectReference();
        for (ImportedPage importedPage : this.importedPages) {
            this.addToBody(importedPage.mergedFields, importedPage.annotsIndirectReference);
        }
    }

    private void createWidgets(ArrayList<Object> arrayList, AcroFields.Item item) {
        for (int i = 0; i < item.size(); ++i) {
            arrayList.add(item.getPage(i));
            PdfDictionary pdfDictionary = item.getMerged(i);
            PdfObject pdfObject = pdfDictionary.get(PdfName.DR);
            if (pdfObject != null) {
                PdfFormField.mergeResources(this.resources, (PdfDictionary)PdfReader.getPdfObject(pdfObject));
            }
            pdfObject = new PdfDictionary();
            for (PdfName pdfName : pdfDictionary.getKeys()) {
                if (!widgetKeys.contains(pdfName)) continue;
                pdfObject.put(pdfName, pdfDictionary.get(pdfName));
            }
            pdfObject.put(iTextTag, new PdfNumber(item.getTabOrder(i) + 1));
            arrayList.add(pdfObject);
        }
    }

    private ArrayList<PdfIndirectReference> findActiveParents(HashSet<RefKey> hashSet) {
        ArrayList<PdfIndirectReference> arrayList = new ArrayList<PdfIndirectReference>();
        ArrayList<RefKey> arrayList2 = new ArrayList<RefKey>(hashSet);
        for (int i = 0; i < arrayList2.size(); ++i) {
            Object object = this.indirectObjects.get(arrayList2.get(i));
            if (object == null || !object.object.isDictionary() || (object = ((PdfDictionary)object.object).get(PdfName.P)) == null || object.type() != 0) continue;
            PdfIndirectReference pdfIndirectReference = (PdfIndirectReference)object;
            object = new RefKey(pdfIndirectReference);
            if (hashSet.contains(object)) continue;
            hashSet.add((RefKey)object);
            arrayList2.add((RefKey)object);
            arrayList.add(pdfIndirectReference);
        }
        return arrayList;
    }

    private void findActives(ArrayList<PdfIndirectReference> arrayList, HashSet<RefKey> hashSet, HashSet<PdfName> hashSet2) {
        for (int i = 0; i < arrayList.size(); ++i) {
            Object object = new RefKey(arrayList.get(i));
            if ((object = this.indirectObjects.get(object)) == null || object.object == null) continue;
            int n = object.object.type();
            if (n != 0) {
                switch (n) {
                    default: {
                        break;
                    }
                    case 6: 
                    case 7: {
                        this.findActivesFromDict((PdfDictionary)object.object, arrayList, hashSet, hashSet2);
                        break;
                    }
                    case 5: {
                        this.findActivesFromArray((PdfArray)object.object, arrayList, hashSet, hashSet2);
                        break;
                    }
                }
                continue;
            }
            this.findActivesFromReference((PdfIndirectReference)object.object, arrayList, hashSet);
        }
    }

    private void findActivesFromArray(PdfArray object, ArrayList<PdfIndirectReference> arrayList, HashSet<RefKey> hashSet, HashSet<PdfName> hashSet2) {
        object = object.iterator();
        block4 : while (object.hasNext()) {
            PdfObject pdfObject = (PdfObject)object.next();
            int n = pdfObject.type();
            if (n != 0) {
                switch (n) {
                    default: {
                        continue block4;
                    }
                    case 6: 
                    case 7: {
                        this.findActivesFromDict((PdfDictionary)pdfObject, arrayList, hashSet, hashSet2);
                        continue block4;
                    }
                    case 5: 
                }
                this.findActivesFromArray((PdfArray)pdfObject, arrayList, hashSet, hashSet2);
                continue;
            }
            this.findActivesFromReference((PdfIndirectReference)pdfObject, arrayList, hashSet);
        }
    }

    private void findActivesFromDict(PdfDictionary pdfDictionary, ArrayList<PdfIndirectReference> arrayList, HashSet<RefKey> hashSet, HashSet<PdfName> hashSet2) {
        if (this.containsInactivePg(pdfDictionary, hashSet)) {
            return;
        }
        block4 : for (PdfName pdfName : pdfDictionary.getKeys()) {
            PdfObject pdfObject2 = pdfDictionary.get(pdfName);
            if (pdfName.equals(PdfName.P)) continue;
            if (pdfName.equals(PdfName.C)) {
                if (pdfObject2.isArray()) {
                    for (PdfObject pdfObject2 : (PdfArray)pdfObject2) {
                        if (!pdfObject2.isName()) continue;
                        hashSet2.add((PdfName)pdfObject2);
                    }
                    continue;
                }
                if (!pdfObject2.isName()) continue;
                hashSet2.add((PdfName)pdfObject2);
                continue;
            }
            int n = pdfObject2.type();
            if (n != 0) {
                switch (n) {
                    default: {
                        continue block4;
                    }
                    case 6: 
                    case 7: {
                        this.findActivesFromDict((PdfDictionary)pdfObject2, arrayList, hashSet, hashSet2);
                        continue block4;
                    }
                    case 5: 
                }
                this.findActivesFromArray((PdfArray)pdfObject2, arrayList, hashSet, hashSet2);
                continue;
            }
            this.findActivesFromReference((PdfIndirectReference)pdfObject2, arrayList, hashSet);
        }
    }

    private void findActivesFromReference(PdfIndirectReference pdfIndirectReference, ArrayList<PdfIndirectReference> arrayList, HashSet<RefKey> hashSet) {
        RefKey refKey = new RefKey(pdfIndirectReference);
        PdfIndirectObject pdfIndirectObject = this.indirectObjects.get(refKey);
        if (pdfIndirectObject != null && pdfIndirectObject.object.isDictionary() && this.containsInactivePg((PdfDictionary)pdfIndirectObject.object, hashSet)) {
            return;
        }
        if (!hashSet.contains(refKey)) {
            hashSet.add(refKey);
            arrayList.add(pdfIndirectReference);
        }
    }

    private void fixPgKey(ArrayList<PdfIndirectReference> object, HashSet<RefKey> hashSet) {
        object = object.iterator();
        block0 : while (object.hasNext()) {
            PdfObject pdfObject;
            Object object2 = (PdfIndirectReference)object.next();
            if ((object2 = this.indirectObjects.get(new RefKey((PdfIndirectReference)object2))) == null || !object2.object.isDictionary() || (pdfObject = (object2 = (PdfDictionary)object2.object).get(PdfName.PG)) == null || hashSet.contains(new RefKey((PdfIndirectReference)pdfObject)) || (pdfObject = object2.getAsArray(PdfName.K)) == null) continue;
            int n = 0;
            while (n < pdfObject.size()) {
                int n2;
                Object object3 = pdfObject.getPdfObject(n);
                if (object3.type() != 0) {
                    pdfObject.remove(n);
                    n2 = n - 1;
                } else {
                    object3 = this.indirectObjects.get(new RefKey((PdfIndirectReference)object3));
                    n2 = n;
                    if (object3 != null) {
                        n2 = n;
                        if (object3.object.isDictionary()) {
                            object3 = ((PdfDictionary)object3.object).get(PdfName.PG);
                            n2 = n;
                            if (object3 != null) {
                                n2 = n;
                                if (hashSet.contains(new RefKey((PdfIndirectReference)object3))) {
                                    object2.put(PdfName.PG, (PdfObject)object3);
                                    continue block0;
                                }
                            }
                        }
                    }
                }
                n = n2 + 1;
            }
        }
    }

    private static String getCOName(PdfReader object, PRIndirectReference object2) {
        object = "";
        while (object2 != null && (object2 = PdfReader.getPdfObject((PdfObject)object2)) != null && object2.type() == 6) {
            PdfObject pdfObject = (PdfDictionary)object2;
            PdfString pdfString = pdfObject.getAsString(PdfName.T);
            object2 = object;
            if (pdfString != null) {
                object2 = new StringBuilder();
                object2.append(pdfString.toUnicodeString());
                object2.append(".");
                object2.append((String)object);
                object2 = object2.toString();
            }
            pdfObject = (PRIndirectReference)pdfObject.get(PdfName.PARENT);
            object = object2;
            object2 = pdfObject;
        }
        object2 = object;
        if (object.endsWith(".")) {
            object2 = object.substring(0, object.length() - 2);
        }
        return object2;
    }

    static Integer getFlags(PdfDictionary pdfObject) {
        PdfName pdfName = pdfObject.getAsName(PdfName.FT);
        if (!PdfName.BTN.equals(pdfName)) {
            return null;
        }
        if ((pdfObject = pdfObject.getAsNumber(PdfName.FF)) == null) {
            return null;
        }
        return pdfObject.intValue();
    }

    static boolean isCheckButton(PdfDictionary serializable) {
        if ((serializable = PdfCopy.getFlags((PdfDictionary)serializable)) != null && ((serializable.intValue() & 65536) != 0 || (serializable.intValue() & 32768) != 0)) {
            return false;
        }
        return true;
    }

    static boolean isRadioButton(PdfDictionary serializable) {
        if ((serializable = PdfCopy.getFlags((PdfDictionary)serializable)) != null && (serializable.intValue() & 65536) == 0 && (serializable.intValue() & 32768) != 0) {
            return true;
        }
        return false;
    }

    static boolean isTextField(PdfDictionary pdfObject) {
        pdfObject = pdfObject.getAsName(PdfName.FT);
        return PdfName.TX.equals(pdfObject);
    }

    private void mergeField(String serializable, AcroFields.Item item) {
        Object object;
        Object object2;
        Object object3;
        Serializable serializable2;
        block16 : {
            serializable2 = this.fieldTree;
            object2 = new StringTokenizer((String)((Object)serializable), ".");
            serializable = serializable2;
            if (!object2.hasMoreTokens()) {
                return;
            }
            do {
                object = object2.nextToken();
                object3 = serializable.get(object);
                if (!object2.hasMoreTokens()) break block16;
                if (object3 == null) {
                    serializable2 = new LinkedHashMap<String, Object>();
                    serializable.put(object, serializable2);
                    serializable = serializable2;
                    continue;
                }
                if (!(object3 instanceof HashMap)) break;
                serializable = (HashMap)object3;
            } while (true);
            return;
        }
        if (object3 instanceof HashMap) {
            return;
        }
        int n = 0;
        serializable2 = item.getMerged(0);
        if (object3 == null) {
            object2 = new PdfDictionary();
            if (PdfName.SIG.equals(serializable2.get(PdfName.FT))) {
                this.hasSignature = true;
            }
            for (PdfName pdfName : serializable2.getKeys()) {
                if (!fieldKeys.contains(pdfName)) continue;
                object2.put(pdfName, serializable2.get(pdfName));
            }
            serializable2 = new ArrayList();
            serializable2.add(object2);
            this.createWidgets((ArrayList<Object>)serializable2, item);
            serializable.put(object, serializable2);
            return;
        }
        serializable = (ArrayList)object3;
        object2 = (PdfDictionary)serializable.get(0);
        object = (PdfName)object2.get(PdfName.FT);
        object3 = (PdfName)serializable2.get(PdfName.FT);
        if (object != null) {
            if (!object.equals(object3)) {
                return;
            }
            int n2 = (object2 = object2.get(PdfName.FF)) != null && object2.isNumber() ? ((PdfNumber)object2).intValue() : 0;
            serializable2 = serializable2.get(PdfName.FF);
            int n3 = n;
            if (serializable2 != null) {
                n3 = n;
                if (serializable2.isNumber()) {
                    n3 = ((PdfNumber)serializable2).intValue();
                }
            }
            if (object.equals(PdfName.BTN)) {
                if (((n3 = n2 ^ n3) & 65536) != 0) {
                    return;
                }
                if ((n2 & 65536) == 0 && (32768 & n3) != 0) {
                    return;
                }
            } else if (object.equals(PdfName.CH) && ((n2 ^ n3) & 131072) != 0) {
                return;
            }
            this.createWidgets((ArrayList<Object>)serializable, item);
            return;
        }
    }

    private void mergeFields() {
        int n = 0;
        for (int i = 0; i < this.fields.size(); ++i) {
            AcroFields acroFields = this.fields.get(i);
            Map<String, AcroFields.Item> map = acroFields.getFields();
            int n2 = n;
            if (n < this.importedPages.size()) {
                n2 = n;
                if (this.importedPages.get((int)n).reader == acroFields.reader) {
                    this.addPageOffsetToField(map, n);
                    n2 = n + acroFields.reader.getNumberOfPages();
                }
            }
            this.mergeWithMaster(map);
            n = n2;
        }
    }

    private void mergeWithMaster(Map<String, AcroFields.Item> object) {
        for (Map.Entry entry : object.entrySet()) {
            this.mergeField((String)entry.getKey(), (AcroFields.Item)entry.getValue());
        }
    }

    private PdfObject propagate(PdfObject pdfObject) throws IOException {
        if (pdfObject == null) {
            return new PdfNull();
        }
        if (pdfObject.isArray()) {
            pdfObject = (PdfArray)pdfObject;
            for (int i = 0; i < pdfObject.size(); ++i) {
                pdfObject.set(i, this.propagate(pdfObject.getPdfObject(i)));
            }
            return pdfObject;
        }
        if (!pdfObject.isDictionary() && !pdfObject.isStream()) {
            if (pdfObject.isIndirect()) {
                return this.addToBody(this.propagate(PdfReader.getPdfObject(pdfObject))).getIndirectReference();
            }
            return pdfObject;
        }
        pdfObject = (PdfDictionary)pdfObject;
        for (PdfName pdfName : pdfObject.getKeys()) {
            pdfObject.put(pdfName, this.propagate(pdfObject.get(pdfName)));
        }
        return pdfObject;
    }

    private void removeInactiveReferences(PdfArray pdfArray, HashSet<RefKey> hashSet) {
        int n = 0;
        while (n < pdfArray.size()) {
            int n2;
            block4 : {
                block3 : {
                    PdfObject pdfObject = pdfArray.getPdfObject(n);
                    if (pdfObject.type() == 0 && !hashSet.contains(new RefKey((PdfIndirectReference)pdfObject))) break block3;
                    n2 = n;
                    if (!pdfObject.isDictionary()) break block4;
                    n2 = n;
                    if (!this.containsInactivePg((PdfDictionary)pdfObject, hashSet)) break block4;
                }
                pdfArray.remove(n);
                n2 = n - 1;
            }
            n = n2 + 1;
        }
    }

    private void updateAnnotationReferences(PdfObject pdfObject) {
        block5 : {
            block4 : {
                if (!pdfObject.isArray()) break block4;
                pdfObject = (PdfArray)pdfObject;
                for (int i = 0; i < pdfObject.size(); ++i) {
                    Object object = pdfObject.getPdfObject(i);
                    if (object != null && object.type() == 0) {
                        if ((object = this.unmergedIndirectRefsMap.get(new RefKey((PdfIndirectReference)object))) == null || !object.object.isDictionary() || (object = ((PdfDictionary)object.object).getAsNumber(annotId)) == null || (object = this.mergedMap.get(object.intValue())) == null) continue;
                        pdfObject.set(i, object.getIndirectReference());
                        continue;
                    }
                    this.updateAnnotationReferences((PdfObject)object);
                }
                break block5;
            }
            if (!pdfObject.isDictionary() && !pdfObject.isStream()) break block5;
            pdfObject = (PdfDictionary)pdfObject;
            for (PdfName pdfName : pdfObject.getKeys()) {
                Object object = pdfObject.get(pdfName);
                if (object != null && object.type() == 0) {
                    if ((object = this.unmergedIndirectRefsMap.get(new RefKey((PdfIndirectReference)object))) == null || !object.object.isDictionary() || (object = ((PdfDictionary)object.object).getAsNumber(annotId)) == null || (object = this.mergedMap.get(object.intValue())) == null) continue;
                    pdfObject.put(pdfName, object.getIndirectReference());
                    continue;
                }
                this.updateAnnotationReferences((PdfObject)object);
            }
        }
    }

    private void updateCalculationOrder(PdfReader pdfReader) {
        PdfObject pdfObject = pdfReader.getCatalog().getAsDict(PdfName.ACROFORM);
        if (pdfObject == null) {
            return;
        }
        if ((pdfObject = pdfObject.getAsArray(PdfName.CO)) != null) {
            if (pdfObject.size() == 0) {
                return;
            }
            AcroFields acroFields = pdfReader.getAcroFields();
            for (int i = 0; i < pdfObject.size(); ++i) {
                Object object = pdfObject.getPdfObject(i);
                if (object == null || !object.isIndirect() || acroFields.getFieldItem((String)(object = PdfCopy.getCOName(pdfReader, (PRIndirectReference)object))) == null) continue;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(".");
                stringBuilder.append((String)object);
                object = stringBuilder.toString();
                if (this.calculationOrder.contains(object)) continue;
                this.calculationOrder.add((String)object);
            }
            return;
        }
    }

    private void updateReferences(PdfObject pdfObject) {
        block5 : {
            block4 : {
                if (pdfObject.isDictionary() || pdfObject.isStream()) break block4;
                if (!pdfObject.isArray()) break block5;
                pdfObject = (PdfArray)pdfObject;
                for (int i = 0; i < pdfObject.size(); ++i) {
                    Object object = pdfObject.getPdfObject(i);
                    if (object.isIndirect()) {
                        object = (PRIndirectReference)object;
                        PdfReader pdfReader = object.getReader();
                        object = this.indirectMap.get(pdfReader).get(new RefKey((PRIndirectReference)object));
                        if (object == null) continue;
                        pdfObject.set(i, object.getRef());
                        continue;
                    }
                    this.updateReferences((PdfObject)object);
                }
                break block5;
            }
            pdfObject = (PdfDictionary)pdfObject;
            for (PdfName pdfName : pdfObject.getKeys()) {
                Object object = pdfObject.get(pdfName);
                if (object.isIndirect()) {
                    object = (PRIndirectReference)object;
                    PdfReader pdfReader = object.getReader();
                    object = this.indirectMap.get(pdfReader).get(new RefKey((PRIndirectReference)object));
                    if (object == null) continue;
                    pdfObject.put(pdfName, object.getRef());
                    continue;
                }
                this.updateReferences((PdfObject)object);
            }
        }
    }

    private void writeObjectToBody(PdfIndirectObject pdfIndirectObject) throws IOException {
        boolean bl;
        boolean bl2;
        PdfDictionary pdfDictionary;
        Object object;
        block17 : {
            boolean bl3;
            boolean bl4;
            block18 : {
                bl2 = this.mergeFields;
                bl3 = false;
                bl4 = false;
                bl = bl3;
                if (!bl2) break block17;
                this.updateAnnotationReferences(pdfIndirectObject.object);
                if (pdfIndirectObject.object.isDictionary()) break block18;
                bl = bl3;
                if (!pdfIndirectObject.object.isStream()) break block17;
            }
            pdfDictionary = (PdfDictionary)pdfIndirectObject.object;
            bl3 = bl4;
            if (this.unmergedIndirectRefsMap.containsKey(new RefKey(pdfIndirectObject.number, pdfIndirectObject.generation))) {
                object = pdfDictionary.getAsNumber(annotId);
                bl3 = bl4;
                if (object != null) {
                    bl3 = bl4;
                    if (this.mergedMap.containsKey(object.intValue())) {
                        bl3 = true;
                    }
                }
            }
            bl = bl3;
            if (this.mergedSet.contains(pdfIndirectObject)) {
                object = pdfDictionary.getAsNumber(annotId);
                bl = bl3;
                if (object != null) {
                    object = this.unmergedMap.get(object.intValue());
                    bl = bl3;
                    if (object != null) {
                        bl = bl3;
                        if (object.object.isDictionary()) {
                            object = ((PdfDictionary)object.object).getAsNumber(PdfName.STRUCTPARENT);
                            bl = bl3;
                            if (object != null) {
                                pdfDictionary.put(PdfName.STRUCTPARENT, (PdfObject)object);
                                bl = bl3;
                            }
                        }
                    }
                }
            }
        }
        if (!bl) {
            bl2 = this.mergeFields;
            pdfDictionary = null;
            if (bl2 && pdfIndirectObject.object.isDictionary()) {
                PdfDictionary pdfDictionary2 = (PdfDictionary)pdfIndirectObject.object;
                PdfNumber pdfNumber = pdfDictionary2.getAsNumber(annotId);
                object = pdfNumber;
                pdfDictionary = pdfDictionary2;
                if (pdfNumber != null) {
                    pdfDictionary2.remove(annotId);
                    object = pdfNumber;
                    pdfDictionary = pdfDictionary2;
                }
            } else {
                object = null;
            }
            this.body.add(pdfIndirectObject.object, pdfIndirectObject.number, pdfIndirectObject.generation, true);
            if (object != null) {
                pdfDictionary.put(annotId, (PdfObject)object);
            }
        }
    }

    public PdfIndirectReference add(PdfOutline pdfOutline) {
        return null;
    }

    @Override
    PdfIndirectReference add(PdfPage pdfPage, PdfContents pdfContents) throws PdfException {
        return null;
    }

    @Override
    public void addAnnotation(PdfAnnotation pdfAnnotation) {
    }

    public void addDocument(PdfReader pdfReader) throws DocumentException, IOException {
        int n;
        if (!this.document.isOpen()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("the.document.is.not.open.yet.you.can.only.add.meta.information", new Object[0]));
        }
        boolean bl = this.indirectMap.containsKey(pdfReader);
        int n2 = 1;
        if (bl) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("document.1.has.already.been.added", pdfReader.toString()));
        }
        if (!pdfReader.isOpenedWithFullPermissions()) {
            throw new BadPasswordException(MessageLocalization.getComposedMessage("pdfreader.not.opened.with.owner.password", new Object[0]));
        }
        if (this.mergeFields) {
            Object object;
            pdfReader.consolidateNamedDestinations();
            pdfReader.shuffleSubsetNames();
            for (n = 1; n <= pdfReader.getNumberOfPages(); ++n) {
                object = pdfReader.getPageNRelease(n);
                if (object == null || !object.contains(PdfName.ANNOTS) || (object = object.getAsArray(PdfName.ANNOTS)) == null) continue;
                for (int i = 0; i < object.size(); ++i) {
                    int n3;
                    PdfDictionary pdfDictionary = object.getAsDict(i);
                    if (pdfDictionary == null) continue;
                    PdfName pdfName = annotId;
                    annotIdCnt = n3 = annotIdCnt + 1;
                    pdfDictionary.put(pdfName, new PdfNumber(n3));
                }
            }
            object = pdfReader.getAcroFields();
            if (object.isGenerateAppearances() ^ true) {
                this.needAppearances = true;
            }
            this.fields.add((AcroFields)object);
            this.updateCalculationOrder(pdfReader);
        }
        bl = this.tagged && PdfStructTreeController.checkTagged(pdfReader);
        this.mergeFieldsInternalCall = true;
        for (n = n2; n <= pdfReader.getNumberOfPages(); ++n) {
            this.addPage(this.getImportedPage(pdfReader, n, bl));
        }
        this.mergeFieldsInternalCall = false;
    }

    public void addDocument(PdfReader pdfReader, List<Integer> list) throws DocumentException, IOException {
        if (this.indirectMap.containsKey(pdfReader)) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("document.1.has.already.been.added", pdfReader.toString()));
        }
        pdfReader.selectPages(list, false);
        this.addDocument(pdfReader);
    }

    public void addPage(Rectangle object, int n) throws DocumentException {
        if (this.mergeFields && !this.mergeFieldsInternalCall) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("1.method.cannot.be.used.in.mergeFields.mode.please.use.addDocument", "addPage"));
        }
        object = new PdfRectangle((Rectangle)object, n);
        PageResources pageResources = new PageResources();
        object = new PdfPage((PdfRectangle)object, new HashMap<String, PdfRectangle>(), pageResources.getResources(), 0);
        object.put(PdfName.TABS, this.getTabs());
        this.root.addPage((PdfDictionary)object);
        ++this.currentPageNumber;
        this.pdf.setPageCount(this.currentPageNumber);
    }

    public void addPage(PdfImportedPage pdfImportedPage) throws IOException, BadPdfFormatException {
        if (this.mergeFields && !this.mergeFieldsInternalCall) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("1.method.cannot.be.used.in.mergeFields.mode.please.use.addDocument", "addPage"));
        }
        int n = this.setFromIPage(pdfImportedPage);
        PdfDictionary pdfDictionary = this.reader.getPageN(n);
        Object object = this.reader.getPageOrigRef(n);
        this.reader.releasePage(n);
        RefKey refKey = new RefKey((PRIndirectReference)object);
        Object object2 = this.indirects.get(refKey);
        if (object2 != null && !object2.getCopied()) {
            this.pageReferences.add(object2.getRef());
            object2.setCopied();
        }
        PdfIndirectReference pdfIndirectReference = this.getCurrentPage();
        object = object2;
        if (object2 == null) {
            object = new IndirectReferences(pdfIndirectReference);
            this.indirects.put(refKey, (IndirectReferences)object);
        }
        object.setCopied();
        if (this.tagged) {
            this.structTreeRootReference = (PRIndirectReference)this.reader.getCatalog().get(PdfName.STRUCTTREEROOT);
        }
        object = this.copyDictionary(pdfDictionary);
        if (this.mergeFields) {
            object2 = this.importedPages.get(this.importedPages.size() - 1);
            object2.annotsIndirectReference = this.body.getPdfIndirectReference();
            object.put(PdfName.ANNOTS, object2.annotsIndirectReference);
        }
        this.root.addPage((PdfDictionary)object);
        pdfImportedPage.setCopied();
        ++this.currentPageNumber;
        this.pdf.setPageCount(this.currentPageNumber);
        this.structTreeRootReference = null;
    }

    @Override
    public PdfIndirectObject addToBody(PdfObject pdfObject, PdfIndirectReference pdfIndirectReference) throws IOException {
        return this.addToBody(pdfObject, pdfIndirectReference, false);
    }

    @Override
    public PdfIndirectObject addToBody(PdfObject pdfObject, PdfIndirectReference pdfIndirectReference, boolean bl) throws IOException {
        PdfIndirectObject pdfIndirectObject;
        if (bl) {
            this.updateReferences(pdfObject);
        }
        if ((this.tagged || this.mergeFields) && this.indirectObjects != null && (pdfObject.isArray() || pdfObject.isDictionary() || pdfObject.isStream() || pdfObject.isNull())) {
            PdfIndirectObject pdfIndirectObject2;
            RefKey refKey = new RefKey(pdfIndirectReference);
            pdfIndirectObject = pdfIndirectObject2 = this.indirectObjects.get(refKey);
            if (pdfIndirectObject2 == null) {
                pdfIndirectObject = new PdfIndirectObject(pdfIndirectReference, pdfObject, (PdfWriter)this);
                this.indirectObjects.put(refKey, pdfIndirectObject);
            }
        } else {
            pdfIndirectObject = super.addToBody(pdfObject, pdfIndirectReference);
        }
        if (this.mergeFields && pdfObject.isDictionary() && (pdfObject = ((PdfDictionary)pdfObject).getAsNumber(annotId)) != null) {
            if (bl) {
                this.mergedMap.put(pdfObject.intValue(), pdfIndirectObject);
                this.mergedSet.add(pdfIndirectObject);
                return pdfIndirectObject;
            }
            this.unmergedMap.put(pdfObject.intValue(), pdfIndirectObject);
            this.unmergedIndirectRefsMap.put(new RefKey(pdfIndirectObject.number, pdfIndirectObject.generation), pdfIndirectObject);
        }
        return pdfIndirectObject;
    }

    @Override
    protected void cacheObject(PdfIndirectObject pdfIndirectObject) {
        if ((this.tagged || this.mergeFields) && this.indirectObjects != null) {
            this.savedObjects.add(pdfIndirectObject);
            RefKey refKey = new RefKey(pdfIndirectObject.number, pdfIndirectObject.generation);
            if (!this.indirectObjects.containsKey(refKey)) {
                this.indirectObjects.put(refKey, pdfIndirectObject);
            }
        }
    }

    @Override
    public void close() {
        if (this.open) {
            this.pdf.close();
            super.close();
        }
    }

    protected PdfArray copyArray(PdfArray pdfArray) throws IOException, BadPdfFormatException {
        return this.copyArray(pdfArray, false, false);
    }

    protected PdfArray copyArray(PdfArray pdfArray, boolean bl, boolean bl2) throws IOException, BadPdfFormatException {
        PdfArray pdfArray2 = new PdfArray(pdfArray.size());
        ListIterator<PdfObject> listIterator = pdfArray.listIterator();
        while (listIterator.hasNext()) {
            PdfObject pdfObject = listIterator.next();
            this.parentObjects.put(pdfObject, pdfArray);
            if ((pdfObject = this.copyObject(pdfObject, bl, bl2)) == null) continue;
            pdfArray2.add(pdfObject);
        }
        return pdfArray2;
    }

    protected PdfDictionary copyDictionary(PdfDictionary pdfDictionary) throws IOException, BadPdfFormatException {
        return this.copyDictionary(pdfDictionary, false, false);
    }

    protected PdfDictionary copyDictionary(PdfDictionary pdfObject, boolean bl, boolean bl2) throws IOException, BadPdfFormatException {
        Object object;
        PdfDictionary pdfDictionary = new PdfDictionary(pdfObject.size());
        PdfObject pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.TYPE));
        if (bl) {
            if (bl2 && pdfObject.contains(PdfName.PG)) {
                this.disableIndirects.add(pdfObject);
                while (this.parentObjects.containsKey(pdfObject) && !this.disableIndirects.contains(pdfObject)) {
                    pdfObject = this.parentObjects.get(pdfObject);
                    this.disableIndirects.add(pdfObject);
                }
                return null;
            }
            object = pdfObject.getAsName(PdfName.S);
            this.structTreeController.addRole((PdfName)object);
            this.structTreeController.addClass(pdfObject);
        }
        if (this.structTreeController != null && this.structTreeController.reader != null && (pdfObject.contains(PdfName.STRUCTPARENTS) || pdfObject.contains(PdfName.STRUCTPARENT))) {
            object = PdfName.STRUCTPARENT;
            if (pdfObject.contains(PdfName.STRUCTPARENTS)) {
                object = PdfName.STRUCTPARENTS;
            }
            Object object2 = pdfObject.get((PdfName)object);
            pdfDictionary.put((PdfName)object, new PdfNumber(this.currentStructArrayNumber));
            object = this.structTreeController;
            object2 = (PdfNumber)object2;
            int n = this.currentStructArrayNumber;
            this.currentStructArrayNumber = n + 1;
            object.copyStructTreeForPage((PdfNumber)object2, n);
        }
        for (PdfName pdfName : pdfObject.getKeys()) {
            object = pdfObject.get(pdfName);
            if (this.structTreeController != null && this.structTreeController.reader != null && (pdfName.equals(PdfName.STRUCTPARENTS) || pdfName.equals(PdfName.STRUCTPARENT))) continue;
            if (PdfName.PAGE.equals(pdfObject2)) {
                if (pdfName.equals(PdfName.B) || pdfName.equals(PdfName.PARENT)) continue;
                this.parentObjects.put((PdfObject)object, pdfObject);
                if ((object = this.copyObject((PdfObject)object, bl, bl2)) == null) continue;
                pdfDictionary.put(pdfName, (PdfObject)object);
                continue;
            }
            object = this.tagged && object.isIndirect() && this.isStructTreeRootReference((PRIndirectReference)object) ? this.structureTreeRoot.getReference() : this.copyObject((PdfObject)object, bl, bl2);
            if (object == null) continue;
            pdfDictionary.put(pdfName, (PdfObject)object);
        }
        return pdfDictionary;
    }

    public void copyDocumentFields(PdfReader pdfReader) throws DocumentException, IOException {
        if (!this.document.isOpen()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("the.document.is.not.open.yet.you.can.only.add.meta.information", new Object[0]));
        }
        if (this.indirectMap.containsKey(pdfReader)) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("document.1.has.already.been.added", pdfReader.toString()));
        }
        if (!pdfReader.isOpenedWithFullPermissions()) {
            throw new BadPasswordException(MessageLocalization.getComposedMessage("pdfreader.not.opened.with.owner.password", new Object[0]));
        }
        if (!this.mergeFields) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("1.method.can.be.only.used.in.mergeFields.mode.please.use.addDocument", "copyDocumentFields"));
        }
        this.indirects = new HashMap();
        this.indirectMap.put(pdfReader, this.indirects);
        pdfReader.consolidateNamedDestinations();
        pdfReader.shuffleSubsetNames();
        if (this.tagged && PdfStructTreeController.checkTagged(pdfReader)) {
            this.structTreeRootReference = (PRIndirectReference)pdfReader.getCatalog().get(PdfName.STRUCTTREEROOT);
            if (this.structTreeController != null) {
                if (pdfReader != this.structTreeController.reader) {
                    this.structTreeController.setReader(pdfReader);
                }
            } else {
                this.structTreeController = new PdfStructTreeController(pdfReader, this);
            }
        }
        Object object = new ArrayList();
        for (int i = 1; i <= pdfReader.getNumberOfPages(); ++i) {
            PdfObject pdfObject = pdfReader.getPageNRelease(i);
            if (pdfObject == null || !pdfObject.contains(PdfName.ANNOTS) || (pdfObject = pdfObject.getAsArray(PdfName.ANNOTS)) == null || pdfObject.size() <= 0) continue;
            if (this.importedPages.size() < i) {
                throw new DocumentException(MessageLocalization.getComposedMessage("there.are.not.enough.imported.pages.for.copied.fields", new Object[0]));
            }
            this.indirectMap.get(pdfReader).put(new RefKey(pdfReader.pageRefs.getPageOrigRef(i)), new IndirectReferences((PdfIndirectReference)this.pageReferences.get(i - 1)));
            for (int j = 0; j < pdfObject.size(); ++j) {
                int n;
                PdfDictionary pdfDictionary = pdfObject.getAsDict(j);
                if (pdfDictionary == null) continue;
                PdfName pdfName = annotId;
                annotIdCnt = n = annotIdCnt + 1;
                pdfDictionary.put(pdfName, new PdfNumber(n));
                object.add(pdfObject.getPdfObject(j));
            }
        }
        object = object.iterator();
        while (object.hasNext()) {
            this.copyObject((PdfObject)object.next());
        }
        if (this.tagged && this.structTreeController != null) {
            this.structTreeController.attachStructTreeRootKids(null);
        }
        if ((object = pdfReader.getAcroFields()).isGenerateAppearances() ^ true) {
            this.needAppearances = true;
        }
        this.fields.add((AcroFields)object);
        this.updateCalculationOrder(pdfReader);
        this.structTreeRootReference = null;
    }

    protected PdfIndirectReference copyIndirect(PRIndirectReference pRIndirectReference) throws IOException, BadPdfFormatException {
        return this.copyIndirect(pRIndirectReference, false, false);
    }

    protected PdfIndirectReference copyIndirect(PRIndirectReference pdfObject, boolean bl, boolean bl2) throws IOException, BadPdfFormatException {
        PdfIndirectReference pdfIndirectReference;
        IndirectReferences indirectReferences;
        RefKey refKey = new RefKey((PRIndirectReference)pdfObject);
        Object object = this.indirects.get(refKey);
        PdfObject pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject);
        if (bl && bl2 && pdfObject2 instanceof PdfDictionary && ((PdfDictionary)pdfObject2).contains(PdfName.PG)) {
            return null;
        }
        if (object != null) {
            PdfIndirectReference pdfIndirectReference2 = object.getRef();
            indirectReferences = object;
            pdfIndirectReference = pdfIndirectReference2;
            if (object.getCopied()) {
                return pdfIndirectReference2;
            }
        } else {
            pdfIndirectReference = this.body.getPdfIndirectReference();
            indirectReferences = new IndirectReferences(pdfIndirectReference);
            this.indirects.put(refKey, indirectReferences);
        }
        if (pdfObject2 != null && pdfObject2.isDictionary() && (object = PdfReader.getPdfObjectRelease(((PdfDictionary)pdfObject2).get(PdfName.TYPE))) != null) {
            if (PdfName.PAGE.equals(object)) {
                return pdfIndirectReference;
            }
            if (PdfName.CATALOG.equals(object)) {
                LOGGER.warn(MessageLocalization.getComposedMessage("make.copy.of.catalog.dictionary.is.forbidden", new Object[0]));
                return null;
            }
        }
        indirectReferences.setCopied();
        if (pdfObject2 != null) {
            this.parentObjects.put(pdfObject2, pdfObject);
        }
        pdfObject = this.copyObject(pdfObject2, bl, bl2);
        if (this.disableIndirects.contains(pdfObject2)) {
            indirectReferences.setNotCopied();
        }
        if (pdfObject != null) {
            this.addToBody(pdfObject, pdfIndirectReference);
            return pdfIndirectReference;
        }
        this.indirects.remove(refKey);
        return null;
    }

    protected PdfObject copyObject(PdfObject pdfObject) throws IOException, BadPdfFormatException {
        return this.copyObject(pdfObject, false, false);
    }

    protected PdfObject copyObject(PdfObject object, boolean bl, boolean bl2) throws IOException, BadPdfFormatException {
        block9 : {
            block10 : {
                if (object == null) {
                    return PdfNull.PDFNULL;
                }
                switch (object.type) {
                    default: {
                        if (object.type >= 0) break block9;
                        if (!(object = ((PdfLiteral)object).toString()).equals("true") && !object.equals("false")) break;
                        break block10;
                    }
                    case 10: {
                        if (!bl && !bl2) {
                            return this.copyIndirect((PRIndirectReference)object);
                        }
                        return this.copyIndirect((PRIndirectReference)object, bl, bl2);
                    }
                    case 7: {
                        return this.copyStream((PRStream)object);
                    }
                    case 6: {
                        return this.copyDictionary((PdfDictionary)object, bl, bl2);
                    }
                    case 5: {
                        return this.copyArray((PdfArray)object, bl, bl2);
                    }
                    case 0: 
                    case 1: 
                    case 2: 
                    case 3: 
                    case 4: 
                    case 8: {
                        return object;
                    }
                }
                return new PdfLiteral((String)object);
            }
            return new PdfBoolean((String)object);
        }
        PrintStream printStream = System.out;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("CANNOT COPY type ");
        stringBuilder.append(object.type);
        printStream.println(stringBuilder.toString());
        return null;
    }

    protected PdfStream copyStream(PRStream pRStream) throws IOException, BadPdfFormatException {
        PRStream pRStream2 = new PRStream(pRStream, null);
        for (PdfName pdfName : pRStream.getKeys()) {
            PdfObject pdfObject = pRStream.get(pdfName);
            this.parentObjects.put(pdfObject, pRStream);
            if ((pdfObject = this.copyObject(pdfObject)) == null) continue;
            pRStream2.put(pdfName, pdfObject);
        }
        return pRStream2;
    }

    public PageStamp createPageStamp(PdfImportedPage object) {
        int n = object.getPageNumber();
        object = object.getPdfReaderInstance().getReader();
        if (this.isTagged()) {
            throw new RuntimeException(MessageLocalization.getComposedMessage("creating.page.stamp.not.allowed.for.tagged.reader", new Object[0]));
        }
        return new PageStamp((PdfReader)object, object.getPageN(n), this);
    }

    protected void fixStructureTreeRoot(HashSet<RefKey> hashSet, HashSet<PdfName> object) {
        HashMap<PdfName, PdfObject> hashMap = new HashMap<PdfName, PdfObject>(object.size());
        object = object.iterator();
        while (object.hasNext()) {
            PdfName pdfName = (PdfName)object.next();
            PdfObject pdfObject = this.structureTreeRoot.classes.get(pdfName);
            if (pdfObject == null) continue;
            hashMap.put(pdfName, pdfObject);
        }
        this.structureTreeRoot.classes = hashMap;
        object = this.structureTreeRoot.getAsArray(PdfName.K);
        if (object != null) {
            int n = 0;
            while (n < object.size()) {
                int n2 = n;
                if (!hashSet.contains(new RefKey((PdfIndirectReference)object.getPdfObject(n)))) {
                    object.remove(n);
                    n2 = n - 1;
                }
                n = n2 + 1;
            }
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void fixTaggedStructure() throws IOException {
        Object object;
        Map.Entry<RefKey, PdfIndirectObject> entry2;
        HashMap<Integer, PdfIndirectReference> hashMap = this.structureTreeRoot.getNumTree();
        HashSet<RefKey> hashSet = new HashSet<RefKey>();
        ArrayList<PdfIndirectReference> arrayList = new ArrayList<PdfIndirectReference>();
        if (this.mergeFields && this.acroForm != null) {
            arrayList.add(this.acroForm);
            hashSet.add(new RefKey(this.acroForm));
        }
        for (Map.Entry<RefKey, PdfIndirectObject> entry2 : this.pageReferences) {
            arrayList.add((PdfIndirectReference)((Object)entry2));
            hashSet.add(new RefKey((PdfIndirectReference)((Object)entry2)));
        }
        int n = hashMap.size() - 1;
        int n2 = 0;
        do {
            int n3;
            if (n < 0) break;
            object = hashMap.get(n);
            if (object == null) {
                n3 = n2;
            } else {
                Serializable serializable;
                entry2 = new RefKey((PdfIndirectReference)object);
                PdfObject pdfObject = this.indirectObjects.get((Object)entry2).object;
                if (pdfObject.isDictionary()) {
                    serializable = this.pageReferences;
                    n3 = serializable.contains((pdfObject = (PdfDictionary)pdfObject).get(PdfName.PG)) || (serializable = PdfStructTreeController.getKDict((PdfDictionary)pdfObject)) != null && this.pageReferences.contains(serializable.get(PdfName.PG)) ? 1 : 0;
                    if (n3 != 0) {
                        hashSet.add((RefKey)((Object)entry2));
                        arrayList.add((PdfIndirectReference)object);
                        n3 = n2;
                    } else {
                        hashMap.remove(n);
                        n3 = n2;
                    }
                } else {
                    n3 = n2;
                    if (pdfObject.isArray()) {
                        hashSet.add((RefKey)((Object)entry2));
                        arrayList.add((PdfIndirectReference)object);
                        serializable = (PdfArray)pdfObject;
                        pdfObject = (PdfIndirectReference)this.pageReferences.get(n2);
                        arrayList.add((PdfIndirectReference)pdfObject);
                        hashSet.add(new RefKey((PdfIndirectReference)pdfObject));
                        object = null;
                        for (n3 = 0; n3 < serializable.size(); ++n3) {
                            PdfIndirectReference pdfIndirectReference;
                            entry2 = (PdfIndirectReference)serializable.getDirectObject(n3);
                            if (entry2.equals(object)) continue;
                            object = new RefKey((PdfIndirectReference)((Object)entry2));
                            hashSet.add((RefKey)object);
                            arrayList.add((PdfIndirectReference)((Object)entry2));
                            object = this.indirectObjects.get(object);
                            if (object.object.isDictionary() && (pdfIndirectReference = (PdfIndirectReference)(object = (PdfDictionary)object.object).get(PdfName.PG)) != null && !this.pageReferences.contains(pdfIndirectReference) && !pdfIndirectReference.equals(pdfObject)) {
                                object.put(PdfName.PG, pdfObject);
                                object = object.getAsArray(PdfName.K);
                                if (object != null && object.getDirectObject(0).isNumber()) {
                                    object.remove(0);
                                }
                            }
                            object = entry2;
                        }
                        n3 = n2 + 1;
                    }
                }
            }
            --n;
            n2 = n3;
        } while (true);
        object = new HashSet();
        this.findActives(arrayList, hashSet, (HashSet<PdfName>)object);
        this.fixPgKey(this.findActiveParents(hashSet), hashSet);
        this.fixStructureTreeRoot(hashSet, (HashSet<PdfName>)object);
        object = this.indirectObjects.entrySet().iterator();
        while (object.hasNext()) {
            entry2 = object.next();
            if (!hashSet.contains(entry2.getKey())) {
                entry2.setValue(null);
                continue;
            }
            if (entry2.getValue().object.isArray()) {
                this.removeInactiveReferences((PdfArray)entry2.getValue().object, hashSet);
                continue;
            }
            if (!entry2.getValue().object.isDictionary() || (entry2 = ((PdfDictionary)entry2.getValue().object).get(PdfName.K)) == null || !entry2.isArray()) continue;
            this.removeInactiveReferences((PdfArray)((Object)entry2), hashSet);
        }
        return;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    protected void flushAcroFields() throws IOException, BadPdfFormatException {
        block12 : {
            block13 : {
                if (!this.mergeFields) break block12;
                try {
                    for (ImportedPage importedPage : this.importedPages) {
                        Object object = importedPage.reader.getPageN(importedPage.pageNumber);
                        if (object == null || (object = object.getAsArray(PdfName.ANNOTS)) == null || object.size() == 0) continue;
                        Iterator<AcroFields.Item> iterator2 = importedPage.reader.getAcroFields().getFields().values().iterator();
                        while (iterator2.hasNext()) {
                            for (PdfIndirectReference pdfIndirectReference : iterator2.next().widget_refs) {
                                object.arrayList.remove(pdfIndirectReference);
                            }
                        }
                        this.indirects = this.indirectMap.get(importedPage.reader);
                        for (PdfObject pdfObject : object.arrayList) {
                            importedPage.mergedFields.add(this.copyObject(pdfObject));
                        }
                    }
                    Iterator<Object> iterator3 = this.indirectMap.keySet().iterator();
                    while (iterator3.hasNext()) {
                        ((PdfReader)iterator3.next()).removeFields();
                    }
                    this.mergeFields();
                    this.createAcroForms();
                    if (this.tagged) break block12;
                    break block13;
                }
                catch (Throwable throwable) {
                    if (!this.tagged) {
                        this.flushIndirectObjects();
                    }
                    throw throwable;
                }
                catch (ClassCastException classCastException) {}
                if (this.tagged) break block12;
            }
            this.flushIndirectObjects();
        }
    }

    protected void flushIndirectObjects() throws IOException {
        for (PdfIndirectObject iterator2 : this.savedObjects) {
            this.indirectObjects.remove(new RefKey(iterator2.number, iterator2.generation));
        }
        HashSet hashSet = new HashSet();
        for (Map.Entry<RefKey, PdfIndirectObject> entry : this.indirectObjects.entrySet()) {
            if (entry.getValue() != null) {
                this.writeObjectToBody(entry.getValue());
                continue;
            }
            hashSet.add(entry.getKey());
        }
        for (PdfWriter.PdfBody.PdfCrossReference pdfCrossReference : new ArrayList<PdfWriter.PdfBody.PdfCrossReference>(this.body.xrefs)) {
            if (!hashSet.contains(new RefKey(pdfCrossReference.getRefnum(), 0))) continue;
            this.body.xrefs.remove(pdfCrossReference);
        }
        this.indirectObjects = null;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    @Override
    protected void flushTaggedObjects() throws IOException {
        try {
            this.fixTaggedStructure();
        }
        catch (Throwable var1_1) {
            this.flushIndirectObjects();
            throw var1_1;
        }
        catch (ClassCastException var1_2) {
            ** continue;
        }
lbl3: // 2 sources:
        do {
            this.flushIndirectObjects();
            return;
            break;
        } while (true);
    }

    @Override
    public void freeReader(PdfReader pdfReader) throws IOException {
        if (this.mergeFields) {
            throw new UnsupportedOperationException(MessageLocalization.getComposedMessage("it.is.not.possible.to.free.reader.in.merge.fields.mode", new Object[0]));
        }
        PdfArray pdfArray = pdfReader.trailer.getAsArray(PdfName.ID);
        if (pdfArray != null) {
            this.originalFileID = pdfArray.getAsString(0).getBytes();
        }
        this.indirectMap.remove(pdfReader);
        this.currentPdfReaderInstance = null;
        super.freeReader(pdfReader);
    }

    @Override
    protected PdfDictionary getCatalog(PdfIndirectReference pdfObject) {
        block4 : {
            try {
                pdfObject = this.pdf.getCatalog((PdfIndirectReference)pdfObject);
                this.buildStructTreeRootForTagged((PdfDictionary)pdfObject);
                if (this.fieldArray == null) break block4;
                this.addFieldResources((PdfDictionary)pdfObject);
                return pdfObject;
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
        }
        if (this.mergeFields && this.acroForm != null) {
            pdfObject.put(PdfName.ACROFORM, this.acroForm);
        }
        return pdfObject;
    }

    @Override
    protected Counter getCounter() {
        return COUNTER;
    }

    @Override
    public PdfImportedPage getImportedPage(PdfReader pdfReader, int n) {
        if (this.mergeFields && !this.mergeFieldsInternalCall) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("1.method.cannot.be.used.in.mergeFields.mode.please.use.addDocument", "getImportedPage"));
        }
        if (this.mergeFields) {
            ImportedPage importedPage = new ImportedPage(pdfReader, n, this.mergeFields);
            this.importedPages.add(importedPage);
        }
        if (this.structTreeController != null) {
            this.structTreeController.reader = null;
        }
        this.disableIndirects.clear();
        this.parentObjects.clear();
        return this.getImportedPageImpl(pdfReader, n);
    }

    public PdfImportedPage getImportedPage(PdfReader pdfReader, int n, boolean bl) throws BadPdfFormatException {
        if (this.mergeFields && !this.mergeFieldsInternalCall) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("1.method.cannot.be.used.in.mergeFields.mode.please.use.addDocument", "getImportedPage"));
        }
        this.updateRootKids = false;
        if (!bl) {
            if (this.mergeFields) {
                ImportedPage importedPage = new ImportedPage(pdfReader, n, this.mergeFields);
                this.importedPages.add(importedPage);
            }
            return this.getImportedPageImpl(pdfReader, n);
        }
        if (this.structTreeController != null) {
            if (pdfReader != this.structTreeController.reader) {
                this.structTreeController.setReader(pdfReader);
            }
        } else {
            this.structTreeController = new PdfStructTreeController(pdfReader, this);
        }
        ImportedPage importedPage = new ImportedPage(pdfReader, n, this.mergeFields);
        switch (this.checkStructureTreeRootKids(importedPage)) {
            default: {
                break;
            }
            case 1: {
                this.updateRootKids = true;
                break;
            }
            case 0: {
                this.updateRootKids = false;
                break;
            }
            case -1: {
                this.clearIndirects(pdfReader);
                this.updateRootKids = true;
            }
        }
        this.importedPages.add(importedPage);
        this.disableIndirects.clear();
        this.parentObjects.clear();
        return this.getImportedPageImpl(pdfReader, n);
    }

    protected PdfImportedPage getImportedPageImpl(PdfReader pdfReader, int n) {
        if (this.currentPdfReaderInstance != null) {
            if (this.currentPdfReaderInstance.getReader() != pdfReader) {
                this.currentPdfReaderInstance = super.getPdfReaderInstance(pdfReader);
            }
        } else {
            this.currentPdfReaderInstance = super.getPdfReaderInstance(pdfReader);
        }
        return this.currentPdfReaderInstance.getImportedPage(n);
    }

    protected PdfName getOffStateName(PdfDictionary pdfDictionary) {
        return PdfName.Off;
    }

    public boolean isRotateContents() {
        return this.rotateContents;
    }

    protected boolean isStructTreeRootReference(PdfIndirectReference pdfIndirectReference) {
        boolean bl = false;
        if (pdfIndirectReference != null) {
            if (this.structTreeRootReference == null) {
                return false;
            }
            boolean bl2 = bl;
            if (pdfIndirectReference.number == this.structTreeRootReference.number) {
                bl2 = bl;
                if (pdfIndirectReference.generation == this.structTreeRootReference.generation) {
                    bl2 = true;
                }
            }
            return bl2;
        }
        return false;
    }

    protected int setFromIPage(PdfImportedPage object) {
        int n = object.getPageNumber();
        this.currentPdfReaderInstance = object = object.getPdfReaderInstance();
        this.reader = object.getReader();
        this.setFromReader(this.reader);
        return n;
    }

    protected void setFromReader(PdfReader pdfReader) {
        this.reader = pdfReader;
        this.indirects = this.indirectMap.get(pdfReader);
        if (this.indirects == null) {
            this.indirects = new HashMap();
            this.indirectMap.put(pdfReader, this.indirects);
        }
    }

    public void setMergeFields() {
        this.mergeFields = true;
        this.resources = new PdfDictionary();
        this.fields = new ArrayList();
        this.calculationOrder = new ArrayList();
        this.fieldTree = new LinkedHashMap<String, Object>();
        this.unmergedMap = new HashMap();
        this.unmergedIndirectRefsMap = new HashMap();
        this.mergedMap = new HashMap();
        this.mergedSet = new HashSet();
    }

    @Override
    public void setPageEvent(PdfPageEvent pdfPageEvent) {
        throw new UnsupportedOperationException();
    }

    public void setRotateContents(boolean bl) {
        this.rotateContents = bl;
    }

    protected void structureTreeRootKidsForReaderImported(PdfReader pdfReader) {
        this.readersWithImportedStructureTreeRootKids.add(pdfReader);
    }

    protected static class ImportedPage {
        PdfIndirectReference annotsIndirectReference;
        PdfArray mergedFields;
        int pageNumber;
        PdfReader reader;

        ImportedPage(PdfReader pdfReader, int n, boolean bl) {
            this.pageNumber = n;
            this.reader = pdfReader;
            if (bl) {
                this.mergedFields = new PdfArray();
            }
        }

        public boolean equals(Object object) {
            boolean bl = object instanceof ImportedPage;
            boolean bl2 = false;
            if (!bl) {
                return false;
            }
            object = (ImportedPage)object;
            bl = bl2;
            if (this.pageNumber == object.pageNumber) {
                bl = bl2;
                if (this.reader.equals(object.reader)) {
                    bl = true;
                }
            }
            return bl;
        }

        public String toString() {
            return Integer.toString(this.pageNumber);
        }
    }

    static class IndirectReferences {
        boolean hasCopied;
        PdfIndirectReference theRef;

        IndirectReferences(PdfIndirectReference pdfIndirectReference) {
            this.theRef = pdfIndirectReference;
            this.hasCopied = false;
        }

        boolean getCopied() {
            return this.hasCopied;
        }

        PdfIndirectReference getRef() {
            return this.theRef;
        }

        void setCopied() {
            this.hasCopied = true;
        }

        void setNotCopied() {
            this.hasCopied = false;
        }

        public String toString() {
            CharSequence charSequence = "";
            if (this.hasCopied) {
                charSequence = new StringBuilder();
                charSequence.append("");
                charSequence.append(" Copied");
                charSequence = charSequence.toString();
            }
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(this.getRef());
            stringBuilder.append((String)charSequence);
            return stringBuilder.toString();
        }
    }

    public static class PageStamp {
        PdfCopy cstp;
        StampContent over;
        PdfDictionary pageN;
        PageResources pageResources;
        PdfReader reader;
        StampContent under;

        PageStamp(PdfReader pdfReader, PdfDictionary pdfDictionary, PdfCopy pdfCopy) {
            this.pageN = pdfDictionary;
            this.reader = pdfReader;
            this.cstp = pdfCopy;
        }

        private void addDocumentField(PdfIndirectReference pdfIndirectReference) {
            if (this.cstp.fieldArray == null) {
                this.cstp.fieldArray = new PdfArray();
            }
            this.cstp.fieldArray.add(pdfIndirectReference);
        }

        private void expandFields(PdfFormField object, ArrayList<PdfAnnotation> arrayList) {
            arrayList.add((PdfAnnotation)object);
            object = object.getKids();
            if (object != null) {
                object = object.iterator();
                while (object.hasNext()) {
                    this.expandFields((PdfFormField)object.next(), arrayList);
                }
            }
        }

        /*
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         */
        public void addAnnotation(PdfAnnotation serializable) {
            try {
                ArrayList<PdfAnnotation> arrayList = new ArrayList<PdfAnnotation>();
                if (serializable.isForm()) {
                    if ((serializable = (PdfFormField)serializable).getParent() != null) {
                        return;
                    }
                    this.expandFields((PdfFormField)serializable, arrayList);
                    if (this.cstp.fieldTemplates == null) {
                        this.cstp.fieldTemplates = new HashSet();
                    }
                } else {
                    arrayList.add((PdfAnnotation)serializable);
                }
                int n = 0;
                while (n < arrayList.size()) {
                    PdfAnnotation pdfAnnotation = arrayList.get(n);
                    if (pdfAnnotation.isForm()) {
                        if (!pdfAnnotation.isUsed() && (serializable = pdfAnnotation.getTemplates()) != null) {
                            this.cstp.fieldTemplates.addAll((Collection<PdfTemplate>)((Object)serializable));
                        }
                        if ((serializable = (PdfFormField)pdfAnnotation).getParent() == null) {
                            this.addDocumentField(serializable.getIndirectReference());
                        }
                    }
                    if (pdfAnnotation.isAnnotation()) {
                        serializable = PdfReader.getPdfObject(this.pageN.get(PdfName.ANNOTS), this.pageN);
                        if (serializable != null && serializable.isArray()) {
                            serializable = (PdfArray)serializable;
                        } else {
                            serializable = new PdfArray();
                            this.pageN.put(PdfName.ANNOTS, (PdfObject)serializable);
                        }
                        serializable.add(pdfAnnotation.getIndirectReference());
                        if (!(pdfAnnotation.isUsed() || (serializable = (PdfRectangle)pdfAnnotation.get(PdfName.RECT)) == null || serializable.left() == 0.0f && serializable.right() == 0.0f && serializable.top() == 0.0f && serializable.bottom() == 0.0f)) {
                            int n2 = this.reader.getPageRotation(this.pageN);
                            Rectangle rectangle = this.reader.getPageSizeWithRotation(this.pageN);
                            if (n2 != 90) {
                                if (n2 != 180) {
                                    if (n2 == 270) {
                                        pdfAnnotation.put(PdfName.RECT, new PdfRectangle(serializable.bottom(), rectangle.getRight() - serializable.left(), serializable.top(), rectangle.getRight() - serializable.right()));
                                    }
                                } else {
                                    pdfAnnotation.put(PdfName.RECT, new PdfRectangle(rectangle.getRight() - serializable.left(), rectangle.getTop() - serializable.bottom(), rectangle.getRight() - serializable.right(), rectangle.getTop() - serializable.top()));
                                }
                            } else {
                                pdfAnnotation.put(PdfName.RECT, new PdfRectangle(rectangle.getTop() - serializable.bottom(), serializable.left(), rectangle.getTop() - serializable.top(), serializable.right()));
                            }
                        }
                    }
                    if (!pdfAnnotation.isUsed()) {
                        pdfAnnotation.setUsed();
                        this.cstp.addToBody(pdfAnnotation, pdfAnnotation.getIndirectReference());
                    }
                    ++n;
                }
                return;
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
        }

        public void alterContents() throws IOException {
            if (this.over == null && this.under == null) {
                return;
            }
            PdfObject pdfObject = PdfReader.getPdfObject(this.pageN.get(PdfName.CONTENTS), this.pageN);
            if (pdfObject == null) {
                pdfObject = new PdfArray();
                this.pageN.put(PdfName.CONTENTS, pdfObject);
            } else if (pdfObject.isArray()) {
                pdfObject = (PdfArray)pdfObject;
            } else if (pdfObject.isStream()) {
                pdfObject = new PdfArray();
                pdfObject.add(this.pageN.get(PdfName.CONTENTS));
                this.pageN.put(PdfName.CONTENTS, pdfObject);
            } else {
                pdfObject = new PdfArray();
                this.pageN.put(PdfName.CONTENTS, pdfObject);
            }
            Object object = new ByteBuffer();
            if (this.under != null) {
                object.append(PdfContents.SAVESTATE);
                this.applyRotation(this.pageN, (ByteBuffer)object);
                object.append(this.under.getInternalBuffer());
                object.append(PdfContents.RESTORESTATE);
            }
            if (this.over != null) {
                object.append(PdfContents.SAVESTATE);
            }
            PdfStream pdfStream = new PdfStream(object.toByteArray());
            pdfStream.flateCompress(this.cstp.getCompressionLevel());
            pdfObject.addFirst(this.cstp.addToBody(pdfStream).getIndirectReference());
            object.reset();
            if (this.over != null) {
                object.append(' ');
                object.append(PdfContents.RESTORESTATE);
                object.append(PdfContents.SAVESTATE);
                this.applyRotation(this.pageN, (ByteBuffer)object);
                object.append(this.over.getInternalBuffer());
                object.append(PdfContents.RESTORESTATE);
                object = new PdfStream(object.toByteArray());
                object.flateCompress(this.cstp.getCompressionLevel());
                pdfObject.add(this.cstp.addToBody((PdfObject)object).getIndirectReference());
            }
            this.pageN.put(PdfName.RESOURCES, this.pageResources.getResources());
        }

        void applyRotation(PdfDictionary object, ByteBuffer byteBuffer) {
            if (!this.cstp.rotateContents) {
                return;
            }
            int n = (object = this.reader.getPageSizeWithRotation((PdfDictionary)object)).getRotation();
            if (n != 90) {
                if (n != 180) {
                    if (n != 270) {
                        return;
                    }
                    byteBuffer.append(PdfContents.ROTATE270);
                    byteBuffer.append('0').append(' ');
                    byteBuffer.append(object.getRight());
                    byteBuffer.append(PdfContents.ROTATEFINAL);
                    return;
                }
                byteBuffer.append(PdfContents.ROTATE180);
                byteBuffer.append(object.getRight());
                byteBuffer.append(' ');
                byteBuffer.append(object.getTop());
                byteBuffer.append(PdfContents.ROTATEFINAL);
                return;
            }
            byteBuffer.append(PdfContents.ROTATE90);
            byteBuffer.append(object.getTop());
            byteBuffer.append(' ').append('0').append(PdfContents.ROTATEFINAL);
        }

        public PdfContentByte getOverContent() {
            if (this.over == null) {
                if (this.pageResources == null) {
                    this.pageResources = new PageResources();
                    PdfDictionary pdfDictionary = this.pageN.getAsDict(PdfName.RESOURCES);
                    this.pageResources.setOriginalResources(pdfDictionary, this.cstp.namePtr);
                }
                this.over = new StampContent(this.cstp, this.pageResources);
            }
            return this.over;
        }

        public PdfContentByte getUnderContent() {
            if (this.under == null) {
                if (this.pageResources == null) {
                    this.pageResources = new PageResources();
                    PdfDictionary pdfDictionary = this.pageN.getAsDict(PdfName.RESOURCES);
                    this.pageResources.setOriginalResources(pdfDictionary, this.cstp.namePtr);
                }
                this.under = new StampContent(this.cstp, this.pageResources);
            }
            return this.under;
        }
    }

    public static class StampContent
    extends PdfContentByte {
        PageResources pageResources;

        StampContent(PdfWriter pdfWriter, PageResources pageResources) {
            super(pdfWriter);
            this.pageResources = pageResources;
        }

        @Override
        public PdfContentByte getDuplicate() {
            return new StampContent(this.writer, this.pageResources);
        }

        @Override
        PageResources getPageResources() {
            return this.pageResources;
        }
    }

}

