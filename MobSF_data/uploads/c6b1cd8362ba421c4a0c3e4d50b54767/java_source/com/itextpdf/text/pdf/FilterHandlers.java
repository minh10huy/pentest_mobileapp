/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.UnsupportedPdfException;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.codec.TIFFFaxDecoder;
import com.itextpdf.text.pdf.codec.TIFFFaxDecompressor;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public final class FilterHandlers {
    private static final Map<PdfName, FilterHandler> defaults;

    static {
        HashMap<PdfName, FilterHandler> hashMap = new HashMap<PdfName, FilterHandler>();
        hashMap.put(PdfName.FLATEDECODE, new Filter_FLATEDECODE());
        hashMap.put(PdfName.FL, new Filter_FLATEDECODE());
        hashMap.put(PdfName.ASCIIHEXDECODE, new Filter_ASCIIHEXDECODE());
        hashMap.put(PdfName.AHX, new Filter_ASCIIHEXDECODE());
        hashMap.put(PdfName.ASCII85DECODE, new Filter_ASCII85DECODE());
        hashMap.put(PdfName.A85, new Filter_ASCII85DECODE());
        hashMap.put(PdfName.LZWDECODE, new Filter_LZWDECODE());
        hashMap.put(PdfName.CCITTFAXDECODE, new Filter_CCITTFAXDECODE());
        hashMap.put(PdfName.CRYPT, new Filter_DoNothing());
        hashMap.put(PdfName.RUNLENGTHDECODE, new Filter_RUNLENGTHDECODE());
        defaults = Collections.unmodifiableMap(hashMap);
    }

    public static Map<PdfName, FilterHandler> getDefaultFilterHandlers() {
        return defaults;
    }

    public static interface FilterHandler {
        public byte[] decode(byte[] var1, PdfName var2, PdfObject var3, PdfDictionary var4) throws IOException;
    }

    private static class Filter_ASCII85DECODE
    implements FilterHandler {
        private Filter_ASCII85DECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) throws IOException {
            return PdfReader.ASCII85Decode(arrby);
        }
    }

    private static class Filter_ASCIIHEXDECODE
    implements FilterHandler {
        private Filter_ASCIIHEXDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) throws IOException {
            return PdfReader.ASCIIHexDecode(arrby);
        }
    }

    private static class Filter_CCITTFAXDECODE
    implements FilterHandler {
        private Filter_CCITTFAXDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfObject, PdfObject object, PdfDictionary pdfObject2) throws IOException {
            pdfObject = (PdfNumber)PdfReader.getPdfObjectRelease(pdfObject2.get(PdfName.WIDTH));
            pdfObject2 = (PdfNumber)PdfReader.getPdfObjectRelease(pdfObject2.get(PdfName.HEIGHT));
            int n = 0;
            if (pdfObject != null && pdfObject2 != null) {
                boolean bl;
                int n2;
                int n3;
                boolean bl2;
                int n4 = pdfObject.intValue();
                int n5 = pdfObject2.intValue();
                pdfObject = object instanceof PdfDictionary ? (PdfDictionary)object : null;
                if (pdfObject != null) {
                    object = pdfObject.getAsNumber(PdfName.K);
                    n3 = object != null ? object.intValue() : 0;
                    object = pdfObject.getAsBoolean(PdfName.BLACKIS1);
                    bl = object != null ? object.booleanValue() : false;
                    bl2 = (pdfObject = pdfObject.getAsBoolean(PdfName.ENCODEDBYTEALIGN)) != null ? pdfObject.booleanValue() : false;
                } else {
                    bl2 = false;
                    n3 = 0;
                    bl = false;
                }
                int n6 = (n4 + 7) / 8 * n5;
                object = new byte[n6];
                TIFFFaxDecompressor tIFFFaxDecompressor = new TIFFFaxDecompressor();
                if (n3 != 0 && n3 <= 0) {
                    new TIFFFaxDecoder(1L, n4, n5).decodeT6((byte[])object, arrby, 0, n5, 0L);
                    pdfObject = object;
                } else {
                    n3 = n3 > 0 ? 1 : 0;
                    n2 = bl2 ? 4 : 0;
                    n3 = n2 | n3;
                    tIFFFaxDecompressor.SetOptions(1, 3, n3, 0);
                    tIFFFaxDecompressor.decodeRaw((byte[])object, arrby, n4, n5);
                    pdfObject = object;
                    if (tIFFFaxDecompressor.fails > 0) {
                        pdfObject2 = new byte[n6];
                        n2 = tIFFFaxDecompressor.fails;
                        tIFFFaxDecompressor.SetOptions(1, 2, n3, 0);
                        tIFFFaxDecompressor.decodeRaw((byte[])pdfObject2, arrby, n4, n5);
                        pdfObject = object;
                        if (tIFFFaxDecompressor.fails < n2) {
                            pdfObject = pdfObject2;
                        }
                    }
                }
                if (!bl) {
                    n2 = ((PdfObject)pdfObject).length;
                    for (n3 = n; n3 < n2; ++n3) {
                        pdfObject[n3] = (PdfObject)((byte)(pdfObject[n3] ^ 255));
                    }
                }
                return pdfObject;
            }
            throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("filter.ccittfaxdecode.is.only.supported.for.images", new Object[0]));
        }
    }

    private static class Filter_DoNothing
    implements FilterHandler {
        private Filter_DoNothing() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) throws IOException {
            return arrby;
        }
    }

    private static class Filter_FLATEDECODE
    implements FilterHandler {
        private Filter_FLATEDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) throws IOException {
            return PdfReader.decodePredictor(PdfReader.FlateDecode(arrby), pdfObject);
        }
    }

    private static class Filter_LZWDECODE
    implements FilterHandler {
        private Filter_LZWDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) throws IOException {
            return PdfReader.decodePredictor(PdfReader.LZWDecode(arrby), pdfObject);
        }
    }

    private static class Filter_RUNLENGTHDECODE
    implements FilterHandler {
        private Filter_RUNLENGTHDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName object, PdfObject pdfObject, PdfDictionary pdfDictionary) throws IOException {
            byte by;
            object = new ByteArrayOutputStream();
            int n = 0;
            while (n < arrby.length && (by = arrby[n]) != -128) {
                int n2;
                if (by >= 0 && by <= 127) {
                    n2 = by + 1;
                    object.write(arrby, n, n2);
                    n2 = n + n2;
                } else {
                    int n3 = n + 1;
                    n = 0;
                    do {
                        n2 = n3;
                        if (n >= 1 - by) break;
                        object.write(arrby[n3]);
                        ++n;
                    } while (true);
                }
                n = n2 + 1;
            }
            return object.toByteArray();
        }
    }

}

