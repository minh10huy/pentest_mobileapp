/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.Glyph;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.TrueTypeFont;
import com.itextpdf.text.pdf.TtfUnicodeWriter;
import com.itextpdf.text.pdf.fonts.otf.GlyphSubstitutionTableReader;
import com.itextpdf.text.pdf.fonts.otf.Language;
import com.itextpdf.text.pdf.languages.ArabicLigaturizer;
import java.io.IOException;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

class TrueTypeFontUnicode
extends TrueTypeFont
implements Comparator<int[]> {
    private static final List<Language> SUPPORTED_LANGUAGES_FOR_OTF = Arrays.asList(new Language[]{Language.BENGALI});
    private static final byte[] rotbits = new byte[]{-128, 64, 32, 16, 8, 4, 2, 1};
    private Map<String, Glyph> glyphSubstitutionMap;
    private Language supportedLanguage;

    TrueTypeFontUnicode(String charSequence, String string2, boolean bl, byte[] arrby, boolean bl2) throws DocumentException, IOException {
        String string3 = TrueTypeFontUnicode.getBaseName((String)charSequence);
        String string4 = TrueTypeFontUnicode.getTTCName(string3);
        if (string3.length() < charSequence.length()) {
            this.style = charSequence.substring(string3.length());
        }
        this.encoding = string2;
        this.embedded = bl;
        this.fileName = string4;
        this.ttcIndex = "";
        if (string4.length() < string3.length()) {
            this.ttcIndex = string3.substring(string4.length() + 1);
        }
        this.fontType = 3;
        if ((this.fileName.toLowerCase().endsWith(".ttf") || this.fileName.toLowerCase().endsWith(".otf") || this.fileName.toLowerCase().endsWith(".ttc")) && (string2.equals("Identity-H") || string2.equals("Identity-V")) && bl) {
            this.process(arrby, bl2);
            if (this.os_2.fsType == 2) {
                charSequence = new StringBuilder();
                charSequence.append(this.fileName);
                charSequence.append(this.style);
                throw new DocumentException(MessageLocalization.getComposedMessage("1.cannot.be.embedded.due.to.licensing.restrictions", charSequence.toString()));
            }
            if (this.cmap31 == null && !this.fontSpecific || this.cmap10 == null && this.fontSpecific) {
                this.directTextToByte = true;
            }
            if (this.fontSpecific) {
                this.fontSpecific = false;
                charSequence = this.encoding;
                this.encoding = "";
                this.createEncoding();
                this.encoding = charSequence;
                this.fontSpecific = true;
            }
            this.vertical = string2.endsWith("V");
            return;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("1.2.is.not.a.ttf.font.file", this.fileName, this.style));
    }

    private void readGsubTable() throws IOException {
        if (this.tables.get("GSUB") != null) {
            Object object = new HashMap<Integer, Character>(this.cmap31.size());
            for (Integer n : this.cmap31.keySet()) {
                char c = (char)n.intValue();
                object.put(((int[])this.cmap31.get(n))[0], (Character)Character.valueOf(c));
            }
            object = new GlyphSubstitutionTableReader(this.rf, ((int[])this.tables.get("GSUB"))[0], (Map<Integer, Character>)object, this.glyphWidthsByIndex);
            try {
                object.read();
                this.supportedLanguage = object.getSupportedLanguage();
                if (SUPPORTED_LANGUAGES_FOR_OTF.contains((Object)this.supportedLanguage)) {
                    this.glyphSubstitutionMap = object.getGlyphSubstitutionMap();
                    return;
                }
            }
            catch (Exception exception) {
                exception.printStackTrace();
            }
        }
    }

    static String toHex(int n) {
        if (n < 65536) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("<");
            stringBuilder.append(TrueTypeFontUnicode.toHex4(n));
            stringBuilder.append(">");
            return stringBuilder.toString();
        }
        int n2 = (n -= 65536) / 1024;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("[<");
        stringBuilder.append(TrueTypeFontUnicode.toHex4(n2 + 55296));
        stringBuilder.append(TrueTypeFontUnicode.toHex4(n % 1024 + 56320));
        stringBuilder.append(">]");
        return stringBuilder.toString();
    }

    private static String toHex4(int n) {
        CharSequence charSequence = new StringBuilder();
        charSequence.append("0000");
        charSequence.append(Integer.toHexString(n));
        charSequence = charSequence.toString();
        return charSequence.substring(charSequence.length() - 4);
    }

    public int GetCharFromGlyphId(int n) {
        if (this.glyphIdToChar == null) {
            int[] arrn = new int[this.maxGlyphId];
            Object object = null;
            if (this.cmapExt != null) {
                object = this.cmapExt;
            } else if (this.cmap31 != null) {
                object = this.cmap31;
            }
            if (object != null) {
                for (Map.Entry entry : object.entrySet()) {
                    arrn[((int[])entry.getValue())[0]] = (Integer)entry.getKey();
                }
            }
            this.glyphIdToChar = arrn;
        }
        return this.glyphIdToChar[n];
    }

    @Override
    public boolean charExists(int n) {
        if (this.getMetricsTT(n) != null) {
            return true;
        }
        return false;
    }

    @Override
    public int compare(int[] arrn, int[] arrn2) {
        int n = arrn[0];
        int n2 = arrn2[0];
        if (n < n2) {
            return -1;
        }
        if (n == n2) {
            return 0;
        }
        return 1;
    }

    @Override
    byte[] convertToBytes(int n) {
        return null;
    }

    @Override
    public byte[] convertToBytes(String string2) {
        return null;
    }

    public PdfDictionary getCIDFontType2(PdfIndirectReference serializable, String arrn, Object[] arrobject) {
        PdfName pdfName;
        StringBuilder stringBuilder;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        if (this.cff) {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.CIDFONTTYPE0);
            pdfName = PdfName.BASEFONT;
            stringBuilder = new StringBuilder();
            stringBuilder.append((String)arrn);
            stringBuilder.append(this.fontName);
            stringBuilder.append("-");
            stringBuilder.append(this.encoding);
            pdfDictionary.put(pdfName, new PdfName(stringBuilder.toString()));
        } else {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.CIDFONTTYPE2);
            pdfName = PdfName.BASEFONT;
            stringBuilder = new StringBuilder();
            stringBuilder.append((String)arrn);
            stringBuilder.append(this.fontName);
            pdfDictionary.put(pdfName, new PdfName(stringBuilder.toString()));
        }
        pdfDictionary.put(PdfName.FONTDESCRIPTOR, (PdfObject)serializable);
        if (!this.cff) {
            pdfDictionary.put(PdfName.CIDTOGIDMAP, PdfName.IDENTITY);
        }
        serializable = new PdfDictionary();
        serializable.put(PdfName.REGISTRY, new PdfString("Adobe"));
        serializable.put(PdfName.ORDERING, new PdfString("Identity"));
        serializable.put(PdfName.SUPPLEMENT, new PdfNumber(0));
        pdfDictionary.put(PdfName.CIDSYSTEMINFO, (PdfObject)serializable);
        if (!this.vertical) {
            pdfDictionary.put(PdfName.DW, new PdfNumber(1000));
            serializable = new StringBuffer("[");
            int n = -10;
            boolean bl = true;
            for (int i = 0; i < arrobject.length; ++i) {
                arrn = (int[])arrobject[i];
                if (arrn[1] == 1000) continue;
                int n2 = arrn[0];
                if (n2 == n + 1) {
                    serializable.append(' ');
                    serializable.append(arrn[1]);
                } else {
                    if (!bl) {
                        serializable.append(']');
                    }
                    serializable.append(n2);
                    serializable.append('[');
                    serializable.append(arrn[1]);
                    bl = false;
                }
                n = n2;
            }
            if (serializable.length() > 1) {
                serializable.append("]]");
                pdfDictionary.put(PdfName.W, new PdfLiteral(serializable.toString()));
            }
        }
        return pdfDictionary;
    }

    @Override
    public int[] getCharBBox(int n) {
        if (this.bboxes == null) {
            return null;
        }
        int[] arrn = this.getMetricsTT(n);
        if (arrn == null) {
            return null;
        }
        return this.bboxes[arrn[0]];
    }

    public PdfDictionary getFontBaseType(PdfIndirectReference pdfIndirectReference, String string2, PdfIndirectReference pdfIndirectReference2) {
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        pdfDictionary.put(PdfName.SUBTYPE, PdfName.TYPE0);
        if (this.cff) {
            PdfName pdfName = PdfName.BASEFONT;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(string2);
            stringBuilder.append(this.fontName);
            stringBuilder.append("-");
            stringBuilder.append(this.encoding);
            pdfDictionary.put(pdfName, new PdfName(stringBuilder.toString()));
        } else {
            PdfName pdfName = PdfName.BASEFONT;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(string2);
            stringBuilder.append(this.fontName);
            pdfDictionary.put(pdfName, new PdfName(stringBuilder.toString()));
        }
        pdfDictionary.put(PdfName.ENCODING, new PdfName(this.encoding));
        pdfDictionary.put(PdfName.DESCENDANTFONTS, new PdfArray(pdfIndirectReference));
        if (pdfIndirectReference2 != null) {
            pdfDictionary.put(PdfName.TOUNICODE, pdfIndirectReference2);
        }
        return pdfDictionary;
    }

    @Override
    public PdfStream getFullFontStream() throws IOException, DocumentException {
        if (this.cff) {
            return new BaseFont.StreamFont(this.readCffFont(), "CIDFontType0C", this.compressionLevel);
        }
        return super.getFullFontStream();
    }

    protected Map<String, Glyph> getGlyphSubstitutionMap() {
        return this.glyphSubstitutionMap;
    }

    @Override
    public int[] getMetricsTT(int n) {
        int[] arrn;
        if (this.cmapExt != null) {
            return (int[])this.cmapExt.get(n);
        }
        HashMap hashMap = this.fontSpecific ? this.cmap10 : this.cmap31;
        if (hashMap == null) {
            return null;
        }
        if (this.fontSpecific) {
            int n2 = n & -256;
            if (n2 != 0 && n2 != 61440) {
                return null;
            }
            return (int[])hashMap.get(n & 255);
        }
        int[] arrn2 = arrn = (int[])hashMap.get(n);
        if (arrn == null) {
            Character c = ArabicLigaturizer.getReverseMapping((char)n);
            arrn2 = arrn;
            if (c != null) {
                arrn2 = (int[])hashMap.get(Integer.valueOf(c.charValue()));
            }
        }
        return arrn2;
    }

    Language getSupportedLanguage() {
        return this.supportedLanguage;
    }

    public PdfStream getToUnicode(Object[] object) {
        if (((Object[])object).length == 0) {
            return null;
        }
        StringBuffer stringBuffer = new StringBuffer("/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo\n<< /Registry (TTX+0)\n/Ordering (T42UV)\n/Supplement 0\n>> def\n/CMapName /TTX+0 def\n/CMapType 2 def\n1 begincodespacerange\n<0000><FFFF>\nendcodespacerange\n");
        int n = 0;
        for (int i = 0; i < ((Object[])object).length; ++i) {
            int n2 = n;
            if (n == 0) {
                if (i != 0) {
                    stringBuffer.append("endbfrange\n");
                }
                n2 = Math.min(100, ((Object[])object).length - i);
                stringBuffer.append(n2);
                stringBuffer.append(" beginbfrange\n");
            }
            n = n2 - 1;
            int[] arrn = (int[])object[i];
            String string2 = TrueTypeFontUnicode.toHex(arrn[0]);
            stringBuffer.append(string2);
            stringBuffer.append(string2);
            stringBuffer.append(TrueTypeFontUnicode.toHex(arrn[2]));
            stringBuffer.append('\n');
        }
        stringBuffer.append("endbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend end\n");
        object = new PdfStream(PdfEncodings.convertToBytes(stringBuffer.toString(), null));
        object.flateCompress(this.compressionLevel);
        return object;
    }

    @Override
    public int getWidth(int n) {
        if (this.vertical) {
            return 1000;
        }
        if (this.fontSpecific) {
            int n2 = 65280 & n;
            if (n2 != 0 && n2 != 61440) {
                return 0;
            }
            return this.getRawWidth(n & 255, null);
        }
        return this.getRawWidth(n, this.encoding);
    }

    @Override
    public int getWidth(String arrc) {
        int n;
        block8 : {
            int n2;
            int n3;
            block9 : {
                if (this.vertical) {
                    return arrc.length() * 1000;
                }
                boolean bl = this.fontSpecific;
                n3 = 0;
                n2 = 0;
                if (!bl) break block9;
                arrc = arrc.toCharArray();
                int n4 = arrc.length;
                n3 = 0;
                do {
                    block11 : {
                        char c;
                        block10 : {
                            n = n3;
                            if (n2 >= n4) break block8;
                            c = arrc[n2];
                            int n5 = 65280 & c;
                            if (n5 == 0) break block10;
                            n = n3;
                            if (n5 != 61440) break block11;
                        }
                        n = n3 + this.getRawWidth(c & 255, null);
                    }
                    ++n2;
                    n3 = n;
                } while (true);
            }
            int n6 = arrc.length();
            n2 = 0;
            do {
                n = n2;
                if (n3 >= n6) break;
                if (Utilities.isSurrogatePair((String)arrc, n3)) {
                    n2 += this.getRawWidth(Utilities.convertToUtf32((String)arrc, n3), this.encoding);
                    ++n3;
                } else {
                    n2 += this.getRawWidth(arrc.charAt(n3), this.encoding);
                }
                ++n3;
            } while (true);
        }
        return n;
    }

    @Override
    void process(byte[] arrby, boolean bl) throws DocumentException, IOException {
        super.process(arrby, bl);
    }

    @Override
    public boolean setCharAdvance(int n, int n2) {
        int[] arrn = this.getMetricsTT(n);
        if (arrn == null) {
            return false;
        }
        arrn[1] = n2;
        return true;
    }

    @Override
    void writeFont(PdfWriter pdfWriter, PdfIndirectReference pdfIndirectReference, Object[] arrobject) throws DocumentException, IOException {
        pdfWriter.getTtfUnicodeWriter().writeFont(this, pdfIndirectReference, arrobject, rotbits);
    }
}

