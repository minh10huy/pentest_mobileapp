/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Clipper;
import com.itextpdf.text.pdf.parser.clipper.Edge;
import com.itextpdf.text.pdf.parser.clipper.Path;
import com.itextpdf.text.pdf.parser.clipper.Paths;
import com.itextpdf.text.pdf.parser.clipper.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

public abstract class ClipperBase
implements Clipper {
    private static final long HI_RANGE = 0x3FFFFFFFFFFFFFFFL;
    private static final Logger LOGGER = Logger.getLogger(Clipper.class.getName());
    private static final long LOW_RANGE = 0x3FFFFFFFL;
    protected LocalMinima currentLM;
    private final List<List<Edge>> edges;
    protected boolean hasOpenPaths;
    protected LocalMinima minimaList;
    protected final boolean preserveCollinear;
    protected boolean useFullRange;

    protected ClipperBase(boolean bl) {
        this.preserveCollinear = bl;
        this.minimaList = null;
        this.currentLM = null;
        this.hasOpenPaths = false;
        this.edges = new ArrayList<List<Edge>>();
    }

    private void disposeLocalMinimaList() {
        while (this.minimaList != null) {
            LocalMinima localMinima = this.minimaList.next;
            this.minimaList = null;
            this.minimaList = localMinima;
        }
        this.currentLM = null;
    }

    private static void initEdge(Edge edge, Edge edge2, Edge edge3, Point.LongPoint longPoint) {
        edge.next = edge2;
        edge.prev = edge3;
        edge.setCurrent(new Point.LongPoint(longPoint));
        edge.outIdx = -1;
    }

    private static void initEdge2(Edge edge, Clipper.PolyType polyType) {
        if (edge.getCurrent().getY() >= edge.next.getCurrent().getY()) {
            edge.setBot(new Point.LongPoint(edge.getCurrent()));
            edge.setTop(new Point.LongPoint(edge.next.getCurrent()));
        } else {
            edge.setTop(new Point.LongPoint(edge.getCurrent()));
            edge.setBot(new Point.LongPoint(edge.next.getCurrent()));
        }
        edge.updateDeltaX();
        edge.polyTyp = polyType;
    }

    private void insertLocalMinima(LocalMinima localMinima) {
        if (this.minimaList == null) {
            this.minimaList = localMinima;
            return;
        }
        if (localMinima.y >= this.minimaList.y) {
            localMinima.next = this.minimaList;
            this.minimaList = localMinima;
            return;
        }
        LocalMinima localMinima2 = this.minimaList;
        while (localMinima2.next != null && localMinima.y < localMinima2.next.y) {
            localMinima2 = localMinima2.next;
        }
        localMinima.next = localMinima2.next;
        localMinima2.next = localMinima;
    }

    protected static Path.OutRec parseFirstLeft(Path.OutRec outRec) {
        while (outRec != null && outRec.getPoints() == null) {
            outRec = outRec.firstLeft;
        }
        return outRec;
    }

    private Edge processBound(Edge edge, boolean bl) {
        Edge edge2;
        Edge edge3;
        block34 : {
            block35 : {
                if (edge.outIdx == -2) {
                    Object object;
                    Edge edge4;
                    if (bl) {
                        edge4 = edge;
                        do {
                            object = edge4;
                            if (edge4.getTop().getY() != edge4.next.getBot().getY()) break;
                            edge4 = edge4.next;
                        } while (true);
                        do {
                            edge4 = object;
                            if (object != edge) {
                                edge4 = object;
                                if (object.deltaX == -3.4E38) {
                                    object = object.prev;
                                    continue;
                                }
                            }
                            break;
                        } while (true);
                    } else {
                        edge4 = edge;
                        do {
                            object = edge4;
                            if (edge4.getTop().getY() != edge4.prev.getBot().getY()) break;
                            edge4 = edge4.prev;
                        } while (true);
                        do {
                            edge4 = object;
                            if (object == edge) break;
                            edge4 = object;
                            if (object.deltaX != -3.4E38) break;
                            object = object.next;
                        } while (true);
                    }
                    if (edge4 == edge) {
                        if (bl) {
                            return edge4.next;
                        }
                        return edge4.prev;
                    }
                    edge = bl ? edge.next : edge.prev;
                    object = new LocalMinima();
                    object.next = null;
                    object.y = edge.getBot().getY();
                    object.leftBound = null;
                    object.rightBound = edge;
                    edge.windDelta = 0;
                    edge = this.processBound(edge, bl);
                    this.insertLocalMinima((LocalMinima)object);
                    return edge;
                }
                if (edge.deltaX == -3.4E38) {
                    edge3 = bl ? edge.prev : edge.next;
                    if (edge3.deltaX == -3.4E38) {
                        if (edge3.getBot().getX() != edge.getBot().getX() && edge3.getTop().getX() != edge.getBot().getX()) {
                            edge.reverseHorizontal();
                        }
                    } else if (edge3.getBot().getX() != edge.getBot().getX()) {
                        edge.reverseHorizontal();
                    }
                }
                if (bl) {
                    edge3 = edge;
                    while (edge3.getTop().getY() == edge3.next.getBot().getY() && edge3.next.outIdx != -2) {
                        edge3 = edge3.next;
                    }
                    Edge edge5 = edge3;
                    if (edge3.deltaX == -3.4E38) {
                        edge5 = edge3;
                        if (edge3.next.outIdx != -2) {
                            Edge edge6 = edge3;
                            while (edge6.prev.deltaX == -3.4E38) {
                                edge6 = edge6.prev;
                            }
                            edge5 = edge3;
                            if (edge6.prev.getTop().getX() > edge3.next.getTop().getX()) {
                                edge5 = edge6.prev;
                            }
                        }
                    }
                    edge3 = edge;
                    while (edge3 != edge5) {
                        edge3.nextInLML = edge3.next;
                        if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.prev.getTop().getX()) {
                            edge3.reverseHorizontal();
                        }
                        edge3 = edge3.next;
                    }
                    if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.prev.getTop().getX()) {
                        edge3.reverseHorizontal();
                    }
                    return edge5.next;
                }
                edge3 = edge;
                while (edge3.getTop().getY() == edge3.prev.getBot().getY() && edge3.prev.outIdx != -2) {
                    edge3 = edge3.prev;
                }
                edge2 = edge3;
                if (edge3.deltaX != -3.4E38) break block34;
                edge2 = edge3;
                if (edge3.prev.outIdx == -2) break block34;
                Edge edge7 = edge3;
                while (edge7.next.deltaX == -3.4E38) {
                    edge7 = edge7.next;
                }
                if (edge7.next.getTop().getX() == edge3.prev.getTop().getX()) break block35;
                edge2 = edge3;
                if (edge7.next.getTop().getX() <= edge3.prev.getTop().getX()) break block34;
            }
            edge2 = edge7.next;
        }
        edge3 = edge;
        while (edge3 != edge2) {
            edge3.nextInLML = edge3.prev;
            if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.next.getTop().getX()) {
                edge3.reverseHorizontal();
            }
            edge3 = edge3.prev;
        }
        if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.next.getTop().getX()) {
            edge3.reverseHorizontal();
        }
        return edge2.prev;
    }

    private static boolean rangeTest(Point.LongPoint longPoint, boolean bl) {
        block7 : {
            block6 : {
                block5 : {
                    if (!bl) break block5;
                    if (longPoint.getX() > 0x3FFFFFFFFFFFFFFFL || longPoint.getY() > 0x3FFFFFFFFFFFFFFFL || - longPoint.getX() > 0x3FFFFFFFFFFFFFFFL || - longPoint.getY() > 0x3FFFFFFFFFFFFFFFL) {
                        throw new IllegalStateException("Coordinate outside allowed range");
                    }
                    break block6;
                }
                if (longPoint.getX() > 0x3FFFFFFFL || longPoint.getY() > 0x3FFFFFFFL || - longPoint.getX() > 0x3FFFFFFFL || - longPoint.getY() > 0x3FFFFFFFL) break block7;
            }
            return bl;
        }
        return ClipperBase.rangeTest(longPoint, true);
    }

    private static Edge removeEdge(Edge edge) {
        edge.prev.next = edge.next;
        edge.next.prev = edge.prev;
        Edge edge2 = edge.next;
        edge.prev = null;
        return edge2;
    }

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public boolean addPath(Path object, Clipper.PolyType object2, boolean bl) {
        Edge edge;
        void var2_17;
        Object object3;
        void var1_3;
        int n;
        ArrayList<Edge> arrayList;
        void var3_23;
        int n2;
        Edge edge2;
        block36 : {
            Edge edge3;
            if (var3_23 == false && var2_17 == Clipper.PolyType.CLIP) {
                throw new IllegalStateException("AddPath: Open paths must be subject.");
            }
            n2 = n = object.size() - 1;
            if (var3_23 != false) {
                do {
                    n2 = n;
                    if (n <= 0) break;
                    n2 = n;
                    if (!((Point.LongPoint)object.get(n)).equals(object.get(0))) break;
                    --n;
                } while (true);
            }
            while (n2 > 0 && ((Point.LongPoint)object.get(n2)).equals(object.get(n2 - 1))) {
                --n2;
            }
            if (var3_23 != false && n2 < 2 || var3_23 == false && n2 < 1) {
                return false;
            }
            arrayList = new ArrayList<Edge>(n2 + 1);
            for (n = 0; n <= n2; ++n) {
                arrayList.add(new Edge());
            }
            ((Edge)arrayList.get(1)).setCurrent(new Point.LongPoint((Point.LongPoint)object.get(1)));
            this.useFullRange = ClipperBase.rangeTest((Point.LongPoint)object.get(0), this.useFullRange);
            this.useFullRange = ClipperBase.rangeTest((Point.LongPoint)object.get(n2), this.useFullRange);
            ClipperBase.initEdge((Edge)arrayList.get(0), (Edge)arrayList.get(1), (Edge)arrayList.get(n2), (Point.LongPoint)object.get(0));
            edge = (Edge)arrayList.get(n2);
            edge2 = (Edge)arrayList.get(0);
            n = n2 - 1;
            ClipperBase.initEdge(edge, edge2, (Edge)arrayList.get(n), (Point.LongPoint)object.get(n2));
            for (n2 = n; n2 >= 1; --n2) {
                this.useFullRange = ClipperBase.rangeTest((Point.LongPoint)object.get(n2), this.useFullRange);
                ClipperBase.initEdge((Edge)arrayList.get(n2), (Edge)arrayList.get(n2 + 1), (Edge)arrayList.get(n2 - 1), (Point.LongPoint)object.get(n2));
            }
            edge2 = edge3 = (edge = (Edge)arrayList.get(0));
            do {
                block39 : {
                    block38 : {
                        block37 : {
                            if (!edge.getCurrent().equals(edge.next.getCurrent()) || var3_23 == false && edge.next.equals(var1_3)) break block37;
                            if (edge == edge.next) break block36;
                            edge2 = var1_3;
                            if (edge == var1_3) {
                                edge2 = edge.next;
                            }
                            edge = ClipperBase.removeEdge(edge);
                            Edge edge4 = edge2;
                            break block38;
                        }
                        if (edge.prev == edge.next) break block36;
                        if (var3_23 == false || !Point.slopesEqual(edge.prev.getCurrent(), edge.getCurrent(), edge.next.getCurrent(), this.useFullRange) || this.isPreserveCollinear() && Point.isPt2BetweenPt1AndPt3(edge.prev.getCurrent(), edge.getCurrent(), edge.next.getCurrent())) break block39;
                        edge2 = var1_3;
                        if (edge == var1_3) {
                            edge2 = edge.next;
                        }
                        edge = ClipperBase.removeEdge((Edge)edge).prev;
                        Edge edge5 = edge2;
                    }
                    object3 = edge;
                    edge2 = edge;
                    edge = object3;
                    continue;
                }
                object3 = edge.next;
                edge = object3;
                if (object3 == edge2) break block36;
                edge = object3;
                if (var3_23 != false) continue;
                edge = object3;
                if (object3.next == var1_3) break;
            } while (true);
            edge = object3;
        }
        if (var3_23 == false && edge == edge.next || var3_23 != false && edge.prev == edge.next) {
            return false;
        }
        if (var3_23 == false) {
            this.hasOpenPaths = true;
            var1_3.prev.outIdx = -2;
        }
        edge2 = var1_3;
        n2 = 1;
        do {
            ClipperBase.initEdge2(edge2, (Clipper.PolyType)var2_17);
            edge = edge2.next;
            n = n2;
            if (n2 != 0) {
                n = n2;
                if (edge.getCurrent().getY() != var1_3.getCurrent().getY()) {
                    n = 0;
                }
            }
            edge2 = edge;
            n2 = n;
        } while (edge != var1_3);
        if (n == 0) {
            this.edges.add(arrayList);
            Edge edge6 = edge;
            if (edge.prev.getBot().equals(edge.prev.getTop())) {
                Edge edge7 = edge.next;
            }
        } else {
            if (var3_23 != false) {
                return false;
            }
            edge.prev.outIdx = -2;
            LocalMinima localMinima = new LocalMinima();
            localMinima.next = null;
            localMinima.y = edge.getBot().getY();
            localMinima.leftBound = null;
            localMinima.rightBound = edge;
            localMinima.rightBound.side = Edge.Side.RIGHT;
            localMinima.rightBound.windDelta = 0;
            do {
                if (edge.getBot().getX() != edge.prev.getTop().getX()) {
                    edge.reverseHorizontal();
                }
                if (edge.next.outIdx == -2) {
                    this.insertLocalMinima(localMinima);
                    this.edges.add(arrayList);
                    return true;
                }
                edge.nextInLML = edge.next;
                edge = edge.next;
            } while (true);
        }
        edge2 = null;
        Edge edge8;
        void var1_11;
        while ((edge8 = var1_11.findNextLocMin()) != edge2) {
            void var2_22;
            Edge edge9;
            boolean bl2;
            edge = edge2;
            if (edge2 == null) {
                edge = edge8;
            }
            object3 = new LocalMinima();
            object3.next = null;
            object3.y = edge8.getBot().getY();
            if (edge8.deltaX < edge8.prev.deltaX) {
                object3.leftBound = edge8.prev;
                object3.rightBound = edge8;
                bl2 = false;
            } else {
                object3.leftBound = edge8;
                object3.rightBound = edge8.prev;
                bl2 = true;
            }
            object3.leftBound.side = Edge.Side.LEFT;
            object3.rightBound.side = Edge.Side.RIGHT;
            object3.leftBound.windDelta = var3_23 == false ? 0 : (object3.leftBound.next == object3.rightBound ? -1 : 1);
            object3.rightBound.windDelta = - object3.leftBound.windDelta;
            Edge edge10 = edge9 = this.processBound(object3.leftBound, bl2);
            if (edge9.outIdx == -2) {
                Edge edge11 = this.processBound(edge9, bl2);
            }
            Edge edge12 = edge2 = this.processBound(object3.rightBound, bl2 ^ true);
            if (edge2.outIdx == -2) {
                Edge edge13 = this.processBound(edge2, bl2 ^ true);
            }
            if (object3.leftBound.outIdx == -2) {
                object3.leftBound = null;
            } else if (object3.rightBound.outIdx == -2) {
                object3.rightBound = null;
            }
            this.insertLocalMinima((LocalMinima)object3);
            edge2 = edge;
            if (bl2) continue;
            void var1_16 = var2_22;
            edge2 = edge;
        }
        return true;
    }

    @Override
    public boolean addPaths(Paths paths, Clipper.PolyType polyType, boolean bl) {
        boolean bl2 = false;
        for (int i = 0; i < paths.size(); ++i) {
            if (!this.addPath((Path)paths.get(i), polyType, bl)) continue;
            bl2 = true;
        }
        return bl2;
    }

    @Override
    public void clear() {
        this.disposeLocalMinimaList();
        this.edges.clear();
        this.useFullRange = false;
        this.hasOpenPaths = false;
    }

    public boolean isPreserveCollinear() {
        return this.preserveCollinear;
    }

    protected void popLocalMinima() {
        LOGGER.entering(ClipperBase.class.getName(), "popLocalMinima");
        if (this.currentLM == null) {
            return;
        }
        this.currentLM = this.currentLM.next;
    }

    protected void reset() {
        this.currentLM = this.minimaList;
        if (this.currentLM == null) {
            return;
        }
        LocalMinima localMinima = this.minimaList;
        while (localMinima != null) {
            Edge edge = localMinima.leftBound;
            if (edge != null) {
                edge.setCurrent(new Point.LongPoint(edge.getBot()));
                edge.side = Edge.Side.LEFT;
                edge.outIdx = -1;
            }
            if ((edge = localMinima.rightBound) != null) {
                edge.setCurrent(new Point.LongPoint(edge.getBot()));
                edge.side = Edge.Side.RIGHT;
                edge.outIdx = -1;
            }
            localMinima = localMinima.next;
        }
    }

    protected class LocalMinima {
        Edge leftBound;
        LocalMinima next;
        Edge rightBound;
        long y;

        protected LocalMinima() {
        }
    }

    protected class Scanbeam {
        Scanbeam next;
        long y;

        protected Scanbeam() {
        }
    }

}

