/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocWriter;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.BadPasswordException;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.OutputStreamEncryption;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfPublicKeyRecipient;
import com.itextpdf.text.pdf.PdfPublicKeySecurityHandler;
import com.itextpdf.text.pdf.StandardDecryption;
import com.itextpdf.text.pdf.StringUtils;
import com.itextpdf.text.pdf.crypto.AESCipherCBCnoPad;
import com.itextpdf.text.pdf.crypto.ARCFOUREncryption;
import com.itextpdf.text.pdf.crypto.IVGenerator;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.MessageDigest;
import java.security.cert.Certificate;

public class PdfEncryption {
    public static final int AES_128 = 4;
    public static final int AES_256 = 5;
    private static final int KEY_SALT_OFFSET = 40;
    private static final int OU_LENGHT = 48;
    private static final int SALT_LENGHT = 8;
    public static final int STANDARD_ENCRYPTION_128 = 3;
    public static final int STANDARD_ENCRYPTION_40 = 2;
    private static final int VALIDATION_SALT_OFFSET = 32;
    private static final byte[] metadataPad;
    private static final byte[] pad;
    private static final byte[] salt;
    static long seq;
    private ARCFOUREncryption arcfour = new ARCFOUREncryption();
    private int cryptoMode;
    byte[] documentID;
    private boolean embeddedFilesOnly;
    private boolean encryptMetadata;
    byte[] extra = new byte[5];
    byte[] key;
    private int keyLength;
    int keySize;
    MessageDigest md5;
    byte[] mkey = new byte[0];
    byte[] oeKey;
    byte[] ownerKey = new byte[32];
    long permissions;
    byte[] perms;
    protected PdfPublicKeySecurityHandler publicKeyHandler = null;
    private int revision;
    byte[] ueKey;
    byte[] userKey = new byte[32];

    static {
        pad = new byte[]{40, -65, 78, 94, 78, 117, -118, 65, 100, 0, 78, 86, -1, -6, 1, 8, 46, 46, 0, -74, -48, 104, 62, -128, 47, 12, -87, -2, 100, 83, 105, 122};
        salt = new byte[]{115, 65, 108, 84};
        metadataPad = new byte[]{-1, -1, -1, -1};
        seq = System.currentTimeMillis();
    }

    public PdfEncryption() {
        try {
            this.md5 = MessageDigest.getInstance("MD5");
            this.publicKeyHandler = new PdfPublicKeySecurityHandler();
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public PdfEncryption(PdfEncryption pdfEncryption) {
        this();
        if (pdfEncryption.key != null) {
            this.key = (byte[])pdfEncryption.key.clone();
        }
        this.keySize = pdfEncryption.keySize;
        this.mkey = (byte[])pdfEncryption.mkey.clone();
        this.ownerKey = (byte[])pdfEncryption.ownerKey.clone();
        this.userKey = (byte[])pdfEncryption.userKey.clone();
        this.permissions = pdfEncryption.permissions;
        if (pdfEncryption.documentID != null) {
            this.documentID = (byte[])pdfEncryption.documentID.clone();
        }
        this.revision = pdfEncryption.revision;
        this.keyLength = pdfEncryption.keyLength;
        this.encryptMetadata = pdfEncryption.encryptMetadata;
        this.embeddedFilesOnly = pdfEncryption.embeddedFilesOnly;
        this.publicKeyHandler = pdfEncryption.publicKeyHandler;
        if (pdfEncryption.ueKey != null) {
            this.ueKey = (byte[])pdfEncryption.ueKey.clone();
        }
        if (pdfEncryption.oeKey != null) {
            this.oeKey = (byte[])pdfEncryption.oeKey.clone();
        }
        if (pdfEncryption.perms != null) {
            this.perms = (byte[])pdfEncryption.perms.clone();
        }
    }

    private static boolean compareArray(byte[] arrby, byte[] arrby2, int n) {
        for (int i = 0; i < n; ++i) {
            if (arrby[i] == arrby2[i]) continue;
            return false;
        }
        return true;
    }

    private byte[] computeOwnerKey(byte[] arrby, byte[] arrby2) {
        int n;
        byte[] arrby3 = new byte[32];
        arrby2 = this.md5.digest(arrby2);
        if (this.revision != 3 && this.revision != 4) {
            this.arcfour.prepareARCFOURKey(arrby2, 0, 5);
            this.arcfour.encryptARCFOUR(arrby, arrby3);
            return arrby3;
        }
        byte[] arrby4 = new byte[this.keyLength / 8];
        for (n = 0; n < 50; ++n) {
            this.md5.update(arrby2, 0, arrby4.length);
            System.arraycopy(this.md5.digest(), 0, arrby2, 0, arrby4.length);
        }
        System.arraycopy(arrby, 0, arrby3, 0, 32);
        for (n = 0; n < 20; ++n) {
            for (int i = 0; i < arrby4.length; ++i) {
                arrby4[i] = (byte)(arrby2[i] ^ n);
            }
            this.arcfour.prepareARCFOURKey(arrby4);
            this.arcfour.encryptARCFOUR(arrby3);
        }
        return arrby3;
    }

    public static byte[] createDocumentId() {
        MessageDigest messageDigest;
        try {
            messageDigest = MessageDigest.getInstance("MD5");
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
        long l = System.currentTimeMillis();
        long l2 = Runtime.getRuntime().freeMemory();
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(l);
        stringBuilder.append("+");
        stringBuilder.append(l2);
        stringBuilder.append("+");
        l = seq;
        seq = l + 1L;
        stringBuilder.append(l);
        return messageDigest.digest(stringBuilder.toString().getBytes());
    }

    public static PdfObject createInfoId(byte[] arrby, boolean bl) throws IOException {
        int n;
        ByteBuffer byteBuffer = new ByteBuffer(90);
        byte[] arrby2 = arrby;
        if (arrby.length == 0) {
            arrby2 = PdfEncryption.createDocumentId();
        }
        byteBuffer.append('[').append('<');
        int n2 = 0;
        for (n = 0; n < arrby2.length; ++n) {
            byteBuffer.appendHex(arrby2[n]);
        }
        byteBuffer.append('>').append('<');
        n = n2;
        if (bl) {
            arrby2 = PdfEncryption.createDocumentId();
            n = n2;
        }
        while (n < arrby2.length) {
            byteBuffer.appendHex(arrby2[n]);
            ++n;
        }
        byteBuffer.append('>').append(']');
        byteBuffer.close();
        return new PdfLiteral(byteBuffer.toByteArray());
    }

    private byte[] padPassword(byte[] arrby) {
        byte[] arrby2 = new byte[32];
        if (arrby == null) {
            System.arraycopy(pad, 0, arrby2, 0, 32);
            return arrby2;
        }
        System.arraycopy(arrby, 0, arrby2, 0, Math.min(arrby.length, 32));
        if (arrby.length < 32) {
            System.arraycopy(pad, 0, arrby2, arrby.length, 32 - arrby.length);
        }
        return arrby2;
    }

    private void setupByOwnerPad(byte[] arrby, byte[] arrby2, byte[] arrby3, byte[] arrby4, long l) {
        this.setupGlobalEncryptionKey(arrby, this.computeOwnerKey(arrby4, arrby2), arrby4, l);
        this.setupUserKey();
    }

    private void setupByUserPad(byte[] arrby, byte[] arrby2, byte[] arrby3, long l) {
        this.setupGlobalEncryptionKey(arrby, arrby2, arrby3, l);
        this.setupUserKey();
    }

    private void setupGlobalEncryptionKey(byte[] arrby, byte[] arrby2, byte[] arrby3, long l) {
        this.documentID = arrby;
        this.ownerKey = arrby3;
        this.permissions = l;
        this.mkey = new byte[this.keyLength / 8];
        this.md5.reset();
        this.md5.update(arrby2);
        this.md5.update(arrby3);
        byte by = (byte)l;
        byte by2 = (byte)(l >> 8);
        byte by3 = (byte)(l >> 16);
        byte by4 = (byte)(l >> 24);
        this.md5.update(new byte[]{by, by2, by3, by4}, 0, 4);
        if (arrby != null) {
            this.md5.update(arrby);
        }
        if (!this.encryptMetadata) {
            this.md5.update(metadataPad);
        }
        arrby = new byte[this.mkey.length];
        System.arraycopy(this.md5.digest(), 0, arrby, 0, this.mkey.length);
        if (this.revision == 3 || this.revision == 4) {
            for (int i = 0; i < 50; ++i) {
                System.arraycopy(this.md5.digest(arrby), 0, arrby, 0, this.mkey.length);
            }
        }
        System.arraycopy(arrby, 0, this.mkey, 0, this.mkey.length);
    }

    private void setupUserKey() {
        int n;
        if (this.revision != 3 && this.revision != 4) {
            this.arcfour.prepareARCFOURKey(this.mkey);
            this.arcfour.encryptARCFOUR(pad, this.userKey);
            return;
        }
        this.md5.update(pad);
        byte[] arrby = this.md5.digest(this.documentID);
        System.arraycopy(arrby, 0, this.userKey, 0, 16);
        for (n = 16; n < 32; ++n) {
            this.userKey[n] = 0;
        }
        for (n = 0; n < 20; ++n) {
            for (int i = 0; i < this.mkey.length; ++i) {
                arrby[i] = (byte)(this.mkey[i] ^ n);
            }
            this.arcfour.prepareARCFOURKey(arrby, 0, this.mkey.length);
            this.arcfour.encryptARCFOUR(this.userKey, 0, 16);
        }
    }

    public void addRecipient(Certificate certificate, int n) {
        this.documentID = PdfEncryption.createDocumentId();
        this.publicKeyHandler.addRecipient(new PdfPublicKeyRecipient(certificate, n));
    }

    public int calculateStreamSize(int n) {
        if (this.revision != 4 && this.revision != 5) {
            return n;
        }
        return (n & 2147483632) + 32;
    }

    public byte[] computeUserPassword(byte[] arrby) {
        block3 : {
            if (this.publicKeyHandler.getRecipientsSize() == 0 && 2 <= this.revision && this.revision <= 4) {
                byte[] arrby2 = this.computeOwnerKey(this.ownerKey, this.padPassword(arrby));
                int n = 0;
                do {
                    int n2;
                    block4 : {
                        arrby = arrby2;
                        if (n >= arrby2.length) break block3;
                        for (n2 = 0; n2 < arrby2.length - n; ++n2) {
                            if (arrby2[n + n2] == pad[n2]) continue;
                            n2 = 0;
                            break block4;
                        }
                        n2 = 1;
                    }
                    if (n2 != 0) break;
                    ++n;
                } while (true);
                arrby = new byte[n];
                System.arraycopy(arrby2, 0, arrby, 0, n);
                return arrby;
            }
            arrby = null;
        }
        return arrby;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public byte[] decryptByteArray(byte[] arrby) {
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            StandardDecryption standardDecryption = this.getDecryptor();
            arrby = standardDecryption.update(arrby, 0, arrby.length);
            if (arrby != null) {
                byteArrayOutputStream.write(arrby);
            }
            if ((arrby = standardDecryption.finish()) == null) return byteArrayOutputStream.toByteArray();
            byteArrayOutputStream.write(arrby);
            return byteArrayOutputStream.toByteArray();
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public byte[] encryptByteArray(byte[] arrby) {
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            OutputStreamEncryption outputStreamEncryption = this.getEncryptionStream(byteArrayOutputStream);
            outputStreamEncryption.write(arrby);
            outputStreamEncryption.finish();
            arrby = byteArrayOutputStream.toByteArray();
            return arrby;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public int getCryptoMode() {
        return this.cryptoMode;
    }

    public StandardDecryption getDecryptor() {
        return new StandardDecryption(this.key, 0, this.keySize, this.revision);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public PdfDictionary getEncryptionDictionary() {
        block29 : {
            pdfDictionary = new PdfDictionary();
            if (this.publicKeyHandler.getRecipientsSize() <= 0) ** GOTO lbl55
            pdfDictionary.put(PdfName.FILTER, PdfName.PUBSEC);
            pdfDictionary.put(PdfName.R, new PdfNumber(this.revision));
            pdfObject = this.publicKeyHandler.getEncodedRecipients();
            if (this.revision == 2) {
                pdfDictionary.put(PdfName.V, new PdfNumber(1));
                pdfDictionary.put(PdfName.SUBFILTER, PdfName.ADBE_PKCS7_S4);
                pdfDictionary.put(PdfName.RECIPIENTS, pdfObject);
                break block29;
            }
            if (this.revision == 3 && this.encryptMetadata) {
                pdfDictionary.put(PdfName.V, new PdfNumber(2));
                pdfDictionary.put(PdfName.LENGTH, new PdfNumber(128));
                pdfDictionary.put(PdfName.SUBFILTER, PdfName.ADBE_PKCS7_S4);
                pdfDictionary.put(PdfName.RECIPIENTS, pdfObject);
                break block29;
            }
            if (this.revision == 5) {
                pdfDictionary.put(PdfName.R, new PdfNumber(5));
                pdfDictionary.put(PdfName.V, new PdfNumber(5));
            } else {
                pdfDictionary.put(PdfName.R, new PdfNumber(4));
                pdfDictionary.put(PdfName.V, new PdfNumber(4));
            }
            pdfDictionary.put(PdfName.SUBFILTER, PdfName.ADBE_PKCS7_S5);
            object /* !! */  = new PdfDictionary();
            object /* !! */ .put(PdfName.RECIPIENTS, pdfObject);
            if (!this.encryptMetadata) {
                object /* !! */ .put(PdfName.ENCRYPTMETADATA, PdfBoolean.PDFFALSE);
            }
            if (this.revision == 4) {
                object /* !! */ .put(PdfName.CFM, PdfName.AESV2);
                object /* !! */ .put(PdfName.LENGTH, new PdfNumber(128));
            } else if (this.revision == 5) {
                object /* !! */ .put(PdfName.CFM, PdfName.AESV3);
                object /* !! */ .put(PdfName.LENGTH, new PdfNumber(256));
            } else {
                object /* !! */ .put(PdfName.CFM, PdfName.V2);
            }
            pdfObject = new PdfDictionary();
            pdfObject.put(PdfName.DEFAULTCRYPTFILTER, (PdfObject)object /* !! */ );
            pdfDictionary.put(PdfName.CF, pdfObject);
            if (this.embeddedFilesOnly) {
                pdfDictionary.put(PdfName.EFF, PdfName.DEFAULTCRYPTFILTER);
                pdfDictionary.put(PdfName.STRF, PdfName.IDENTITY);
                pdfDictionary.put(PdfName.STMF, PdfName.IDENTITY);
                break block29;
            }
            pdfDictionary.put(PdfName.STRF, PdfName.DEFAULTCRYPTFILTER);
            pdfDictionary.put(PdfName.STMF, PdfName.DEFAULTCRYPTFILTER);
            {
                catch (Exception exception) {
                    throw new ExceptionConverter(exception);
                }
            }
        }
        try {
            block30 : {
                object /* !! */  = this.revision == 5 ? MessageDigest.getInstance("SHA-256") : MessageDigest.getInstance("SHA-1");
                object /* !! */ .update(this.publicKeyHandler.getSeed());
                break block30;
lbl55: // 1 sources:
                pdfDictionary.put(PdfName.FILTER, PdfName.STANDARD);
                pdfDictionary.put(PdfName.O, new PdfLiteral(StringUtils.escapeString(this.ownerKey)));
                pdfDictionary.put(PdfName.U, new PdfLiteral(StringUtils.escapeString(this.userKey)));
                pdfDictionary.put(PdfName.P, new PdfNumber(this.permissions));
                pdfDictionary.put(PdfName.R, new PdfNumber(this.revision));
                if (this.revision == 2) {
                    pdfDictionary.put(PdfName.V, new PdfNumber(1));
                    return pdfDictionary;
                }
                if (this.revision == 3 && this.encryptMetadata) {
                    pdfDictionary.put(PdfName.V, new PdfNumber(2));
                    pdfDictionary.put(PdfName.LENGTH, new PdfNumber(128));
                    return pdfDictionary;
                }
                if (this.revision == 5) {
                    if (!this.encryptMetadata) {
                        pdfDictionary.put(PdfName.ENCRYPTMETADATA, PdfBoolean.PDFFALSE);
                    }
                    pdfDictionary.put(PdfName.OE, new PdfLiteral(StringUtils.escapeString(this.oeKey)));
                    pdfDictionary.put(PdfName.UE, new PdfLiteral(StringUtils.escapeString(this.ueKey)));
                    pdfDictionary.put(PdfName.PERMS, new PdfLiteral(StringUtils.escapeString(this.perms)));
                    pdfDictionary.put(PdfName.V, new PdfNumber(this.revision));
                    pdfDictionary.put(PdfName.LENGTH, new PdfNumber(256));
                    pdfDictionary2 = new PdfDictionary();
                    pdfDictionary2.put(PdfName.LENGTH, new PdfNumber(32));
                    if (this.embeddedFilesOnly) {
                        pdfDictionary2.put(PdfName.AUTHEVENT, PdfName.EFOPEN);
                        pdfDictionary.put(PdfName.EFF, PdfName.STDCF);
                        pdfDictionary.put(PdfName.STRF, PdfName.IDENTITY);
                        pdfDictionary.put(PdfName.STMF, PdfName.IDENTITY);
                    } else {
                        pdfDictionary2.put(PdfName.AUTHEVENT, PdfName.DOCOPEN);
                        pdfDictionary.put(PdfName.STRF, PdfName.STDCF);
                        pdfDictionary.put(PdfName.STMF, PdfName.STDCF);
                    }
                    pdfDictionary2.put(PdfName.CFM, PdfName.AESV3);
                    pdfDictionary3 = new PdfDictionary();
                    pdfDictionary3.put(PdfName.STDCF, pdfDictionary2);
                    pdfDictionary.put(PdfName.CF, pdfDictionary3);
                    return pdfDictionary;
                }
                if (!this.encryptMetadata) {
                    pdfDictionary.put(PdfName.ENCRYPTMETADATA, PdfBoolean.PDFFALSE);
                }
                pdfDictionary.put(PdfName.R, new PdfNumber(4));
                pdfDictionary.put(PdfName.V, new PdfNumber(4));
                pdfDictionary.put(PdfName.LENGTH, new PdfNumber(128));
                pdfDictionary4 = new PdfDictionary();
                pdfDictionary4.put(PdfName.LENGTH, new PdfNumber(16));
                if (this.embeddedFilesOnly) {
                    pdfDictionary4.put(PdfName.AUTHEVENT, PdfName.EFOPEN);
                    pdfDictionary.put(PdfName.EFF, PdfName.STDCF);
                    pdfDictionary.put(PdfName.STRF, PdfName.IDENTITY);
                    pdfDictionary.put(PdfName.STMF, PdfName.IDENTITY);
                } else {
                    pdfDictionary4.put(PdfName.AUTHEVENT, PdfName.DOCOPEN);
                    pdfDictionary.put(PdfName.STRF, PdfName.STDCF);
                    pdfDictionary.put(PdfName.STMF, PdfName.STDCF);
                }
                if (this.revision == 4) {
                    pdfDictionary4.put(PdfName.CFM, PdfName.AESV2);
                } else {
                    pdfDictionary4.put(PdfName.CFM, PdfName.V2);
                }
                pdfDictionary5 = new PdfDictionary();
                pdfDictionary5.put(PdfName.STDCF, pdfDictionary4);
                pdfDictionary.put(PdfName.CF, pdfDictionary5);
                return pdfDictionary;
            }
            for (n = 0; n < this.publicKeyHandler.getRecipientsSize(); ++n) {
                object /* !! */ .update(this.publicKeyHandler.getEncodedRecipient(n));
            }
            if (!this.encryptMetadata) {
                object /* !! */ .update(new byte[]{-1, -1, -1, -1});
            }
            object /* !! */  = object /* !! */ .digest();
            if (this.revision == 5) {
                this.key = object /* !! */ ;
                return pdfDictionary;
            }
            this.setupByEncryptionKey(object /* !! */ , this.keyLength);
            return pdfDictionary;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public OutputStreamEncryption getEncryptionStream(OutputStream outputStream) {
        return new OutputStreamEncryption(outputStream, this.key, 0, this.keySize, this.revision);
    }

    public PdfObject getFileID(boolean bl) throws IOException {
        return PdfEncryption.createInfoId(this.documentID, bl);
    }

    public long getPermissions() {
        return this.permissions;
    }

    public boolean isEmbeddedFilesOnly() {
        return this.embeddedFilesOnly;
    }

    public boolean isMetadataEncrypted() {
        return this.encryptMetadata;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public boolean readKey(PdfDictionary var1_1, byte[] var2_4) throws BadPasswordException {
        var3_5 = false;
        var5_6 = var2_4;
        if (var2_4 != null) ** GOTO lbl6
        var5_6 = new byte[]{};
lbl6: // 2 sources:
        var2_4 = DocWriter.getISOBytes(var1_1.get(PdfName.O).toString());
        var6_7 = DocWriter.getISOBytes(var1_1.get(PdfName.U).toString());
        var7_8 = DocWriter.getISOBytes(var1_1.get(PdfName.OE).toString());
        var8_9 = DocWriter.getISOBytes(var1_1.get(PdfName.UE).toString());
        var9_10 = DocWriter.getISOBytes(var1_1.get(PdfName.PERMS).toString());
        var1_1 = (PdfNumber)var1_1.get(PdfName.P);
        this.oeKey = var7_8;
        this.ueKey = var8_9;
        this.perms = var9_10;
        this.ownerKey = var2_4;
        this.userKey = var6_7;
        this.permissions = var1_1.longValue();
        var1_1 = MessageDigest.getInstance("SHA-256");
        var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
        var1_1.update(var2_4, 32, 8);
        var1_1.update(var6_7, 0, 48);
        var4_11 = PdfEncryption.compareArray(var1_1.digest(), var2_4, 32);
        if (var4_11) {
            var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
            var1_1.update(var2_4, 40, 8);
            var1_1.update(var6_7, 0, 48);
            this.key = new AESCipherCBCnoPad(false, var1_1.digest()).processBlock(var7_8, 0, var7_8.length);
        } else {
            var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
            var1_1.update(var6_7, 32, 8);
            if (!PdfEncryption.compareArray(var1_1.digest(), var6_7, 32)) {
                throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
            }
            var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
            var1_1.update(var6_7, 40, 8);
            this.key = new AESCipherCBCnoPad(false, var1_1.digest()).processBlock(var8_9, 0, var8_9.length);
        }
        var1_1 = new AESCipherCBCnoPad(false, this.key).processBlock(var9_10, 0, var9_10.length);
        if (var1_1[9] != 97) throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
        if (var1_1[10] != 100) throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
        if (var1_1[11] != 98) {
            throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
        }
        this.permissions = var1_1[0] & 255 | (var1_1[1] & 255) << 8 | (var1_1[2] & 255) << 16 | (var1_1[2] & 255) << 24;
        if (var1_1[8] == 84) {
            var3_5 = true;
        }
        try {
            this.encryptMetadata = var3_5;
            return var4_11;
        }
        catch (Exception var1_2) {
            throw new ExceptionConverter(var1_2);
        }
        catch (BadPasswordException var1_3) {
            throw var1_3;
        }
    }

    public void setCryptoMode(int n, int n2) {
        this.cryptoMode = n;
        boolean bl = (n & 8) != 8;
        this.encryptMetadata = bl;
        bl = (n & 24) == 24;
        this.embeddedFilesOnly = bl;
        switch (n & 7) {
            default: {
                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("no.valid.encryption.mode", new Object[0]));
            }
            case 3: {
                this.keyLength = 256;
                this.keySize = 32;
                this.revision = 5;
                return;
            }
            case 2: {
                this.keyLength = 128;
                this.revision = 4;
                return;
            }
            case 1: {
                this.embeddedFilesOnly = false;
                this.keyLength = n2 > 0 ? n2 : 128;
                this.revision = 3;
                return;
            }
            case 0: 
        }
        this.encryptMetadata = true;
        this.embeddedFilesOnly = false;
        this.keyLength = 40;
        this.revision = 2;
    }

    public void setHashKey(int n, int n2) {
        if (this.revision == 5) {
            return;
        }
        this.md5.reset();
        this.extra[0] = (byte)n;
        this.extra[1] = (byte)(n >> 8);
        this.extra[2] = (byte)(n >> 16);
        this.extra[3] = (byte)n2;
        this.extra[4] = (byte)(n2 >> 8);
        this.md5.update(this.mkey);
        this.md5.update(this.extra);
        if (this.revision == 4) {
            this.md5.update(salt);
        }
        this.key = this.md5.digest();
        this.keySize = this.mkey.length + 5;
        if (this.keySize > 16) {
            this.keySize = 16;
        }
    }

    public void setKey(byte[] arrby) {
        this.key = arrby;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void setupAllKeys(byte[] var1_1, byte[] var2_3, int var3_4) {
        block9 : {
            block8 : {
                var8_5 = var2_3;
                if (var8_5 == null) break block8;
                var2_3 = var8_5;
                if (((byte[])var8_5).length != 0) break block9;
            }
            var2_3 = this.md5.digest(PdfEncryption.createDocumentId());
        }
        var5_6 = this.revision != 3 && this.revision != 4 && this.revision != 5 ? -64 : -3904;
        var3_4 = (var3_4 | var5_6) & -4;
        this.permissions = var6_7 = (long)var3_4;
        if (this.revision != 5) {
            var1_1 = this.padPassword(var1_1);
            this.ownerKey = this.computeOwnerKey(var1_1, this.padPassword(var2_3));
            this.documentID = PdfEncryption.createDocumentId();
            this.setupByUserPad(this.documentID, var1_1, this.ownerKey, var6_7);
            return;
        }
        if (var1_1 != null) ** GOTO lbl20
        try {
            var1_1 = new byte[]{};
lbl20: // 2 sources:
            this.documentID = PdfEncryption.createDocumentId();
            var9_8 = IVGenerator.getIV(8);
            var10_9 = IVGenerator.getIV(8);
            this.key = IVGenerator.getIV(32);
            var8_5 = MessageDigest.getInstance("SHA-256");
            var8_5.update(var1_1, 0, Math.min(var1_1.length, 127));
            var8_5.update(var9_8);
            this.userKey = new byte[48];
            var8_5.digest(this.userKey, 0, 32);
            System.arraycopy(var9_8, 0, this.userKey, 32, 8);
            System.arraycopy(var10_9, 0, this.userKey, 40, 8);
            var8_5.update(var1_1, 0, Math.min(var1_1.length, 127));
            var8_5.update(var10_9);
            this.ueKey = new AESCipherCBCnoPad(true, var8_5.digest()).processBlock(this.key, 0, this.key.length);
            var1_1 = IVGenerator.getIV(8);
            var9_8 = IVGenerator.getIV(8);
            var8_5.update(var2_3, 0, Math.min(var2_3.length, 127));
            var8_5.update(var1_1);
            var8_5.update(this.userKey);
            this.ownerKey = new byte[48];
            var8_5.digest(this.ownerKey, 0, 32);
            System.arraycopy(var1_1, 0, this.ownerKey, 32, 8);
            System.arraycopy(var9_8, 0, this.ownerKey, 40, 8);
            var8_5.update(var2_3, 0, Math.min(var2_3.length, 127));
            var8_5.update(var9_8);
            var8_5.update(this.userKey);
            this.oeKey = new AESCipherCBCnoPad(true, var8_5.digest()).processBlock(this.key, 0, this.key.length);
            var1_1 = IVGenerator.getIV(16);
        }
        catch (Exception var1_2) {
            throw new ExceptionConverter(var1_2);
        }
        var1_1[0] = (byte)var3_4;
        var1_1[1] = (byte)(var3_4 >> 8);
        var1_1[2] = (byte)(var3_4 >> 16);
        var1_1[3] = (byte)(var3_4 >> 24);
        var1_1[4] = -1;
        var1_1[5] = -1;
        var1_1[6] = -1;
        var1_1[7] = -1;
        var4_10 = this.encryptMetadata != false ? 84 : 70;
        var1_1[8] = var4_10;
        var1_1[9] = 97;
        var1_1[10] = 100;
        var1_1[11] = 98;
        this.perms = new AESCipherCBCnoPad(true, this.key).processBlock(var1_1, 0, var1_1.length);
    }

    public void setupByEncryptionKey(byte[] arrby, int n) {
        this.mkey = new byte[n / 8];
        System.arraycopy(arrby, 0, this.mkey, 0, this.mkey.length);
    }

    public void setupByOwnerPassword(byte[] arrby, byte[] arrby2, byte[] arrby3, byte[] arrby4, long l) {
        this.setupByOwnerPad(arrby, this.padPassword(arrby2), arrby3, arrby4, l);
    }

    public void setupByUserPassword(byte[] arrby, byte[] arrby2, byte[] arrby3, long l) {
        this.setupByUserPad(arrby, this.padPassword(arrby2), arrby3, l);
    }
}

