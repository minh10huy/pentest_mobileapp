/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Method;
import java.nio.Buffer;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class MappedRandomAccessFile {
    private static final int BUFSIZE = 1073741824;
    private FileChannel channel = null;
    private MappedByteBuffer[] mappedBuffers;
    private long pos;
    private long size;

    public MappedRandomAccessFile(String string2, String string3) throws FileNotFoundException, IOException {
        if (string3.equals("rw")) {
            this.init(new RandomAccessFile(string2, string3).getChannel(), FileChannel.MapMode.READ_WRITE);
            return;
        }
        this.init(new FileInputStream(string2).getChannel(), FileChannel.MapMode.READ_ONLY);
    }

    public static boolean clean(final ByteBuffer byteBuffer) {
        if (byteBuffer != null && byteBuffer.isDirect()) {
            return (Boolean)AccessController.doPrivileged(new PrivilegedAction<Boolean>(){

                @Override
                public Boolean run() {
                    Boolean bl = Boolean.FALSE;
                    try {
                        Object object = byteBuffer.getClass().getMethod("cleaner", null);
                        object.setAccessible(true);
                        object = object.invoke(byteBuffer, null);
                        object.getClass().getMethod("clean", null).invoke(object, null);
                        object = Boolean.TRUE;
                        return object;
                    }
                    catch (Exception exception) {
                        return bl;
                    }
                }
            });
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void init(FileChannel object, FileChannel.MapMode mapMode) throws IOException {
        this.channel = object;
        this.size = object.size();
        this.pos = 0L;
        int n = (int)(this.size / 0x40000000L);
        long l = this.size;
        int n2 = 0;
        int n3 = l % 0x40000000L == 0L ? 0 : 1;
        this.mappedBuffers = new MappedByteBuffer[n += n3];
        n3 = n2;
        try {
            for (long i = 0L; i < this.size; ++n3, i += 0x40000000L) {
                l = Math.min(this.size - i, 0x40000000L);
                this.mappedBuffers[n3] = object.map(mapMode, i, l);
                this.mappedBuffers[n3].load();
            }
            if (n3 != n) {
                object = new StringBuilder();
                object.append("Should never happen - ");
                object.append(n3);
                object.append(" != ");
                object.append(n);
                throw new Error(object.toString());
            }
            return;
        }
        catch (RuntimeException runtimeException) {
            this.close();
            throw runtimeException;
        }
        catch (IOException iOException) {
            this.close();
            throw iOException;
        }
    }

    public void close() throws IOException {
        for (int i = 0; i < this.mappedBuffers.length; ++i) {
            if (this.mappedBuffers[i] == null) continue;
            MappedRandomAccessFile.clean(this.mappedBuffers[i]);
            this.mappedBuffers[i] = null;
        }
        if (this.channel != null) {
            this.channel.close();
        }
        this.channel = null;
    }

    protected void finalize() throws Throwable {
        this.close();
        super.finalize();
    }

    public FileChannel getChannel() {
        return this.channel;
    }

    public long getFilePointer() {
        return this.pos;
    }

    public long length() {
        return this.size;
    }

    public int read() {
        int n;
        int n2;
        block5 : {
            block4 : {
                try {
                    n = (int)(this.pos / 0x40000000L);
                    n2 = (int)(this.pos % 0x40000000L);
                    if (n < this.mappedBuffers.length) break block4;
                    return -1;
                }
                catch (BufferUnderflowException bufferUnderflowException) {
                    return -1;
                }
            }
            if (n2 < this.mappedBuffers[n].limit()) break block5;
            return -1;
        }
        n = this.mappedBuffers[n].get(n2);
        ++this.pos;
        return n & 255;
    }

    public int read(byte[] arrby, int n, int n2) {
        MappedByteBuffer mappedByteBuffer;
        int n3 = (int)(this.pos / 0x40000000L);
        int n4 = (int)(this.pos % 0x40000000L);
        int n5 = n;
        for (n = 0; n < n2 && n3 < this.mappedBuffers.length && n4 <= (mappedByteBuffer = this.mappedBuffers[n3]).limit(); n += n4, ++n3) {
            mappedByteBuffer.position(n4);
            n4 = Math.min(n2 - n, mappedByteBuffer.remaining());
            mappedByteBuffer.get(arrby, n5, n4);
            n5 += n4;
            this.pos += (long)n4;
            n4 = 0;
        }
        n2 = n;
        if (n == 0) {
            n2 = -1;
        }
        return n2;
    }

    public void seek(long l) {
        this.pos = l;
    }

}

