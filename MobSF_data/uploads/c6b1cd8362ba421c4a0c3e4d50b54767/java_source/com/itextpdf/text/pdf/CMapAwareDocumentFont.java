/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.fonts.cmaps.CMapByteCid;
import com.itextpdf.text.pdf.fonts.cmaps.CMapCache;
import com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni;
import com.itextpdf.text.pdf.fonts.cmaps.CMapParserEx;
import com.itextpdf.text.pdf.fonts.cmaps.CMapSequence;
import com.itextpdf.text.pdf.fonts.cmaps.CMapToUnicode;
import com.itextpdf.text.pdf.fonts.cmaps.CidLocation;
import com.itextpdf.text.pdf.fonts.cmaps.CidLocationFromByte;
import com.itextpdf.text.pdf.fonts.cmaps.IdentityToUnicode;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class CMapAwareDocumentFont
extends DocumentFont {
    private CMapByteCid byteCid;
    private CMapCidUni cidUni;
    private char[] cidbyte2uni;
    private PdfDictionary fontDic;
    private int spaceWidth;
    private CMapToUnicode toUnicodeCmap;
    private Map<Integer, Integer> uni2cid;

    public CMapAwareDocumentFont(PRIndirectReference pRIndirectReference) {
        super(pRIndirectReference);
        this.fontDic = (PdfDictionary)PdfReader.getPdfObjectRelease(pRIndirectReference);
        this.initFont();
    }

    public CMapAwareDocumentFont(PdfDictionary pdfDictionary) {
        super(pdfDictionary);
        this.fontDic = pdfDictionary;
        this.initFont();
    }

    private int computeAverageWidth() {
        int n;
        int n2 = 0;
        int n3 = 0;
        int n4 = 0;
        for (n = 0; n < this.widths.length; ++n) {
            int n5 = n3;
            int n6 = n4;
            if (this.widths[n] != 0) {
                n6 = n4 + this.widths[n];
                n5 = n3 + 1;
            }
            n3 = n5;
            n4 = n6;
        }
        n = n2;
        if (n3 != 0) {
            n = n4 / n3;
        }
        return n;
    }

    private String decodeSingleCID(byte[] arrby, int n, int n2) {
        if (this.toUnicodeCmap != null) {
            int n3 = n + n2;
            if (n3 > arrby.length) {
                throw new ArrayIndexOutOfBoundsException(MessageLocalization.getComposedMessage("invalid.index.1", n3));
            }
            String string2 = this.toUnicodeCmap.lookup(arrby, n, n2);
            if (string2 != null) {
                return string2;
            }
            if (n2 != 1 || this.cidbyte2uni == null) {
                return null;
            }
        }
        if (n2 == 1) {
            if (this.cidbyte2uni == null) {
                return "";
            }
            return new String(this.cidbyte2uni, arrby[n] & 255, 1);
        }
        throw new Error("Multi-byte glyphs not implemented yet");
    }

    private void initFont() {
        this.processToUnicode();
        try {
            this.processUni2Byte();
            this.spaceWidth = super.getWidth(32);
            if (this.spaceWidth == 0) {
                this.spaceWidth = this.computeAverageWidth();
            }
            if (this.cjkEncoding != null) {
                this.byteCid = CMapCache.getCachedCMapByteCid(this.cjkEncoding);
                this.cidUni = CMapCache.getCachedCMapCidUni(this.uniMap);
            }
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void processToUnicode() {
        Object object = PdfReader.getPdfObjectRelease(this.fontDic.get(PdfName.TOUNICODE));
        if (object instanceof PRStream) {
            object = new CidLocationFromByte(PdfReader.getStreamBytes((PRStream)object));
            this.toUnicodeCmap = new CMapToUnicode();
            CMapParserEx.parseCid("", this.toUnicodeCmap, (CidLocation)object);
            this.uni2cid = this.toUnicodeCmap.createReverseMapping();
            return;
        }
        if (!this.isType0) return;
        try {
            object = this.fontDic.getAsName(PdfName.ENCODING);
            if (object == null) {
                return;
            }
            if (!PdfName.decodeName(object.toString()).equals("Identity-H")) {
                return;
            }
            object = ((PdfDictionary)PdfReader.getPdfObjectRelease(((PdfArray)PdfReader.getPdfObjectRelease(this.fontDic.get(PdfName.DESCENDANTFONTS))).getPdfObject(0))).getAsDict(PdfName.CIDSYSTEMINFO);
            if (object == null) {
                return;
            }
            if ((object = object.getAsString(PdfName.ORDERING)) == null) {
                return;
            }
            if ((object = IdentityToUnicode.GetMapFromOrdering(object.toUnicodeString())) == null) {
                return;
            }
            this.toUnicodeCmap = object;
            this.uni2cid = this.toUnicodeCmap.createReverseMapping();
            return;
        }
        catch (IOException iOException) {}
        catch (IOException iOException) {}
        this.toUnicodeCmap = null;
        this.uni2cid = null;
        return;
        this.toUnicodeCmap = null;
        this.uni2cid = null;
    }

    private void processUni2Byte() throws IOException {
        int n;
        Object object = this.getByte2Uni();
        Object object2 = object.toOrderedKeys();
        if (((int[])object2).length == 0) {
            return;
        }
        this.cidbyte2uni = new char[256];
        int n2 = 0;
        for (n = 0; n < ((int[])object2).length; ++n) {
            int n3 = object2[n];
            this.cidbyte2uni[n3] = (char)object.get(n3);
        }
        if (this.toUnicodeCmap != null) {
            object = this.toUnicodeCmap.createDirectMapping().entrySet().iterator();
            while (object.hasNext()) {
                object2 = (Map.Entry)object.next();
                if ((Integer)object2.getKey() >= 256) continue;
                this.cidbyte2uni[((Integer)object2.getKey()).intValue()] = (char)((Integer)object2.getValue()).intValue();
            }
        }
        if ((object = this.getDiffmap()) != null) {
            object2 = object.toOrderedKeys();
            for (n = n2; n < ((int[])object2).length; ++n) {
                n2 = object.get((int)object2[n]);
                if (n2 >= 256) continue;
                this.cidbyte2uni[n2] = (char)object2[n];
            }
        }
    }

    public String decode(byte[] object, int n, int n2) {
        StringBuilder stringBuilder;
        stringBuilder = new StringBuilder();
        if (this.toUnicodeCmap == null && this.byteCid != null) {
            object = new CMapSequence((byte[])object, n, n2);
            object = this.byteCid.decodeSequence((CMapSequence)object);
            for (n = 0; n < object.length(); ++n) {
                n2 = this.cidUni.lookup(object.charAt(n));
                if (n2 <= 0) continue;
                stringBuilder.append(Utilities.convertFromUtf32(n2));
            }
        } else {
            int n3;
            int n4 = n;
            while (n4 < (n3 = n + n2)) {
                String string2 = this.decodeSingleCID((byte[])object, n4, 1);
                int n5 = n4;
                String string3 = string2;
                if (string2 == null) {
                    n5 = n4;
                    string3 = string2;
                    if (n4 < n3 - 1) {
                        string3 = this.decodeSingleCID((byte[])object, n4, 2);
                        n5 = n4 + 1;
                    }
                }
                if (string3 != null) {
                    stringBuilder.append(string3);
                }
                n4 = n5 + 1;
            }
        }
        return stringBuilder.toString();
    }

    public String encode(byte[] arrby, int n, int n2) {
        return this.decode(arrby, n, n2);
    }

    @Override
    public int getWidth(int n) {
        if (n == 32) {
            if (this.spaceWidth != 0) {
                return this.spaceWidth;
            }
            return this.defaultWidth;
        }
        return super.getWidth(n);
    }
}

