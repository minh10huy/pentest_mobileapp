/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.LongRect;
import com.itextpdf.text.pdf.parser.clipper.Path;
import com.itextpdf.text.pdf.parser.clipper.Point;
import com.itextpdf.text.pdf.parser.clipper.PolyNode;
import com.itextpdf.text.pdf.parser.clipper.PolyTree;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class Paths
extends ArrayList<Path> {
    private static final long serialVersionUID = 1910552127810480852L;

    public Paths() {
    }

    public Paths(int n) {
        super(n);
    }

    public static Paths closedPathsFromPolyTree(PolyTree polyTree) {
        Paths paths = new Paths();
        paths.addPolyNode(polyTree, PolyNode.NodeType.CLOSED);
        return paths;
    }

    public static Paths makePolyTreeToPaths(PolyTree polyTree) {
        Paths paths = new Paths();
        paths.addPolyNode(polyTree, PolyNode.NodeType.ANY);
        return paths;
    }

    public static Paths openPathsFromPolyTree(PolyTree object) {
        Paths paths = new Paths();
        for (PolyNode polyNode : object.getChilds()) {
            if (!polyNode.isOpen()) continue;
            paths.add(polyNode.getPolygon());
        }
        return paths;
    }

    public void addPolyNode(PolyNode object, PolyNode.NodeType nodeType) {
        int n = .$SwitchMap$com$itextpdf$text$pdf$parser$clipper$PolyNode$NodeType[nodeType.ordinal()];
        boolean bl = true;
        switch (n) {
            default: {
                break;
            }
            case 2: {
                bl = true ^ object.isOpen();
                break;
            }
            case 1: {
                return;
            }
        }
        if (object.getPolygon().size() > 0 && bl) {
            this.add(object.getPolygon());
        }
        object = object.getChilds().iterator();
        while (object.hasNext()) {
            this.addPolyNode((PolyNode)object.next(), nodeType);
        }
    }

    public Paths cleanPolygons() {
        return this.cleanPolygons(1.415);
    }

    public Paths cleanPolygons(double d) {
        Paths paths = new Paths(this.size());
        for (int i = 0; i < this.size(); ++i) {
            paths.add(((Path)this.get(i)).cleanPolygon(d));
        }
        return paths;
    }

    public LongRect getBounds() {
        int n;
        int n2 = this.size();
        LongRect longRect = new LongRect();
        for (n = 0; n < n2 && ((Path)this.get(n)).isEmpty(); ++n) {
        }
        if (n == n2) {
            return longRect;
        }
        longRect.right = longRect.left = ((Point.LongPoint)((Path)this.get(n)).get(0)).getX();
        longRect.bottom = longRect.top = ((Point.LongPoint)((Path)this.get(n)).get(0)).getY();
        while (n < n2) {
            for (int i = 0; i < ((Path)this.get(n)).size(); ++i) {
                if (((Point.LongPoint)((Path)this.get(n)).get(i)).getX() < longRect.left) {
                    longRect.left = ((Point.LongPoint)((Path)this.get(n)).get(i)).getX();
                } else if (((Point.LongPoint)((Path)this.get(n)).get(i)).getX() > longRect.right) {
                    longRect.right = ((Point.LongPoint)((Path)this.get(n)).get(i)).getX();
                }
                if (((Point.LongPoint)((Path)this.get(n)).get(i)).getY() < longRect.top) {
                    longRect.top = ((Point.LongPoint)((Path)this.get(n)).get(i)).getY();
                    continue;
                }
                if (((Point.LongPoint)((Path)this.get(n)).get(i)).getY() <= longRect.bottom) continue;
                longRect.bottom = ((Point.LongPoint)((Path)this.get(n)).get(i)).getY();
            }
            ++n;
        }
        return longRect;
    }

    public void reversePaths() {
        Iterator iterator = this.iterator();
        while (iterator.hasNext()) {
            ((Path)iterator.next()).reverse();
        }
    }

}

