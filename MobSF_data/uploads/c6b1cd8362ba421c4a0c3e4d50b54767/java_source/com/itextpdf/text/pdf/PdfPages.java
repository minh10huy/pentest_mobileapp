/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfWriter;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class PdfPages {
    private int leafSize = 10;
    private ArrayList<PdfIndirectReference> pages = new ArrayList();
    private ArrayList<PdfIndirectReference> parents = new ArrayList();
    private PdfIndirectReference topParent;
    private PdfWriter writer;

    PdfPages(PdfWriter pdfWriter) {
        this.writer = pdfWriter;
    }

    void addPage(PdfDictionary pdfDictionary) {
        try {
            if (this.pages.size() % this.leafSize == 0) {
                this.parents.add(this.writer.getPdfIndirectReference());
            }
            PdfIndirectReference pdfIndirectReference = this.parents.get(this.parents.size() - 1);
            pdfDictionary.put(PdfName.PARENT, pdfIndirectReference);
            pdfIndirectReference = this.writer.getCurrentPage();
            this.writer.addToBody((PdfObject)pdfDictionary, pdfIndirectReference);
            this.pages.add(pdfIndirectReference);
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    void addPage(PdfIndirectReference pdfIndirectReference) {
        this.pages.add(pdfIndirectReference);
    }

    PdfIndirectReference addPageRef(PdfIndirectReference pdfIndirectReference) {
        try {
            if (this.pages.size() % this.leafSize == 0) {
                this.parents.add(this.writer.getPdfIndirectReference());
            }
            this.pages.add(pdfIndirectReference);
            pdfIndirectReference = this.parents.get(this.parents.size() - 1);
            return pdfIndirectReference;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    PdfIndirectReference getTopParent() {
        return this.topParent;
    }

    int reorderPages(int[] arrn) throws DocumentException {
        if (arrn == null) {
            return this.pages.size();
        }
        int n = this.parents.size();
        int n2 = 0;
        if (n > 1) {
            throw new DocumentException(MessageLocalization.getComposedMessage("page.reordering.requires.a.single.parent.in.the.page.tree.call.pdfwriter.setlinearmode.after.open", new Object[0]));
        }
        if (arrn.length != this.pages.size()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("page.reordering.requires.an.array.with.the.same.size.as.the.number.of.pages", new Object[0]));
        }
        int n3 = this.pages.size();
        Object[] arrobject = new boolean[n3];
        for (n = 0; n < n3; ++n) {
            int n4 = arrn[n];
            if (n4 >= 1 && n4 <= n3) {
                int n5 = n4 - 1;
                if (arrobject[n5]) {
                    throw new DocumentException(MessageLocalization.getComposedMessage("page.reordering.requires.no.page.repetition.page.1.is.repeated", n4));
                }
                arrobject[n5] = true;
                continue;
            }
            throw new DocumentException(MessageLocalization.getComposedMessage("page.reordering.requires.pages.between.1.and.1.found.2", String.valueOf(n3), String.valueOf(n4)));
        }
        arrobject = this.pages.toArray(new PdfIndirectReference[this.pages.size()]);
        for (n = n2; n < n3; ++n) {
            this.pages.set(n, (PdfIndirectReference)arrobject[arrn[n] - 1]);
        }
        return n3;
    }

    void setLinearMode(PdfIndirectReference pdfIndirectReference) {
        if (this.parents.size() > 1) {
            throw new RuntimeException(MessageLocalization.getComposedMessage("linear.page.mode.can.only.be.called.with.a.single.parent", new Object[0]));
        }
        if (pdfIndirectReference != null) {
            this.topParent = pdfIndirectReference;
            this.parents.clear();
            this.parents.add(pdfIndirectReference);
        }
        this.leafSize = 10000000;
    }

    PdfIndirectReference writePageTree() throws IOException {
        if (this.pages.isEmpty()) {
            throw new IOException(MessageLocalization.getComposedMessage("the.document.has.no.pages", new Object[0]));
        }
        ArrayList<PdfIndirectReference> arrayList = this.parents;
        ArrayList<PdfIndirectReference> arrayList2 = this.pages;
        ArrayList<PdfIndirectReference> arrayList3 = new ArrayList<PdfIndirectReference>();
        int n = 1;
        do {
            Serializable serializable;
            int n2;
            n *= this.leafSize;
            int n3 = this.leafSize;
            int n4 = n2 = arrayList2.size() % this.leafSize;
            if (n2 == 0) {
                n4 = this.leafSize;
            }
            for (int i = 0; i < arrayList.size(); ++i) {
                int n5;
                int n6;
                if (i == arrayList.size() - 1) {
                    n2 = n5 = this.pages.size() % n;
                    if (n5 == 0) {
                        n2 = n;
                    }
                    n5 = n4;
                    n6 = n2;
                    n2 = n5;
                } else {
                    n5 = n;
                    n2 = n3;
                    n6 = n5;
                }
                serializable = new PdfDictionary(PdfName.PAGES);
                serializable.put(PdfName.COUNT, new PdfNumber(n6));
                PdfArray pdfArray = new PdfArray();
                ArrayList<PdfObject> arrayList4 = pdfArray.getArrayList();
                n5 = i * n3;
                arrayList4.addAll(arrayList2.subList(n5, n2 + n5));
                serializable.put(PdfName.KIDS, pdfArray);
                if (arrayList.size() > 1) {
                    if (i % this.leafSize == 0) {
                        arrayList3.add(this.writer.getPdfIndirectReference());
                    }
                    serializable.put(PdfName.PARENT, (PdfObject)arrayList3.get(i / this.leafSize));
                }
                this.writer.addToBody((PdfObject)serializable, arrayList.get(i));
            }
            if (arrayList.size() == 1) {
                this.topParent = arrayList.get(0);
                return this.topParent;
            }
            serializable = new ArrayList();
            arrayList2 = arrayList;
            arrayList = arrayList3;
            arrayList3 = serializable;
        } while (true);
    }
}

