/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.fonts.cmaps;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap;
import com.itextpdf.text.pdf.fonts.cmaps.CMapSequence;
import java.util.ArrayList;

public class CMapByteCid
extends AbstractCMap {
    private ArrayList<char[]> planes = new ArrayList();

    public CMapByteCid() {
        this.planes.add(new char[256]);
    }

    private void encodeSequence(byte[] arrby, char c) {
        int n;
        char[] arrc;
        int n2 = arrby.length - 1;
        int n3 = 0;
        for (n = 0; n < n2; ++n) {
            arrc = this.planes.get(n3);
            int n4 = arrby[n] & 255;
            n3 = arrc[n4];
            if (n3 != 0 && (n3 & 32768) == 0) {
                throw new RuntimeException(MessageLocalization.getComposedMessage("inconsistent.mapping", new Object[0]));
            }
            int n5 = n3;
            if (n3 == 0) {
                char c2;
                this.planes.add(new char[256]);
                arrc[n4] = c2 = (char)(32768 | this.planes.size() - 1);
                n5 = c2;
            }
            n3 = n5 & 32767;
        }
        arrc = this.planes.get(n3);
        if ((arrc[n = arrby[n2] & 255] & 32768) != 0) {
            throw new RuntimeException(MessageLocalization.getComposedMessage("inconsistent.mapping", new Object[0]));
        }
        arrc[n] = c;
    }

    @Override
    void addChar(PdfString pdfString, PdfObject pdfObject) {
        if (!(pdfObject instanceof PdfNumber)) {
            return;
        }
        this.encodeSequence(CMapByteCid.decodeStringToByte(pdfString), (char)((PdfNumber)pdfObject).intValue());
    }

    public String decodeSequence(CMapSequence cMapSequence) {
        int n;
        StringBuilder stringBuilder = new StringBuilder();
        while ((n = this.decodeSingle(cMapSequence)) >= 0) {
            stringBuilder.append((char)n);
        }
        return stringBuilder.toString();
    }

    public int decodeSingle(CMapSequence cMapSequence) {
        int n = cMapSequence.off;
        int n2 = cMapSequence.len;
        int n3 = 0;
        while (cMapSequence.off < n + n2) {
            byte[] arrby = cMapSequence.seq;
            int n4 = cMapSequence.off;
            cMapSequence.off = n4 + 1;
            n4 = arrby[n4];
            --cMapSequence.len;
            if ((32768 & (n3 = this.planes.get(n3)[n4 & 255])) == 0) {
                return n3;
            }
            n3 &= 32767;
        }
        return -1;
    }
}

