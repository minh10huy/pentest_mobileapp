/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Clipper;
import com.itextpdf.text.pdf.parser.clipper.ClipperBase;
import com.itextpdf.text.pdf.parser.clipper.Edge;
import com.itextpdf.text.pdf.parser.clipper.Path;
import com.itextpdf.text.pdf.parser.clipper.Paths;
import com.itextpdf.text.pdf.parser.clipper.Point;
import com.itextpdf.text.pdf.parser.clipper.PolyNode;
import com.itextpdf.text.pdf.parser.clipper.PolyTree;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.logging.Logger;

public class DefaultClipper
extends ClipperBase {
    private static final Logger LOGGER = Logger.getLogger(DefaultClipper.class.getName());
    private Edge activeEdges;
    private Clipper.PolyFillType clipFillType;
    private Clipper.ClipType clipType;
    private final List<Path.Join> ghostJoins;
    private final List<IntersectNode> intersectList;
    private final Comparator<IntersectNode> intersectNodeComparer;
    private final List<Path.Join> joins;
    private Path.Maxima maxima;
    protected final List<Path.OutRec> polyOuts;
    private final boolean reverseSolution;
    private ClipperBase.Scanbeam scanbeam;
    private Edge sortedEdges;
    private final boolean strictlySimple;
    private Clipper.PolyFillType subjFillType;
    private boolean usingPolyTree;
    public Clipper.ZFillCallback zFillFunction;

    public DefaultClipper() {
        this(0);
    }

    public DefaultClipper(int n) {
        boolean bl = false;
        boolean bl2 = (n & 4) != 0;
        super(bl2);
        this.scanbeam = null;
        this.maxima = null;
        this.activeEdges = null;
        this.sortedEdges = null;
        this.intersectList = new ArrayList<IntersectNode>();
        this.intersectNodeComparer = new Comparator<IntersectNode>(){

            @Override
            public int compare(IntersectNode intersectNode, IntersectNode intersectNode2) {
                long l = intersectNode2.getPt().getY() - intersectNode.getPt().getY();
                if (l > 0L) {
                    return 1;
                }
                if (l < 0L) {
                    return -1;
                }
                return 0;
            }
        };
        this.usingPolyTree = false;
        this.polyOuts = new ArrayList<Path.OutRec>();
        this.joins = new ArrayList<Path.Join>();
        this.ghostJoins = new ArrayList<Path.Join>();
        bl2 = (n & 1) != 0;
        this.reverseSolution = bl2;
        bl2 = bl;
        if ((n & 2) != 0) {
            bl2 = true;
        }
        this.strictlySimple = bl2;
        this.zFillFunction = null;
    }

    private boolean EdgesAdjacent(IntersectNode intersectNode) {
        if (intersectNode.edge1.nextInSEL != intersectNode.Edge2 && intersectNode.edge1.prevInSEL != intersectNode.Edge2) {
            return false;
        }
        return true;
    }

    private Path.OutPt GetLastOutPt(Edge edge) {
        Path.OutRec outRec = this.polyOuts.get(edge.outIdx);
        if (edge.side == Edge.Side.LEFT) {
            return outRec.pts;
        }
        return outRec.pts.prev;
    }

    private void InsertMaxima(long l) {
        Path.Maxima maxima = new Path.Maxima();
        maxima.X = l;
        if (this.maxima == null) {
            this.maxima = maxima;
            this.maxima.Next = null;
            this.maxima.Prev = null;
            return;
        }
        if (l < this.maxima.X) {
            maxima.Next = this.maxima;
            maxima.Prev = null;
            this.maxima = maxima;
            return;
        }
        Path.Maxima maxima2 = this.maxima;
        while (maxima2.Next != null && l >= maxima2.Next.X) {
            maxima2 = maxima2.Next;
        }
        if (l == maxima2.X) {
            return;
        }
        maxima.Next = maxima2.Next;
        maxima.Prev = maxima2;
        if (maxima2.Next != null) {
            maxima2.Next.Prev = maxima;
        }
        maxima2.Next = maxima;
    }

    private void addEdgeToSEL(Edge edge) {
        LOGGER.entering(DefaultClipper.class.getName(), "addEdgeToSEL");
        if (this.sortedEdges == null) {
            this.sortedEdges = edge;
            edge.prevInSEL = null;
            edge.nextInSEL = null;
            return;
        }
        edge.nextInSEL = this.sortedEdges;
        edge.prevInSEL = null;
        this.sortedEdges.prevInSEL = edge;
        this.sortedEdges = edge;
    }

    private void addGhostJoin(Path.OutPt outPt, Point.LongPoint longPoint) {
        Path.Join join = new Path.Join();
        join.outPt1 = outPt;
        join.setOffPt(longPoint);
        this.ghostJoins.add(join);
    }

    private void addJoin(Path.OutPt outPt, Path.OutPt outPt2, Point.LongPoint longPoint) {
        LOGGER.entering(DefaultClipper.class.getName(), "addJoin");
        Path.Join join = new Path.Join();
        join.outPt1 = outPt;
        join.outPt2 = outPt2;
        join.setOffPt(longPoint);
        this.joins.add(join);
    }

    private void addLocalMaxPoly(Edge edge, Edge edge2, Point.LongPoint longPoint) {
        this.addOutPt(edge, longPoint);
        if (edge2.windDelta == 0) {
            this.addOutPt(edge2, longPoint);
        }
        if (edge.outIdx == edge2.outIdx) {
            edge.outIdx = -1;
            edge2.outIdx = -1;
            return;
        }
        if (edge.outIdx < edge2.outIdx) {
            this.appendPolygon(edge, edge2);
            return;
        }
        this.appendPolygon(edge2, edge);
    }

    /*
     * Enabled aggressive block sorting
     */
    private Path.OutPt addLocalMinPoly(Edge edge, Edge edge2, Point.LongPoint longPoint) {
        Path.OutPt outPt;
        LOGGER.entering(DefaultClipper.class.getName(), "addLocalMinPoly");
        if (!edge2.isHorizontal() && edge.deltaX <= edge2.deltaX) {
            outPt = this.addOutPt(edge2, longPoint);
            edge.outIdx = edge2.outIdx;
            edge.side = Edge.Side.RIGHT;
            edge2.side = Edge.Side.LEFT;
            edge = edge2.prevInAEL == edge ? edge.prevInAEL : edge2.prevInAEL;
        } else {
            outPt = this.addOutPt(edge, longPoint);
            edge2.outIdx = edge.outIdx;
            edge.side = Edge.Side.LEFT;
            edge2.side = Edge.Side.RIGHT;
            edge2 = edge.prevInAEL == edge2 ? edge2.prevInAEL : edge.prevInAEL;
            Edge edge3 = edge;
            edge = edge2;
            edge2 = edge3;
        }
        if (edge != null && edge.outIdx >= 0 && Edge.topX(edge, longPoint.getY()) == Edge.topX(edge2, longPoint.getY()) && Edge.slopesEqual(edge2, edge, this.useFullRange) && edge2.windDelta != 0 && edge.windDelta != 0) {
            this.addJoin(outPt, this.addOutPt(edge, longPoint), edge2.getTop());
        }
        return outPt;
    }

    private Path.OutPt addOutPt(Edge object, Point.LongPoint longPoint) {
        LOGGER.entering(DefaultClipper.class.getName(), "addOutPt");
        int n = object.outIdx;
        boolean bl = false;
        boolean bl2 = false;
        if (n < 0) {
            Path.OutPt outPt;
            Path.OutRec outRec = this.createOutRec();
            if (object.windDelta == 0) {
                bl2 = true;
            }
            outRec.isOpen = bl2;
            outRec.pts = outPt = new Path.OutPt();
            outPt.idx = outRec.Idx;
            outPt.pt = longPoint;
            outPt.next = outPt;
            outPt.prev = outPt;
            if (!outRec.isOpen) {
                this.setHoleState((Edge)object, outRec);
            }
            object.outIdx = outRec.Idx;
            return outPt;
        }
        Path.OutRec outRec = this.polyOuts.get(object.outIdx);
        Path.OutPt outPt = outRec.getPoints();
        bl2 = bl;
        if (object.side == Edge.Side.LEFT) {
            bl2 = true;
        }
        object = LOGGER;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("op=");
        stringBuilder.append(outPt.getPointCount());
        object.finest(stringBuilder.toString());
        object = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append(bl2);
        stringBuilder.append(" ");
        stringBuilder.append(longPoint);
        stringBuilder.append(" ");
        stringBuilder.append(outPt.getPt());
        object.finest(stringBuilder.toString());
        if (bl2 && longPoint.equals(outPt.getPt())) {
            return outPt;
        }
        if (!bl2 && longPoint.equals(outPt.prev.getPt())) {
            return outPt.prev;
        }
        object = new Path.OutPt();
        object.idx = outRec.Idx;
        object.setPt(new Point.LongPoint(longPoint));
        object.next = outPt;
        object.prev = outPt.prev;
        object.prev.next = object;
        outPt.prev = object;
        if (bl2) {
            outRec.setPoints((Path.OutPt)object);
        }
        return object;
    }

    private void appendPolygon(Edge edge, Edge edge2) {
        LOGGER.entering(DefaultClipper.class.getName(), "appendPolygon");
        Path.OutRec outRec = this.polyOuts.get(edge.outIdx);
        Path.OutRec outRec2 = this.polyOuts.get(edge2.outIdx);
        Object object = LOGGER;
        Object object2 = new StringBuilder();
        object2.append("");
        object2.append(edge.outIdx);
        object.finest(object2.toString());
        object = LOGGER;
        object2 = new StringBuilder();
        object2.append("");
        object2.append(edge2.outIdx);
        object.finest(object2.toString());
        object = DefaultClipper.isParam1RightOfParam2(outRec, outRec2) ? outRec2 : (DefaultClipper.isParam1RightOfParam2(outRec2, outRec) ? outRec : Path.OutPt.getLowerMostRec(outRec, outRec2));
        object2 = outRec.getPoints();
        Path.OutPt outPt = object2.prev;
        Path.OutPt outPt2 = outRec2.getPoints();
        Path.OutPt outPt3 = outPt2.prev;
        Logger logger = LOGGER;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("p1_lft.getPointCount() = ");
        stringBuilder.append(object2.getPointCount());
        logger.finest(stringBuilder.toString());
        logger = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append("p1_rt.getPointCount() = ");
        stringBuilder.append(outPt.getPointCount());
        logger.finest(stringBuilder.toString());
        logger = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append("p2_lft.getPointCount() = ");
        stringBuilder.append(outPt2.getPointCount());
        logger.finest(stringBuilder.toString());
        logger = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append("p2_rt.getPointCount() = ");
        stringBuilder.append(outPt3.getPointCount());
        logger.finest(stringBuilder.toString());
        if (edge.side == Edge.Side.LEFT) {
            if (edge2.side == Edge.Side.LEFT) {
                outPt2.reversePolyPtLinks();
                outPt2.next = object2;
                object2.prev = outPt2;
                outPt.next = outPt3;
                outPt3.prev = outPt;
                outRec.setPoints(outPt3);
            } else {
                outPt3.next = object2;
                object2.prev = outPt3;
                outPt2.prev = outPt;
                outPt.next = outPt2;
                outRec.setPoints(outPt2);
            }
            object2 = Edge.Side.LEFT;
        } else {
            if (edge2.side == Edge.Side.RIGHT) {
                outPt2.reversePolyPtLinks();
                outPt.next = outPt3;
                outPt3.prev = outPt;
                outPt2.next = object2;
                object2.prev = outPt2;
            } else {
                outPt.next = outPt2;
                outPt2.prev = outPt;
                object2.prev = outPt3;
                outPt3.next = object2;
            }
            object2 = Edge.Side.RIGHT;
        }
        outRec.bottomPt = null;
        if (object.equals(outRec2)) {
            if (outRec2.firstLeft != outRec) {
                outRec.firstLeft = outRec2.firstLeft;
            }
            outRec.isHole = outRec2.isHole;
        }
        outRec2.setPoints(null);
        outRec2.bottomPt = null;
        outRec2.firstLeft = outRec;
        int n = edge.outIdx;
        int n2 = edge2.outIdx;
        edge.outIdx = -1;
        edge2.outIdx = -1;
        edge = this.activeEdges;
        while (edge != null) {
            if (edge.outIdx == n2) {
                edge.outIdx = n;
                edge.side = object2;
                break;
            }
            edge = edge.nextInAEL;
        }
        outRec2.Idx = outRec.Idx;
    }

    private void buildIntersectList(long l) {
        Edge edge;
        if (this.activeEdges == null) {
            return;
        }
        this.sortedEdges = edge = this.activeEdges;
        while (edge != null) {
            edge.prevInSEL = edge.prevInAEL;
            edge.nextInSEL = edge.nextInAEL;
            edge.getCurrent().setX(Edge.topX(edge, l));
            edge = edge.nextInAEL;
        }
        boolean bl = true;
        while (bl && this.sortedEdges != null) {
            edge = this.sortedEdges;
            bl = false;
            while (edge.nextInSEL != null) {
                Edge edge2 = edge.nextInSEL;
                Point.LongPoint[] arrlongPoint = new Point.LongPoint[1];
                if (edge.getCurrent().getX() > edge2.getCurrent().getX()) {
                    this.intersectPoint(edge, edge2, arrlongPoint);
                    IntersectNode intersectNode = new IntersectNode();
                    intersectNode.edge1 = edge;
                    intersectNode.Edge2 = edge2;
                    intersectNode.setPt(arrlongPoint[0]);
                    this.intersectList.add(intersectNode);
                    this.swapPositionsInSEL(edge, edge2);
                    bl = true;
                    continue;
                }
                edge = edge2;
            }
            if (edge.prevInSEL == null) break;
            edge.prevInSEL.nextInSEL = null;
        }
        this.sortedEdges = null;
    }

    private void buildResult(Paths paths) {
        paths.clear();
        for (int i = 0; i < this.polyOuts.size(); ++i) {
            Object object = this.polyOuts.get(i);
            if (object.getPoints() == null) continue;
            object = object.getPoints().prev;
            int n = object.getPointCount();
            Object object2 = LOGGER;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("cnt = ");
            stringBuilder.append(n);
            object2.finest(stringBuilder.toString());
            if (n < 2) continue;
            object2 = new Path(n);
            for (int j = 0; j < n; ++j) {
                object2.add(object.getPt());
                object = object.prev;
            }
            paths.add(object2);
        }
    }

    private void buildResult2(PolyTree polyTree) {
        int n;
        Object object;
        polyTree.Clear();
        int n2 = 0;
        int n3 = 0;
        do {
            if (n3 >= this.polyOuts.size()) break;
            object = this.polyOuts.get(n3);
            n = object.getPoints() != null ? object.getPoints().getPointCount() : 0;
            if (!(object.isOpen && n < 2 || !object.isOpen && n < 3)) {
                object.fixHoleLinkage();
                PolyNode polyNode = new PolyNode();
                polyTree.getAllPolys().add(polyNode);
                object.polyNode = polyNode;
                object = object.getPoints().prev;
                for (int i = 0; i < n; ++i) {
                    polyNode.getPolygon().add(object.getPt());
                    object = object.prev;
                }
            }
            ++n3;
        } while (true);
        for (n = n2; n < this.polyOuts.size(); ++n) {
            object = this.polyOuts.get(n);
            if (object.polyNode == null) continue;
            if (object.isOpen) {
                object.polyNode.setOpen(true);
                polyTree.addChild(object.polyNode);
                continue;
            }
            if (object.firstLeft != null && object.firstLeft.polyNode != null) {
                object.firstLeft.polyNode.addChild(object.polyNode);
                continue;
            }
            polyTree.addChild(object.polyNode);
        }
    }

    private void copyAELToSEL() {
        Edge edge;
        this.sortedEdges = edge = this.activeEdges;
        while (edge != null) {
            edge.prevInSEL = edge.prevInAEL;
            edge.nextInSEL = edge.nextInAEL;
            edge = edge.nextInAEL;
        }
    }

    private Path.OutRec createOutRec() {
        Path.OutRec outRec = new Path.OutRec();
        outRec.Idx = -1;
        outRec.isHole = false;
        outRec.isOpen = false;
        outRec.firstLeft = null;
        outRec.setPoints(null);
        outRec.bottomPt = null;
        outRec.polyNode = null;
        this.polyOuts.add(outRec);
        outRec.Idx = this.polyOuts.size() - 1;
        return outRec;
    }

    private void deleteFromAEL(Edge edge) {
        LOGGER.entering(DefaultClipper.class.getName(), "deleteFromAEL");
        Edge edge2 = edge.prevInAEL;
        Edge edge3 = edge.nextInAEL;
        if (edge2 == null && edge3 == null && edge != this.activeEdges) {
            return;
        }
        if (edge2 != null) {
            edge2.nextInAEL = edge3;
        } else {
            this.activeEdges = edge3;
        }
        if (edge3 != null) {
            edge3.prevInAEL = edge2;
        }
        edge.nextInAEL = null;
        edge.prevInAEL = null;
        LOGGER.exiting(DefaultClipper.class.getName(), "deleteFromAEL");
    }

    private void deleteFromSEL(Edge edge) {
        LOGGER.entering(DefaultClipper.class.getName(), "deleteFromSEL");
        Edge edge2 = edge.prevInSEL;
        Edge edge3 = edge.nextInSEL;
        if (edge2 == null && edge3 == null && !edge.equals(this.sortedEdges)) {
            return;
        }
        if (edge2 != null) {
            edge2.nextInSEL = edge3;
        } else {
            this.sortedEdges = edge3;
        }
        if (edge3 != null) {
            edge3.prevInSEL = edge2;
        }
        edge.nextInSEL = null;
        edge.prevInSEL = null;
    }

    private boolean doHorzSegmentsOverlap(long l, long l2, long l3, long l4) {
        long l5 = l;
        long l6 = l2;
        if (l > l2) {
            l6 = l;
            l5 = l2;
        }
        if (l3 > l4) {
            l = l4;
        } else {
            l = l3;
            l3 = l4;
        }
        if (l5 < l3 && l < l6) {
            return true;
        }
        return false;
    }

    private void doMaxima(Edge edge) {
        Edge edge2 = edge.getMaximaPair();
        if (edge2 == null) {
            if (edge.outIdx >= 0) {
                this.addOutPt(edge, edge.getTop());
            }
            this.deleteFromAEL(edge);
            return;
        }
        Edge edge3 = edge.nextInAEL;
        while (edge3 != null && edge3 != edge2) {
            Point.LongPoint longPoint = new Point.LongPoint(edge.getTop());
            this.intersectEdges(edge, edge3, longPoint);
            edge.setTop(longPoint);
            this.swapPositionsInAEL(edge, edge3);
            edge3 = edge.nextInAEL;
        }
        if (edge.outIdx == -1 && edge2.outIdx == -1) {
            this.deleteFromAEL(edge);
            this.deleteFromAEL(edge2);
            return;
        }
        if (edge.outIdx >= 0 && edge2.outIdx >= 0) {
            if (edge.outIdx >= 0) {
                this.addLocalMaxPoly(edge, edge2, edge.getTop());
            }
            this.deleteFromAEL(edge);
            this.deleteFromAEL(edge2);
            return;
        }
        if (edge.windDelta == 0) {
            if (edge.outIdx >= 0) {
                this.addOutPt(edge, edge.getTop());
                edge.outIdx = -1;
            }
            this.deleteFromAEL(edge);
            if (edge2.outIdx >= 0) {
                this.addOutPt(edge2, edge.getTop());
                edge2.outIdx = -1;
            }
            this.deleteFromAEL(edge2);
            return;
        }
        throw new IllegalStateException("DoMaxima error");
    }

    private void doSimplePolygons() {
        for (int i = 0; i < this.polyOuts.size(); ++i) {
            Path.OutPt outPt;
            Path.OutRec outRec = this.polyOuts.get(i);
            Path.OutPt outPt2 = outRec.getPoints();
            if (outPt2 == null || outRec.isOpen) continue;
            do {
                outPt = outPt2.next;
                while (outPt != outRec.getPoints()) {
                    Object object = outPt;
                    if (outPt2.getPt().equals(outPt.getPt())) {
                        object = outPt;
                        if (!outPt.next.equals(outPt2)) {
                            object = outPt;
                            if (!outPt.prev.equals(outPt2)) {
                                Path.OutPt outPt3;
                                object = outPt2.prev;
                                outPt2.prev = outPt3 = outPt.prev;
                                outPt3.next = outPt2;
                                outPt.prev = object;
                                object.next = outPt;
                                outRec.setPoints(outPt2);
                                object = this.createOutRec();
                                object.setPoints(outPt);
                                this.updateOutPtIdxs((Path.OutRec)object);
                                if (DefaultClipper.poly2ContainsPoly1(object.getPoints(), outRec.getPoints())) {
                                    object.isHole = outRec.isHole ^ true;
                                    object.firstLeft = outRec;
                                    if (this.usingPolyTree) {
                                        this.fixupFirstLefts2((Path.OutRec)object, outRec);
                                    }
                                } else if (DefaultClipper.poly2ContainsPoly1(outRec.getPoints(), object.getPoints())) {
                                    object.isHole = outRec.isHole;
                                    outRec.isHole = object.isHole ^ true;
                                    object.firstLeft = outRec.firstLeft;
                                    outRec.firstLeft = object;
                                    if (this.usingPolyTree) {
                                        this.fixupFirstLefts2(outRec, (Path.OutRec)object);
                                    }
                                } else {
                                    object.isHole = outRec.isHole;
                                    object.firstLeft = outRec.firstLeft;
                                    if (this.usingPolyTree) {
                                        this.fixupFirstLefts1(outRec, (Path.OutRec)object);
                                    }
                                }
                                object = outPt2;
                            }
                        }
                    }
                    outPt = object.next;
                }
                outPt2 = outPt = outPt2.next;
            } while (outPt != outRec.getPoints());
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    private boolean executeInternal() {
        block20 : {
            block18 : {
                block19 : {
                    block17 : {
                        block16 : {
                            this.reset();
                            var11_1 = this.currentLM;
                            var3_3 = 0;
                            if (var11_1 != null) break block16;
                            do {
                                this.joins.clear();
                                this.ghostJoins.clear();
                                return false;
                                break;
                            } while (true);
                        }
                        try {
                            var5_4 = this.popScanbeam();
                            do lbl-1000: // 3 sources:
                            {
                                this.insertLocalMinimaIntoAEL(var5_4);
                                this.processHorizontals();
                                this.ghostJoins.clear();
                                if (this.scanbeam == null) break block17;
                                if (!this.processIntersections(var7_5 = this.popScanbeam())) ** continue;
                                this.processEdgesAtTopOfScanbeam(var7_5);
                                var5_4 = var7_5;
                                if (this.scanbeam != null) ** GOTO lbl-1000
                                var5_4 = var7_5;
                            } while (this.currentLM != null);
                            break block17;
lbl25: // 2 sources:
                            var4_8 = this.polyOuts.size();
                            var2_7 = true;
                            if (var1_6 >= var4_8) ** GOTO lbl-1000
                            var11_1 = this.polyOuts.get(var1_6);
                            if (var11_1.pts == null || var11_1.isOpen) break block18;
                            var9_9 = var11_1.isHole;
                            var10_10 = this.reverseSolution;
                            if (var11_1.area() <= 0.0) break block19;
                        }
                        catch (Throwable var11_2) {
                            this.joins.clear();
                            this.ghostJoins.clear();
                            throw var11_2;
                        }
lbl33: // 1 sources:
                        if ((var9_9 ^ var10_10) == var2_7) {
                            var11_1.getPoints().reversePolyPtLinks();
                            break block18;
                        }
                        break block18;
lbl-1000: // 1 sources:
                        {
                            this.joinCommonEdges();
                            var1_6 = var3_3;
lbl40: // 2 sources:
                            if (var1_6 < this.polyOuts.size()) {
                                var11_1 = this.polyOuts.get(var1_6);
                                if (var11_1.getPoints() != null) {
                                    if (var11_1.isOpen) {
                                        this.fixupOutPolyline((Path.OutRec)var11_1);
                                    } else {
                                        this.fixupOutPolygon((Path.OutRec)var11_1);
                                    }
                                }
                                break block20;
                            }
                            if (this.strictlySimple) {
                                this.doSimplePolygons();
                            }
                            this.joins.clear();
                            this.ghostJoins.clear();
                            return true;
                        }
                    }
                    var1_6 = 0;
                    ** GOTO lbl25
                }
                var2_7 = false;
                ** GOTO lbl33
            }
            ++var1_6;
            ** GOTO lbl25
        }
        ++var1_6;
        ** GOTO lbl40
    }

    private void fixupFirstLefts1(Path.OutRec outRec, Path.OutRec outRec2) {
        for (int i = 0; i < this.polyOuts.size(); ++i) {
            Path.OutRec outRec3 = this.polyOuts.get(i);
            if (outRec3.getPoints() == null || outRec3.firstLeft == null || !DefaultClipper.parseFirstLeft(outRec3.firstLeft).equals(outRec) || !DefaultClipper.poly2ContainsPoly1(outRec3.getPoints(), outRec2.getPoints())) continue;
            outRec3.firstLeft = outRec2;
        }
    }

    private void fixupFirstLefts2(Path.OutRec outRec, Path.OutRec outRec2) {
        for (Path.OutRec outRec3 : this.polyOuts) {
            if (outRec3.firstLeft != outRec) continue;
            outRec3.firstLeft = outRec2;
        }
    }

    private boolean fixupIntersectionOrder() {
        Collections.sort(this.intersectList, this.intersectNodeComparer);
        this.copyAELToSEL();
        int n = this.intersectList.size();
        for (int i = 0; i < n; ++i) {
            if (!this.EdgesAdjacent(this.intersectList.get(i))) {
                int n2;
                for (n2 = i + 1; n2 < n && !this.EdgesAdjacent(this.intersectList.get(n2)); ++n2) {
                }
                if (n2 == n) {
                    return false;
                }
                IntersectNode intersectNode = this.intersectList.get(i);
                this.intersectList.set(i, this.intersectList.get(n2));
                this.intersectList.set(n2, intersectNode);
            }
            this.swapPositionsInSEL(this.intersectList.get((int)i).edge1, this.intersectList.get((int)i).Edge2);
        }
        return true;
    }

    private void fixupOutPolygon(Path.OutRec outRec) {
        outRec.bottomPt = null;
        Path.OutPt outPt = outRec.getPoints();
        boolean bl = this.preserveCollinear || this.strictlySimple;
        block0 : do {
            Path.OutPt outPt2 = null;
            while (outPt.prev != outPt && outPt.prev != outPt.next) {
                if (!outPt.getPt().equals(outPt.next.getPt()) && !outPt.getPt().equals(outPt.prev.getPt()) && (!Point.slopesEqual(outPt.prev.getPt(), outPt.getPt(), outPt.next.getPt(), this.useFullRange) || bl && Point.isPt2BetweenPt1AndPt3(outPt.prev.getPt(), outPt.getPt(), outPt.next.getPt()))) {
                    if (outPt == outPt2) {
                        outRec.setPoints(outPt);
                        return;
                    }
                    Path.OutPt outPt3 = outPt2;
                    if (outPt2 == null) {
                        outPt3 = outPt;
                    }
                    outPt = outPt.next;
                    outPt2 = outPt3;
                    continue;
                }
                outPt.prev.next = outPt.next;
                outPt.next.prev = outPt.prev;
                outPt = outPt.prev;
                continue block0;
            }
            break;
        } while (true);
        outRec.setPoints(null);
    }

    private void fixupOutPolyline(Path.OutRec outRec) {
        Path.OutPt outPt = outRec.pts;
        Path.OutPt outPt2 = outPt.prev;
        while (outPt != outPt2) {
            Path.OutPt outPt3;
            outPt = outPt3 = outPt.next;
            if (!outPt3.pt.equals(outPt3.prev.pt)) continue;
            Path.OutPt outPt4 = outPt2;
            if (outPt3 == outPt2) {
                outPt4 = outPt3.prev;
            }
            outPt = outPt3.prev;
            outPt.next = outPt3.next;
            outPt3.next.prev = outPt;
            outPt2 = outPt4;
        }
        if (outPt == outPt.prev) {
            outRec.pts = null;
        }
    }

    private static void getHorzDirection(Edge edge, Clipper.Direction[] arrdirection, long[] arrl, long[] arrl2) {
        if (edge.getBot().getX() < edge.getTop().getX()) {
            arrl[0] = edge.getBot().getX();
            arrl2[0] = edge.getTop().getX();
            arrdirection[0] = Clipper.Direction.LEFT_TO_RIGHT;
            return;
        }
        arrl[0] = edge.getTop().getX();
        arrl2[0] = edge.getBot().getX();
        arrdirection[0] = Clipper.Direction.RIGHT_TO_LEFT;
    }

    private Path.OutRec getOutRec(int n) {
        Path.OutRec outRec = this.polyOuts.get(n);
        while (outRec != this.polyOuts.get(outRec.Idx)) {
            outRec = this.polyOuts.get(outRec.Idx);
        }
        return outRec;
    }

    private static boolean getOverlap(long l, long l2, long l3, long l4, long[] arrl, long[] arrl2) {
        boolean bl = false;
        if (l < l2) {
            if (l3 < l4) {
                arrl[0] = Math.max(l, l3);
                arrl2[0] = Math.min(l2, l4);
            } else {
                arrl[0] = Math.max(l, l4);
                arrl2[0] = Math.min(l2, l3);
            }
        } else if (l3 < l4) {
            arrl[0] = Math.max(l2, l3);
            arrl2[0] = Math.min(l, l4);
        } else {
            arrl[0] = Math.max(l2, l4);
            arrl2[0] = Math.min(l, l3);
        }
        if (arrl[0] < arrl2[0]) {
            bl = true;
        }
        return bl;
    }

    private void insertEdgeIntoAEL(Edge edge, Edge object) {
        LOGGER.entering(DefaultClipper.class.getName(), "insertEdgeIntoAEL");
        if (this.activeEdges == null) {
            edge.prevInAEL = null;
            edge.nextInAEL = null;
            object = LOGGER;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Edge ");
            stringBuilder.append(edge.outIdx);
            stringBuilder.append(" -> ");
            stringBuilder.append((Object)null);
            object.finest(stringBuilder.toString());
            this.activeEdges = edge;
            return;
        }
        if (object == null && Edge.doesE2InsertBeforeE1(this.activeEdges, edge)) {
            edge.prevInAEL = null;
            edge.nextInAEL = this.activeEdges;
            object = LOGGER;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Edge ");
            stringBuilder.append(edge.outIdx);
            stringBuilder.append(" -> ");
            stringBuilder.append(edge.nextInAEL.outIdx);
            object.finest(stringBuilder.toString());
            this.activeEdges.prevInAEL = edge;
            this.activeEdges = edge;
            return;
        }
        LOGGER.finest("activeEdges unchanged");
        Edge edge2 = object;
        if (object == null) {
            edge2 = this.activeEdges;
        }
        while (edge2.nextInAEL != null && !Edge.doesE2InsertBeforeE1(edge2.nextInAEL, edge)) {
            edge2 = edge2.nextInAEL;
        }
        edge.nextInAEL = edge2.nextInAEL;
        if (edge2.nextInAEL != null) {
            edge2.nextInAEL.prevInAEL = edge;
        }
        edge.prevInAEL = edge2;
        edge2.nextInAEL = edge;
    }

    private void insertLocalMinimaIntoAEL(long l) {
        LOGGER.entering(DefaultClipper.class.getName(), "insertLocalMinimaIntoAEL");
        while (this.currentLM != null && this.currentLM.y == l) {
            Edge edge = this.currentLM.leftBound;
            Edge edge2 = this.currentLM.rightBound;
            this.popLocalMinima();
            Object object = null;
            Object var6_5 = null;
            Object object2 = null;
            if (edge == null) {
                this.insertEdgeIntoAEL(edge2, null);
                this.updateWindingCount(edge2);
                if (edge2.isContributing(this.clipFillType, this.subjFillType, this.clipType)) {
                    object2 = this.addOutPt(edge2, edge2.getBot());
                }
            } else if (edge2 == null) {
                this.insertEdgeIntoAEL(edge, null);
                this.updateWindingCount(edge);
                object2 = object;
                if (edge.isContributing(this.clipFillType, this.subjFillType, this.clipType)) {
                    object2 = this.addOutPt(edge, edge.getBot());
                }
                this.insertScanbeam(edge.getTop().getY());
            } else {
                this.insertEdgeIntoAEL(edge, null);
                this.insertEdgeIntoAEL(edge2, edge);
                this.updateWindingCount(edge);
                edge2.windCnt = edge.windCnt;
                edge2.windCnt2 = edge.windCnt2;
                object2 = var6_5;
                if (edge.isContributing(this.clipFillType, this.subjFillType, this.clipType)) {
                    object2 = this.addLocalMinPoly(edge, edge2, edge.getBot());
                }
                this.insertScanbeam(edge.getTop().getY());
            }
            if (edge2 != null) {
                if (edge2.isHorizontal()) {
                    this.addEdgeToSEL(edge2);
                } else {
                    this.insertScanbeam(edge2.getTop().getY());
                }
            }
            if (edge == null || edge2 == null) continue;
            if (object2 != null && edge2.isHorizontal() && this.ghostJoins.size() > 0 && edge2.windDelta != 0) {
                for (int i = 0; i < this.ghostJoins.size(); ++i) {
                    object = this.ghostJoins.get(i);
                    if (!this.doHorzSegmentsOverlap(object.outPt1.getPt().getX(), object.getOffPt().getX(), edge2.getBot().getX(), edge2.getTop().getX())) continue;
                    this.addJoin(object.outPt1, (Path.OutPt)object2, object.getOffPt());
                }
            }
            if (edge.outIdx >= 0 && edge.prevInAEL != null && edge.prevInAEL.getCurrent().getX() == edge.getBot().getX() && edge.prevInAEL.outIdx >= 0 && Edge.slopesEqual(edge.prevInAEL, edge, this.useFullRange) && edge.windDelta != 0 && edge.prevInAEL.windDelta != 0) {
                this.addJoin((Path.OutPt)object2, this.addOutPt(edge.prevInAEL, edge.getBot()), edge.getTop());
            }
            if (edge.nextInAEL == edge2) continue;
            if (edge2.outIdx >= 0 && edge2.prevInAEL.outIdx >= 0 && Edge.slopesEqual(edge2.prevInAEL, edge2, this.useFullRange) && edge2.windDelta != 0 && edge2.prevInAEL.windDelta != 0) {
                this.addJoin((Path.OutPt)object2, this.addOutPt(edge2.prevInAEL, edge2.getBot()), edge2.getTop());
            }
            if ((object2 = edge.nextInAEL) == null) continue;
            while (object2 != edge2) {
                this.intersectEdges(edge2, (Edge)object2, edge.getCurrent());
                object2 = object2.nextInAEL;
            }
        }
    }

    private void insertScanbeam(long l) {
        if (this.scanbeam == null) {
            this.scanbeam = new ClipperBase.Scanbeam();
            this.scanbeam.next = null;
            this.scanbeam.y = l;
            return;
        }
        if (l > this.scanbeam.y) {
            ClipperBase.Scanbeam scanbeam = new ClipperBase.Scanbeam();
            scanbeam.y = l;
            scanbeam.next = this.scanbeam;
            this.scanbeam = scanbeam;
            return;
        }
        ClipperBase.Scanbeam scanbeam = this.scanbeam;
        while (scanbeam.next != null && l <= scanbeam.next.y) {
            scanbeam = scanbeam.next;
        }
        if (l == scanbeam.y) {
            return;
        }
        ClipperBase.Scanbeam scanbeam2 = new ClipperBase.Scanbeam();
        scanbeam2.y = l;
        scanbeam2.next = scanbeam.next;
        scanbeam.next = scanbeam2;
    }

    private void intersectEdges(Edge edge, Edge edge2, Point.LongPoint longPoint) {
        int n;
        int n2;
        block58 : {
            block60 : {
                block62 : {
                    Clipper.PolyFillType polyFillType;
                    Clipper.PolyFillType polyFillType2;
                    int n3;
                    int n4;
                    block61 : {
                        block59 : {
                            Clipper.PolyFillType polyFillType3;
                            Clipper.PolyFillType polyFillType4;
                            LOGGER.entering(DefaultClipper.class.getName(), "insersectEdges");
                            n4 = edge.outIdx;
                            n3 = 0;
                            n = n4 >= 0 ? 1 : 0;
                            n2 = edge2.outIdx >= 0 ? 1 : 0;
                            this.setZ(longPoint, edge, edge2);
                            if (edge.windDelta == 0 || edge2.windDelta == 0) break block58;
                            if (edge.polyTyp == edge2.polyTyp) {
                                if (edge.isEvenOddFillType(this.clipFillType, this.subjFillType)) {
                                    n4 = edge.windCnt;
                                    edge.windCnt = edge2.windCnt;
                                    edge2.windCnt = n4;
                                } else {
                                    edge.windCnt = edge.windCnt + edge2.windDelta == 0 ? - edge.windCnt : (edge.windCnt += edge2.windDelta);
                                    edge2.windCnt = edge2.windCnt - edge.windDelta == 0 ? - edge2.windCnt : (edge2.windCnt -= edge.windDelta);
                                }
                            } else {
                                if (!edge2.isEvenOddFillType(this.clipFillType, this.subjFillType)) {
                                    edge.windCnt2 += edge2.windDelta;
                                } else {
                                    n4 = edge.windCnt2 == 0 ? 1 : 0;
                                    edge.windCnt2 = n4;
                                }
                                if (!edge.isEvenOddFillType(this.clipFillType, this.subjFillType)) {
                                    edge2.windCnt2 -= edge.windDelta;
                                } else {
                                    n4 = n3;
                                    if (edge2.windCnt2 == 0) {
                                        n4 = 1;
                                    }
                                    edge2.windCnt2 = n4;
                                }
                            }
                            if (edge.polyTyp == Clipper.PolyType.SUBJECT) {
                                polyFillType4 = this.subjFillType;
                                polyFillType2 = this.clipFillType;
                            } else {
                                polyFillType4 = this.clipFillType;
                                polyFillType2 = this.subjFillType;
                            }
                            if (edge2.polyTyp == Clipper.PolyType.SUBJECT) {
                                polyFillType3 = this.subjFillType;
                                polyFillType = this.clipFillType;
                            } else {
                                polyFillType3 = this.clipFillType;
                                polyFillType = this.subjFillType;
                            }
                            switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[polyFillType4.ordinal()]) {
                                default: {
                                    n4 = Math.abs(edge.windCnt);
                                    break;
                                }
                                case 2: {
                                    n4 = - edge.windCnt;
                                    break;
                                }
                                case 1: {
                                    n4 = edge.windCnt;
                                }
                            }
                            switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[polyFillType3.ordinal()]) {
                                default: {
                                    n3 = Math.abs(edge2.windCnt);
                                    break;
                                }
                                case 2: {
                                    n3 = - edge2.windCnt;
                                    break;
                                }
                                case 1: {
                                    n3 = edge2.windCnt;
                                }
                            }
                            if (n != 0 && n2 != 0) {
                                if (n4 != 0 && n4 != 1 || n3 != 0 && n3 != 1 || edge.polyTyp != edge2.polyTyp && this.clipType != Clipper.ClipType.XOR) {
                                    this.addLocalMaxPoly(edge, edge2, longPoint);
                                    return;
                                }
                                this.addOutPt(edge, longPoint);
                                this.addOutPt(edge2, longPoint);
                                Edge.swapSides(edge, edge2);
                                Edge.swapPolyIndexes(edge, edge2);
                                return;
                            }
                            if (n == 0) break block59;
                            if (n3 == 0 || n3 == 1) {
                                this.addOutPt(edge, longPoint);
                                Edge.swapSides(edge, edge2);
                                Edge.swapPolyIndexes(edge, edge2);
                                return;
                            }
                            break block60;
                        }
                        if (n2 == 0) break block61;
                        if (n4 == 0 || n4 == 1) {
                            this.addOutPt(edge2, longPoint);
                            Edge.swapSides(edge, edge2);
                            Edge.swapPolyIndexes(edge, edge2);
                            return;
                        }
                        break block60;
                    }
                    if (n4 != 0 && n4 != 1 || n3 != 0 && n3 != 1) break block60;
                    switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[polyFillType2.ordinal()]) {
                        default: {
                            n = Math.abs(edge.windCnt2);
                            break;
                        }
                        case 2: {
                            n = - edge.windCnt2;
                            break;
                        }
                        case 1: {
                            n = edge.windCnt2;
                        }
                    }
                    switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[polyFillType.ordinal()]) {
                        default: {
                            n2 = Math.abs(edge2.windCnt2);
                            break;
                        }
                        case 2: {
                            n2 = - edge2.windCnt2;
                            break;
                        }
                        case 1: {
                            n2 = edge2.windCnt2;
                        }
                    }
                    if (edge.polyTyp != edge2.polyTyp) {
                        this.addLocalMinPoly(edge, edge2, longPoint);
                        return;
                    }
                    if (n4 != 1 || n3 != 1) break block62;
                    switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$ClipType[this.clipType.ordinal()]) {
                        default: {
                            return;
                        }
                        case 4: {
                            this.addLocalMinPoly(edge, edge2, longPoint);
                            return;
                        }
                        case 3: {
                            if (edge.polyTyp == Clipper.PolyType.CLIP && n > 0 && n2 > 0 || edge.polyTyp == Clipper.PolyType.SUBJECT && n <= 0 && n2 <= 0) {
                                this.addLocalMinPoly(edge, edge2, longPoint);
                                return;
                            }
                            break block60;
                        }
                        case 2: {
                            if (n <= 0 && n2 <= 0) {
                                this.addLocalMinPoly(edge, edge2, longPoint);
                                return;
                            }
                            break block60;
                        }
                        case 1: {
                            if (n > 0 && n2 > 0) {
                                this.addLocalMinPoly(edge, edge2, longPoint);
                                return;
                            }
                            break block60;
                        }
                    }
                }
                Edge.swapSides(edge, edge2);
            }
            return;
        }
        if (edge.windDelta == 0 && edge2.windDelta == 0) {
            return;
        }
        if (edge.polyTyp == edge2.polyTyp && edge.windDelta != edge2.windDelta && this.clipType == Clipper.ClipType.UNION) {
            if (edge.windDelta == 0) {
                if (n2 != 0) {
                    this.addOutPt(edge, longPoint);
                    if (n != 0) {
                        edge.outIdx = -1;
                        return;
                    }
                }
            } else if (n != 0) {
                this.addOutPt(edge2, longPoint);
                if (n2 != 0) {
                    edge2.outIdx = -1;
                    return;
                }
            }
        } else if (edge.polyTyp != edge2.polyTyp) {
            if (edge.windDelta == 0 && Math.abs(edge2.windCnt) == 1 && (this.clipType != Clipper.ClipType.UNION || edge2.windCnt2 == 0)) {
                this.addOutPt(edge, longPoint);
                if (n != 0) {
                    edge.outIdx = -1;
                    return;
                }
            } else if (edge2.windDelta == 0 && Math.abs(edge.windCnt) == 1 && (this.clipType != Clipper.ClipType.UNION || edge.windCnt2 == 0)) {
                this.addOutPt(edge2, longPoint);
                if (n2 != 0) {
                    edge2.outIdx = -1;
                }
            }
        }
    }

    private void intersectPoint(Edge edge, Edge edge2, Point.LongPoint[] arrlongPoint) {
        Point.LongPoint longPoint;
        arrlongPoint[0] = longPoint = new Point.LongPoint();
        if (edge.deltaX == edge2.deltaX) {
            longPoint.setY(edge.getCurrent().getY());
            longPoint.setX(Edge.topX(edge, longPoint.getY()));
            return;
        }
        if (edge.getDelta().getX() == 0L) {
            longPoint.setX(edge.getBot().getX());
            if (edge2.isHorizontal()) {
                longPoint.setY(edge2.getBot().getY());
            } else {
                double d = edge2.getBot().getY();
                double d2 = (double)edge2.getBot().getX() / edge2.deltaX;
                longPoint.setY(Math.round((double)longPoint.getX() / edge2.deltaX + (d - d2)));
            }
        } else if (edge2.getDelta().getX() == 0L) {
            longPoint.setX(edge2.getBot().getX());
            if (edge.isHorizontal()) {
                longPoint.setY(edge.getBot().getY());
            } else {
                double d = edge.getBot().getY();
                double d3 = (double)edge.getBot().getX() / edge.deltaX;
                longPoint.setY(Math.round((double)longPoint.getX() / edge.deltaX + (d - d3)));
            }
        } else {
            double d = (double)edge.getBot().getX() - (double)edge.getBot().getY() * edge.deltaX;
            double d4 = (double)edge2.getBot().getX() - (double)edge2.getBot().getY() * edge2.deltaX;
            double d5 = (d4 - d) / (edge.deltaX - edge2.deltaX);
            longPoint.setY(Math.round(d5));
            if (Math.abs(edge.deltaX) < Math.abs(edge2.deltaX)) {
                longPoint.setX(Math.round(edge.deltaX * d5 + d));
            } else {
                longPoint.setX(Math.round(edge2.deltaX * d5 + d4));
            }
        }
        if (longPoint.getY() < edge.getTop().getY() || longPoint.getY() < edge2.getTop().getY()) {
            if (edge.getTop().getY() > edge2.getTop().getY()) {
                longPoint.setY(edge.getTop().getY());
            } else {
                longPoint.setY(edge2.getTop().getY());
            }
            if (Math.abs(edge.deltaX) < Math.abs(edge2.deltaX)) {
                longPoint.setX(Edge.topX(edge, longPoint.getY()));
            } else {
                longPoint.setX(Edge.topX(edge2, longPoint.getY()));
            }
        }
        if (longPoint.getY() > edge.getCurrent().getY()) {
            longPoint.setY(edge.getCurrent().getY());
            if (Math.abs(edge.deltaX) > Math.abs(edge2.deltaX)) {
                longPoint.setX(Edge.topX(edge2, longPoint.getY()));
                return;
            }
            longPoint.setX(Edge.topX(edge, longPoint.getY()));
        }
    }

    private static boolean isParam1RightOfParam2(Path.OutRec outRec, Path.OutRec outRec2) {
        Path.OutRec outRec3;
        do {
            if ((outRec3 = outRec.firstLeft) == outRec2) {
                return true;
            }
            outRec = outRec3;
        } while (outRec3 != null);
        return false;
    }

    private static int isPointInPolygon(Point.LongPoint object, Path.OutPt outPt) {
        long l = object.getX();
        long l2 = object.getY();
        long l3 = outPt.getPt().getX();
        long l4 = outPt.getPt().getY();
        int n = 0;
        object = outPt;
        do {
            boolean bl;
            boolean bl2;
            long l5;
            long l6;
            block16 : {
                block17 : {
                    object = object.next;
                    l5 = object.getPt().getX();
                    l6 = object.getPt().getY();
                    if (l6 != l2) break block16;
                    if (l5 == l) break block17;
                    if (l4 != l2) break block16;
                    bl2 = l5 > l;
                    bl = l3 < l;
                    if (bl2 != bl) break block16;
                }
                return -1;
            }
            bl2 = l4 < l2;
            bl = l6 < l2;
            if (bl2 != bl) {
                double d;
                if (l3 >= l) {
                    if (l5 > l) {
                        n = 1 - n;
                    } else {
                        d = (double)(l3 - l) * (double)(l6 - l2) - (double)(l5 - l) * (double)(l4 - l2);
                        if (d == 0.0) {
                            return -1;
                        }
                        bl2 = d > 0.0;
                        bl = l6 > l4;
                        if (bl2 == bl) {
                            n = 1 - n;
                        }
                    }
                } else {
                    long l7 = l;
                    if (l5 > l7) {
                        d = (double)(l3 - l7) * (double)(l6 - l2) - (double)(l5 - l7) * (double)(l4 - l2);
                        if (d == 0.0) {
                            return -1;
                        }
                        bl2 = d > 0.0;
                        bl = l6 > l4;
                        if (bl2 == bl) {
                            n = 1 - n;
                        }
                    }
                }
            }
            if (outPt == object) {
                return n;
            }
            l3 = l5;
            l4 = l6;
        } while (true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void joinCommonEdges() {
        var1_1 = 0;
        while (var1_1 < this.joins.size()) {
            block17 : {
                block19 : {
                    block20 : {
                        block18 : {
                            var10_10 = this.joins.get(var1_1);
                            var8_8 = this.getOutRec(var10_10.outPt1.idx);
                            var9_9 = this.getOutRec(var10_10.outPt2.idx);
                            if (var8_8.getPoints() == null || var9_9.getPoints() == null || var8_8.isOpen || var9_9.isOpen) break block17;
                            if (var8_8 == var9_9) ** GOTO lbl-1000
                            if (DefaultClipper.isParam1RightOfParam2(var8_8, var9_9)) {
                                var7_7 = var9_9;
                            } else if (DefaultClipper.isParam1RightOfParam2(var9_9, var8_8)) lbl-1000: // 2 sources:
                            {
                                var7_7 = var8_8;
                            } else {
                                var7_7 = Path.OutPt.getLowerMostRec(var8_8, var9_9);
                            }
                            if (!this.joinPoints(var10_10, var8_8, var9_9)) break block17;
                            if (var8_8 != var9_9) break block18;
                            var8_8.setPoints(var10_10.outPt1);
                            var8_8.bottomPt = null;
                            var7_7 = this.createOutRec();
                            var7_7.setPoints(var10_10.outPt2);
                            this.updateOutPtIdxs(var7_7);
                            var5_5 = this.usingPolyTree;
                            var4_4 = 1;
                            var3_3 = 1;
                            if (!var5_5) break block19;
                            break block20;
                        }
                        var9_9.setPoints(null);
                        var9_9.bottomPt = null;
                        var9_9.Idx = var8_8.Idx;
                        var8_8.isHole = var7_7.isHole;
                        if (var7_7 == var9_9) {
                            var8_8.firstLeft = var9_9.firstLeft;
                        }
                        var9_9.firstLeft = var8_8;
                        if (this.usingPolyTree) {
                            this.fixupFirstLefts2(var9_9, var8_8);
                        }
                        break block17;
                    }
                    for (var2_2 = 0; var2_2 < this.polyOuts.size() - 1; ++var2_2) {
                        var9_9 = this.polyOuts.get(var2_2);
                        if (var9_9.getPoints() == null || DefaultClipper.parseFirstLeft(var9_9.firstLeft) != var8_8 || var9_9.isHole == var8_8.isHole || !DefaultClipper.poly2ContainsPoly1(var9_9.getPoints(), var10_10.outPt2)) continue;
                        var9_9.firstLeft = var7_7;
                    }
                }
                if (DefaultClipper.poly2ContainsPoly1(var7_7.getPoints(), var8_8.getPoints())) {
                    var7_7.isHole = var8_8.isHole ^ true;
                    var7_7.firstLeft = var8_8;
                    if (this.usingPolyTree) {
                        this.fixupFirstLefts2(var7_7, var8_8);
                    }
                    var5_5 = var7_7.isHole;
                    var6_6 = this.reverseSolution;
                    var2_2 = var7_7.area() > 0.0 ? var3_3 : 0;
                    if ((var5_5 ^ var6_6) == var2_2) {
                        var7_7.getPoints().reversePolyPtLinks();
                    }
                } else if (DefaultClipper.poly2ContainsPoly1(var8_8.getPoints(), var7_7.getPoints())) {
                    var7_7.isHole = var8_8.isHole;
                    var8_8.isHole = var7_7.isHole ^ true;
                    var7_7.firstLeft = var8_8.firstLeft;
                    var8_8.firstLeft = var7_7;
                    if (this.usingPolyTree) {
                        this.fixupFirstLefts2(var8_8, var7_7);
                    }
                    var5_5 = var8_8.isHole;
                    var6_6 = this.reverseSolution;
                    var2_2 = var8_8.area() > 0.0 ? var4_4 : 0;
                    if ((var5_5 ^ var6_6) == var2_2) {
                        var8_8.getPoints().reversePolyPtLinks();
                    }
                } else {
                    var7_7.isHole = var8_8.isHole;
                    var7_7.firstLeft = var8_8.firstLeft;
                    if (this.usingPolyTree) {
                        this.fixupFirstLefts1(var8_8, var7_7);
                    }
                }
            }
            ++var1_1;
        }
    }

    private static boolean joinHorz(Path.OutPt outPt, Path.OutPt outPt2, Path.OutPt object, Path.OutPt object2, Point.LongPoint object3, boolean bl) {
        boolean bl2;
        Clipper.Direction direction;
        block25 : {
            block26 : {
                Object object4;
                block24 : {
                    block22 : {
                        block23 : {
                            block21 : {
                                direction = outPt.getPt().getX() > outPt2.getPt().getX() ? Clipper.Direction.RIGHT_TO_LEFT : Clipper.Direction.LEFT_TO_RIGHT;
                                object4 = object.getPt().getX() > object2.getPt().getX() ? Clipper.Direction.RIGHT_TO_LEFT : Clipper.Direction.LEFT_TO_RIGHT;
                                bl2 = false;
                                if (direction == object4) {
                                    return false;
                                }
                                object2 = outPt;
                                if (direction != Clipper.Direction.LEFT_TO_RIGHT) break block21;
                                while (outPt.next.getPt().getX() <= object3.getX() && outPt.next.getPt().getX() >= outPt.getPt().getX() && outPt.next.getPt().getY() == object3.getY()) {
                                    outPt = outPt.next;
                                }
                                outPt2 = outPt;
                                if (bl) {
                                    outPt2 = outPt;
                                    if (outPt.getPt().getX() != object3.getX()) {
                                        outPt2 = outPt.next;
                                    }
                                }
                                outPt = object2 = outPt2.duplicate(bl ^ true);
                                if (object2.getPt().equals(object3)) break block22;
                                object2.setPt((Point.LongPoint)object3);
                                outPt2 = object2.duplicate(bl ^ true);
                                outPt = object2;
                                break block23;
                            }
                            while (object2.next.getPt().getX() >= object3.getX() && object2.next.getPt().getX() <= object2.getPt().getX() && object2.next.getPt().getY() == object3.getY()) {
                                object2 = object2.next;
                            }
                            outPt2 = object2;
                            if (!bl) {
                                outPt2 = object2;
                                if (object2.getPt().getX() != object3.getX()) {
                                    outPt2 = object2.next;
                                }
                            }
                            outPt = object2 = outPt2.duplicate(bl);
                            if (object2.getPt().equals(object3)) break block22;
                            object2.setPt((Point.LongPoint)object3);
                            outPt2 = object2.duplicate(bl);
                            outPt = object2;
                        }
                        object2 = outPt2;
                        outPt2 = outPt;
                        outPt = object2;
                    }
                    object2 = object;
                    if (object4 != Clipper.Direction.LEFT_TO_RIGHT) break block24;
                    while (object.next.getPt().getX() <= object3.getX() && object.next.getPt().getX() >= object.getPt().getX() && object.next.getPt().getY() == object3.getY()) {
                        object = object.next;
                    }
                    object2 = object;
                    if (bl) {
                        object2 = object;
                        if (object.getPt().getX() != object3.getX()) {
                            object2 = object.next;
                        }
                    }
                    object4 = object2.duplicate(bl ^ true);
                    object = object4;
                    if (object4.getPt().equals(object3)) break block25;
                    object4.setPt((Point.LongPoint)object3);
                    object2 = object4.duplicate(bl ^ true);
                    object = object4;
                    break block26;
                }
                while (object2.next.getPt().getX() >= object3.getX() && object2.next.getPt().getX() <= object2.getPt().getX() && object2.next.getPt().getY() == object3.getY()) {
                    object2 = object2.next;
                }
                object = object2;
                if (!bl) {
                    object = object2;
                    if (object2.getPt().getX() != object3.getX()) {
                        object = object2.next;
                    }
                }
                object4 = object.duplicate(bl);
                object2 = object;
                object = object4;
                if (object4.getPt().equals(object3)) break block25;
                object4.setPt((Point.LongPoint)object3);
                object2 = object4.duplicate(bl);
                object = object4;
            }
            object3 = object;
            object = object2;
            object2 = object3;
        }
        if (direction == Clipper.Direction.LEFT_TO_RIGHT) {
            bl2 = true;
        }
        if (bl2 == bl) {
            outPt2.prev = object2;
            object2.next = outPt2;
            outPt.next = object;
            object.prev = outPt;
            return true;
        }
        outPt2.next = object2;
        object2.prev = outPt2;
        outPt.prev = object;
        object.next = outPt;
        return true;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private boolean joinPoints(Path.Join var1_1, Path.OutRec var2_2, Path.OutRec var3_3) {
        block28 : {
            block30 : {
                block32 : {
                    block31 : {
                        block29 : {
                            block27 : {
                                block26 : {
                                    var13_25 = var1_1.outPt1;
                                    var12_26 = var1_1.outPt2;
                                    var6_27 = var1_1.outPt1.getPt().getY();
                                    var8_28 = var1_1.getOffPt().getY();
                                    var10_29 = true;
                                    var4_30 = var6_27 == var8_28;
                                    if (!var4_30) break block26;
                                    if (var1_1.getOffPt().equals(var1_1.outPt1.getPt())) {
                                        if (var1_1.getOffPt().equals(var1_1.outPt2.getPt())) {
                                            if (var2_2 /* !! */  != var3_24) {
                                                return false;
                                            }
                                            var2_3 = var1_1.outPt1.next;
                                            while (var2_4 != var13_25 && var2_4.getPt().equals(var1_1.getOffPt())) {
                                                var2_5 = var2_4.next;
                                            }
                                            var4_30 = var2_4.getPt().getY() > var1_1.getOffPt().getY();
                                            var2_6 = var1_1.outPt2.next;
                                            while (var2_7 != var12_26 && var2_7.getPt().equals(var1_1.getOffPt())) {
                                                var2_8 = var2_7.next;
                                            }
                                            var5_31 = var2_7.getPt().getY() > var1_1.getOffPt().getY();
                                            if (var4_30 == var5_31) {
                                                return false;
                                            }
                                            if (var4_30) {
                                                var2_9 = var13_25.duplicate(false);
                                                var3_24 = var12_26.duplicate(true);
                                                var13_25.prev = var12_26;
                                                var12_26.next = var13_25;
                                                var2_9.next = var3_24;
                                                var3_24.prev = var2_9;
                                                var1_1.outPt1 = var13_25;
                                                var1_1.outPt2 = var2_9;
                                                return true;
                                            }
                                            var2_10 = var13_25.duplicate(true);
                                            var3_24 = var12_26.duplicate(false);
                                            var13_25.next = var12_26;
                                            var12_26.prev = var13_25;
                                            var2_10.prev = var3_24;
                                            var3_24.next = var2_10;
                                            var1_1.outPt1 = var13_25;
                                            var1_1.outPt2 = var2_10;
                                            return true;
                                        } else {
                                            ** GOTO lbl44
                                        }
                                    }
                                    break block27;
                                }
                                if (!var4_30) break block28;
                            }
                            var3_24 = var13_25;
                            while (var3_24.prev.getPt().getY() == var3_24.getPt().getY() && var3_24.prev != var13_25 && var3_24.prev != var12_26) {
                                var3_24 = var3_24.prev;
                            }
                            var11_33 = var13_25;
                            while (var11_33.next.getPt().getY() == var11_33.getPt().getY() && var11_33.next != var3_24 && var11_33.next != var12_26) {
                                var11_33 = var11_33.next;
                            }
                            if (var11_33.next == var3_24) return false;
                            if (var11_33.next == var12_26) {
                                return false;
                            }
                            var13_25 = var12_26;
                            while (var13_25.prev.getPt().getY() == var13_25.getPt().getY() && var13_25.prev != var12_26 && var13_25.prev != var11_33) {
                                var13_25 = var13_25.prev;
                            }
                            while (var12_26.next.getPt().getY() == var12_26.getPt().getY() && var12_26.next != var13_25 && var12_26.next != var3_24) {
                                var12_26 = var12_26.next;
                            }
                            if (var12_26.next == var13_25) return false;
                            if (var12_26.next == var3_24) {
                                return false;
                            }
                            var2_11 = new long[1];
                            var14_35 = new long[1];
                            if (!DefaultClipper.getOverlap(var3_24.getPt().getX(), var11_33.getPt().getX(), var13_25.getPt().getX(), var12_26.getPt().getX(), var2_11, var14_35)) {
                                return false;
                            }
                            var6_27 = var2_11[0];
                            var8_28 = var14_35[0];
                            if (var3_24.getPt().getX() < var6_27 || var3_24.getPt().getX() > var8_28) break block29;
                            var2_12 = var14_36 = new Point.LongPoint(var3_24.getPt());
                            if (var3_24.getPt().getX() <= var11_33.getPt().getX()) ** GOTO lbl-1000
                            var2_13 = var14_36;
                            break block30;
                        }
                        if (var13_25.getPt().getX() < var6_27 || var13_25.getPt().getX() > var8_28) break block31;
                        var2_16 = var14_37 = new Point.LongPoint(var13_25.getPt());
                        if (var13_25.getPt().getX() <= var12_26.getPt().getX()) ** GOTO lbl-1000
                        var2_17 = var14_37;
                        break block30;
                    }
                    if (var11_33.getPt().getX() < var6_27 || var11_33.getPt().getX() > var8_28) break block32;
                    var2_18 = var14_38 = new Point.LongPoint(var11_33.getPt());
                    if (var11_33.getPt().getX() <= var3_24.getPt().getX()) ** GOTO lbl-1000
                    var2_19 = var14_38;
                    break block30;
                }
                var2_20 = var14_39 = new Point.LongPoint(var12_26.getPt());
                if (var12_26.getPt().getX() > var13_25.getPt().getX()) {
                    var2_21 = var14_39;
                } else lbl-1000: // 4 sources:
                {
                    var10_29 = false;
                }
            }
            var1_1.outPt1 = var3_24;
            var1_1.outPt2 = var13_25;
            return DefaultClipper.joinHorz(var3_24, var11_33, var13_25, var12_26, (Point.LongPoint)var2_15, var10_29);
        }
        var11_34 = var13_25.next;
        while (var11_34.getPt().equals(var13_25.getPt()) && var11_34 != var13_25) {
            var11_34 = var11_34.next;
        }
        var4_30 = var11_34.getPt().getY() > var13_25.getPt().getY() || !Point.slopesEqual(var13_25.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange);
        var14_40 = var11_34;
        if (var4_30) {
            var11_34 = var13_25.prev;
            while (var11_34.getPt().equals(var13_25.getPt()) && var11_34 != var13_25) {
                var11_34 = var11_34.prev;
            }
            if (var11_34.getPt().getY() > var13_25.getPt().getY()) return false;
            var14_41 = var11_34;
            if (!Point.slopesEqual(var13_25.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange)) {
                return false;
            }
        }
        var11_34 = var12_26.next;
        while (var11_34.getPt().equals(var12_26.getPt()) && var11_34 != var12_26) {
            var11_34 = var11_34.next;
        }
        var5_32 = var11_34.getPt().getY() > var12_26.getPt().getY() || !Point.slopesEqual(var12_26.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange);
        var15_43 = var11_34;
        if (var5_32) {
            var11_34 = var12_26.prev;
            while (var11_34.getPt().equals(var12_26.getPt()) && var11_34 != var12_26) {
                var11_34 = var11_34.prev;
            }
            if (var11_34.getPt().getY() > var12_26.getPt().getY()) return false;
            var15_43 = var11_34;
            if (!Point.slopesEqual(var12_26.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange)) {
                return false;
            }
        }
        if (var14_42 == var13_25) return false;
        if (var15_43 == var12_26) return false;
        if (var14_42 == var15_43) return false;
        if (var2_2 /* !! */  == var3_24 && var4_30 == var5_32) {
            return false;
        }
        if (var4_30) {
            var2_22 = var13_25.duplicate(false);
            var3_24 = var12_26.duplicate(true);
            var13_25.prev = var12_26;
            var12_26.next = var13_25;
            var2_22.next = var3_24;
            var3_24.prev = var2_22;
            var1_1.outPt1 = var13_25;
            var1_1.outPt2 = var2_22;
            return true;
        }
        var2_23 = var13_25.duplicate(true);
        var3_24 = var12_26.duplicate(false);
        var13_25.next = var12_26;
        var12_26.prev = var13_25;
        var2_23.prev = var3_24;
        var3_24.next = var2_23;
        var1_1.outPt1 = var13_25;
        var1_1.outPt2 = var2_23;
        return true;
    }

    private static Paths minkowski(Path path, Path path2, boolean bl, boolean bl2) {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    public static Paths minkowskiDiff(Path arrayList, Path object) {
        arrayList = DefaultClipper.minkowski(arrayList, (Path)object, false, true);
        object = new DefaultClipper();
        object.addPaths((Paths)arrayList, Clipper.PolyType.SUBJECT, true);
        object.execute(Clipper.ClipType.UNION, (Paths)arrayList, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO);
        return arrayList;
    }

    public static Paths minkowskiSum(Path arrayList, Path object, boolean bl) {
        arrayList = DefaultClipper.minkowski(arrayList, (Path)object, true, bl);
        object = new DefaultClipper();
        object.addPaths((Paths)arrayList, Clipper.PolyType.SUBJECT, true);
        object.execute(Clipper.ClipType.UNION, (Paths)arrayList, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO);
        return arrayList;
    }

    public static Paths minkowskiSum(Path path, Paths paths, boolean bl) {
        Paths paths2 = new Paths();
        DefaultClipper defaultClipper = new DefaultClipper();
        for (int i = 0; i < paths.size(); ++i) {
            defaultClipper.addPaths(DefaultClipper.minkowski(path, (Path)paths.get(i), true, bl), Clipper.PolyType.SUBJECT, true);
            if (!bl) continue;
            defaultClipper.addPath(((Path)paths.get(i)).TranslatePath((Point.LongPoint)path.get(0)), Clipper.PolyType.CLIP, true);
        }
        defaultClipper.execute(Clipper.ClipType.UNION, paths2, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO);
        return paths2;
    }

    private static boolean poly2ContainsPoly1(Path.OutPt outPt, Path.OutPt outPt2) {
        Path.OutPt outPt3;
        Path.OutPt outPt4 = outPt;
        do {
            int n;
            if ((n = DefaultClipper.isPointInPolygon(outPt4.getPt(), outPt2)) >= 0) {
                if (n > 0) {
                    return true;
                }
                return false;
            }
            outPt4 = outPt3 = outPt4.next;
        } while (outPt3 != outPt);
        return true;
    }

    private long popScanbeam() {
        LOGGER.entering(DefaultClipper.class.getName(), "popBeam");
        long l = this.scanbeam.y;
        this.scanbeam = this.scanbeam.next;
        return l;
    }

    private void processEdgesAtTopOfScanbeam(long l) {
        Object object;
        Object object2;
        LOGGER.entering(DefaultClipper.class.getName(), "processEdgesAtTopOfScanbeam");
        Object object3 = this.activeEdges;
        while (object3 != null) {
            boolean bl;
            double d = l;
            boolean bl2 = bl = object3.isMaxima(d);
            if (bl) {
                object = object3.getMaximaPair();
                bl2 = object == null || !object.isHorizontal();
            }
            if (bl2) {
                if (this.strictlySimple) {
                    this.InsertMaxima(object3.getTop().getX());
                }
                object = object3.prevInAEL;
                this.doMaxima((Edge)object3);
                if (object == null) {
                    object3 = this.activeEdges;
                    continue;
                }
                object3 = object.nextInAEL;
                continue;
            }
            if (object3.isIntermediate(d) && object3.nextInLML.isHorizontal()) {
                object = new Edge[]{object3};
                this.updateEdgeIntoAEL((Edge[])object);
                object3 = object[0];
                if (object3.outIdx >= 0) {
                    this.addOutPt((Edge)object3, object3.getBot());
                }
                this.addEdgeToSEL((Edge)object3);
            } else {
                object3.getCurrent().setX(Edge.topX((Edge)object3, l));
                object3.getCurrent().setY(l);
            }
            if (this.strictlySimple) {
                object = object3.prevInAEL;
                if (object3.outIdx >= 0 && object3.windDelta != 0 && object != null && object.outIdx >= 0 && object.getCurrent().getX() == object3.getCurrent().getX() && object.windDelta != 0) {
                    object2 = new Point.LongPoint(object3.getCurrent());
                    this.setZ((Point.LongPoint)object2, (Edge)object, (Edge)object3);
                    this.addJoin(this.addOutPt((Edge)object, (Point.LongPoint)object2), this.addOutPt((Edge)object3, (Point.LongPoint)object2), (Point.LongPoint)object2);
                }
            }
            object3 = object3.nextInAEL;
        }
        this.processHorizontals();
        this.maxima = null;
        object3 = this.activeEdges;
        while (object3 != null) {
            object2 = object3;
            if (object3.isIntermediate(l)) {
                object = object3.outIdx >= 0 ? this.addOutPt((Edge)object3, object3.getTop()) : null;
                object2 = new Edge[]{object3};
                this.updateEdgeIntoAEL((Edge[])object2);
                object3 = object2[0];
                object2 = object3.prevInAEL;
                Edge edge = object3.nextInAEL;
                if (object2 != null && object2.getCurrent().getX() == object3.getBot().getX() && object2.getCurrent().getY() == object3.getBot().getY() && object != null && object2.outIdx >= 0 && object2.getCurrent().getY() > object2.getTop().getY() && Edge.slopesEqual((Edge)object3, (Edge)object2, this.useFullRange) && object3.windDelta != 0 && object2.windDelta != 0) {
                    this.addJoin((Path.OutPt)object, this.addOutPt((Edge)object2, object3.getBot()), object3.getTop());
                    object2 = object3;
                } else {
                    object2 = object3;
                    if (edge != null) {
                        object2 = object3;
                        if (edge.getCurrent().getX() == object3.getBot().getX()) {
                            object2 = object3;
                            if (edge.getCurrent().getY() == object3.getBot().getY()) {
                                object2 = object3;
                                if (object != null) {
                                    object2 = object3;
                                    if (edge.outIdx >= 0) {
                                        object2 = object3;
                                        if (edge.getCurrent().getY() > edge.getTop().getY()) {
                                            object2 = object3;
                                            if (Edge.slopesEqual((Edge)object3, edge, this.useFullRange)) {
                                                object2 = object3;
                                                if (object3.windDelta != 0) {
                                                    object2 = object3;
                                                    if (edge.windDelta != 0) {
                                                        this.addJoin((Path.OutPt)object, this.addOutPt(edge, object3.getBot()), object3.getTop());
                                                        object2 = object3;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            object3 = object2.nextInAEL;
        }
        LOGGER.exiting(DefaultClipper.class.getName(), "processEdgesAtTopOfScanbeam");
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void processHorizontal(Edge var1_1) {
        block37 : {
            block39 : {
                block38 : {
                    DefaultClipper.LOGGER.entering(DefaultClipper.class.getName(), "isHorizontal");
                    var15_2 = new Clipper.Direction[1];
                    var10_3 = new long[1];
                    var11_4 = new long[1];
                    var2_5 = var1_1.outIdx >= 0 && this.polyOuts.get((int)var1_1.outIdx).isOpen != false;
                    DefaultClipper.getHorzDirection((Edge)var1_1, var15_2, (long[])var10_3, (long[])var11_4);
                    var6_6 = var1_1;
                    while (var6_6.nextInLML != null && var6_6.nextInLML.isHorizontal()) {
                        var6_6 = var6_6.nextInLML;
                    }
                    var5_7 = var6_6.nextInLML;
                    var12_8 = null;
                    var7_9 = var5_7 == null ? var6_6.getMaximaPair() : null;
                    var8_10 = this.maxima;
                    var5_7 = var8_10;
                    if (var8_10 == null) break block37;
                    var9_19 = var8_10;
                    if (var15_2[0] != Clipper.Direction.LEFT_TO_RIGHT) break block38;
                    while (var8_11 != null && var8_11.X <= var1_1.getBot().getX()) {
                        var8_12 = var8_11.Next;
                    }
                    var5_7 = var8_11;
                    if (var8_11 == null) break block37;
                    var5_7 = var8_11;
                    if (var8_11.X < var6_6.getBot().getX()) break block37;
                    break block39;
                }
                while (var9_19.Next != null && var9_19.Next.X < var1_1.getBot().getX()) {
                    var9_19 = var9_19.Next;
                }
                var5_7 = var9_19;
                if (var9_19.X > var6_6.getTop().getX()) break block37;
            }
            var5_7 = null;
        }
        var9_19 = var11_4;
        var8_13 = var10_3;
        var10_3 = var7_9;
        var7_9 = var6_6;
        var6_6 = var1_1;
        var1_1 = var5_7;
        do {
            var4_21 = var6_6 == var7_9;
            var11_4 = var6_6.getNextInAEL(var15_2[0]);
            var5_7 = var10_3;
            var10_3 = var11_4;
            while (var10_3 != null) {
                var11_4 = var1_1;
                var3_20 = var2_5;
                if (var1_1 == null) ** GOTO lbl76
                if (var15_2[0] != Clipper.Direction.LEFT_TO_RIGHT) {
                    var3_20 = var2_5;
                    do {
                        var11_4 = var1_1;
                        var2_5 = var3_20;
                        if (var1_1 != null) {
                            var11_4 = var1_1;
                            var2_5 = var3_20;
                            if (var1_1.X > var10_3.getCurrent().getX()) {
                                if (var6_6.outIdx >= 0 && !var3_20) {
                                    this.addOutPt((Edge)var6_6, new Point.LongPoint(var1_1.X, var6_6.getBot().getY()));
                                }
                                var1_1 = var1_1.Prev;
                                continue;
                            }
                        }
                        break;
                    } while (true);
                } else {
                    do {
                        var11_4 = var1_1;
                        var3_20 = var2_5;
                        if (var1_1 != null) {
                            var11_4 = var1_1;
                            var3_20 = var2_5;
                            if (var1_1.X < var10_3.getCurrent().getX()) {
                                if (var6_6.outIdx >= 0 && !var2_5) {
                                    this.addOutPt((Edge)var6_6, new Point.LongPoint(var1_1.X, var6_6.getBot().getY()));
                                }
                                var1_1 = var1_1.Next;
                                continue;
                            } else {
                            }
                        } else {
                        }
                        break;
                    } while (true);
lbl76: // 5 sources:
                    var2_5 = var3_20;
                }
                var1_1 = var11_4;
                if (var15_2[0] == Clipper.Direction.LEFT_TO_RIGHT && var10_3.getCurrent().getX() > var9_19[0] || var15_2[0] == Clipper.Direction.RIGHT_TO_LEFT && var10_3.getCurrent().getX() < var8_14[0] || var10_3.getCurrent().getX() == var6_6.getTop().getX() && var6_6.nextInLML != null && var10_3.deltaX < var6_6.nextInLML.deltaX) break;
                if (var6_6.outIdx >= 0 && !var2_5) {
                    var12_8 = this.addOutPt((Edge)var6_6, var10_3.getCurrent());
                    var11_4 = this.sortedEdges;
                    while (var11_4 != null) {
                        if (var11_4.outIdx >= 0 && this.doHorzSegmentsOverlap(var6_6.getBot().getX(), var6_6.getTop().getX(), var11_4.getBot().getX(), var11_4.getTop().getX())) {
                            this.addJoin(this.GetLastOutPt((Edge)var11_4), var12_8, var11_4.getTop());
                        }
                        var11_4 = var11_4.nextInSEL;
                    }
                    var11_4 = var8_14;
                    var13_22 = var9_19;
                    this.addGhostJoin(var12_8, var6_6.getBot());
                    var9_19 = var6_6;
                    var8_15 = var5_7;
                    var6_6 = var1_1;
                    var5_7 = var11_4;
                    var1_1 = var13_22;
                } else {
                    var11_4 = var1_1;
                    var1_1 = var9_19;
                    var9_19 = var6_6;
                    var13_22 = var5_7;
                    var5_7 = var8_14;
                    var6_6 = var11_4;
                    var8_16 = var13_22;
                }
                if (var10_3 == var8_17 && var4_21) {
                    if (var9_19.outIdx >= 0) {
                        this.addLocalMaxPoly((Edge)var9_19, (Edge)var8_17, var9_19.getTop());
                    }
                    this.deleteFromAEL((Edge)var9_19);
                    this.deleteFromAEL((Edge)var8_17);
                    return;
                }
                if (var15_2[0] == Clipper.Direction.LEFT_TO_RIGHT) {
                    this.intersectEdges((Edge)var9_19, (Edge)var10_3, new Point.LongPoint(var10_3.getCurrent().getX(), var9_19.getCurrent().getY()));
                } else {
                    this.intersectEdges((Edge)var10_3, (Edge)var9_19, new Point.LongPoint(var10_3.getCurrent().getX(), var9_19.getCurrent().getY()));
                }
                var14_23 = var10_3.getNextInAEL(var15_2[0]);
                this.swapPositionsInAEL((Edge)var9_19, (Edge)var10_3);
                var11_4 = var5_7;
                var13_22 = var1_1;
                var1_1 = var6_6;
                var6_6 = var9_19;
                var10_3 = var14_23;
                var5_7 = var8_17;
                var8_18 = var11_4;
                var9_19 = var13_22;
            }
            if (var6_6.nextInLML == null || !var6_6.nextInLML.isHorizontal()) break;
            var10_3 = new Edge[]{(long)var6_6};
            this.updateEdgeIntoAEL((Edge[])var10_3);
            var6_6 = var10_3[0];
            if (var6_6.outIdx >= 0) {
                this.addOutPt((Edge)var6_6, var6_6.getBot());
            }
            DefaultClipper.getHorzDirection((Edge)var6_6, var15_2, (long[])var8_14, (long[])var9_19);
            var10_3 = var5_7;
        } while (true);
        if (var6_6.outIdx >= 0 && var12_8 == null) {
            var5_7 = this.GetLastOutPt((Edge)var6_6);
            var1_1 = this.sortedEdges;
            while (var1_1 != null) {
                if (var1_1.outIdx >= 0 && this.doHorzSegmentsOverlap(var6_6.getBot().getX(), var6_6.getTop().getX(), var1_1.getBot().getX(), var1_1.getTop().getX())) {
                    this.addJoin(this.GetLastOutPt((Edge)var1_1), (Path.OutPt)var5_7, var1_1.getTop());
                }
                var1_1 = var1_1.nextInSEL;
            }
            this.addGhostJoin((Path.OutPt)var5_7, var6_6.getTop());
        }
        if (var6_6.nextInLML != null) {
            if (var6_6.outIdx < 0) {
                var1_1 = new Edge[]{var6_6};
                this.updateEdgeIntoAEL((Edge[])var1_1);
                var1_1 = var1_1[0];
                return;
            }
            var1_1 = this.addOutPt((Edge)var6_6, var6_6.getTop());
            var5_7 = new Edge[]{(long)var6_6};
            this.updateEdgeIntoAEL((Edge[])var5_7);
            var5_7 = var5_7[0];
            if (var5_7.windDelta == 0) {
                return;
            }
            var6_6 = var5_7.prevInAEL;
            var7_9 = var5_7.nextInAEL;
            if (var6_6 != null && var6_6.getCurrent().getX() == var5_7.getBot().getX() && var6_6.getCurrent().getY() == var5_7.getBot().getY() && var6_6.windDelta != 0 && var6_6.outIdx >= 0 && var6_6.getCurrent().getY() > var6_6.getTop().getY() && Edge.slopesEqual((Edge)var5_7, (Edge)var6_6, this.useFullRange)) {
                this.addJoin((Path.OutPt)var1_1, this.addOutPt((Edge)var6_6, var5_7.getBot()), var5_7.getTop());
                return;
            }
            if (var7_9 == null) return;
            if (var7_9.getCurrent().getX() != var5_7.getBot().getX()) return;
            if (var7_9.getCurrent().getY() != var5_7.getBot().getY()) return;
            if (var7_9.windDelta == 0) return;
            if (var7_9.outIdx < 0) return;
            if (var7_9.getCurrent().getY() <= var7_9.getTop().getY()) return;
            if (Edge.slopesEqual((Edge)var5_7, (Edge)var7_9, this.useFullRange) == false) return;
            this.addJoin((Path.OutPt)var1_1, this.addOutPt((Edge)var7_9, var5_7.getBot()), var5_7.getTop());
            return;
        }
        if (var6_6.outIdx >= 0) {
            this.addOutPt((Edge)var6_6, var6_6.getTop());
        }
        this.deleteFromAEL((Edge)var6_6);
    }

    private void processHorizontals() {
        LOGGER.entering(DefaultClipper.class.getName(), "processHorizontals");
        Edge edge = this.sortedEdges;
        while (edge != null) {
            this.deleteFromSEL(edge);
            this.processHorizontal(edge);
            edge = this.sortedEdges;
        }
    }

    private void processIntersectList() {
        for (int i = 0; i < this.intersectList.size(); ++i) {
            IntersectNode intersectNode = this.intersectList.get(i);
            this.intersectEdges(intersectNode.edge1, intersectNode.Edge2, intersectNode.getPt());
            this.swapPositionsInAEL(intersectNode.edge1, intersectNode.Edge2);
        }
        this.intersectList.clear();
    }

    private boolean processIntersections(long l) {
        block5 : {
            LOGGER.entering(DefaultClipper.class.getName(), "processIntersections");
            if (this.activeEdges == null) {
                return true;
            }
            try {
                this.buildIntersectList(l);
                if (this.intersectList.size() != 0) break block5;
                return true;
            }
            catch (Exception exception) {
                this.sortedEdges = null;
                this.intersectList.clear();
                throw new IllegalStateException("ProcessIntersections error", exception);
            }
        }
        if (this.intersectList.size() == 1 || this.fixupIntersectionOrder()) {
            this.processIntersectList();
            this.sortedEdges = null;
            return true;
        }
        return false;
    }

    private void setHoleState(Edge edge, Path.OutRec outRec) {
        edge = edge.prevInAEL;
        boolean bl = false;
        while (edge != null) {
            boolean bl2 = bl;
            if (edge.outIdx >= 0) {
                bl2 = bl;
                if (edge.windDelta != 0) {
                    bl2 = bl ^= true;
                    if (outRec.firstLeft == null) {
                        outRec.firstLeft = this.polyOuts.get(edge.outIdx);
                        bl2 = bl;
                    }
                }
            }
            edge = edge.prevInAEL;
            bl = bl2;
        }
        if (bl) {
            outRec.isHole = true;
        }
    }

    private void setZ(Point.LongPoint longPoint, Edge edge, Edge edge2) {
        if (longPoint.getZ() == 0L) {
            if (this.zFillFunction == null) {
                return;
            }
            if (longPoint.equals(edge.getBot())) {
                longPoint.setZ(edge.getBot().getZ());
                return;
            }
            if (longPoint.equals(edge.getTop())) {
                longPoint.setZ(edge.getTop().getZ());
                return;
            }
            if (longPoint.equals(edge2.getBot())) {
                longPoint.setZ(edge2.getBot().getZ());
                return;
            }
            if (longPoint.equals(edge2.getTop())) {
                longPoint.setZ(edge2.getTop().getZ());
                return;
            }
            this.zFillFunction.zFill(edge.getBot(), edge.getTop(), edge2.getBot(), edge2.getTop(), longPoint);
            return;
        }
    }

    public static Paths simplifyPolygon(Path path) {
        return DefaultClipper.simplifyPolygon(path, Clipper.PolyFillType.EVEN_ODD);
    }

    public static Paths simplifyPolygon(Path path, Clipper.PolyFillType polyFillType) {
        Paths paths = new Paths();
        DefaultClipper defaultClipper = new DefaultClipper(2);
        defaultClipper.addPath(path, Clipper.PolyType.SUBJECT, true);
        defaultClipper.execute(Clipper.ClipType.UNION, paths, polyFillType, polyFillType);
        return paths;
    }

    public static Paths simplifyPolygons(Paths paths) {
        return DefaultClipper.simplifyPolygons(paths, Clipper.PolyFillType.EVEN_ODD);
    }

    public static Paths simplifyPolygons(Paths paths, Clipper.PolyFillType polyFillType) {
        Paths paths2 = new Paths();
        DefaultClipper defaultClipper = new DefaultClipper(2);
        defaultClipper.addPaths(paths, Clipper.PolyType.SUBJECT, true);
        defaultClipper.execute(Clipper.ClipType.UNION, paths2, polyFillType, polyFillType);
        return paths2;
    }

    private void swapPositionsInAEL(Edge edge, Edge edge2) {
        LOGGER.entering(DefaultClipper.class.getName(), "swapPositionsInAEL");
        if (edge.nextInAEL != edge.prevInAEL) {
            if (edge2.nextInAEL == edge2.prevInAEL) {
                return;
            }
            if (edge.nextInAEL == edge2) {
                Edge edge3;
                Edge edge4 = edge2.nextInAEL;
                if (edge4 != null) {
                    edge4.prevInAEL = edge;
                }
                if ((edge3 = edge.prevInAEL) != null) {
                    edge3.nextInAEL = edge2;
                }
                edge2.prevInAEL = edge3;
                edge2.nextInAEL = edge;
                edge.prevInAEL = edge2;
                edge.nextInAEL = edge4;
            } else if (edge2.nextInAEL == edge) {
                Edge edge5;
                Edge edge6 = edge.nextInAEL;
                if (edge6 != null) {
                    edge6.prevInAEL = edge2;
                }
                if ((edge5 = edge2.prevInAEL) != null) {
                    edge5.nextInAEL = edge;
                }
                edge.prevInAEL = edge5;
                edge.nextInAEL = edge2;
                edge2.prevInAEL = edge;
                edge2.nextInAEL = edge6;
            } else {
                Edge edge7 = edge.nextInAEL;
                Edge edge8 = edge.prevInAEL;
                edge.nextInAEL = edge2.nextInAEL;
                if (edge.nextInAEL != null) {
                    edge.nextInAEL.prevInAEL = edge;
                }
                edge.prevInAEL = edge2.prevInAEL;
                if (edge.prevInAEL != null) {
                    edge.prevInAEL.nextInAEL = edge;
                }
                edge2.nextInAEL = edge7;
                if (edge2.nextInAEL != null) {
                    edge2.nextInAEL.prevInAEL = edge2;
                }
                edge2.prevInAEL = edge8;
                if (edge2.prevInAEL != null) {
                    edge2.prevInAEL.nextInAEL = edge2;
                }
            }
            if (edge.prevInAEL == null) {
                this.activeEdges = edge;
            } else if (edge2.prevInAEL == null) {
                this.activeEdges = edge2;
            }
            LOGGER.exiting(DefaultClipper.class.getName(), "swapPositionsInAEL");
            return;
        }
    }

    private void swapPositionsInSEL(Edge edge, Edge edge2) {
        if (edge.nextInSEL == null && edge.prevInSEL == null) {
            return;
        }
        if (edge2.nextInSEL == null && edge2.prevInSEL == null) {
            return;
        }
        if (edge.nextInSEL == edge2) {
            Edge edge3;
            Edge edge4 = edge2.nextInSEL;
            if (edge4 != null) {
                edge4.prevInSEL = edge;
            }
            if ((edge3 = edge.prevInSEL) != null) {
                edge3.nextInSEL = edge2;
            }
            edge2.prevInSEL = edge3;
            edge2.nextInSEL = edge;
            edge.prevInSEL = edge2;
            edge.nextInSEL = edge4;
        } else if (edge2.nextInSEL == edge) {
            Edge edge5;
            Edge edge6 = edge.nextInSEL;
            if (edge6 != null) {
                edge6.prevInSEL = edge2;
            }
            if ((edge5 = edge2.prevInSEL) != null) {
                edge5.nextInSEL = edge;
            }
            edge.prevInSEL = edge5;
            edge.nextInSEL = edge2;
            edge2.prevInSEL = edge;
            edge2.nextInSEL = edge6;
        } else {
            Edge edge7 = edge.nextInSEL;
            Edge edge8 = edge.prevInSEL;
            edge.nextInSEL = edge2.nextInSEL;
            if (edge.nextInSEL != null) {
                edge.nextInSEL.prevInSEL = edge;
            }
            edge.prevInSEL = edge2.prevInSEL;
            if (edge.prevInSEL != null) {
                edge.prevInSEL.nextInSEL = edge;
            }
            edge2.nextInSEL = edge7;
            if (edge2.nextInSEL != null) {
                edge2.nextInSEL.prevInSEL = edge2;
            }
            edge2.prevInSEL = edge8;
            if (edge2.prevInSEL != null) {
                edge2.prevInSEL.nextInSEL = edge2;
            }
        }
        if (edge.prevInSEL == null) {
            this.sortedEdges = edge;
            return;
        }
        if (edge2.prevInSEL == null) {
            this.sortedEdges = edge2;
        }
    }

    private void updateEdgeIntoAEL(Edge[] arredge) {
        Edge edge = arredge[0];
        if (edge.nextInLML == null) {
            throw new IllegalStateException("UpdateEdgeIntoAEL: invalid call");
        }
        Edge edge2 = edge.prevInAEL;
        Edge edge3 = edge.nextInAEL;
        edge.nextInLML.outIdx = edge.outIdx;
        if (edge2 != null) {
            edge2.nextInAEL = edge.nextInLML;
        } else {
            this.activeEdges = edge.nextInLML;
        }
        if (edge3 != null) {
            edge3.prevInAEL = edge.nextInLML;
        }
        edge.nextInLML.side = edge.side;
        edge.nextInLML.windDelta = edge.windDelta;
        edge.nextInLML.windCnt = edge.windCnt;
        edge.nextInLML.windCnt2 = edge.windCnt2;
        arredge[0] = edge = edge.nextInLML;
        edge.setCurrent(edge.getBot());
        edge.prevInAEL = edge2;
        edge.nextInAEL = edge3;
        if (!edge.isHorizontal()) {
            this.insertScanbeam(edge.getTop().getY());
        }
    }

    private void updateOutPtIdxs(Path.OutRec outRec) {
        Path.OutPt outPt;
        Path.OutPt outPt2 = outRec.getPoints();
        do {
            outPt2.idx = outRec.Idx;
            outPt2 = outPt = outPt2.prev;
        } while (outPt != outRec.getPoints());
    }

    private void updateWindingCount(Edge edge) {
        Edge edge2;
        int n;
        LOGGER.entering(DefaultClipper.class.getName(), "updateWindingCount");
        Edge edge3 = edge.prevInAEL;
        while (edge3 != null && (edge3.polyTyp != edge.polyTyp || edge3.windDelta == 0)) {
            edge3 = edge3.prevInAEL;
        }
        if (edge3 == null) {
            n = edge.windDelta == 0 ? 1 : edge.windDelta;
            edge.windCnt = n;
            edge.windCnt2 = 0;
            edge3 = this.activeEdges;
        } else if (edge.windDelta == 0 && this.clipType != Clipper.ClipType.UNION) {
            edge.windCnt = 1;
            edge.windCnt2 = edge3.windCnt2;
            edge3 = edge3.nextInAEL;
        } else if (edge.isEvenOddFillType(this.clipFillType, this.subjFillType)) {
            if (edge.windDelta == 0) {
                edge2 = edge3.prevInAEL;
                n = 1;
                while (edge2 != null) {
                    int n2 = n;
                    if (edge2.polyTyp == edge3.polyTyp) {
                        n2 = n;
                        if (edge2.windDelta != 0) {
                            n2 = n ^ 1;
                        }
                    }
                    edge2 = edge2.prevInAEL;
                    n = n2;
                }
                n = n != 0 ? 0 : 1;
                edge.windCnt = n;
            } else {
                edge.windCnt = edge.windDelta;
            }
            edge.windCnt2 = edge3.windCnt2;
            edge3 = edge3.nextInAEL;
        } else {
            if (edge3.windCnt * edge3.windDelta < 0) {
                if (Math.abs(edge3.windCnt) > 1) {
                    edge.windCnt = edge3.windDelta * edge.windDelta < 0 ? edge3.windCnt : edge3.windCnt + edge.windDelta;
                } else {
                    n = edge.windDelta == 0 ? 1 : edge.windDelta;
                    edge.windCnt = n;
                }
            } else if (edge.windDelta == 0) {
                n = edge3.windCnt < 0 ? edge3.windCnt - 1 : edge3.windCnt + 1;
                edge.windCnt = n;
            } else {
                edge.windCnt = edge3.windDelta * edge.windDelta < 0 ? edge3.windCnt : edge3.windCnt + edge.windDelta;
            }
            edge.windCnt2 = edge3.windCnt2;
            edge3 = edge3.nextInAEL;
        }
        edge2 = edge3;
        if (edge.isEvenOddAltFillType(this.clipFillType, this.subjFillType)) {
            while (edge3 != edge) {
                if (edge3.windDelta != 0) {
                    n = edge.windCnt2 == 0 ? 1 : 0;
                    edge.windCnt2 = n;
                }
                edge3 = edge3.nextInAEL;
            }
        } else {
            while (edge2 != edge) {
                edge.windCnt2 += edge2.windDelta;
                edge2 = edge2.nextInAEL;
            }
        }
    }

    @Override
    public boolean execute(Clipper.ClipType clipType, Paths paths) {
        return this.execute(clipType, paths, Clipper.PolyFillType.EVEN_ODD);
    }

    public boolean execute(Clipper.ClipType clipType, Paths paths, Clipper.PolyFillType polyFillType) {
        return this.execute(clipType, paths, polyFillType, polyFillType);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public boolean execute(Clipper.ClipType clipType, Paths paths, Clipper.PolyFillType polyFillType, Clipper.PolyFillType polyFillType2) {
        synchronized (this) {
            if (this.hasOpenPaths) {
                throw new IllegalStateException("Error: PolyTree struct is needed for open path clipping.");
            }
            paths.clear();
            this.subjFillType = polyFillType;
            this.clipFillType = polyFillType2;
            this.clipType = clipType;
            this.usingPolyTree = false;
            try {
                boolean bl = this.executeInternal();
                if (bl) {
                    this.buildResult(paths);
                }
                return bl;
            }
            finally {
                this.polyOuts.clear();
            }
        }
    }

    @Override
    public boolean execute(Clipper.ClipType clipType, PolyTree polyTree) {
        return this.execute(clipType, polyTree, Clipper.PolyFillType.EVEN_ODD);
    }

    public boolean execute(Clipper.ClipType clipType, PolyTree polyTree, Clipper.PolyFillType polyFillType) {
        return this.execute(clipType, polyTree, polyFillType, polyFillType);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public boolean execute(Clipper.ClipType clipType, PolyTree polyTree, Clipper.PolyFillType polyFillType, Clipper.PolyFillType polyFillType2) {
        synchronized (this) {
            this.subjFillType = polyFillType;
            this.clipFillType = polyFillType2;
            this.clipType = clipType;
            this.usingPolyTree = true;
            try {
                boolean bl = this.executeInternal();
                if (bl) {
                    this.buildResult2(polyTree);
                }
                return bl;
            }
            finally {
                this.polyOuts.clear();
            }
        }
    }

    @Override
    protected void reset() {
        super.reset();
        this.scanbeam = null;
        this.maxima = null;
        this.activeEdges = null;
        this.sortedEdges = null;
        ClipperBase.LocalMinima localMinima = this.minimaList;
        while (localMinima != null) {
            this.insertScanbeam(localMinima.y);
            localMinima = localMinima.next;
        }
    }

    private class IntersectNode {
        Edge Edge2;
        Edge edge1;
        private Point.LongPoint pt;

        private IntersectNode() {
        }

        public Point.LongPoint getPt() {
            return this.pt;
        }

        public void setPt(Point.LongPoint longPoint) {
            this.pt = longPoint;
        }
    }

}

