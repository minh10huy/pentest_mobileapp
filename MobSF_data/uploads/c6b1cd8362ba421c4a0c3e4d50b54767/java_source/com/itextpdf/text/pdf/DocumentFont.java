/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.CJKFont;
import com.itextpdf.text.pdf.GlyphList;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.fonts.cmaps.CMapParserEx;
import com.itextpdf.text.pdf.fonts.cmaps.CMapToUnicode;
import com.itextpdf.text.pdf.fonts.cmaps.CidLocation;
import com.itextpdf.text.pdf.fonts.cmaps.CidLocationFromByte;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class DocumentFont
extends BaseFont {
    private static final int[] stdEnc = new int[]{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 33, 34, 35, 36, 37, 38, 8217, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 8216, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 161, 162, 163, 8260, 165, 402, 167, 164, 39, 8220, 171, 8249, 8250, 64257, 64258, 0, 8211, 8224, 8225, 183, 0, 182, 8226, 8218, 8222, 8221, 187, 8230, 8240, 0, 191, 0, 96, 180, 710, 732, 175, 728, 729, 168, 0, 730, 184, 0, 733, 731, 711, 8212, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 198, 0, 170, 0, 0, 0, 0, 321, 216, 338, 186, 0, 0, 0, 0, 0, 230, 0, 0, 0, 305, 0, 0, 322, 248, 339, 223, 0, 0, 0, 0};
    private float ascender = 800.0f;
    private IntHashtable byte2uni = new IntHashtable();
    private float capHeight = 700.0f;
    protected String cjkEncoding;
    private BaseFont cjkMirror;
    protected int defaultWidth = 1000;
    private float descender = -200.0f;
    private IntHashtable diffmap;
    private PdfDictionary font;
    private String fontName;
    private float fontWeight = 0.0f;
    private IntHashtable hMetrics;
    protected boolean isType0 = false;
    private float italicAngle = 0.0f;
    private float llx = -50.0f;
    private float lly = -200.0f;
    private HashMap<Integer, int[]> metrics = new HashMap();
    private PRIndirectReference refFont;
    private IntHashtable uni2byte = new IntHashtable();
    protected String uniMap;
    private float urx = 100.0f;
    private float ury = 900.0f;

    DocumentFont(PRIndirectReference pRIndirectReference) {
        this.refFont = pRIndirectReference;
        this.font = (PdfDictionary)PdfReader.getPdfObject(pRIndirectReference);
        this.init();
    }

    DocumentFont(PRIndirectReference object, PdfDictionary pdfDictionary) {
        this.refFont = object;
        this.font = (PdfDictionary)PdfReader.getPdfObject((PdfObject)object);
        if (this.font.get(PdfName.ENCODING) == null && pdfDictionary != null) {
            for (PdfName pdfName : pdfDictionary.getKeys()) {
                this.font.put(PdfName.ENCODING, pdfDictionary.get(pdfName));
            }
        }
        this.init();
    }

    DocumentFont(PdfDictionary pdfDictionary) {
        this.refFont = null;
        this.font = pdfDictionary;
        this.init();
    }

    private String decodeString(PdfString pdfString) {
        if (pdfString.isHexWriting()) {
            return PdfEncodings.convertToString(pdfString.getBytes(), "UnicodeBigUnmarked");
        }
        return pdfString.toUnicodeString();
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void doType1TT() {
        var4_1 = PdfReader.getPdfObject(this.font.get(PdfName.ENCODING));
        if (var4_1 == null) {
            var4_1 = this.font.getAsName(PdfName.BASEFONT);
            if (DocumentFont.BuiltinFonts14.containsKey(this.fontName) && (PdfName.SYMBOL.equals(var4_1) || PdfName.ZAPFDINGBATS.equals(var4_1))) {
                this.fillEncoding((PdfName)var4_1);
            } else {
                this.fillEncoding(null);
            }
            try {
                var4_1 = this.processToUnicode();
                if (var4_1 == null) ** GOTO lbl28
                for (Map.Entry<Integer, Integer> var5_4 : var4_1.createReverseMapping().entrySet()) {
                    this.uni2byte.put(var5_4.getKey(), var5_4.getValue());
                    this.byte2uni.put(var5_4.getValue(), var5_4.getKey());
                }
            }
            catch (Exception var4_2) {
                throw new ExceptionConverter(var4_2);
            }
        } else if (var4_1.isName()) {
            this.fillEncoding((PdfName)var4_1);
        } else if (var4_1.isDictionary()) {
            var5_5 = PdfReader.getPdfObject((var4_1 = (PdfDictionary)var4_1).get(PdfName.BASEENCODING));
            if (var5_5 == null) {
                this.fillEncoding(null);
            } else {
                this.fillEncoding((PdfName)var5_5);
            }
            this.fillDiffMap((PdfDictionary)var4_1, null);
        }
lbl28: // 6 sources:
        if (DocumentFont.BuiltinFonts14.containsKey(this.fontName)) {
            try {
                var4_1 = this.fontName;
                var2_9 = 0;
                var4_1 = BaseFont.createFont((String)var4_1, "Cp1252", false);
                var5_7 = this.uni2byte.toOrderedKeys();
            }
            catch (Exception var4_3) {
                throw new ExceptionConverter(var4_3);
            }
            for (var1_10 = 0; var1_10 < var5_7.length; ++var1_10) {
                var3_11 = this.uni2byte.get(var5_7[var1_10]);
                this.widths[var3_11] = var4_1.getRawWidth(var3_11, GlyphList.unicodeToName(var5_7[var1_10]));
            }
            if (this.diffmap != null) {
                var5_8 = this.diffmap.toOrderedKeys();
                for (var1_10 = var2_9; var1_10 < var5_8.length; ++var1_10) {
                    var2_9 = this.diffmap.get(var5_8[var1_10]);
                    this.widths[var2_9] = var4_1.getRawWidth(var2_9, GlyphList.unicodeToName(var5_8[var1_10]));
                }
                this.diffmap = null;
            }
            this.ascender = var4_1.getFontDescriptor(1, 1000.0f);
            this.capHeight = var4_1.getFontDescriptor(2, 1000.0f);
            this.descender = var4_1.getFontDescriptor(3, 1000.0f);
            this.italicAngle = var4_1.getFontDescriptor(4, 1000.0f);
            this.fontWeight = var4_1.getFontDescriptor(23, 1000.0f);
            this.llx = var4_1.getFontDescriptor(5, 1000.0f);
            this.lly = var4_1.getFontDescriptor(6, 1000.0f);
            this.urx = var4_1.getFontDescriptor(7, 1000.0f);
            this.ury = var4_1.getFontDescriptor(8, 1000.0f);
        }
        this.fillWidths();
        this.fillFontDesc(this.font.getAsDict(PdfName.FONTDESCRIPTOR));
    }

    private void fillDiffMap(PdfDictionary object, CMapToUnicode object2) {
        PdfArray pdfArray = object.getAsArray(PdfName.DIFFERENCES);
        if (pdfArray != null) {
            this.diffmap = new IntHashtable();
            int n = 0;
            for (int i = 0; i < pdfArray.size(); ++i) {
                object = pdfArray.getPdfObject(i);
                if (object.isNumber()) {
                    n = ((PdfNumber)object).intValue();
                    continue;
                }
                if ((object = GlyphList.nameToUnicode(PdfName.decodeName(((PdfName)object).toString()))) != null && ((PdfObject)object).length > 0) {
                    this.uni2byte.put((int)object[0], n);
                    this.byte2uni.put(n, (int)object[0]);
                    this.diffmap.put((int)object[0], n);
                } else {
                    object = object2;
                    if (object2 == null) {
                        object = object2 = this.processToUnicode();
                        if (object2 == null) {
                            object = new CMapToUnicode();
                        }
                    }
                    String string2 = object.lookup(new byte[]{(byte)n}, 0, 1);
                    object2 = object;
                    if (string2 != null) {
                        object2 = object;
                        if (string2.length() == 1) {
                            this.uni2byte.put(string2.charAt(0), n);
                            this.byte2uni.put(n, string2.charAt(0));
                            this.diffmap.put(string2.charAt(0), n);
                            object2 = object;
                        }
                    }
                }
                ++n;
            }
        }
    }

    /*
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void fillEncoding(PdfName arrc) {
        int n = 0;
        int n2 = 0;
        int n3 = 0;
        if (arrc == null && this.isSymbolic()) {
            while (n3 < 256) {
                this.uni2byte.put(n3, n3);
                this.byte2uni.put(n3, n3);
                ++n3;
            }
            return;
        }
        if (!(PdfName.MAC_ROMAN_ENCODING.equals(arrc) || PdfName.WIN_ANSI_ENCODING.equals(arrc) || PdfName.SYMBOL.equals(arrc))) {
            n3 = n;
            if (!PdfName.ZAPFDINGBATS.equals(arrc)) {
                while (n3 < 256) {
                    this.uni2byte.put(stdEnc[n3], n3);
                    this.byte2uni.put(n3, stdEnc[n3]);
                    ++n3;
                }
                return;
            }
        }
        byte[] arrby = new byte[256];
        for (n3 = 0; n3 < 256; ++n3) {
            arrby[n3] = (byte)n3;
        }
        String string2 = "Cp1252";
        if (PdfName.MAC_ROMAN_ENCODING.equals(arrc)) {
            string2 = "MacRoman";
        } else if (PdfName.SYMBOL.equals(arrc)) {
            string2 = "Symbol";
        } else if (PdfName.ZAPFDINGBATS.equals(arrc)) {
            string2 = "ZapfDingbats";
        }
        arrc = PdfEncodings.convertToString(arrby, string2).toCharArray();
        n3 = n2;
        do {
            if (n3 >= 256) {
                this.encoding = string2;
                return;
            }
            this.uni2byte.put(arrc[n3], n3);
            this.byte2uni.put(n3, arrc[n3]);
            ++n3;
        } while (true);
    }

    private void fillFontDesc(PdfDictionary pdfObject) {
        float f;
        if (pdfObject == null) {
            return;
        }
        PdfNumber pdfNumber = pdfObject.getAsNumber(PdfName.ASCENT);
        if (pdfNumber != null) {
            this.ascender = pdfNumber.floatValue();
        }
        if ((pdfNumber = pdfObject.getAsNumber(PdfName.CAPHEIGHT)) != null) {
            this.capHeight = pdfNumber.floatValue();
        }
        if ((pdfNumber = pdfObject.getAsNumber(PdfName.DESCENT)) != null) {
            this.descender = pdfNumber.floatValue();
        }
        if ((pdfNumber = pdfObject.getAsNumber(PdfName.ITALICANGLE)) != null) {
            this.italicAngle = pdfNumber.floatValue();
        }
        if ((pdfNumber = pdfObject.getAsNumber(PdfName.FONTWEIGHT)) != null) {
            this.fontWeight = pdfNumber.floatValue();
        }
        if ((pdfObject = pdfObject.getAsArray(PdfName.FONTBBOX)) != null) {
            this.llx = pdfObject.getAsNumber(0).floatValue();
            this.lly = pdfObject.getAsNumber(1).floatValue();
            this.urx = pdfObject.getAsNumber(2).floatValue();
            this.ury = pdfObject.getAsNumber(3).floatValue();
            if (this.llx > this.urx) {
                f = this.llx;
                this.llx = this.urx;
                this.urx = f;
            }
            if (this.lly > this.ury) {
                f = this.lly;
                this.lly = this.ury;
                this.ury = f;
            }
        }
        f = Math.max(this.ury, this.ascender);
        float f2 = Math.min(this.lly, this.descender);
        float f3 = f - f2;
        this.ascender = f * 1000.0f / f3;
        this.descender = f2 * 1000.0f / f3;
    }

    /*
     * Exception decompiling
     */
    private void fillMetrics(byte[] var1_1, IntHashtable var2_3, int var3_4) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [4[TRYBLOCK]], but top level block is 10[DOLOOP]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    private void fillMetricsIdentity(IntHashtable intHashtable, int n) {
        for (int i = 0; i < 65536; ++i) {
            int n2 = intHashtable.containsKey(i) ? intHashtable.get(i) : n;
            this.metrics.put(i, new int[]{i, n2});
        }
    }

    private void fillWidths() {
        PdfArray pdfArray = this.font.getAsArray(PdfName.WIDTHS);
        int[] arrn = this.font.getAsNumber(PdfName.FIRSTCHAR);
        PdfNumber pdfNumber = this.font.getAsNumber(PdfName.LASTCHAR);
        if (arrn != null && pdfNumber != null && pdfArray != null) {
            int n;
            int n2 = arrn.intValue();
            int n3 = pdfArray.size() + n2;
            int n4 = this.widths.length;
            int n5 = n = 0;
            if (n4 < n3) {
                arrn = new int[n3];
                System.arraycopy(this.widths, 0, arrn, 0, n2);
                this.widths = arrn;
                n5 = n;
            }
            while (n5 < pdfArray.size()) {
                this.widths[n2 + n5] = pdfArray.getAsNumber(n5).intValue();
                ++n5;
            }
        }
    }

    private void init() {
        this.encoding = "";
        this.fontSpecific = false;
        this.fontType = 4;
        Object object = this.font.getAsName(PdfName.BASEFONT);
        object = object != null ? PdfName.decodeName(object.toString()) : "Unspecified Font Name";
        this.fontName = object;
        object = this.font.getAsName(PdfName.SUBTYPE);
        if (!PdfName.TYPE1.equals(object) && !PdfName.TRUETYPE.equals(object)) {
            if (PdfName.TYPE3.equals(object)) {
                this.fillEncoding(null);
                this.fillDiffMap(this.font.getAsDict(PdfName.ENCODING), null);
                this.fillWidths();
                return;
            }
            Object object2 = this.font.getAsName(PdfName.ENCODING);
            if (object2 != null) {
                String string2 = CJKFont.GetCompatibleFont((String)(object2 = PdfName.decodeName(object2.toString())));
                if (string2 != null) {
                    try {
                        this.cjkMirror = BaseFont.createFont(string2, (String)object2, false);
                        this.cjkEncoding = object2;
                        this.uniMap = ((CJKFont)this.cjkMirror).getUniMap();
                    }
                    catch (Exception exception) {
                        throw new ExceptionConverter(exception);
                    }
                }
                if (PdfName.TYPE0.equals(object)) {
                    this.isType0 = true;
                    if (!object2.equals("Identity-H") && this.cjkMirror != null) {
                        object = (PdfDictionary)PdfReader.getPdfObjectRelease(((PdfArray)PdfReader.getPdfObjectRelease(this.font.get(PdfName.DESCENDANTFONTS))).getPdfObject(0));
                        object2 = (PdfNumber)PdfReader.getPdfObjectRelease(object.get(PdfName.DW));
                        if (object2 != null) {
                            this.defaultWidth = object2.intValue();
                        }
                        this.hMetrics = this.readWidths((PdfArray)PdfReader.getPdfObjectRelease(object.get(PdfName.W)));
                        this.fillFontDesc((PdfDictionary)PdfReader.getPdfObjectRelease(object.get(PdfName.FONTDESCRIPTOR)));
                        return;
                    }
                    this.processType0(this.font);
                    return;
                }
            }
        } else {
            this.doType1TT();
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private CMapToUnicode processToUnicode() {
        Object object = PdfReader.getPdfObjectRelease(this.font.get(PdfName.TOUNICODE));
        boolean bl = object instanceof PRStream;
        CMapToUnicode cMapToUnicode = null;
        if (!bl) return cMapToUnicode;
        try {
            object = new CidLocationFromByte(PdfReader.getStreamBytes((PRStream)object));
            cMapToUnicode = new CMapToUnicode();
            CMapParserEx.parseCid("", cMapToUnicode, (CidLocation)object);
        }
        catch (Exception exception) {
            return null;
        }
        return cMapToUnicode;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void processType0(PdfDictionary pdfDictionary) {
        try {
            PdfObject pdfObject = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.TOUNICODE));
            pdfDictionary = (PdfDictionary)PdfReader.getPdfObjectRelease(((PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.DESCENDANTFONTS))).getPdfObject(0));
            Object object = (PdfNumber)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.DW));
            int n = 1000;
            if (object != null) {
                n = object.intValue();
            }
            object = this.readWidths((PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.W)));
            this.fillFontDesc((PdfDictionary)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.FONTDESCRIPTOR)));
            if (pdfObject instanceof PRStream) {
                this.fillMetrics(PdfReader.getStreamBytes((PRStream)pdfObject), (IntHashtable)object, n);
                return;
            }
            if (new PdfName("Identity-H").equals(pdfObject)) {
                this.fillMetricsIdentity((IntHashtable)object, n);
            }
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    private IntHashtable readWidths(PdfArray pdfArray) {
        IntHashtable intHashtable = new IntHashtable();
        if (pdfArray == null) {
            return intHashtable;
        }
        int n = 0;
        while (n < pdfArray.size()) {
            int n2;
            int n3 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(n))).intValue();
            int n4 = n + 1;
            PdfObject pdfObject = PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(n4));
            if (pdfObject.isArray()) {
                pdfObject = (PdfArray)pdfObject;
                n2 = 0;
                n = n3;
                do {
                    n3 = n4;
                    if (n2 < pdfObject.size()) {
                        intHashtable.put(n, ((PdfNumber)PdfReader.getPdfObjectRelease(pdfObject.getPdfObject(n2))).intValue());
                        ++n2;
                        ++n;
                        continue;
                    }
                    break;
                } while (true);
            } else {
                int n5 = ((PdfNumber)pdfObject).intValue();
                n2 = n4 + 1;
                n4 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(n2))).intValue();
                n = n3;
                do {
                    n3 = n2;
                    if (n > n5) break;
                    intHashtable.put(n, n4);
                    ++n;
                } while (true);
            }
            n = n3 + 1;
        }
        return intHashtable;
    }

    @Override
    public boolean charExists(int n) {
        if (this.cjkMirror != null) {
            return this.cjkMirror.charExists(n);
        }
        if (this.isType0) {
            return this.metrics.containsKey(n);
        }
        return super.charExists(n);
    }

    @Override
    byte[] convertToBytes(int n) {
        if (this.cjkMirror != null) {
            return this.cjkMirror.convertToBytes(n);
        }
        if (this.isType0) {
            int[] arrn = this.metrics.get(n);
            if (arrn != null) {
                n = arrn[0];
                return new byte[]{(byte)(n / 256), (byte)n};
            }
            return new byte[0];
        }
        if (this.uni2byte.containsKey(n)) {
            return new byte[]{(byte)this.uni2byte.get(n)};
        }
        return new byte[0];
    }

    @Override
    public byte[] convertToBytes(String arrby) {
        if (this.cjkMirror != null) {
            return this.cjkMirror.convertToBytes((String)arrby);
        }
        if (this.isType0) {
            char[] arrc = arrby.toCharArray();
            int n = arrc.length;
            arrby = new byte[n * 2];
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                int[] arrn = this.metrics.get(Integer.valueOf(arrc[i]));
                int n3 = n2;
                if (arrn != null) {
                    int n4 = arrn[0];
                    int n5 = n2 + 1;
                    arrby[n2] = (byte)(n4 / 256);
                    n3 = n5 + 1;
                    arrby[n5] = (byte)n4;
                }
                n2 = n3;
            }
            if (n2 == arrby.length) {
                return arrby;
            }
            arrc = new byte[n2];
            System.arraycopy(arrby, 0, arrc, 0, n2);
            return arrc;
        }
        char[] arrc = arrby.toCharArray();
        arrby = new byte[arrc.length];
        int n = 0;
        for (int i = 0; i < arrc.length; ++i) {
            int n6 = n;
            if (this.uni2byte.containsKey(arrc[i])) {
                arrby[n] = (byte)this.uni2byte.get(arrc[i]);
                n6 = n + 1;
            }
            n = n6;
        }
        if (n == arrby.length) {
            return arrby;
        }
        arrc = new byte[n];
        System.arraycopy(arrby, 0, arrc, 0, n);
        return arrc;
    }

    @Override
    public String[][] getAllNameEntries() {
        return new String[][]{{"4", "", "", "", this.fontName}};
    }

    IntHashtable getByte2Uni() {
        return this.byte2uni;
    }

    @Override
    public int[] getCharBBox(int n) {
        return null;
    }

    IntHashtable getDiffmap() {
        return this.diffmap;
    }

    @Override
    public String[][] getFamilyFontName() {
        return this.getFullFontName();
    }

    @Override
    public float getFontDescriptor(int n, float f) {
        if (this.cjkMirror != null) {
            return this.cjkMirror.getFontDescriptor(n, f);
        }
        if (n != 23) {
            switch (n) {
                default: {
                    return 0.0f;
                }
                case 12: {
                    return (this.urx - this.llx) * f / 1000.0f;
                }
                case 11: {
                    return 0.0f;
                }
                case 8: {
                    return this.ury * f / 1000.0f;
                }
                case 7: {
                    return this.urx * f / 1000.0f;
                }
                case 6: {
                    return this.lly * f / 1000.0f;
                }
                case 5: {
                    return this.llx * f / 1000.0f;
                }
                case 4: {
                    return this.italicAngle;
                }
                case 3: 
                case 10: {
                    return this.descender * f / 1000.0f;
                }
                case 2: {
                    return this.capHeight * f / 1000.0f;
                }
                case 1: 
                case 9: 
            }
            return this.ascender * f / 1000.0f;
        }
        return this.fontWeight * f / 1000.0f;
    }

    public PdfDictionary getFontDictionary() {
        return this.font;
    }

    @Override
    public double[] getFontMatrix() {
        if (this.font.getAsArray(PdfName.FONTMATRIX) != null) {
            return this.font.getAsArray(PdfName.FONTMATRIX).asDoubleArray();
        }
        return DEFAULT_FONT_MATRIX;
    }

    @Override
    public String[][] getFullFontName() {
        return new String[][]{{"", "", "", this.fontName}};
    }

    @Override
    public PdfStream getFullFontStream() {
        return null;
    }

    PdfIndirectReference getIndirectReference() {
        if (this.refFont == null) {
            throw new IllegalArgumentException("Font reuse not allowed with direct font objects.");
        }
        return this.refFont;
    }

    @Override
    public int getKerning(int n, int n2) {
        return 0;
    }

    @Override
    public String getPostscriptFontName() {
        return this.fontName;
    }

    @Override
    protected int[] getRawCharBBox(int n, String string2) {
        return null;
    }

    @Override
    int getRawWidth(int n, String string2) {
        return 0;
    }

    IntHashtable getUni2Byte() {
        return this.uni2byte;
    }

    @Override
    public int getWidth(int n) {
        if (this.isType0) {
            if (this.hMetrics != null && this.cjkMirror != null && !this.cjkMirror.isVertical()) {
                n = this.cjkMirror.getCidCode(n);
                if ((n = this.hMetrics.get(n)) > 0) {
                    return n;
                }
                return this.defaultWidth;
            }
            int[] arrn = this.metrics.get(n);
            if (arrn != null) {
                return arrn[1];
            }
            return 0;
        }
        if (this.cjkMirror != null) {
            return this.cjkMirror.getWidth(n);
        }
        return super.getWidth(n);
    }

    @Override
    public int getWidth(String arrc) {
        if (this.isType0) {
            int n;
            block12 : {
                int n2;
                int[] arrn = this.hMetrics;
                n = 0;
                int n3 = 0;
                if (arrn != null && this.cjkMirror != null && !this.cjkMirror.isVertical()) {
                    if (((CJKFont)this.cjkMirror).isIdentity()) {
                        n = 0;
                        n2 = n3;
                        n3 = n;
                        do {
                            n = n3;
                            if (n2 < arrc.length()) {
                                n3 += this.getWidth(arrc.charAt(n2));
                                ++n2;
                                continue;
                            }
                            break block12;
                            break;
                        } while (true);
                    }
                    n3 = 0;
                    n2 = n;
                    do {
                        n = n3;
                        if (n2 < arrc.length()) {
                            if (Utilities.isSurrogatePair((String)arrc, n2)) {
                                n = Utilities.convertToUtf32((String)arrc, n2);
                                ++n2;
                            } else {
                                n = arrc.charAt(n2);
                            }
                            n3 += this.getWidth(n);
                            ++n2;
                            continue;
                        }
                        break block12;
                        break;
                    } while (true);
                }
                arrc = arrc.toCharArray();
                int n4 = arrc.length;
                n3 = 0;
                for (n2 = 0; n2 < n4; ++n2) {
                    arrn = this.metrics.get(Integer.valueOf(arrc[n2]));
                    n = n3;
                    if (arrn != null) {
                        n = n3 + arrn[1];
                    }
                    n3 = n;
                }
                n = n3;
            }
            return n;
        }
        if (this.cjkMirror != null) {
            return this.cjkMirror.getWidth((String)arrc);
        }
        return super.getWidth((String)arrc);
    }

    @Override
    public boolean hasKernPairs() {
        return false;
    }

    boolean isSymbolic() {
        PdfObject pdfObject = this.font.getAsDict(PdfName.FONTDESCRIPTOR);
        boolean bl = false;
        if (pdfObject == null) {
            return false;
        }
        if ((pdfObject = pdfObject.getAsNumber(PdfName.FLAGS)) == null) {
            return false;
        }
        if ((pdfObject.intValue() & 4) != 0) {
            bl = true;
        }
        return bl;
    }

    @Override
    public boolean isVertical() {
        if (this.cjkMirror != null) {
            return this.cjkMirror.isVertical();
        }
        return super.isVertical();
    }

    @Override
    public boolean setKerning(int n, int n2, int n3) {
        return false;
    }

    @Override
    public void setPostscriptFontName(String string2) {
    }

    @Override
    void writeFont(PdfWriter pdfWriter, PdfIndirectReference pdfIndirectReference, Object[] arrobject) throws DocumentException, IOException {
    }
}

