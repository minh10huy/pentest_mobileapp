/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.spongycastle.cert.X509CertificateHolder
 *  org.spongycastle.cms.CMSEnvelopedData
 *  org.spongycastle.cms.Recipient
 *  org.spongycastle.cms.RecipientId
 *  org.spongycastle.cms.RecipientInformation
 *  org.spongycastle.cms.RecipientInformationStore
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocWriter;
import com.itextpdf.text.Document;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.PageSize;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.BadPasswordException;
import com.itextpdf.text.exceptions.InvalidPdfException;
import com.itextpdf.text.exceptions.UnsupportedPdfException;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.io.WindowRandomAccessSource;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.log.Level;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.FilterHandlers;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.LZWDecoder;
import com.itextpdf.text.pdf.LongHashtable;
import com.itextpdf.text.pdf.PRAcroForm;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfEncryption;
import com.itextpdf.text.pdf.PdfEncryptor;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNameTree;
import com.itextpdf.text.pdf.PdfNull;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReaderInstance;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.SequenceList;
import com.itextpdf.text.pdf.interfaces.PdfViewerPreferences;
import com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp;
import com.itextpdf.text.pdf.security.ExternalDecryptionProcess;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.net.URL;
import java.security.Key;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.zip.InflaterInputStream;
import org.spongycastle.cert.X509CertificateHolder;
import org.spongycastle.cms.CMSEnvelopedData;
import org.spongycastle.cms.Recipient;
import org.spongycastle.cms.RecipientId;
import org.spongycastle.cms.RecipientInformation;
import org.spongycastle.cms.RecipientInformationStore;

public class PdfReader
implements PdfViewerPreferences {
    protected static Counter COUNTER;
    private static final Logger LOGGER;
    public static boolean debugmode = false;
    static final byte[] endobj;
    static final byte[] endstream;
    static final PdfName[] pageInhCandidates;
    public static boolean unethicalreading = false;
    protected PRAcroForm acroForm = null;
    protected boolean acroFormParsed;
    private boolean appendable;
    protected PdfDictionary catalog;
    protected Certificate certificate;
    protected Key certificateKey;
    protected String certificateKeyProvider;
    protected boolean consolidateNamedDestinations;
    private PRIndirectReference cryptoRef;
    protected PdfEncryption decrypt;
    protected boolean encrypted;
    private boolean encryptionError;
    protected long eofPos;
    protected ExternalDecryptionProcess externalDecryptionProcess;
    private long fileLength;
    protected int freeXref;
    private boolean hybridXref;
    protected long lastXref;
    private int lastXrefPartial;
    protected boolean newXrefType;
    private int objGen;
    private int objNum;
    protected HashMap<Integer, IntHashtable> objStmMark;
    protected LongHashtable objStmToOffset;
    private boolean ownerPasswordUsed;
    protected long pValue;
    protected PageRefs pageRefs;
    private boolean partial;
    protected byte[] password;
    protected char pdfVersion;
    protected int rValue;
    private int readDepth;
    protected boolean rebuilt;
    protected boolean remoteToLocalNamedDestinations;
    PdfDictionary rootPages;
    protected boolean sharedStreams;
    protected ArrayList<PdfString> strings;
    protected boolean tampered;
    protected PRTokeniser tokens;
    protected PdfDictionary trailer;
    private final PdfViewerPreferencesImp viewerPreferences;
    protected long[] xref;
    protected ArrayList<PdfObject> xrefObj;

    static {
        LOGGER = LoggerFactory.getLogger(PdfReader.class);
        pageInhCandidates = new PdfName[]{PdfName.MEDIABOX, PdfName.ROTATE, PdfName.RESOURCES, PdfName.CROPBOX};
        endstream = PdfEncodings.convertToBytes("endstream", null);
        endobj = PdfEncodings.convertToBytes("endobj", null);
        COUNTER = CounterFactory.getCounter(PdfReader.class);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private PdfReader(RandomAccessSource randomAccessSource, boolean bl, byte[] arrby, Certificate certificate, Key key, String string2, ExternalDecryptionProcess externalDecryptionProcess, boolean bl2) throws IOException {
        this.acroFormParsed = false;
        this.encrypted = false;
        this.rebuilt = false;
        this.tampered = false;
        this.password = null;
        this.certificateKey = null;
        this.certificate = null;
        this.certificateKeyProvider = null;
        this.externalDecryptionProcess = null;
        this.strings = new ArrayList();
        this.sharedStreams = true;
        this.consolidateNamedDestinations = false;
        this.remoteToLocalNamedDestinations = false;
        this.lastXrefPartial = -1;
        this.viewerPreferences = new PdfViewerPreferencesImp();
        this.readDepth = 0;
        this.certificate = certificate;
        this.certificateKey = key;
        this.certificateKeyProvider = string2;
        this.externalDecryptionProcess = externalDecryptionProcess;
        this.password = arrby;
        this.partial = bl;
        try {
            this.tokens = PdfReader.getOffsetTokeniser(randomAccessSource);
            if (bl) {
                this.readPdfPartial();
            } else {
                this.readPdf();
            }
            this.getCounter().read(this.fileLength);
            return;
        }
        catch (IOException iOException) {
            if (bl2) {
                randomAccessSource.close();
            }
            throw iOException;
        }
    }

    public PdfReader(PdfReader pdfReader) {
        int n = 0;
        this.acroFormParsed = false;
        this.encrypted = false;
        this.rebuilt = false;
        this.tampered = false;
        this.password = null;
        this.certificateKey = null;
        this.certificate = null;
        this.certificateKeyProvider = null;
        this.externalDecryptionProcess = null;
        this.strings = new ArrayList();
        this.sharedStreams = true;
        this.consolidateNamedDestinations = false;
        this.remoteToLocalNamedDestinations = false;
        this.lastXrefPartial = -1;
        this.viewerPreferences = new PdfViewerPreferencesImp();
        this.readDepth = 0;
        this.appendable = pdfReader.appendable;
        this.consolidateNamedDestinations = pdfReader.consolidateNamedDestinations;
        this.encrypted = pdfReader.encrypted;
        this.rebuilt = pdfReader.rebuilt;
        this.sharedStreams = pdfReader.sharedStreams;
        this.tampered = pdfReader.tampered;
        this.password = pdfReader.password;
        this.pdfVersion = pdfReader.pdfVersion;
        this.eofPos = pdfReader.eofPos;
        this.freeXref = pdfReader.freeXref;
        this.lastXref = pdfReader.lastXref;
        this.newXrefType = pdfReader.newXrefType;
        this.tokens = new PRTokeniser(pdfReader.tokens.getSafeFile());
        if (pdfReader.decrypt != null) {
            this.decrypt = new PdfEncryption(pdfReader.decrypt);
        }
        this.pValue = pdfReader.pValue;
        this.rValue = pdfReader.rValue;
        this.xrefObj = new ArrayList<PdfObject>(pdfReader.xrefObj);
        while (n < pdfReader.xrefObj.size()) {
            this.xrefObj.set(n, PdfReader.duplicatePdfObject(pdfReader.xrefObj.get(n), this));
            ++n;
        }
        this.pageRefs = new PageRefs(pdfReader.pageRefs, this);
        this.trailer = (PdfDictionary)PdfReader.duplicatePdfObject(pdfReader.trailer, this);
        this.catalog = this.trailer.getAsDict(PdfName.ROOT);
        this.rootPages = this.catalog.getAsDict(PdfName.PAGES);
        this.fileLength = pdfReader.fileLength;
        this.partial = pdfReader.partial;
        this.hybridXref = pdfReader.hybridXref;
        this.objStmToOffset = pdfReader.objStmToOffset;
        this.xref = pdfReader.xref;
        this.cryptoRef = (PRIndirectReference)PdfReader.duplicatePdfObject(pdfReader.cryptoRef, this);
        this.ownerPasswordUsed = pdfReader.ownerPasswordUsed;
    }

    public PdfReader(RandomAccessFileOrArray randomAccessFileOrArray, byte[] arrby) throws IOException {
        this(randomAccessFileOrArray, arrby, true);
    }

    public PdfReader(RandomAccessFileOrArray randomAccessFileOrArray, byte[] arrby, boolean bl) throws IOException {
        this(randomAccessFileOrArray.getByteSource(), bl, arrby, null, null, null, null, false);
    }

    public PdfReader(InputStream inputStream) throws IOException {
        this(inputStream, null);
    }

    public PdfReader(InputStream inputStream, Certificate certificate, ExternalDecryptionProcess externalDecryptionProcess) throws IOException {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createSource(inputStream), false, null, certificate, null, null, externalDecryptionProcess, true);
    }

    public PdfReader(InputStream inputStream, byte[] arrby) throws IOException {
        this(new RandomAccessSourceFactory().createSource(inputStream), false, arrby, null, null, null, null, false);
    }

    public PdfReader(String string2) throws IOException {
        this(string2, (byte[])null);
    }

    public PdfReader(String string2, Certificate certificate, ExternalDecryptionProcess externalDecryptionProcess) throws IOException {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2), false, null, certificate, null, null, externalDecryptionProcess, true);
    }

    public PdfReader(String string2, Certificate certificate, Key key, String string3) throws IOException {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2), false, null, certificate, key, string3, null, true);
    }

    public PdfReader(String string2, byte[] arrby) throws IOException {
        this(string2, arrby, false);
    }

    public PdfReader(String string2, byte[] arrby, boolean bl) throws IOException {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2), bl, arrby, null, null, null, null, true);
    }

    public PdfReader(URL uRL) throws IOException {
        this(uRL, null);
    }

    public PdfReader(URL uRL, byte[] arrby) throws IOException {
        this(new RandomAccessSourceFactory().createSource(uRL), false, arrby, null, null, null, null, true);
    }

    public PdfReader(byte[] arrby) throws IOException {
        this(arrby, null);
    }

    public PdfReader(byte[] arrby, Certificate certificate, ExternalDecryptionProcess externalDecryptionProcess) throws IOException {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createSource(arrby), false, null, certificate, null, null, externalDecryptionProcess, true);
    }

    public PdfReader(byte[] arrby, byte[] arrby2) throws IOException {
        this(new RandomAccessSourceFactory().createSource(arrby), false, arrby2, null, null, null, null, true);
    }

    public static byte[] ASCII85Decode(byte[] arrby) {
        int n;
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        int[] arrn = new int[5];
        int n2 = 0;
        for (int i = 0; i < arrby.length && (n = arrby[i] & 255) != 126; ++i) {
            if (PRTokeniser.isWhitespace(n)) continue;
            if (n == 122 && n2 == 0) {
                byteArrayOutputStream.write(0);
                byteArrayOutputStream.write(0);
                byteArrayOutputStream.write(0);
                byteArrayOutputStream.write(0);
                continue;
            }
            if (n >= 33 && n <= 117) {
                arrn[n2] = n - 33;
                n2 = n = n2 + 1;
                if (n != 5) continue;
                n = 0;
                for (n2 = 0; n2 < 5; ++n2) {
                    n = n * 85 + arrn[n2];
                }
                byteArrayOutputStream.write((byte)(n >> 24));
                byteArrayOutputStream.write((byte)(n >> 16));
                byteArrayOutputStream.write((byte)(n >> 8));
                byteArrayOutputStream.write((byte)n);
                n2 = 0;
                continue;
            }
            throw new RuntimeException(MessageLocalization.getComposedMessage("illegal.character.in.ascii85decode", new Object[0]));
        }
        if (n2 == 2) {
            byteArrayOutputStream.write((byte)(arrn[0] * 85 * 85 * 85 * 85 + arrn[1] * 85 * 85 * 85 + 614125 + 7225 + 85 >> 24));
        } else if (n2 == 3) {
            n2 = arrn[0] * 85 * 85 * 85 * 85 + arrn[1] * 85 * 85 * 85 + arrn[2] * 85 * 85 + 7225 + 85;
            byteArrayOutputStream.write((byte)(n2 >> 24));
            byteArrayOutputStream.write((byte)(n2 >> 16));
        } else if (n2 == 4) {
            n2 = arrn[0] * 85 * 85 * 85 * 85 + arrn[1] * 85 * 85 * 85 + arrn[2] * 85 * 85 + arrn[3] * 85 + 85;
            byteArrayOutputStream.write((byte)(n2 >> 24));
            byteArrayOutputStream.write((byte)(n2 >> 16));
            byteArrayOutputStream.write((byte)(n2 >> 8));
        }
        return byteArrayOutputStream.toByteArray();
    }

    public static byte[] ASCIIHexDecode(byte[] arrby) {
        int n;
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        boolean bl = true;
        int n2 = 0;
        for (int i = 0; i < arrby.length && (n = arrby[i] & 255) != 62; ++i) {
            if (PRTokeniser.isWhitespace(n)) continue;
            if ((n = PRTokeniser.getHex(n)) == -1) {
                throw new RuntimeException(MessageLocalization.getComposedMessage("illegal.character.in.asciihexdecode", new Object[0]));
            }
            if (bl) {
                n2 = n;
            } else {
                byteArrayOutputStream.write((byte)((n2 << 4) + n));
            }
            bl ^= true;
        }
        if (!bl) {
            byteArrayOutputStream.write((byte)(n2 << 4));
        }
        return byteArrayOutputStream.toByteArray();
    }

    public static byte[] FlateDecode(byte[] arrby) {
        byte[] arrby2 = PdfReader.FlateDecode(arrby, true);
        if (arrby2 == null) {
            return PdfReader.FlateDecode(arrby, false);
        }
        return arrby2;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static byte[] FlateDecode(byte[] object, boolean bl) {
        byte[] arrby = new byte[](new ByteArrayInputStream((byte[])object));
        object = new ByteArrayOutputStream();
        int n = bl ? 4092 : 1;
        byte[] arrby2 = new byte[n];
        try {
            do {
                if ((n = arrby.read(arrby2)) < 0) {
                    arrby.close();
                    object.close();
                    return object.toByteArray();
                }
                object.write(arrby2, 0, n);
            } while (true);
        }
        catch (Exception exception) {}
        if (!bl) return object.toByteArray();
        return null;
    }

    public static byte[] LZWDecode(byte[] arrby) {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        new LZWDecoder().decode(arrby, byteArrayOutputStream);
        return byteArrayOutputStream.toByteArray();
    }

    private void checkPRStreamLength(PRStream pRStream) throws IOException {
        long l;
        long l2;
        long l3 = this.tokens.length();
        long l4 = pRStream.getOffset();
        Object object = PdfReader.getPdfObjectRelease(pRStream.get(PdfName.LENGTH));
        int n = 1;
        if (object != null && object.type() == 2) {
            l2 = ((PdfNumber)object).intValue();
            l = l2 + l4;
            if (l <= l3 - 20L) {
                this.tokens.seek(l);
                object = this.tokens.readString(20);
                if (object.startsWith("\nendstream") || object.startsWith("\r\nendstream") || object.startsWith("\rendstream") || object.startsWith("endstream")) {
                    n = 0;
                }
            }
        } else {
            l2 = 0L;
        }
        if (n != 0) {
            block10 : {
                object = new byte[16];
                this.tokens.seek(l4);
                do {
                    l3 = this.tokens.getFilePointer();
                    if (!this.tokens.readLineSegment((byte[])object, false)) break block10;
                    if (!PdfReader.equalsn((byte[])object, endstream)) continue;
                    l2 = l3 - l4;
                    break block10;
                } while (!PdfReader.equalsn((byte[])object, endobj));
                object = this.tokens;
                l = l3 - 16L;
                object.seek(l);
                n = this.tokens.readString(16).indexOf("endstream");
                l2 = l3;
                if (n >= 0) {
                    l2 = l + (long)n;
                }
                l4 = l2 - l4;
                l3 = l2;
                l2 = l4;
            }
            this.tokens.seek(l3 - 2L);
            if (this.tokens.read() == 13) {
                --l2;
            }
            this.tokens.seek(l3 - 1L);
            l3 = l2;
            if (this.tokens.read() == 10) {
                l3 = l2 - 1L;
            }
            l2 = l3;
            if (l3 < 0L) {
                l2 = 0L;
            }
        }
        pRStream.setLength((int)l2);
    }

    private boolean convertNamedDestination(PdfObject object, HashMap<Object, PdfObject> hashMap) {
        PdfObject pdfObject;
        PdfObject pdfObject2 = PdfReader.getPdfObject((PdfObject)object);
        int n = this.lastXrefPartial;
        this.releaseLastXrefPartial();
        if (pdfObject2 != null && pdfObject2.isDictionary() && (pdfObject = PdfReader.getPdfObject(((PdfDictionary)pdfObject2).get(PdfName.A))) != null) {
            int n2 = this.lastXrefPartial;
            this.releaseLastXrefPartial();
            PdfDictionary pdfDictionary = (PdfDictionary)pdfObject;
            object = (PdfName)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.S));
            if (PdfName.GOTOR.equals(object) && (object = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.D))) != null) {
                if (!object.isName()) {
                    object = object.isString() ? object.toString() : null;
                }
                if ((PdfArray)hashMap.get(object) != null) {
                    pdfDictionary.remove(PdfName.F);
                    pdfDictionary.remove(PdfName.NEWWINDOW);
                    pdfDictionary.put(PdfName.S, PdfName.GOTO);
                    this.setXrefPartialObject(n2, pdfObject);
                    this.setXrefPartialObject(n, pdfObject2);
                    return true;
                }
            }
        }
        return false;
    }

    public static byte[] decodeBytes(byte[] arrby, PdfDictionary pdfDictionary) throws IOException {
        return PdfReader.decodeBytes(arrby, pdfDictionary, FilterHandlers.getDefaultFilterHandlers());
    }

    public static byte[] decodeBytes(byte[] arrby, PdfDictionary pdfDictionary, Map<PdfName, FilterHandlers.FilterHandler> map) throws IOException {
        Serializable serializable;
        ArrayList<Serializable> arrayList;
        ArrayList<Object> arrayList2;
        Serializable serializable2;
        block21 : {
            block20 : {
                serializable2 = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.FILTER));
                serializable = new ArrayList<PdfObject>();
                arrayList2 = serializable;
                if (serializable2 != null) {
                    if (serializable2.isName()) {
                        serializable.add(serializable2);
                        arrayList2 = serializable;
                    } else {
                        arrayList2 = serializable;
                        if (serializable2.isArray()) {
                            arrayList2 = ((PdfArray)serializable2).getArrayList();
                        }
                    }
                }
                arrayList = new ArrayList<Serializable>();
                serializable = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.DECODEPARMS));
                if (serializable == null) break block20;
                serializable2 = serializable;
                if (serializable.isDictionary()) break block21;
                serializable2 = serializable;
                if (serializable.isArray()) break block21;
            }
            serializable2 = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.DP));
        }
        serializable = arrayList;
        if (serializable2 != null) {
            if (serializable2.isDictionary()) {
                arrayList.add(serializable2);
                serializable = arrayList;
            } else {
                serializable = arrayList;
                if (serializable2.isArray()) {
                    serializable = ((PdfArray)serializable2).getArrayList();
                }
            }
        }
        for (int i = 0; i < arrayList2.size(); ++i) {
            PdfName pdfName = (PdfName)arrayList2.get(i);
            FilterHandlers.FilterHandler filterHandler = map.get(pdfName);
            if (filterHandler == null) {
                throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("the.filter.1.is.not.supported", pdfName));
            }
            int n = serializable.size();
            arrayList = null;
            serializable2 = arrayList;
            if (i < n) {
                PdfObject pdfObject = PdfReader.getPdfObject((PdfObject)serializable.get(i));
                if (pdfObject instanceof PdfDictionary) {
                    serializable2 = (PdfDictionary)pdfObject;
                } else {
                    serializable2 = arrayList;
                    if (pdfObject != null) {
                        serializable2 = arrayList;
                        if (!(pdfObject instanceof PdfNull)) {
                            if (pdfObject instanceof PdfLiteral && Arrays.equals("null".getBytes(), ((PdfLiteral)pdfObject).getBytes())) {
                                serializable2 = arrayList;
                            } else {
                                throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("the.decode.parameter.type.1.is.not.supported", pdfObject.getClass().toString()));
                            }
                        }
                    }
                }
            }
            arrby = filterHandler.decode(arrby, pdfName, (PdfObject)serializable2, pdfDictionary);
        }
        return arrby;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public static byte[] decodePredictor(byte[] object, PdfObject object2) {
        if (object2 == null) return object;
        if (!object2.isDictionary()) {
            return object;
        }
        Object arrby = PdfReader.getPdfObject((object2 = (PdfDictionary)object2).get(PdfName.PREDICTOR));
        if (arrby == null) return object;
        if (!arrby.isNumber()) {
            return object;
        }
        int n = ((PdfNumber)arrby).intValue();
        if (n < 10 && n != 2) {
            return object;
        }
        arrby = PdfReader.getPdfObject(object2.get(PdfName.COLUMNS));
        int n2 = 1;
        int n3 = arrby != null && arrby.isNumber() ? ((PdfNumber)arrby).intValue() : 1;
        arrby = PdfReader.getPdfObject(object2.get(PdfName.COLORS));
        int n4 = n2;
        if (arrby != null) {
            n4 = n2;
            if (arrby.isNumber()) {
                n4 = ((PdfNumber)arrby).intValue();
            }
        }
        int n5 = (object2 = PdfReader.getPdfObject(object2.get(PdfName.BITSPERCOMPONENT))) != null && object2.isNumber() ? ((PdfNumber)object2).intValue() : 8;
        DataInputStream dataInputStream = new DataInputStream(new ByteArrayInputStream((byte[])object));
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(((Object)object).length);
        n2 = n4 * n5 / 8;
        int n6 = (n4 * n3 * n5 + 7) / 8;
        object2 = new byte[n6];
        arrby = new byte[n6];
        n3 = 0;
        if (n == 2) {
            if (n5 != 8) return object;
            n5 = ((Object)object).length / n6;
            while (n3 < n5) {
                for (n4 = n2 + 0; n4 < n6; ++n4) {
                    n = n3 * n6 + n4;
                    object[n] = (byte)(object[n] + object[n - n2]);
                }
                ++n3;
            }
            return object;
        }
        do {
            block29 : {
                n3 = dataInputStream.read();
                if (n3 < 0) {
                    return byteArrayOutputStream.toByteArray();
                }
                dataInputStream.readFully((byte[])object2, 0, n6);
                switch (n3) {
                    default: {
                        throw new RuntimeException(MessageLocalization.getComposedMessage("png.filter.unknown", new Object[0]));
                    }
                    case 4: {
                        for (n3 = 0; n3 < n2; ++n3) {
                            object2[n3] = (byte)(object2[n3] + arrby[n3]);
                        }
                        for (n4 = n2; n4 < n6; ++n4) {
                            n = n4 - n2;
                            n3 = object2[n] & 255;
                            n5 = arrby[n4] & 255;
                            n = arrby[n] & 255;
                            int n7 = n3 + n5 - n;
                            int n8 = Math.abs(n7 - n3);
                            int n9 = Math.abs(n7 - n5);
                            n7 = Math.abs(n7 - n);
                            if (n8 > n9 || n8 > n7) {
                                n3 = n;
                                if (n9 <= n7) {
                                    n3 = n5;
                                }
                            }
                            object2[n4] = (byte)(object2[n4] + (byte)n3);
                        }
                        break;
                    }
                    case 3: {
                        for (n3 = 0; n3 < n2; ++n3) {
                            object2[n3] = (byte)(object2[n3] + arrby[n3] / 2);
                        }
                        for (n3 = n2; n3 < n6; ++n3) {
                            object2[n3] = (byte)(object2[n3] + ((object2[n3 - n2] & 255) + (arrby[n3] & 255)) / 2);
                        }
                        break;
                    }
                    case 2: {
                        for (n3 = 0; n3 < n6; ++n3) {
                            object2[n3] = (byte)(object2[n3] + arrby[n3]);
                        }
                        break;
                    }
                    case 1: {
                        for (n3 = n2; n3 < n6; ++n3) {
                            object2[n3] = (byte)(object2[n3] + object2[n3 - n2]);
                        }
                        break;
                    }
                    case 0: 
                }
                try {
                    byteArrayOutputStream.write((byte[])object2);
                    break block29;
                }
                catch (IOException iOException) {}
                catch (Exception exception) {
                    return byteArrayOutputStream.toByteArray();
                }
            }
            object = object2;
            object2 = arrby;
            arrby = object;
        } while (true);
    }

    protected static PdfDictionary duplicatePdfDictionary(PdfDictionary pdfDictionary, PdfDictionary object, PdfReader pdfReader) {
        PdfDictionary pdfDictionary2 = object;
        if (object == null) {
            pdfDictionary2 = new PdfDictionary(pdfDictionary.size());
        }
        for (PdfName pdfName : pdfDictionary.getKeys()) {
            pdfDictionary2.put(pdfName, PdfReader.duplicatePdfObject(pdfDictionary.get(pdfName), pdfReader));
        }
        return pdfDictionary2;
    }

    protected static PdfObject duplicatePdfObject(PdfObject pdfObject, PdfReader pdfReader) {
        if (pdfObject == null) {
            return null;
        }
        int n = pdfObject.type();
        if (n != 10) {
            switch (n) {
                default: {
                    return pdfObject;
                }
                case 7: {
                    pdfObject = (PRStream)pdfObject;
                    PRStream pRStream = new PRStream((PRStream)pdfObject, null, pdfReader);
                    PdfReader.duplicatePdfDictionary((PdfDictionary)pdfObject, pRStream, pdfReader);
                    return pRStream;
                }
                case 6: {
                    return PdfReader.duplicatePdfDictionary((PdfDictionary)pdfObject, null, pdfReader);
                }
                case 5: 
            }
            Object object = (PdfArray)pdfObject;
            pdfObject = new PdfArray(object.size());
            object = object.listIterator();
            while (object.hasNext()) {
                pdfObject.add(PdfReader.duplicatePdfObject((PdfObject)object.next(), pdfReader));
            }
            return pdfObject;
        }
        pdfObject = (PRIndirectReference)pdfObject;
        return new PRIndirectReference(pdfReader, pdfObject.getNumber(), pdfObject.getGeneration());
    }

    private void ensureXrefSize(int n) {
        if (n == 0) {
            return;
        }
        if (this.xref == null) {
            this.xref = new long[n];
            return;
        }
        if (this.xref.length < n) {
            long[] arrl = new long[n];
            System.arraycopy(this.xref, 0, arrl, 0, this.xref.length);
            this.xref = arrl;
        }
    }

    private boolean equalsArray(byte[] arrby, byte[] arrby2, int n) {
        for (int i = 0; i < n; ++i) {
            if (arrby[i] == arrby2[i]) continue;
            return false;
        }
        return true;
    }

    static boolean equalsn(byte[] arrby, byte[] arrby2) {
        int n = arrby2.length;
        for (int i = 0; i < n; ++i) {
            if (arrby[i] == arrby2[i]) continue;
            return false;
        }
        return true;
    }

    static boolean existsName(PdfDictionary pdfObject, PdfName pdfName, PdfName pdfName2) {
        if ((pdfObject = PdfReader.getPdfObjectRelease(pdfObject.get(pdfName))) != null && pdfObject.isName()) {
            return ((PdfName)pdfObject).equals(pdfName2);
        }
        return false;
    }

    static String getFontName(PdfDictionary pdfObject) {
        if (pdfObject == null) {
            return null;
        }
        if ((pdfObject = PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.BASEFONT))) != null) {
            if (!pdfObject.isName()) {
                return null;
            }
            return PdfName.decodeName(pdfObject.toString());
        }
        return null;
    }

    private static PdfArray getNameArray(PdfObject pdfObject) {
        if (pdfObject == null) {
            return null;
        }
        if ((pdfObject = PdfReader.getPdfObjectRelease(pdfObject)) == null) {
            return null;
        }
        if (pdfObject.isArray()) {
            return (PdfArray)pdfObject;
        }
        if (pdfObject.isDictionary() && (pdfObject = PdfReader.getPdfObjectRelease(((PdfDictionary)pdfObject).get(PdfName.D))) != null && pdfObject.isArray()) {
            return (PdfArray)pdfObject;
        }
        return null;
    }

    public static Rectangle getNormalizedRectangle(PdfArray pdfArray) {
        float f = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(0))).floatValue();
        float f2 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(1))).floatValue();
        float f3 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(2))).floatValue();
        float f4 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(3))).floatValue();
        return new Rectangle(Math.min(f, f3), Math.min(f2, f4), Math.max(f, f3), Math.max(f2, f4));
    }

    private static PRTokeniser getOffsetTokeniser(RandomAccessSource randomAccessSource) throws IOException {
        PRTokeniser pRTokeniser = new PRTokeniser(new RandomAccessFileOrArray(randomAccessSource));
        int n = pRTokeniser.getHeaderOffset();
        if (n != 0) {
            return new PRTokeniser(new RandomAccessFileOrArray(new WindowRandomAccessSource(randomAccessSource, n)));
        }
        return pRTokeniser;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    public static byte[] getPageContent(PdfDictionary var0) throws IOException {
        block24 : {
            block26 : {
                block23 : {
                    block27 : {
                        block25 : {
                            block21 : {
                                block22 : {
                                    var4_4 /* !! */  = null;
                                    var3_5 /* !! */  = null;
                                    if (var0 == null) {
                                        return null;
                                    }
                                    var2_8 /* !! */  = var4_4 /* !! */ ;
                                    var5_10 = PdfReader.getPdfObjectRelease(var0.get(PdfName.CONTENTS));
                                    var1_11 = 0;
                                    if (var5_10 == null) {
                                        var2_8 /* !! */  = var4_4 /* !! */ ;
                                        return new byte[0];
                                    }
                                    var2_8 /* !! */  = var4_4 /* !! */ ;
                                    if (!var5_10.isStream()) break block21;
                                    var2_8 /* !! */  = var4_4 /* !! */ ;
                                    var0 = ((PRStream)var5_10).getReader().getSafeFile();
                                    var0.reOpen();
                                    var2_8 /* !! */  = PdfReader.getStreamBytes((PRStream)var5_10, (RandomAccessFileOrArray)var0);
                                    if (var0 == null) break block22;
                                    var0.close();
                                }
                                return var2_8 /* !! */ ;
                                catch (Throwable var3_6) {
                                    var2_8 /* !! */  = var0;
                                    var0 = var3_6;
                                }
                                break block26;
                            }
                            var2_8 /* !! */  = var4_4 /* !! */ ;
                            if (!var5_10.isArray()) break block23;
                            var2_8 /* !! */  = var4_4 /* !! */ ;
                            var5_10 = (PdfArray)var5_10;
                            var2_8 /* !! */  = var4_4 /* !! */ ;
                            var6_12 = new ByteArrayOutputStream();
                            var0 = var3_5 /* !! */ ;
lbl37: // 2 sources:
                            var2_8 /* !! */  = var0;
                            if (var1_11 >= var5_10.size()) ** GOTO lbl70
                            var2_8 /* !! */  = var0;
                            var7_13 = PdfReader.getPdfObjectRelease(var5_10.getPdfObject(var1_11));
                            var4_4 /* !! */  = var0;
                            if (var7_13 == null) break block24;
                            var2_8 /* !! */  = var0;
                            if (!var7_13.isStream()) {
                                var4_4 /* !! */  = var0;
                                break block24;
                            }
                            var3_5 /* !! */  = var0;
                            if (var0 != null) break block25;
                            var2_8 /* !! */  = var0;
                            var0 = ((PRStream)var7_13).getReader().getSafeFile();
                            try {
                                var0.reOpen();
                                var3_5 /* !! */  = var0;
                            }
                            catch (Throwable var3_7) {
                                var2_8 /* !! */  = var0;
                                var0 = var3_7;
                                break block26;
                            }
                        }
                        var2_8 /* !! */  = var3_5 /* !! */ ;
                        var6_12.write(PdfReader.getStreamBytes((PRStream)var7_13, (RandomAccessFileOrArray)var3_5 /* !! */ ));
                        var2_8 /* !! */  = var3_5 /* !! */ ;
                        var4_4 /* !! */  = var3_5 /* !! */ ;
                        if (var1_11 != var5_10.size() - 1) {
                            var2_8 /* !! */  = var3_5 /* !! */ ;
                            var6_12.write(10);
                            var4_4 /* !! */  = var3_5 /* !! */ ;
                        }
                        break block24;
lbl70: // 1 sources:
                        var2_8 /* !! */  = var0;
                        var3_5 /* !! */  = var6_12.toByteArray();
                        if (var0 == null) break block27;
                        try {
                            var0.close();
                        }
                        catch (Exception var0_3) {
                            return var3_5 /* !! */ ;
                        }
                    }
                    return var3_5 /* !! */ ;
                }
                return new byte[0];
                catch (Throwable var0_1) {
                    // empty catch block
                }
            }
            if (var2_8 /* !! */  != null) {
                var2_8 /* !! */ .close();
            }
lbl85: // 4 sources:
            do {
                throw var0;
                break;
            } while (true);
            catch (Exception var0_2) {
                return var2_8 /* !! */ ;
            }
            catch (Exception var2_9) {
                ** continue;
            }
        }
        ++var1_11;
        var0 = var4_4 /* !! */ ;
        ** GOTO lbl37
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static PdfObject getPdfObject(PdfObject pdfObject) {
        if (pdfObject == null) {
            return null;
        }
        if (!pdfObject.isIndirect()) {
            return pdfObject;
        }
        try {
            PRIndirectReference pRIndirectReference = (PRIndirectReference)pdfObject;
            int n = pRIndirectReference.getNumber();
            boolean bl = pRIndirectReference.getReader().appendable;
            pdfObject = pRIndirectReference.getReader().getPdfObject(n);
            if (pdfObject == null) {
                return null;
            }
            PdfObject pdfObject2 = pdfObject;
            if (!bl) return pdfObject2;
            n = pdfObject.type();
            if (n != 1) {
                if (n != 4) {
                    if (n == 8) {
                        pdfObject = new PdfNull();
                    }
                } else {
                    pdfObject = new PdfName(pdfObject.getBytes());
                }
            } else {
                pdfObject = new PdfBoolean(((PdfBoolean)pdfObject).booleanValue());
            }
            pdfObject.setIndRef(pRIndirectReference);
            return pdfObject;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public static PdfObject getPdfObject(PdfObject pdfObject, PdfObject pdfObject2) {
        if (pdfObject == null) {
            return null;
        }
        if (!pdfObject.isIndirect()) {
            PdfObject pdfObject3 = pdfObject;
            if (pdfObject2 != null) {
                pdfObject2 = pdfObject2.getIndRef();
                pdfObject3 = pdfObject;
                if (pdfObject2 != null) {
                    pdfObject3 = pdfObject;
                    if (pdfObject2.getReader().isAppendable()) {
                        int n = pdfObject.type();
                        if (n != 1) {
                            if (n != 4) {
                                if (n == 8) {
                                    pdfObject = new PdfNull();
                                }
                            } else {
                                pdfObject = new PdfName(pdfObject.getBytes());
                            }
                        } else {
                            pdfObject = new PdfBoolean(((PdfBoolean)pdfObject).booleanValue());
                        }
                        pdfObject.setIndRef((PRIndirectReference)pdfObject2);
                        pdfObject3 = pdfObject;
                    }
                }
            }
            return pdfObject3;
        }
        return PdfReader.getPdfObject(pdfObject);
    }

    public static PdfObject getPdfObjectRelease(PdfObject pdfObject) {
        PdfObject pdfObject2 = PdfReader.getPdfObject(pdfObject);
        PdfReader.releaseLastXrefPartial(pdfObject);
        return pdfObject2;
    }

    public static PdfObject getPdfObjectRelease(PdfObject pdfObject, PdfObject pdfObject2) {
        pdfObject2 = PdfReader.getPdfObject(pdfObject, pdfObject2);
        PdfReader.releaseLastXrefPartial(pdfObject);
        return pdfObject2;
    }

    public static byte[] getStreamBytes(PRStream arrby) throws IOException {
        RandomAccessFileOrArray randomAccessFileOrArray = arrby.getReader().getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            arrby = PdfReader.getStreamBytes((PRStream)arrby, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public static byte[] getStreamBytes(PRStream pRStream, RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        return PdfReader.decodeBytes(PdfReader.getStreamBytesRaw(pRStream, randomAccessFileOrArray), pRStream);
    }

    public static byte[] getStreamBytesRaw(PRStream arrby) throws IOException {
        RandomAccessFileOrArray randomAccessFileOrArray = arrby.getReader().getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            arrby = PdfReader.getStreamBytesRaw((PRStream)arrby, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public static byte[] getStreamBytesRaw(PRStream pRStream, RandomAccessFileOrArray arrayList) throws IOException {
        Object object = pRStream.getReader();
        if (pRStream.getOffset() < 0L) {
            return pRStream.getBytes();
        }
        byte[] arrby = new byte[pRStream.getLength()];
        arrayList.seek(pRStream.getOffset());
        arrayList.readFully(arrby);
        PdfEncryption pdfEncryption = object.getDecrypt();
        if (pdfEncryption != null) {
            boolean bl;
            PdfObject pdfObject = PdfReader.getPdfObjectRelease(pRStream.get(PdfName.FILTER));
            object = new ArrayList();
            arrayList = object;
            if (pdfObject != null) {
                if (pdfObject.isName()) {
                    object.add(pdfObject);
                    arrayList = object;
                } else {
                    arrayList = object;
                    if (pdfObject.isArray()) {
                        arrayList = ((PdfArray)pdfObject).getArrayList();
                    }
                }
            }
            boolean bl2 = false;
            int n = 0;
            do {
                bl = bl2;
                if (n >= arrayList.size()) break;
                object = PdfReader.getPdfObjectRelease(arrayList.get(n));
                if (object != null && object.toString().equals("/Crypt")) {
                    bl = true;
                    break;
                }
                ++n;
            } while (true);
            if (!bl) {
                pdfEncryption.setHashKey(pRStream.getObjNum(), pRStream.getObjGen());
                return pdfEncryption.decryptByteArray(arrby);
            }
        }
        return arrby;
    }

    static String getSubsetPrefix(PdfDictionary object) {
        if (object == null) {
            return null;
        }
        if ((object = PdfReader.getFontName((PdfDictionary)object)) == null) {
            return null;
        }
        if (object.length() >= 8) {
            if (object.charAt(6) != '+') {
                return null;
            }
            for (int i = 0; i < 6; ++i) {
                char c = object.charAt(i);
                if (c >= 'A') {
                    if (c <= 'Z') continue;
                    return null;
                }
                return null;
            }
            return object;
        }
        return null;
    }

    private void iterateBookmarks(PdfObject pdfObject, HashMap<Object, PdfObject> hashMap) {
        while (pdfObject != null) {
            this.replaceNamedDestination(pdfObject, hashMap);
            pdfObject = (PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject);
            PdfObject pdfObject2 = pdfObject.get(PdfName.FIRST);
            if (pdfObject2 != null) {
                this.iterateBookmarks(pdfObject2, hashMap);
            }
            pdfObject = pdfObject.get(PdfName.NEXT);
        }
    }

    public static PdfObject killIndirect(PdfObject pdfObject) {
        if (pdfObject != null) {
            if (pdfObject.isNull()) {
                return null;
            }
            PdfObject pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject);
            if (pdfObject.isIndirect()) {
                pdfObject = (PRIndirectReference)pdfObject;
                PdfReader pdfReader = pdfObject.getReader();
                int n = pdfObject.getNumber();
                pdfReader.xrefObj.set(n, null);
                if (pdfReader.partial) {
                    pdfReader.xref[n * 2] = -1L;
                }
            }
            return pdfObject2;
        }
        return null;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void readDecryptedDocObj() throws IOException {
        block76 : {
            block77 : {
                block79 : {
                    block78 : {
                        block74 : {
                            block75 : {
                                if (this.encrypted) {
                                    return;
                                }
                                var12_1 = this.trailer.get(PdfName.ENCRYPT);
                                if (var12_1 == null) return;
                                if (var12_1.toString().equals("null")) {
                                    return;
                                }
                                this.encryptionError = true;
                                this.encrypted = true;
                                var13_2 = (PdfDictionary)PdfReader.getPdfObject(var12_1);
                                var7_3 = var13_2.getAsDict(PdfName.CF);
                                if (var7_3 != null && (var7_3 = var7_3.getAsDict(PdfName.STDCF)) != null && (var7_3 = var7_3.getAsName(PdfName.AUTHEVENT)) != null && var7_3.compareTo(PdfName.EFOPEN) == 0 && !this.ownerPasswordUsed) {
                                    return;
                                }
                                var9_8 = this.trailer.getAsArray(PdfName.ID);
                                if (var9_8 != null) {
                                    var7_3 = var9_8.getPdfObject(0);
                                    this.strings.remove(var7_3);
                                    var7_3 = var8_9 = DocWriter.getISOBytes(var7_3.toString());
                                    if (var9_8.size() > 1) {
                                        this.strings.remove(var9_8.getPdfObject(1));
                                        var7_3 = var8_9;
                                    }
                                } else {
                                    var7_3 = null;
                                }
                                var10_10 = var7_3;
                                if (var7_3 == null) {
                                    var10_10 = new byte[]{};
                                }
                                var14_11 = PdfReader.getPdfObjectRelease(var13_2.get(PdfName.FILTER));
                                var6_12 = var14_11.equals(PdfName.STANDARD);
                                var1_13 = 40;
                                var2_14 = 128;
                                if (!var6_12) break block75;
                                var7_3 = var13_2.get(PdfName.U).toString();
                                this.strings.remove(var13_2.get(PdfName.U));
                                var7_3 = DocWriter.getISOBytes((String)var7_3);
                                var8_9 = var13_2.get(PdfName.O).toString();
                                this.strings.remove(var13_2.get(PdfName.O));
                                var8_9 = DocWriter.getISOBytes((String)var8_9);
                                if (var13_2.contains(PdfName.OE)) {
                                    this.strings.remove(var13_2.get(PdfName.OE));
                                }
                                if (var13_2.contains(PdfName.UE)) {
                                    this.strings.remove(var13_2.get(PdfName.UE));
                                }
                                if (var13_2.contains(PdfName.PERMS)) {
                                    this.strings.remove(var13_2.get(PdfName.PERMS));
                                }
                                if (!(var9_8 = var13_2.get(PdfName.P)).isNumber()) {
                                    throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.p.value", new Object[0]));
                                }
                                this.pValue = ((PdfNumber)var9_8).longValue();
                                var9_8 = var13_2.get(PdfName.R);
                                if (!var9_8.isNumber()) {
                                    throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.r.value", new Object[0]));
                                }
                                this.rValue = ((PdfNumber)var9_8).intValue();
                                switch (this.rValue) {
                                    default: {
                                        throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("unknown.encryption.type.r.eq.1", this.rValue));
                                    }
                                    case 5: {
                                        var9_8 = var13_2.get(PdfName.ENCRYPTMETADATA);
                                        if (var9_8 != null && var9_8.toString().equals("false")) {
                                            var1_13 = 11;
                                            ** break;
                                        }
                                        var1_13 = 3;
                                        ** break;
                                    }
                                    case 4: {
                                        var9_8 = (PdfDictionary)var13_2.get(PdfName.CF);
                                        if (var9_8 == null) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("cf.not.found.encryption", new Object[0]));
                                        }
                                        if ((var9_8 = (PdfDictionary)var9_8.get(PdfName.STDCF)) == null) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("stdcf.not.found.encryption", new Object[0]));
                                        }
                                        if (PdfName.V2.equals(var9_8.get(PdfName.CFM))) {
                                            var1_13 = 1;
                                        } else {
                                            if (PdfName.AESV2.equals(var9_8.get(PdfName.CFM)) == false) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("no.compatible.encryption.found", new Object[0]));
                                            var1_13 = 2;
                                        }
                                        var9_8 = var13_2.get(PdfName.ENCRYPTMETADATA);
                                        if (var9_8 != null && var9_8.toString().equals("false")) {
                                            var1_13 |= 8;
                                            ** break;
                                        }
                                        var11_15 = null;
                                        var3_16 = 0;
                                        var9_8 = var8_9;
                                        var8_9 = var11_15;
                                        break block76;
                                    }
                                    case 3: {
                                        var9_8 = var13_2.get(PdfName.LENGTH);
                                        if (!var9_8.isNumber()) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        }
                                        var2_14 = ((PdfNumber)var9_8).intValue();
                                        if (var2_14 > 128) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        if (var2_14 < 40) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        if (var2_14 % 8 != 0) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        }
                                        var1_13 = 1;
                                        break;
                                    }
                                    case 2: {
                                        var1_13 = 0;
lbl93: // 4 sources:
                                        var2_14 = 0;
                                    }
                                }
                                var9_8 = var8_9;
                                var8_9 = null;
                                var3_16 = var2_14;
                                break block76;
                            }
                            if (var14_11.equals(PdfName.PUBSEC)) {
                                var7_3 = var13_2.get(PdfName.V);
                                if (!var7_3.isNumber()) {
                                    throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.v.value", new Object[0]));
                                }
                                var3_16 = ((PdfNumber)var7_3).intValue();
                                switch (var3_16) {
                                    default: {
                                        throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("unknown.encryption.type.v.eq.1", var3_16));
                                    }
                                    case 4: 
                                    case 5: {
                                        var7_3 = (PdfDictionary)var13_2.get(PdfName.CF);
                                        if (var7_3 == null) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("cf.not.found.encryption", new Object[0]));
                                        }
                                        if ((var7_3 = (PdfDictionary)var7_3.get(PdfName.DEFAULTCRYPTFILTER)) == null) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("defaultcryptfilter.not.found.encryption", new Object[0]));
                                        }
                                        if (PdfName.V2.equals(var7_3.get(PdfName.CFM))) {
                                            var1_13 = 1;
                                        } else if (PdfName.AESV2.equals(var7_3.get(PdfName.CFM))) {
                                            var1_13 = 2;
                                        } else {
                                            if (PdfName.AESV3.equals(var7_3.get(PdfName.CFM)) == false) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("no.compatible.encryption.found", new Object[0]));
                                            var2_14 = 256;
                                            var1_13 = 3;
                                        }
                                        var8_9 = var7_3.get(PdfName.ENCRYPTMETADATA);
                                        var3_16 = var1_13;
                                        if (var8_9 != null) {
                                            var3_16 = var1_13;
                                            if (var8_9.toString().equals("false")) {
                                                var3_16 = var1_13 | 8;
                                            }
                                        }
                                        var7_3 = (PdfArray)var7_3.get(PdfName.RECIPIENTS);
                                        var1_13 = var2_14;
                                        var2_14 = var3_16;
                                        ** break;
                                    }
                                    case 2: {
                                        var7_3 = var13_2.get(PdfName.LENGTH);
                                        if (!var7_3.isNumber()) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        }
                                        var1_13 = ((PdfNumber)var7_3).intValue();
                                        if (var1_13 > 128) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        if (var1_13 < 40) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        if (var1_13 % 8 != 0) {
                                            throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                        }
                                        var7_3 = (PdfArray)var13_2.get(PdfName.RECIPIENTS);
                                        var2_14 = 1;
                                        ** break;
                                    }
                                    case 1: 
                                }
                                var7_3 = (PdfArray)var13_2.get(PdfName.RECIPIENTS);
                                var2_14 = 0;
lbl147: // 3 sources:
                                try {
                                    var11_15 = new X509CertificateHolder(this.certificate.getEncoded());
                                    if (this.externalDecryptionProcess == null) {
                                        var3_16 = 0;
                                        var8_9 = null;
                                        break block74;
                                    }
                                    var4_17 = 0;
                                    var3_16 = 0;
                                    var8_9 = null;
                                }
                                catch (Exception var7_7) {
                                    throw new ExceptionConverter(var7_7);
                                }
                            }
                            var8_9 = null;
                            var2_14 = 0;
                            var1_13 = 0;
                            break block77;
                        }
                        for (var4_17 = 0; var4_17 < var7_3.size(); ++var4_17) {
                            var9_8 = var7_3.getPdfObject(var4_17);
                            this.strings.remove(var9_8);
                            try {
                                for (RecipientInformation var16_20 : new CMSEnvelopedData(var9_8.getBytes()).getRecipientInfos().getRecipients()) {
                                    var5_18 = var3_16;
                                    var9_8 = var8_9;
                                    if (var16_20.getRID().match((Object)var11_15)) {
                                        var5_18 = var3_16;
                                        var9_8 = var8_9;
                                        if (var3_16 == 0) {
                                            var9_8 = PdfEncryptor.getContent(var16_20, (PrivateKey)this.certificateKey, this.certificateKeyProvider);
                                            var5_18 = 1;
                                        }
                                    }
                                    var3_16 = var5_18;
                                    var8_9 = var9_8;
                                }
                                continue;
                            }
                            catch (Exception var7_4) {
                                throw new ExceptionConverter(var7_4);
                            }
                        }
                        var5_18 = var3_16;
                        var9_8 = var8_9;
                        break block78;
                        do {
                            var5_18 = var3_16;
                            var9_8 = var8_9;
                            if (var4_17 >= var7_3.size()) break;
                            var9_8 = var7_3.getPdfObject(var4_17);
                            this.strings.remove(var9_8);
                            try {
                                var9_8 = new CMSEnvelopedData(var9_8.getBytes()).getRecipientInfos().get(this.externalDecryptionProcess.getCmsRecipientId());
                                if (var9_8 != null) {
                                    var8_9 = var9_8.getContent(this.externalDecryptionProcess.getCmsRecipient());
                                    var3_16 = 1;
                                }
                                ++var4_17;
                            }
                            catch (Exception var7_5) {
                                throw new ExceptionConverter(var7_5);
                            }
                        } while (true);
                    }
                    if (var5_18 == 0) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("bad.certificate.and.key", new Object[0]));
                    if (var9_8 == null) {
                        throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("bad.certificate.and.key", new Object[0]));
                    }
                    if ((var2_14 & 7) != 3) ** GOTO lbl210
                    var8_9 = MessageDigest.getInstance("SHA-256");
                    break block79;
lbl210: // 1 sources:
                    var8_9 = MessageDigest.getInstance("SHA-1");
                }
                var8_9.update((byte[])var9_8, 0, 20);
                for (var3_16 = 0; var3_16 < var7_3.size(); ++var3_16) {
                    var8_9.update(var7_3.getPdfObject(var3_16).getBytes());
                }
                if ((var2_14 & 8) == 0) ** GOTO lbl219
                try {
                    var8_9.update(new byte[]{-1, -1, -1, -1});
lbl219: // 2 sources:
                    var8_9 = var8_9.digest();
                }
                catch (Exception var7_6) {
                    throw new ExceptionConverter(var7_6);
                }
            }
            var7_3 = null;
            var9_8 = null;
            var3_16 = var1_13;
            var1_13 = var2_14;
        }
        this.decrypt = new PdfEncryption();
        this.decrypt.setCryptoMode(var1_13, var3_16);
        if (var14_11.equals(PdfName.STANDARD)) {
            if (this.rValue == 5) {
                this.ownerPasswordUsed = this.decrypt.readKey(var13_2, this.password);
                this.decrypt.documentID = var10_10;
                this.pValue = this.decrypt.getPermissions();
            } else {
                this.decrypt.setupByOwnerPassword(var10_10, this.password, (byte[])var7_3, (byte[])var9_8, this.pValue);
                var8_9 = this.decrypt.userKey;
                var1_13 = this.rValue;
                var2_14 = 16;
                var1_13 = var1_13 != 3 && this.rValue != 4 ? 32 : 16;
                if (!this.equalsArray((byte[])var7_3, (byte[])var8_9, var1_13)) {
                    this.decrypt.setupByUserPassword(var10_10, this.password, (byte[])var9_8, this.pValue);
                    var8_9 = this.decrypt.userKey;
                    var1_13 = var2_14;
                    if (this.rValue != 3) {
                        var1_13 = this.rValue == 4 ? var2_14 : 32;
                    }
                    if (!this.equalsArray((byte[])var7_3, (byte[])var8_9, var1_13)) {
                        throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
                    }
                } else {
                    this.ownerPasswordUsed = true;
                }
            }
        } else if (var14_11.equals(PdfName.PUBSEC)) {
            if ((var1_13 & 7) == 3) {
                this.decrypt.setKey((byte[])var8_9);
            } else {
                this.decrypt.setupByEncryptionKey((byte[])var8_9, var3_16);
            }
            this.ownerPasswordUsed = true;
        }
        for (var1_13 = 0; var1_13 < this.strings.size(); ++var1_13) {
            this.strings.get(var1_13).decrypt(this);
        }
        if (var12_1.isIndirect()) {
            this.cryptoRef = (PRIndirectReference)var12_1;
            this.xrefObj.set(this.cryptoRef.getNumber(), null);
        }
        this.encryptionError = false;
        return;
    }

    public static void releaseLastXrefPartial(PdfObject pdfObject) {
        if (pdfObject == null) {
            return;
        }
        if (!pdfObject.isIndirect()) {
            return;
        }
        if (!(pdfObject instanceof PRIndirectReference)) {
            return;
        }
        pdfObject = (PRIndirectReference)pdfObject;
        PdfReader pdfReader = pdfObject.getReader();
        if (pdfReader.partial && pdfReader.lastXrefPartial != -1 && pdfReader.lastXrefPartial == pdfObject.getNumber()) {
            pdfReader.xrefObj.set(pdfReader.lastXrefPartial, null);
        }
        pdfReader.lastXrefPartial = -1;
    }

    private boolean replaceNamedDestination(PdfObject object, HashMap<Object, PdfObject> hashMap) {
        PdfObject pdfObject = PdfReader.getPdfObject((PdfObject)object);
        int n = this.lastXrefPartial;
        this.releaseLastXrefPartial();
        if (pdfObject != null && pdfObject.isDictionary()) {
            PdfObject pdfObject2 = (PdfDictionary)pdfObject;
            object = PdfReader.getPdfObjectRelease(pdfObject2.get(PdfName.DEST));
            Object var5_6 = null;
            if (object != null) {
                if (!object.isName()) {
                    object = object.isString() ? object.toString() : null;
                }
                if ((object = (PdfArray)hashMap.get(object)) != null) {
                    pdfObject2.put(PdfName.DEST, (PdfObject)object);
                    this.setXrefPartialObject(n, pdfObject);
                    return true;
                }
            } else {
                PdfObject pdfObject3 = PdfReader.getPdfObject(pdfObject2.get(PdfName.A));
                if (pdfObject3 != null) {
                    int n2 = this.lastXrefPartial;
                    this.releaseLastXrefPartial();
                    PdfDictionary pdfDictionary = (PdfDictionary)pdfObject3;
                    object = (PdfName)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.S));
                    if (PdfName.GOTO.equals(object)) {
                        pdfObject2 = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.D));
                        object = var5_6;
                        if (pdfObject2 != null) {
                            if (pdfObject2.isName()) {
                                object = pdfObject2;
                            } else {
                                object = var5_6;
                                if (pdfObject2.isString()) {
                                    object = pdfObject2.toString();
                                }
                            }
                        }
                        if ((object = (PdfArray)hashMap.get(object)) != null) {
                            pdfDictionary.put(PdfName.D, (PdfObject)object);
                            this.setXrefPartialObject(n2, pdfObject3);
                            this.setXrefPartialObject(n, pdfObject);
                            return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    private void setXrefPartialObject(int n, PdfObject pdfObject) {
        if (this.partial) {
            if (n < 0) {
                return;
            }
            this.xrefObj.set(n, pdfObject);
            return;
        }
    }

    public PRIndirectReference addPdfObject(PdfObject pdfObject) {
        this.xrefObj.add(pdfObject);
        return new PRIndirectReference(this, this.xrefObj.size() - 1);
    }

    @Override
    public void addViewerPreference(PdfName pdfName, PdfObject pdfObject) {
        this.viewerPreferences.addViewerPreference(pdfName, pdfObject);
        this.setViewerPreferences(this.viewerPreferences);
    }

    public void close() {
        try {
            this.tokens.close();
            return;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public byte[] computeUserPassword() {
        if (this.encrypted && this.ownerPasswordUsed) {
            return this.decrypt.computeUserPassword(this.password);
        }
        return null;
    }

    public void consolidateNamedDestinations() {
        PdfObject pdfObject;
        if (this.consolidateNamedDestinations) {
            return;
        }
        this.consolidateNamedDestinations = true;
        HashMap<Object, PdfObject> hashMap = this.getNamedDestination(true);
        if (hashMap.isEmpty()) {
            return;
        }
        for (int i = 1; i <= this.pageRefs.size(); ++i) {
            pdfObject = this.pageRefs.getPageN(i).get(PdfName.ANNOTS);
            PdfArray pdfArray = (PdfArray)PdfReader.getPdfObject(pdfObject);
            int n = this.lastXrefPartial;
            this.releaseLastXrefPartial();
            if (pdfArray == null) {
                this.pageRefs.releasePage(i);
                continue;
            }
            boolean bl = false;
            for (int j = 0; j < pdfArray.size(); ++j) {
                PdfObject pdfObject2 = pdfArray.getPdfObject(j);
                boolean bl2 = bl;
                if (this.replaceNamedDestination(pdfObject2, hashMap)) {
                    bl2 = bl;
                    if (!pdfObject2.isIndirect()) {
                        bl2 = true;
                    }
                }
                bl = bl2;
            }
            if (bl) {
                this.setXrefPartialObject(n, pdfArray);
            }
            if (bl && !pdfObject.isIndirect()) continue;
            this.pageRefs.releasePage(i);
        }
        pdfObject = (PdfDictionary)PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.OUTLINES));
        if (pdfObject == null) {
            return;
        }
        this.iterateBookmarks(pdfObject.get(PdfName.FIRST), hashMap);
    }

    public int createFakeFontSubsets() {
        int n = 0;
        for (int i = 1; i < this.xrefObj.size(); ++i) {
            int n2;
            block12 : {
                PdfObject pdfObject;
                block15 : {
                    block14 : {
                        block13 : {
                            pdfObject = this.getPdfObjectRelease(i);
                            n2 = n;
                            if (pdfObject == null) break block12;
                            if (pdfObject.isDictionary()) break block13;
                            n2 = n;
                            break block12;
                        }
                        if (PdfReader.existsName((PdfDictionary)(pdfObject = (PdfDictionary)pdfObject), PdfName.TYPE, PdfName.FONT)) break block14;
                        n2 = n;
                        break block12;
                    }
                    if (PdfReader.existsName((PdfDictionary)pdfObject, PdfName.SUBTYPE, PdfName.TYPE1) || PdfReader.existsName((PdfDictionary)pdfObject, PdfName.SUBTYPE, PdfName.MMTYPE1)) break block15;
                    n2 = n;
                    if (!PdfReader.existsName((PdfDictionary)pdfObject, PdfName.SUBTYPE, PdfName.TRUETYPE)) break block12;
                }
                if (PdfReader.getSubsetPrefix((PdfDictionary)pdfObject) != null) {
                    n2 = n;
                } else {
                    Object object = PdfReader.getFontName((PdfDictionary)pdfObject);
                    if (object == null) {
                        n2 = n;
                    } else {
                        Serializable serializable = new StringBuilder();
                        serializable.append(BaseFont.createSubsetPrefix());
                        serializable.append((String)object);
                        object = serializable.toString();
                        serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.FONTDESCRIPTOR));
                        if (serializable == null) {
                            n2 = n;
                        } else if (serializable.get(PdfName.FONTFILE) == null && serializable.get(PdfName.FONTFILE2) == null && serializable.get(PdfName.FONTFILE3) == null) {
                            n2 = n;
                        } else {
                            serializable = pdfObject.getAsDict(PdfName.FONTDESCRIPTOR);
                            object = new PdfName((String)object);
                            pdfObject.put(PdfName.BASEFONT, (PdfObject)object);
                            serializable.put(PdfName.FONTNAME, (PdfObject)object);
                            this.setXrefPartialObject(i, pdfObject);
                            n2 = n + 1;
                        }
                    }
                }
            }
            n = n2;
        }
        return n;
    }

    public double dumpPerc() {
        int n = 0;
        for (int i = 0; i < this.xrefObj.size(); ++i) {
            int n2 = n;
            if (this.xrefObj.get(i) != null) {
                n2 = n + 1;
            }
            n = n2;
        }
        return (double)n * 100.0 / (double)this.xrefObj.size();
    }

    public void eliminateSharedStreams() {
        int n;
        if (!this.sharedStreams) {
            return;
        }
        this.sharedStreams = false;
        if (this.pageRefs.size() == 1) {
            return;
        }
        ArrayList<PdfObject> arrayList = new ArrayList<PdfObject>();
        ArrayList<PRStream> arrayList2 = new ArrayList<PRStream>();
        IntHashtable intHashtable = new IntHashtable();
        for (n = 1; n <= this.pageRefs.size(); ++n) {
            PdfObject pdfObject;
            PdfObject pdfObject2 = this.pageRefs.getPageN(n);
            if (pdfObject2 == null || (pdfObject = PdfReader.getPdfObject(pdfObject2.get(PdfName.CONTENTS))) == null) continue;
            if (pdfObject.isStream()) {
                if (intHashtable.containsKey((pdfObject2 = (PRIndirectReference)pdfObject2.get(PdfName.CONTENTS)).getNumber())) {
                    arrayList.add(pdfObject2);
                    arrayList2.add(new PRStream((PRStream)pdfObject, null));
                    continue;
                }
                intHashtable.put(pdfObject2.getNumber(), 1);
                continue;
            }
            if (!pdfObject.isArray()) continue;
            pdfObject = (PdfArray)pdfObject;
            for (int i = 0; i < pdfObject.size(); ++i) {
                pdfObject2 = (PRIndirectReference)pdfObject.getPdfObject(i);
                if (intHashtable.containsKey(pdfObject2.getNumber())) {
                    arrayList.add(pdfObject2);
                    arrayList2.add(new PRStream((PRStream)PdfReader.getPdfObject(pdfObject2), null));
                    continue;
                }
                intHashtable.put(pdfObject2.getNumber(), 1);
            }
        }
        if (arrayList2.isEmpty()) {
            return;
        }
        for (n = 0; n < arrayList2.size(); ++n) {
            this.xrefObj.add((PdfObject)arrayList2.get(n));
            ((PRIndirectReference)arrayList.get(n)).setNumber(this.xrefObj.size() - 1, 0);
        }
    }

    public AcroFields getAcroFields() {
        return new AcroFields(this, null);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public PRAcroForm getAcroForm() {
        if (this.acroFormParsed) return this.acroForm;
        this.acroFormParsed = true;
        PdfObject pdfObject = this.catalog.get(PdfName.ACROFORM);
        if (pdfObject == null) return this.acroForm;
        try {
            this.acroForm = new PRAcroForm(this);
            this.acroForm.readAcroForm((PdfDictionary)PdfReader.getPdfObject(pdfObject));
            return this.acroForm;
        }
        catch (Exception exception) {}
        this.acroForm = null;
        return this.acroForm;
    }

    public Rectangle getBoxSize(int n, String object) {
        PdfDictionary pdfDictionary = this.pageRefs.getPageNRelease(n);
        object = object.equals("trim") ? (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.TRIMBOX)) : (object.equals("art") ? (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.ARTBOX)) : (object.equals("bleed") ? (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.BLEEDBOX)) : (object.equals("crop") ? (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.CROPBOX)) : (object.equals("media") ? (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.MEDIABOX)) : null))));
        if (object == null) {
            return null;
        }
        return PdfReader.getNormalizedRectangle((PdfArray)object);
    }

    public PdfDictionary getCatalog() {
        return this.catalog;
    }

    public int getCertificationLevel() {
        PdfObject pdfObject = this.catalog.getAsDict(PdfName.PERMS);
        if (pdfObject == null) {
            return 0;
        }
        if ((pdfObject = pdfObject.getAsDict(PdfName.DOCMDP)) == null) {
            return 0;
        }
        if ((pdfObject = pdfObject.getAsArray(PdfName.REFERENCE)) != null) {
            if (pdfObject.size() == 0) {
                return 0;
            }
            if ((pdfObject = pdfObject.getAsDict(0)) == null) {
                return 0;
            }
            if ((pdfObject = pdfObject.getAsDict(PdfName.TRANSFORMPARAMS)) == null) {
                return 0;
            }
            if ((pdfObject = pdfObject.getAsNumber(PdfName.P)) == null) {
                return 0;
            }
            return pdfObject.intValue();
        }
        return 0;
    }

    protected Counter getCounter() {
        return COUNTER;
    }

    public Rectangle getCropBox(int n) {
        PdfDictionary pdfDictionary = this.pageRefs.getPageNRelease(n);
        PdfArray pdfArray = (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.CROPBOX));
        if (pdfArray == null) {
            return this.getPageSize(pdfDictionary);
        }
        return PdfReader.getNormalizedRectangle(pdfArray);
    }

    public int getCryptoMode() {
        if (this.decrypt == null) {
            return -1;
        }
        return this.decrypt.getCryptoMode();
    }

    PdfIndirectReference getCryptoRef() {
        if (this.cryptoRef == null) {
            return null;
        }
        return new PdfIndirectReference(0, this.cryptoRef.getNumber(), this.cryptoRef.getGeneration());
    }

    PdfEncryption getDecrypt() {
        return this.decrypt;
    }

    public long getEofPos() {
        return this.eofPos;
    }

    public long getFileLength() {
        return this.fileLength;
    }

    public HashMap<String, String> getInfo() {
        HashMap<String, String> hashMap = new HashMap<String, String>();
        PdfDictionary pdfDictionary = this.trailer.getAsDict(PdfName.INFO);
        if (pdfDictionary == null) {
            return hashMap;
        }
        for (PdfName pdfName : pdfDictionary.getKeys()) {
            PdfObject pdfObject = PdfReader.getPdfObject(pdfDictionary.get(pdfName));
            if (pdfObject == null) continue;
            String string2 = pdfObject.toString();
            switch (pdfObject.type()) {
                default: {
                    break;
                }
                case 4: {
                    string2 = PdfName.decodeName(string2);
                    break;
                }
                case 3: {
                    string2 = ((PdfString)pdfObject).toUnicodeString();
                }
            }
            hashMap.put(PdfName.decodeName(pdfName.toString()), string2);
        }
        return hashMap;
    }

    public String getJavaScript() throws IOException {
        RandomAccessFileOrArray randomAccessFileOrArray = this.getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            String string2 = this.getJavaScript(randomAccessFileOrArray);
            return string2;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public String getJavaScript(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        Serializable serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.NAMES));
        if (serializable == null) {
            return null;
        }
        if ((serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(serializable.get(PdfName.JAVASCRIPT))) == null) {
            return null;
        }
        serializable = PdfNameTree.readTree((PdfDictionary)serializable);
        Object[] arrobject = new String[serializable.size()];
        arrobject = serializable.keySet().toArray(arrobject);
        Arrays.sort(arrobject);
        StringBuffer stringBuffer = new StringBuffer();
        for (int i = 0; i < arrobject.length; ++i) {
            PdfObject pdfObject = (PdfDictionary)PdfReader.getPdfObjectRelease((PdfObject)serializable.get(arrobject[i]));
            if (pdfObject == null || (pdfObject = PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.JS))) == null) continue;
            if (pdfObject.isString()) {
                stringBuffer.append(((PdfString)pdfObject).toUnicodeString());
                stringBuffer.append('\n');
                continue;
            }
            if (!pdfObject.isStream()) continue;
            if (((PdfObject)(pdfObject = PdfReader.getStreamBytes((PRStream)pdfObject, randomAccessFileOrArray))).length >= 2 && pdfObject[0] == -2 && pdfObject[1] == -1) {
                stringBuffer.append(PdfEncodings.convertToString((byte[])pdfObject, "UnicodeBig"));
            } else {
                stringBuffer.append(PdfEncodings.convertToString((byte[])pdfObject, "PDF"));
            }
            stringBuffer.append('\n');
        }
        return stringBuffer.toString();
    }

    public long getLastXref() {
        return this.lastXref;
    }

    public ArrayList<PdfAnnotation.PdfImportedLink> getLinks(int n) {
        this.pageRefs.resetReleasePage();
        ArrayList<PdfAnnotation.PdfImportedLink> arrayList = new ArrayList<PdfAnnotation.PdfImportedLink>();
        PdfObject pdfObject = this.pageRefs.getPageN(n);
        if (pdfObject.get(PdfName.ANNOTS) != null) {
            pdfObject = pdfObject.getAsArray(PdfName.ANNOTS);
            for (int i = 0; i < pdfObject.size(); ++i) {
                PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject.getPdfObject(i));
                if (!PdfName.LINK.equals(pdfDictionary.get(PdfName.SUBTYPE))) continue;
                arrayList.add(new PdfAnnotation.PdfImportedLink(pdfDictionary));
            }
        }
        this.pageRefs.releasePage(n);
        this.pageRefs.resetReleasePage();
        return arrayList;
    }

    public byte[] getMetadata() throws IOException {
        byte[] arrby = PdfReader.getPdfObject(this.catalog.get(PdfName.METADATA));
        if (!(arrby instanceof PRStream)) {
            return null;
        }
        RandomAccessFileOrArray randomAccessFileOrArray = this.getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            arrby = PdfReader.getStreamBytes((PRStream)arrby, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public HashMap<Object, PdfObject> getNamedDestination() {
        return this.getNamedDestination(false);
    }

    public HashMap<Object, PdfObject> getNamedDestination(boolean bl) {
        HashMap<Object, PdfObject> hashMap = this.getNamedDestinationFromNames(bl);
        hashMap.putAll(this.getNamedDestinationFromStrings());
        return hashMap;
    }

    public HashMap<String, PdfObject> getNamedDestinationFromNames() {
        return new HashMap<Object, PdfObject>(this.getNamedDestinationFromNames(false));
    }

    public HashMap<Object, PdfObject> getNamedDestinationFromNames(boolean bl) {
        HashMap<Object, PdfObject> hashMap = new HashMap<Object, PdfObject>();
        if (this.catalog.get(PdfName.DESTS) != null) {
            PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.DESTS));
            if (pdfDictionary == null) {
                return hashMap;
            }
            for (PdfName pdfName : pdfDictionary.getKeys()) {
                PdfArray pdfArray = PdfReader.getNameArray(pdfDictionary.get(pdfName));
                if (pdfArray == null) continue;
                if (bl) {
                    hashMap.put(pdfName, pdfArray);
                    continue;
                }
                hashMap.put(PdfName.decodeName(pdfName.toString()), pdfArray);
            }
        }
        return hashMap;
    }

    public HashMap<String, PdfObject> getNamedDestinationFromStrings() {
        Serializable serializable;
        if (this.catalog.get(PdfName.NAMES) != null && (serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.NAMES))) != null && (serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(serializable.get(PdfName.DESTS))) != null) {
            serializable = PdfNameTree.readTree((PdfDictionary)serializable);
            Iterator iterator = serializable.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry entry = iterator.next();
                PdfArray pdfArray = PdfReader.getNameArray((PdfObject)entry.getValue());
                if (pdfArray != null) {
                    entry.setValue(pdfArray);
                    continue;
                }
                iterator.remove();
            }
            return serializable;
        }
        return new HashMap<String, PdfObject>();
    }

    public int getNumberOfPages() {
        return this.pageRefs.size();
    }

    public byte[] getPageContent(int n) throws IOException {
        RandomAccessFileOrArray randomAccessFileOrArray = this.getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            byte[] arrby = this.getPageContent(n, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public byte[] getPageContent(int n, RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        PdfObject pdfObject = this.getPageNRelease(n);
        if (pdfObject == null) {
            return null;
        }
        pdfObject = PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.CONTENTS));
        if (pdfObject == null) {
            return new byte[0];
        }
        if (pdfObject.isStream()) {
            return PdfReader.getStreamBytes((PRStream)pdfObject, randomAccessFileOrArray);
        }
        if (pdfObject.isArray()) {
            pdfObject = (PdfArray)pdfObject;
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            for (n = 0; n < pdfObject.size(); ++n) {
                PdfObject pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject.getPdfObject(n));
                if (pdfObject2 == null || !pdfObject2.isStream()) continue;
                byteArrayOutputStream.write(PdfReader.getStreamBytes((PRStream)pdfObject2, randomAccessFileOrArray));
                if (n == pdfObject.size() - 1) continue;
                byteArrayOutputStream.write(10);
            }
            return byteArrayOutputStream.toByteArray();
        }
        return new byte[0];
    }

    public PdfDictionary getPageN(int n) {
        PdfDictionary pdfDictionary = this.pageRefs.getPageN(n);
        if (pdfDictionary == null) {
            return null;
        }
        if (this.appendable) {
            pdfDictionary.setIndRef(this.pageRefs.getPageOrigRef(n));
        }
        return pdfDictionary;
    }

    public PdfDictionary getPageNRelease(int n) {
        PdfDictionary pdfDictionary = this.getPageN(n);
        this.pageRefs.releasePage(n);
        return pdfDictionary;
    }

    public PRIndirectReference getPageOrigRef(int n) {
        return this.pageRefs.getPageOrigRef(n);
    }

    public PdfDictionary getPageResources(int n) {
        return this.getPageResources(this.getPageN(n));
    }

    public PdfDictionary getPageResources(PdfDictionary pdfDictionary) {
        return pdfDictionary.getAsDict(PdfName.RESOURCES);
    }

    public int getPageRotation(int n) {
        return this.getPageRotation(this.pageRefs.getPageNRelease(n));
    }

    int getPageRotation(PdfDictionary pdfObject) {
        int n;
        if ((pdfObject = pdfObject.getAsNumber(PdfName.ROTATE)) == null) {
            return 0;
        }
        int n2 = n = pdfObject.intValue() % 360;
        if (n < 0) {
            n2 = n + 360;
        }
        return n2;
    }

    public Rectangle getPageSize(int n) {
        return this.getPageSize(this.pageRefs.getPageNRelease(n));
    }

    public Rectangle getPageSize(PdfDictionary pdfDictionary) {
        return PdfReader.getNormalizedRectangle(pdfDictionary.getAsArray(PdfName.MEDIABOX));
    }

    public Rectangle getPageSizeWithRotation(int n) {
        return this.getPageSizeWithRotation(this.pageRefs.getPageNRelease(n));
    }

    public Rectangle getPageSizeWithRotation(PdfDictionary object) {
        Rectangle rectangle = this.getPageSize((PdfDictionary)object);
        int n = this.getPageRotation((PdfDictionary)object);
        object = rectangle;
        while (n > 0) {
            object = object.rotate();
            n -= 90;
        }
        return object;
    }

    public PdfObject getPdfObject(int n) {
        block7 : {
            PdfObject pdfObject;
            block9 : {
                block12 : {
                    block11 : {
                        block10 : {
                            block8 : {
                                try {
                                    this.lastXrefPartial = -1;
                                    if (n < 0) break block7;
                                }
                                catch (Exception exception) {
                                    throw new ExceptionConverter(exception);
                                }
                                if (n < this.xrefObj.size()) break block8;
                                return null;
                            }
                            pdfObject = this.xrefObj.get(n);
                            if (!this.partial) break block9;
                            if (pdfObject == null) break block10;
                            return pdfObject;
                        }
                        if (n * 2 < this.xref.length) break block11;
                        return null;
                    }
                    pdfObject = this.readSingleObject(n);
                    this.lastXrefPartial = -1;
                    if (pdfObject == null) break block12;
                    this.lastXrefPartial = n;
                }
                return pdfObject;
            }
            return pdfObject;
        }
        return null;
    }

    public PdfObject getPdfObjectRelease(int n) {
        PdfObject pdfObject = this.getPdfObject(n);
        this.releaseLastXrefPartial();
        return pdfObject;
    }

    protected PdfReaderInstance getPdfReaderInstance(PdfWriter pdfWriter) {
        return new PdfReaderInstance(this, pdfWriter);
    }

    public char getPdfVersion() {
        return this.pdfVersion;
    }

    public long getPermissions() {
        return this.pValue;
    }

    public RandomAccessFileOrArray getSafeFile() {
        return this.tokens.getSafeFile();
    }

    public int getSimpleViewerPreferences() {
        return PdfViewerPreferencesImp.getViewerPreferences(this.catalog).getPageLayoutAndMode();
    }

    public PdfDictionary getTrailer() {
        return this.trailer;
    }

    public int getXrefSize() {
        return this.xrefObj.size();
    }

    public boolean hasUsageRights() {
        PdfDictionary pdfDictionary = this.catalog.getAsDict(PdfName.PERMS);
        boolean bl = false;
        if (pdfDictionary == null) {
            return false;
        }
        if (pdfDictionary.contains(PdfName.UR) || pdfDictionary.contains(PdfName.UR3)) {
            bl = true;
        }
        return bl;
    }

    public boolean is128Key() {
        if (this.rValue == 3) {
            return true;
        }
        return false;
    }

    public boolean isAppendable() {
        return this.appendable;
    }

    public boolean isEncrypted() {
        return this.encrypted;
    }

    public boolean isHybridXref() {
        return this.hybridXref;
    }

    public boolean isMetadataEncrypted() {
        if (this.decrypt == null) {
            return false;
        }
        return this.decrypt.isMetadataEncrypted();
    }

    public boolean isNewXrefType() {
        return this.newXrefType;
    }

    public final boolean isOpenedWithFullPermissions() {
        if (this.encrypted && !this.ownerPasswordUsed && !unethicalreading) {
            return false;
        }
        return true;
    }

    public boolean isRebuilt() {
        return this.rebuilt;
    }

    public boolean isTagged() {
        PdfDictionary pdfDictionary = this.catalog.getAsDict(PdfName.MARKINFO);
        boolean bl = false;
        if (pdfDictionary == null) {
            return false;
        }
        if (PdfBoolean.PDFTRUE.equals(pdfDictionary.getAsBoolean(PdfName.MARKED))) {
            if (this.catalog.getAsDict(PdfName.STRUCTTREEROOT) != null) {
                bl = true;
            }
            return bl;
        }
        return false;
    }

    public boolean isTampered() {
        return this.tampered;
    }

    protected void killXref(PdfObject pdfObject) {
        block9 : {
            int n;
            block8 : {
                if (pdfObject == null) {
                    return;
                }
                if (pdfObject instanceof PdfIndirectReference && !pdfObject.isIndirect()) {
                    return;
                }
                n = pdfObject.type();
                if (n == 10) break block8;
                block0 : switch (n) {
                    default: {
                        return;
                    }
                    case 6: 
                    case 7: {
                        pdfObject = (PdfDictionary)pdfObject;
                        Iterator<PdfName> iterator = pdfObject.getKeys().iterator();
                        while (iterator.hasNext()) {
                            this.killXref(pdfObject.get(iterator.next()));
                        }
                        break block9;
                    }
                    case 5: {
                        pdfObject = (PdfArray)pdfObject;
                        n = 0;
                        while (n < pdfObject.size()) {
                            this.killXref(pdfObject.getPdfObject(n));
                            ++n;
                            break block0;
                        }
                        break block9;
                    }
                }
                {
                    continue;
                    break;
                }
            }
            n = ((PRIndirectReference)pdfObject).getNumber();
            pdfObject = this.xrefObj.get(n);
            this.xrefObj.set(n, null);
            this.freeXref = n;
            this.killXref(pdfObject);
        }
    }

    public void makeRemoteNamedDestinationsLocal() {
        if (this.remoteToLocalNamedDestinations) {
            return;
        }
        this.remoteToLocalNamedDestinations = true;
        HashMap<Object, PdfObject> hashMap = this.getNamedDestination(true);
        if (hashMap.isEmpty()) {
            return;
        }
        for (int i = 1; i <= this.pageRefs.size(); ++i) {
            PdfObject pdfObject = this.pageRefs.getPageN(i).get(PdfName.ANNOTS);
            PdfArray pdfArray = (PdfArray)PdfReader.getPdfObject(pdfObject);
            int n = this.lastXrefPartial;
            this.releaseLastXrefPartial();
            if (pdfArray == null) {
                this.pageRefs.releasePage(i);
                continue;
            }
            boolean bl = false;
            for (int j = 0; j < pdfArray.size(); ++j) {
                PdfObject pdfObject2 = pdfArray.getPdfObject(j);
                boolean bl2 = bl;
                if (this.convertNamedDestination(pdfObject2, hashMap)) {
                    bl2 = bl;
                    if (!pdfObject2.isIndirect()) {
                        bl2 = true;
                    }
                }
                bl = bl2;
            }
            if (bl) {
                this.setXrefPartialObject(n, pdfArray);
            }
            if (bl && !pdfObject.isIndirect()) continue;
            this.pageRefs.releasePage(i);
        }
    }

    protected PdfArray readArray() throws IOException {
        PdfArray pdfArray = new PdfArray();
        PdfObject pdfObject;
        int n;
        while ((n = - (pdfObject = this.readPRObject()).type()) != PRTokeniser.TokenType.END_ARRAY.ordinal()) {
            if (n == PRTokeniser.TokenType.END_DIC.ordinal()) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("unexpected.gt.gt", new Object[0]));
            }
            pdfArray.add(pdfObject);
        }
        return pdfArray;
    }

    protected PdfDictionary readDictionary() throws IOException {
        PdfDictionary pdfDictionary = new PdfDictionary();
        do {
            this.tokens.nextValidToken();
            if (this.tokens.getTokenType() == PRTokeniser.TokenType.END_DIC) {
                return pdfDictionary;
            }
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NAME) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("dictionary.key.1.is.not.a.name", this.tokens.getStringValue()));
            }
            PdfName pdfName = new PdfName(this.tokens.getStringValue(), false);
            PdfObject pdfObject = this.readPRObject();
            int n = - pdfObject.type();
            if (n == PRTokeniser.TokenType.END_DIC.ordinal()) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("unexpected.gt.gt", new Object[0]));
            }
            if (n == PRTokeniser.TokenType.END_ARRAY.ordinal()) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("unexpected.close.bracket", new Object[0]));
            }
            pdfDictionary.put(pdfName, pdfObject);
        } while (true);
    }

    protected void readDocObj() throws IOException {
        ArrayList<PRStream> arrayList = new ArrayList<PRStream>();
        int n = this.xref.length;
        int n2 = 2;
        this.xrefObj = new ArrayList(n / 2);
        this.xrefObj.addAll(Collections.nCopies(this.xref.length / 2, null));
        do {
            block14 : {
                int n3 = this.xref.length;
                if (n2 >= n3) break;
                long l = this.xref[n2];
                if (l > 0L && this.xref[n2 + 1] <= 0L) {
                    IOException iOException22;
                    block13 : {
                        this.tokens.seek(l);
                        this.tokens.nextValidToken();
                        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                            this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.object.number", new Object[0]));
                        }
                        this.objNum = this.tokens.intValue();
                        this.tokens.nextValidToken();
                        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                            this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.generation.number", new Object[0]));
                        }
                        this.objGen = this.tokens.intValue();
                        this.tokens.nextValidToken();
                        if (!this.tokens.getStringValue().equals("obj")) {
                            this.tokens.throwError(MessageLocalization.getComposedMessage("token.obj.expected", new Object[0]));
                        }
                        PdfObject object = this.readPRObject();
                        Object object2 = object;
                        try {
                            if (object.isStream()) {
                                arrayList.add((PRStream)object);
                                object2 = object;
                            }
                        }
                        catch (IOException iOException22) {
                            if (!debugmode) break block13;
                            if (LOGGER.isLogging(Level.ERROR)) {
                                LOGGER.error(iOException22.getMessage(), iOException22);
                            }
                            object2 = null;
                        }
                        this.xrefObj.set(n2 / 2, (PdfObject)object2);
                        break block14;
                    }
                    throw iOException22;
                }
            }
            n2 += 2;
        } while (true);
        for (n = 0; n < arrayList.size(); ++n) {
            this.checkPRStreamLength((PRStream)arrayList.get(n));
        }
        this.readDecryptedDocObj();
        if (this.objStmMark != null) {
            for (Map.Entry<Integer, IntHashtable> entry : this.objStmMark.entrySet()) {
                n2 = entry.getKey();
                IntHashtable intHashtable = entry.getValue();
                this.readObjStm((PRStream)this.xrefObj.get(n2), intHashtable);
                this.xrefObj.set(n2, null);
            }
            this.objStmMark = null;
        }
        this.xref = null;
    }

    protected void readDocObjPartial() throws IOException {
        this.xrefObj = new ArrayList(this.xref.length / 2);
        this.xrefObj.addAll(Collections.nCopies(this.xref.length / 2, null));
        this.readDecryptedDocObj();
        if (this.objStmToOffset != null) {
            long[] arrl = this.objStmToOffset.getKeys();
            for (int i = 0; i < arrl.length; ++i) {
                long l = arrl[i];
                LongHashtable longHashtable = this.objStmToOffset;
                long[] arrl2 = this.xref;
                int n = (int)(2L * l);
                longHashtable.put(l, arrl2[n]);
                this.xref[n] = -1L;
            }
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected void readObjStm(PRStream var1_1, IntHashtable var2_3) throws IOException {
        block11 : {
            if (var1_1 == null) {
                return;
            }
            var6_4 = var1_1.getAsNumber(PdfName.FIRST).intValue();
            var5_5 = var1_1.getAsNumber(PdfName.N).intValue();
            var1_1 = PdfReader.getStreamBytes((PRStream)var1_1, this.tokens.getFile());
            var8_6 = this.tokens;
            this.tokens = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource((byte[])var1_1)));
            try {
                var9_7 = new int[var5_5];
                var10_8 = new int[var5_5];
                var4_9 = 0;
                var7_11 = true;
                for (var3_10 = 0; var3_10 < var5_5 && (var7_11 = this.tokens.nextToken()); ++var3_10) {
                    if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                        var10_8[var3_10] = this.tokens.intValue();
                        var7_11 = this.tokens.nextToken();
                        if (!var7_11) break;
                        if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                            var9_7[var3_10] = this.tokens.intValue() + var6_4;
                            continue;
                        }
                    }
                    var7_11 = false;
                }
            }
            catch (Throwable var1_2) {
                this.tokens = var8_6;
                throw var1_2;
            }
lbl23: // 3 sources:
            if (!var7_11) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("error.reading.objstm", new Object[0]));
            }
            break block11;
            ** GOTO lbl23
        }
        for (var3_10 = var4_9; var3_10 < var5_5; ++var3_10) {
            if (!var2_3.containsKey(var3_10)) continue;
            this.tokens.seek(var9_7[var3_10]);
            this.tokens.nextToken();
            if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                var1_1 = new PdfNumber(this.tokens.getStringValue());
            } else {
                this.tokens.seek(var9_7[var3_10]);
                var1_1 = this.readPRObject();
            }
            this.xrefObj.set(var10_8[var3_10], (PdfObject)var1_1);
        }
        this.tokens = var8_6;
    }

    /*
     * Exception decompiling
     */
    protected PdfObject readOneObjStm(PRStream var1_1, int var2_3) throws IOException {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [3[FORLOOP]], but top level block is 1[TRYBLOCK]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    protected PdfObject readPRObject() throws IOException {
        Object object;
        String string2;
        block21 : {
            this.tokens.nextValidToken();
            object = this.tokens.getTokenType();
            switch (.$SwitchMap$com$itextpdf$text$pdf$PRTokeniser$TokenType[object.ordinal()]) {
                default: {
                    string2 = this.tokens.getStringValue();
                    if ("null".equals(string2)) {
                        if (this.readDepth != 0) break;
                        return new PdfNull();
                    }
                    break block21;
                }
                case 7: {
                    throw new IOException(MessageLocalization.getComposedMessage("unexpected.end.of.file", new Object[0]));
                }
                case 6: {
                    return new PRIndirectReference(this, this.tokens.getReference(), this.tokens.getGeneration());
                }
                case 5: {
                    object = PdfName.staticNames.get(this.tokens.getStringValue());
                    if (this.readDepth > 0 && object != null) {
                        return object;
                    }
                    return new PdfName(this.tokens.getStringValue(), false);
                }
                case 4: {
                    object = new PdfString(this.tokens.getStringValue(), null).setHexWriting(this.tokens.isHexString());
                    object.setObjNum(this.objNum, this.objGen);
                    if (this.strings != null) {
                        this.strings.add((PdfString)object);
                    }
                    return object;
                }
                case 3: {
                    return new PdfNumber(this.tokens.getStringValue());
                }
                case 2: {
                    ++this.readDepth;
                    object = this.readArray();
                    --this.readDepth;
                    return object;
                }
                case 1: {
                    boolean bl;
                    ++this.readDepth;
                    object = this.readDictionary();
                    --this.readDepth;
                    long l = this.tokens.getFilePointer();
                    while ((bl = this.tokens.nextToken()) && this.tokens.getTokenType() == PRTokeniser.TokenType.COMMENT) {
                    }
                    if (bl && this.tokens.getStringValue().equals("stream")) {
                        int n;
                        while ((n = this.tokens.read()) == 32 || n == 9 || n == 0 || n == 12) {
                        }
                        int n2 = n;
                        if (n != 10) {
                            n2 = this.tokens.read();
                        }
                        if (n2 != 10) {
                            this.tokens.backOnePosition(n2);
                        }
                        PRStream pRStream = new PRStream(this, this.tokens.getFilePointer());
                        pRStream.putAll((PdfDictionary)object);
                        pRStream.setObjNum(this.objNum, this.objGen);
                        return pRStream;
                    }
                    this.tokens.seek(l);
                    return object;
                }
            }
            return PdfNull.PDFNULL;
        }
        if ("true".equals(string2)) {
            if (this.readDepth == 0) {
                return new PdfBoolean(true);
            }
            return PdfBoolean.PDFTRUE;
        }
        if ("false".equals(string2)) {
            if (this.readDepth == 0) {
                return new PdfBoolean(false);
            }
            return PdfBoolean.PDFFALSE;
        }
        return new PdfLiteral(- object.ordinal(), this.tokens.getStringValue());
    }

    protected void readPages() throws IOException {
        block6 : {
            block5 : {
                this.catalog = this.trailer.getAsDict(PdfName.ROOT);
                if (this.catalog == null) {
                    throw new InvalidPdfException(MessageLocalization.getComposedMessage("the.document.has.no.catalog.object", new Object[0]));
                }
                this.rootPages = this.catalog.getAsDict(PdfName.PAGES);
                if (this.rootPages != null && (PdfName.PAGES.equals(this.rootPages.get(PdfName.TYPE)) || PdfName.PAGES.equals(this.rootPages.get(new PdfName("Types"))))) break block5;
                if (!debugmode) break block6;
                if (LOGGER.isLogging(Level.ERROR)) {
                    LOGGER.error(MessageLocalization.getComposedMessage("the.document.has.no.page.root", new Object[0]));
                }
            }
            this.pageRefs = new PageRefs(this);
            return;
        }
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("the.document.has.no.page.root", new Object[0]));
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void readPdf() throws IOException {
        this.fileLength = this.tokens.getFile().length();
        this.pdfVersion = this.tokens.checkPdfHeader();
        try {
            this.readXref();
        }
        catch (Exception exception222) {
            try {
                this.rebuilt = true;
                this.rebuildXref();
                this.lastXref = -1L;
            }
            catch (Exception exception5) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("rebuild.failed.1.original.message.2", exception5.getMessage(), exception222.getMessage()));
            }
        }
        try {
            this.readDocObj();
        }
        catch (Exception exception32) {
            if (exception32 instanceof BadPasswordException) {
                throw new BadPasswordException(exception32.getMessage());
            }
            if (this.rebuilt) throw new InvalidPdfException(exception32.getMessage());
            if (this.encryptionError) {
                throw new InvalidPdfException(exception32.getMessage());
            }
            this.rebuilt = true;
            this.encrypted = false;
            try {
                this.rebuildXref();
                this.lastXref = -1L;
                this.readDocObj();
            }
            catch (Exception exception4) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("rebuild.failed.1.original.message.2", exception4.getMessage(), exception32.getMessage()));
            }
        }
        this.strings.clear();
        this.readPages();
        this.removeUnusedObjects();
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void readPdfPartial() throws IOException {
        this.fileLength = this.tokens.getFile().length();
        this.pdfVersion = this.tokens.checkPdfHeader();
        try {
            this.readXref();
        }
        catch (Exception exception) {
            try {
                this.rebuilt = true;
                this.rebuildXref();
                this.lastXref = -1L;
            }
            catch (Exception exception2) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("rebuild.failed.1.original.message.2", exception2.getMessage(), exception.getMessage()), exception2);
            }
        }
        this.readDocObjPartial();
        this.readPages();
    }

    protected PdfObject readSingleObject(int n) throws IOException {
        IOException iOException2;
        block13 : {
            this.strings.clear();
            int n2 = n * 2;
            long l = this.xref[n2];
            if (l < 0L) {
                return null;
            }
            Object object = this.xref;
            int n3 = n2 + 1;
            if (object[n3] > 0L) {
                l = this.objStmToOffset.get(this.xref[n3]);
            }
            if (l == 0L) {
                return null;
            }
            this.tokens.seek(l);
            this.tokens.nextValidToken();
            object = this.tokens.getTokenType();
            Object object2 = PRTokeniser.TokenType.NUMBER;
            int n4 = 0;
            if (object != object2) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.object.number", new Object[0]));
            }
            this.objNum = this.tokens.intValue();
            this.tokens.nextValidToken();
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.generation.number", new Object[0]));
            }
            this.objGen = this.tokens.intValue();
            this.tokens.nextValidToken();
            if (!this.tokens.getStringValue().equals("obj")) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("token.obj.expected", new Object[0]));
            }
            object2 = this.readPRObject();
            while (n4 < this.strings.size()) {
                this.strings.get(n4).decrypt(this);
                ++n4;
            }
            object = object2;
            try {
                if (object2.isStream()) {
                    this.checkPRStreamLength((PRStream)object2);
                    object = object2;
                }
            }
            catch (IOException iOException2) {
                if (!debugmode) break block13;
                if (LOGGER.isLogging(Level.ERROR)) {
                    LOGGER.error(iOException2.getMessage(), iOException2);
                }
                object = null;
            }
            object2 = object;
            if (this.xref[n3] > 0L) {
                object2 = this.readOneObjStm((PRStream)object, (int)this.xref[n2]);
            }
            this.xrefObj.set(n, (PdfObject)object2);
            return object2;
        }
        throw iOException2;
    }

    protected boolean readXRefStream(long l) throws IOException {
        this.tokens.seek(l);
        if (!this.tokens.nextToken()) {
            return false;
        }
        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
            return false;
        }
        int n = this.tokens.intValue();
        if (this.tokens.nextToken() && this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
            if (this.tokens.nextToken() && this.tokens.getStringValue().equals("obj")) {
                int[] arrn = this.readPRObject();
                if (arrn.isStream()) {
                    int n2;
                    PdfObject pdfObject = (PRStream)arrn;
                    if (!PdfName.XREF.equals(pdfObject.get(PdfName.TYPE))) {
                        return false;
                    }
                    if (this.trailer == null) {
                        this.trailer = new PdfDictionary();
                        this.trailer.putAll((PdfDictionary)pdfObject);
                    }
                    pdfObject.setLength(((PdfNumber)pdfObject.get(PdfName.LENGTH)).intValue());
                    int n3 = ((PdfNumber)pdfObject.get(PdfName.SIZE)).intValue();
                    arrn = pdfObject.get(PdfName.INDEX);
                    if (arrn == null) {
                        arrn = new PdfArray();
                        arrn.add(new int[]{0, n3});
                    } else {
                        arrn = (PdfArray)arrn;
                    }
                    Object object = (PdfArray)pdfObject.get(PdfName.W);
                    byte[] arrby = pdfObject.get(PdfName.PREV);
                    l = arrby != null ? ((PdfNumber)arrby).longValue() : -1L;
                    this.ensureXrefSize(n3 * 2);
                    if (this.objStmMark == null && !this.partial) {
                        this.objStmMark = new HashMap();
                    }
                    if (this.objStmToOffset == null && this.partial) {
                        this.objStmToOffset = new LongHashtable();
                    }
                    arrby = PdfReader.getStreamBytes((PRStream)pdfObject, this.tokens.getFile());
                    Object object2 = new int[3];
                    for (n3 = 0; n3 < 3; ++n3) {
                        object2[n3] = object.getAsNumber(n3).intValue();
                    }
                    n3 = 0;
                    pdfObject = arrn;
                    for (int i = 0; i < pdfObject.size(); i += 2) {
                        int n4;
                        int n5 = pdfObject.getAsNumber(i).intValue();
                        this.ensureXrefSize((n5 + n4) * 2);
                        arrn = object2;
                        for (n4 = pdfObject.getAsNumber((int)(i + 1)).intValue(); n4 > 0; --n4) {
                            int n6;
                            int n7;
                            int n8;
                            if (arrn[0] > 0) {
                                n7 = 0;
                                n6 = 0;
                                n2 = n3;
                                n3 = n6;
                                do {
                                    n8 = n3;
                                    n6 = n2;
                                    if (n7 < arrn[0]) {
                                        n6 = arrby[n2];
                                        ++n7;
                                        ++n2;
                                        n3 = (n3 << 8) + (n6 & 255);
                                        continue;
                                    }
                                    break;
                                } while (true);
                            } else {
                                n8 = 1;
                                n6 = n3;
                            }
                            long l2 = 0L;
                            n3 = 0;
                            while (n3 < arrn[1]) {
                                long l3 = arrby[n6] & 255;
                                ++n3;
                                ++n6;
                                l2 = (l2 << 8) + l3;
                            }
                            n3 = n6;
                            n6 = 0;
                            n2 = 0;
                            while (n6 < arrn[2]) {
                                n7 = arrby[n3];
                                ++n6;
                                ++n3;
                                n2 = (n2 << 8) + (n7 & 255);
                            }
                            n6 = n5 * 2;
                            if (this.xref[n6] == 0L && (object2 = this.xref)[n7 = n6 + 1] == 0L) {
                                switch (n8) {
                                    default: {
                                        break;
                                    }
                                    case 2: {
                                        this.xref[n6] = n2;
                                        this.xref[n7] = l2;
                                        if (this.partial) {
                                            this.objStmToOffset.put(l2, 0L);
                                            break;
                                        }
                                        object2 = (int)l2;
                                        object = this.objStmMark.get(object2);
                                        if (object == null) {
                                            object = new IntHashtable();
                                            object.put(n2, 1);
                                            this.objStmMark.put((Integer)object2, (IntHashtable)object);
                                            break;
                                        }
                                        object.put(n2, 1);
                                        break;
                                    }
                                    case 1: {
                                        this.xref[n6] = l2;
                                        break;
                                    }
                                    case 0: {
                                        this.xref[n6] = -1L;
                                    }
                                }
                            }
                            ++n5;
                        }
                        object2 = arrn;
                    }
                    n3 = n * 2;
                    n2 = n3 + 1;
                    if (n2 < this.xref.length && this.xref[n3] == 0L && this.xref[n2] == 0L) {
                        this.xref[n3] = -1L;
                    }
                    if (l == -1L) {
                        return true;
                    }
                    return this.readXRefStream(l);
                }
                return false;
            }
            return false;
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void readXref() throws IOException {
        long l;
        this.hybridXref = false;
        this.newXrefType = false;
        this.tokens.seek(this.tokens.getStartxref());
        this.tokens.nextToken();
        if (!this.tokens.getStringValue().equals("startxref")) {
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("startxref.not.found", new Object[0]));
        }
        this.tokens.nextToken();
        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("startxref.is.not.followed.by.a.number", new Object[0]));
        }
        this.lastXref = l = this.tokens.longValue();
        this.eofPos = this.tokens.getFilePointer();
        try {
            if (this.readXRefStream(l)) {
                this.newXrefType = true;
                return;
            }
        }
        catch (Exception exception) {}
        this.xref = null;
        this.tokens.seek(l);
        this.trailer = this.readXrefSection();
        PdfObject pdfObject = this.trailer;
        while ((pdfObject = (PdfNumber)pdfObject.get(PdfName.PREV)) != null) {
            if (pdfObject.longValue() == l) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("trailer.prev.entry.points.to.its.own.cross.reference.section", new Object[0]));
            }
            l = pdfObject.longValue();
            this.tokens.seek(l);
            pdfObject = this.readXrefSection();
        }
        return;
    }

    protected PdfDictionary readXrefSection() throws IOException {
        this.tokens.nextValidToken();
        if (!this.tokens.getStringValue().equals("xref")) {
            this.tokens.throwError(MessageLocalization.getComposedMessage("xref.subsection.not.found", new Object[0]));
        }
        block2 : do {
            long l;
            this.tokens.nextValidToken();
            if (this.tokens.getStringValue().equals("trailer")) {
                PdfDictionary pdfDictionary = (PdfDictionary)this.readPRObject();
                this.ensureXrefSize(((PdfNumber)pdfDictionary.get(PdfName.SIZE)).intValue() * 2);
                PdfObject pdfObject = pdfDictionary.get(PdfName.XREFSTM);
                if (pdfObject != null && pdfObject.isNumber()) {
                    l = ((PdfNumber)pdfObject).intValue();
                    try {
                        this.readXRefStream(l);
                        this.newXrefType = true;
                        this.hybridXref = true;
                        return pdfDictionary;
                    }
                    catch (IOException iOException) {
                        this.xref = null;
                        throw iOException;
                    }
                }
                return pdfDictionary;
            }
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("object.number.of.the.first.object.in.this.xref.subsection.not.found", new Object[0]));
            }
            int n = this.tokens.intValue();
            this.tokens.nextValidToken();
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("number.of.entries.in.this.xref.subsection.not.found", new Object[0]));
            }
            int n2 = this.tokens.intValue() + n;
            int n3 = n;
            int n4 = n2;
            if (n == 1) {
                l = this.tokens.getFilePointer();
                this.tokens.nextValidToken();
                long l2 = this.tokens.longValue();
                this.tokens.nextValidToken();
                int n5 = this.tokens.intValue();
                n3 = n;
                n4 = n2;
                if (l2 == 0L) {
                    n3 = n;
                    n4 = n2;
                    if (n5 == 65535) {
                        n3 = n - 1;
                        n4 = n2 - 1;
                    }
                }
                this.tokens.seek(l);
            }
            this.ensureXrefSize(n4 * 2);
            do {
                if (n3 >= n4) continue block2;
                this.tokens.nextValidToken();
                l = this.tokens.longValue();
                this.tokens.nextValidToken();
                this.tokens.intValue();
                this.tokens.nextValidToken();
                n2 = n3 * 2;
                if (this.tokens.getStringValue().equals("n")) {
                    if (this.xref[n2] == 0L && this.xref[n2 + 1] == 0L) {
                        this.xref[n2] = l;
                    }
                } else if (this.tokens.getStringValue().equals("f")) {
                    if (this.xref[n2] == 0L && this.xref[n2 + 1] == 0L) {
                        this.xref[n2] = -1L;
                    }
                } else {
                    this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.cross.reference.entry.in.this.xref.subsection", new Object[0]));
                }
                ++n3;
            } while (true);
            break;
        } while (true);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected void rebuildXref() throws IOException {
        this.hybridXref = false;
        this.newXrefType = false;
        PRTokeniser pRTokeniser = this.tokens;
        long l = 0L;
        pRTokeniser.seek(0L);
        long[][] arrarrl = new long[1024][];
        this.trailer = null;
        byte[] arrby = new byte[64];
        do {
            long[][] arrarrl2;
            long l2;
            long[] arrl;
            int n;
            void var12_3;
            long l3 = this.tokens.getFilePointer();
            if (!this.tokens.readLineSegment(arrby, true)) {
                if (this.trailer == null) {
                    throw new InvalidPdfException(MessageLocalization.getComposedMessage("trailer.not.found", new Object[0]));
                }
                this.xref = new long[(int)(2L * l)];
                n = 0;
                while ((long)n < l) {
                    arrarrl2 = var12_3[n];
                    if (arrarrl2 != null) {
                        this.xref[n * 2] = (long)arrarrl2[0];
                    }
                    ++n;
                }
                return;
            }
            if (arrby[0] == 116) {
                if (!PdfEncodings.convertToString(arrby, null).startsWith("trailer")) continue;
                this.tokens.seek(l3);
                this.tokens.nextToken();
                l2 = this.tokens.getFilePointer();
                arrarrl2 = (long[][])this.readPRObject();
                if (arrarrl2.get(PdfName.ROOT) != null) {
                    this.trailer = arrarrl2;
                    continue;
                }
                this.tokens.seek(l2);
                continue;
            }
            if (arrby[0] < 48 || arrby[0] > 57 || (arrl = PRTokeniser.checkObjectStart(arrby)) == null) continue;
            long l4 = arrl[0];
            long l5 = arrl[1];
            if (l4 >= (long)((void)var12_3).length) {
                arrarrl2 = new long[(int)(2L * l4)][];
                System.arraycopy(var12_3, 0, arrarrl2, 0, (int)l);
                long[][] arrarrl3 = arrarrl2;
            }
            l2 = l;
            if (l4 >= l) {
                l2 = l4 + 1L;
            }
            if (var12_3[n = (int)l4] != null && l5 < var12_3[n][1]) {
                l = l2;
                continue;
            }
            arrl[0] = l3;
            var12_3[n] = arrl;
            l = l2;
            continue;
            catch (Exception exception) {}
            this.tokens.seek(l2);
        } while (true);
    }

    public void releaseLastXrefPartial() {
        if (this.partial && this.lastXrefPartial != -1) {
            this.xrefObj.set(this.lastXrefPartial, null);
            this.lastXrefPartial = -1;
        }
    }

    public void releasePage(int n) {
        this.pageRefs.releasePage(n);
    }

    public void removeAnnotations() {
        this.pageRefs.resetReleasePage();
        for (int i = 1; i <= this.pageRefs.size(); ++i) {
            PdfDictionary pdfDictionary = this.pageRefs.getPageN(i);
            if (pdfDictionary.get(PdfName.ANNOTS) == null) {
                this.pageRefs.releasePage(i);
                continue;
            }
            pdfDictionary.remove(PdfName.ANNOTS);
        }
        this.catalog.remove(PdfName.ACROFORM);
        this.pageRefs.resetReleasePage();
    }

    public void removeFields() {
        this.pageRefs.resetReleasePage();
        for (int i = 1; i <= this.pageRefs.size(); ++i) {
            PdfDictionary pdfDictionary = this.pageRefs.getPageN(i);
            PdfArray pdfArray = pdfDictionary.getAsArray(PdfName.ANNOTS);
            if (pdfArray == null) {
                this.pageRefs.releasePage(i);
                continue;
            }
            int n = 0;
            while (n < pdfArray.size()) {
                PdfObject pdfObject = PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(n));
                int n2 = n;
                if (pdfObject != null) {
                    if (!pdfObject.isDictionary()) {
                        n2 = n;
                    } else {
                        pdfObject = (PdfDictionary)pdfObject;
                        n2 = n;
                        if (PdfName.WIDGET.equals(pdfObject.get(PdfName.SUBTYPE))) {
                            pdfArray.remove(n);
                            n2 = n - 1;
                        }
                    }
                }
                n = n2 + 1;
            }
            if (pdfArray.isEmpty()) {
                pdfDictionary.remove(PdfName.ANNOTS);
                continue;
            }
            this.pageRefs.releasePage(i);
        }
        this.catalog.remove(PdfName.ACROFORM);
        this.pageRefs.resetReleasePage();
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    protected void removeUnusedNode(PdfObject var1_1, boolean[] var2_2) {
        var9_14 = new Stack<PdfObject>();
        var9_14.push(var1_1 /* !! */ );
        block4 : while (var9_14.empty() == false) {
            var1_3 = var9_14.pop();
            if (var1_3 == null) continue;
            var5_17 = var1_3 instanceof PdfObject;
            var7_23 = null;
            if (!var5_17) ** GOTO lbl35
            var1_4 = (PdfObject)var1_3;
            var3_15 = var1_4.type();
            if (var3_15 != 10) {
                switch (var3_15) {
                    default: {
                        continue block4;
                    }
                    case 6: 
                    case 7: {
                        var1_5 = (PdfDictionary)var1_4;
                        var6_19 = new PdfName[var1_5.size()];
                        var1_5.getKeys().toArray(var6_19);
                        var3_15 = 0;
                        var8_24 = null;
                        ** break;
                    }
                    case 5: 
                }
                var7_23 = ((PdfArray)var1_4).getArrayList();
                var6_20 = var1_6 = null;
                var3_15 = 0;
                var8_24 = var6_20;
                ** break;
lbl28: // 2 sources:
            } else {
                var1_7 = (PRIndirectReference)var1_4;
                var3_15 = var1_7.getNumber();
                if (var2_13[var3_15] != false) continue;
                var2_13[var3_15] = true;
                var9_14.push(PdfReader.getPdfObjectRelease(var1_7));
                continue;
lbl35: // 1 sources:
                var8_24 = (Object[])var1_3;
                if (var8_24[0] instanceof ArrayList) {
                    var7_23 = (ArrayList<PdfObject>)var8_24[0];
                    var3_15 = (Integer)var8_24[1];
                    var1_8 = var6_21 = null;
                } else {
                    var6_22 = (PdfName[])var8_24[0];
                    var1_9 = (PdfDictionary)var8_24[1];
                    var3_15 = (Integer)var8_24[2];
                }
            }
            var4_16 = var3_15;
            if (var7_23 != null) {
                do {
                    if (var3_15 >= var7_23.size()) continue block4;
                    var1_12 = var7_23.get(var3_15);
                    if (!var1_12.isIndirect() || (var4_16 = ((PRIndirectReference)var1_12).getNumber()) < this.xrefObj.size() && (this.partial || this.xrefObj.get(var4_16) != null)) break;
                    var7_23.set(var3_15, PdfNull.PDFNULL);
                    ++var3_15;
                } while (true);
                if (var8_24 == null) {
                    var9_14.push((PdfObject)new Object[]{var7_23, var3_15 + 1});
                } else {
                    var8_24[1] = var3_15 + 1;
                    var9_14.push((PdfObject)var8_24);
                }
                var9_14.push(var1_12);
                continue;
            }
            do {
                if (var4_16 >= ((void)var6_18).length) continue block4;
                var7_23 = var6_18[var4_16];
                var10_25 = var1_10.get((PdfName)var7_23);
                if (!var10_25.isIndirect() || (var3_15 = ((PRIndirectReference)var10_25).getNumber()) >= 0 && var3_15 < this.xrefObj.size() && (this.partial || this.xrefObj.get(var3_15) != null)) break;
                var1_10.put((PdfName)var7_23, PdfNull.PDFNULL);
                ++var4_16;
            } while (true);
            if (var8_24 == null) {
                var9_14.push((PdfObject)new Object[]{var6_18, var1_10, var4_16 + 1});
            } else {
                var8_24[2] = var4_16 + 1;
                var9_14.push((PdfObject)var8_24);
            }
            var9_14.push(var10_25);
        }
    }

    public int removeUnusedObjects() {
        boolean[] arrbl = new boolean[this.xrefObj.size()];
        this.removeUnusedNode(this.trailer, arrbl);
        boolean bl = this.partial;
        int n = 1;
        int n2 = 0;
        int n3 = 0;
        if (bl) {
            n = 1;
            n2 = n3;
            do {
                n3 = n2;
                if (n < arrbl.length) {
                    n3 = n2;
                    if (!arrbl[n]) {
                        long[] arrl = this.xref;
                        n3 = n * 2;
                        arrl[n3] = -1L;
                        this.xref[n3 + 1] = 0L;
                        this.xrefObj.set(n, null);
                        n3 = n2 + 1;
                    }
                    ++n;
                    n2 = n3;
                    continue;
                }
                break;
            } while (true);
        } else {
            do {
                n3 = n2;
                if (n >= arrbl.length) break;
                n3 = n2;
                if (!arrbl[n]) {
                    this.xrefObj.set(n, null);
                    n3 = n2 + 1;
                }
                ++n;
                n2 = n3;
            } while (true);
        }
        return n3;
    }

    public void removeUsageRights() {
        PdfDictionary pdfDictionary = this.catalog.getAsDict(PdfName.PERMS);
        if (pdfDictionary == null) {
            return;
        }
        pdfDictionary.remove(PdfName.UR);
        pdfDictionary.remove(PdfName.UR3);
        if (pdfDictionary.size() == 0) {
            this.catalog.remove(PdfName.PERMS);
        }
    }

    public void resetLastXrefPartial() {
        this.lastXrefPartial = -1;
    }

    public void resetReleasePage() {
        this.pageRefs.resetReleasePage();
    }

    public void selectPages(String string2) {
        this.selectPages(SequenceList.expand(string2, this.getNumberOfPages()));
    }

    public void selectPages(List<Integer> list) {
        this.selectPages(list, true);
    }

    protected void selectPages(List<Integer> list, boolean bl) {
        this.pageRefs.selectPages(list);
        if (bl) {
            this.removeUnusedObjects();
        }
    }

    public void setAppendable(boolean bl) {
        this.appendable = bl;
        if (bl) {
            PdfReader.getPdfObject(this.trailer.get(PdfName.ROOT));
        }
    }

    public void setPageContent(int n, byte[] arrby) {
        this.setPageContent(n, arrby, -1);
    }

    public void setPageContent(int n, byte[] arrby, int n2) {
        this.setPageContent(n, arrby, n2, false);
    }

    public void setPageContent(int n, byte[] arrby, int n2, boolean bl) {
        PdfDictionary pdfDictionary = this.getPageN(n);
        if (pdfDictionary == null) {
            return;
        }
        PdfObject pdfObject = pdfDictionary.get(PdfName.CONTENTS);
        this.freeXref = -1;
        if (bl) {
            this.killXref(pdfObject);
        }
        if (this.freeXref == -1) {
            this.xrefObj.add(null);
            this.freeXref = this.xrefObj.size() - 1;
        }
        pdfDictionary.put(PdfName.CONTENTS, new PRIndirectReference(this, this.freeXref));
        this.xrefObj.set(this.freeXref, new PRStream(this, arrby, n2));
    }

    public void setTampered(boolean bl) {
        this.tampered = bl;
        this.pageRefs.keepPages();
    }

    @Override
    public void setViewerPreferences(int n) {
        this.viewerPreferences.setViewerPreferences(n);
        this.setViewerPreferences(this.viewerPreferences);
    }

    public void setViewerPreferences(PdfViewerPreferencesImp pdfViewerPreferencesImp) {
        pdfViewerPreferencesImp.addToCatalog(this.catalog);
    }

    public int shuffleSubsetNames() {
        int n = 0;
        for (int i = 1; i < this.xrefObj.size(); ++i) {
            Serializable serializable = this.getPdfObjectRelease(i);
            int n2 = n;
            if (serializable != null) {
                CharSequence charSequence;
                Object object;
                if (!serializable.isDictionary()) {
                    n2 = n;
                } else if (!PdfReader.existsName((PdfDictionary)(serializable = (PdfDictionary)serializable), PdfName.TYPE, PdfName.FONT)) {
                    n2 = n;
                } else if (!(PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.TYPE1) || PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.MMTYPE1) || PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.TRUETYPE))) {
                    n2 = n;
                    if (PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.TYPE0)) {
                        charSequence = PdfReader.getSubsetPrefix((PdfDictionary)serializable);
                        object = serializable.getAsArray(PdfName.DESCENDANTFONTS);
                        if (object == null) {
                            n2 = n;
                        } else if (object.isEmpty()) {
                            n2 = n;
                        } else {
                            String string2 = PdfReader.getSubsetPrefix((PdfDictionary)(object = object.getAsDict(0)));
                            if (string2 == null) {
                                n2 = n;
                            } else {
                                String string3 = BaseFont.createSubsetPrefix();
                                if (charSequence != null) {
                                    PdfName pdfName = PdfName.BASEFONT;
                                    StringBuilder stringBuilder = new StringBuilder();
                                    stringBuilder.append(string3);
                                    stringBuilder.append(charSequence.substring(7));
                                    serializable.put(pdfName, new PdfName(stringBuilder.toString()));
                                }
                                this.setXrefPartialObject(i, (PdfObject)serializable);
                                serializable = new StringBuilder();
                                serializable.append(string3);
                                serializable.append(string2.substring(7));
                                serializable = new PdfName(serializable.toString());
                                object.put(PdfName.BASEFONT, (PdfObject)serializable);
                                n2 = n + 1;
                                object = object.getAsDict(PdfName.FONTDESCRIPTOR);
                                if (object != null) {
                                    object.put(PdfName.FONTNAME, (PdfObject)serializable);
                                }
                            }
                        }
                    }
                } else {
                    object = PdfReader.getSubsetPrefix((PdfDictionary)serializable);
                    if (object == null) {
                        n2 = n;
                    } else {
                        charSequence = new StringBuilder();
                        charSequence.append(BaseFont.createSubsetPrefix());
                        charSequence.append(object.substring(7));
                        object = new PdfName(charSequence.toString());
                        serializable.put(PdfName.BASEFONT, (PdfObject)object);
                        this.setXrefPartialObject(i, (PdfObject)serializable);
                        n2 = n + 1;
                        serializable = serializable.getAsDict(PdfName.FONTDESCRIPTOR);
                        if (serializable != null) {
                            serializable.put(PdfName.FONTNAME, (PdfObject)object);
                        }
                    }
                }
            }
            n = n2;
        }
        return n;
    }

    static class PageRefs {
        private boolean keepPages;
        private int lastPageRead = -1;
        private ArrayList<PdfDictionary> pageInh;
        private Set<PdfObject> pagesNodes = new HashSet<PdfObject>();
        private final PdfReader reader;
        private ArrayList<PRIndirectReference> refsn;
        private IntHashtable refsp;
        private int sizep;

        PageRefs(PageRefs pageRefs, PdfReader pdfReader) {
            this.reader = pdfReader;
            this.sizep = pageRefs.sizep;
            if (pageRefs.refsn != null) {
                this.refsn = new ArrayList<PRIndirectReference>(pageRefs.refsn);
                for (int i = 0; i < this.refsn.size(); ++i) {
                    this.refsn.set(i, (PRIndirectReference)PdfReader.duplicatePdfObject(this.refsn.get(i), pdfReader));
                }
            } else {
                this.refsp = (IntHashtable)pageRefs.refsp.clone();
            }
        }

        private PageRefs(PdfReader pdfReader) throws IOException {
            this.reader = pdfReader;
            if (pdfReader.partial) {
                this.refsp = new IntHashtable();
                this.sizep = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfReader.rootPages.get(PdfName.COUNT))).intValue();
                return;
            }
            this.readPages();
        }

        private void iteratePages(PRIndirectReference pdfObject) throws IOException {
            boolean bl = this.pagesNodes.add(PdfReader.getPdfObject(pdfObject));
            if (!bl) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.pages.tree", new Object[0]));
            }
            PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObject(pdfObject);
            if (pdfDictionary == null) {
                return;
            }
            PdfObject pdfObject2 = pdfDictionary.getAsArray(PdfName.KIDS);
            if (pdfObject2 == null) {
                pdfDictionary.put(PdfName.TYPE, PdfName.PAGE);
                pdfObject2 = this.pageInh.get(this.pageInh.size() - 1);
                for (PdfName pdfName : pdfObject2.getKeys()) {
                    if (pdfDictionary.get(pdfName) != null) continue;
                    pdfDictionary.put(pdfName, pdfObject2.get(pdfName));
                }
                if (pdfDictionary.get(PdfName.MEDIABOX) == null) {
                    pdfObject2 = new PdfArray(new float[]{0.0f, 0.0f, PageSize.LETTER.getRight(), PageSize.LETTER.getTop()});
                    pdfDictionary.put(PdfName.MEDIABOX, pdfObject2);
                }
                this.refsn.add((PRIndirectReference)pdfObject);
                return;
            }
            pdfDictionary.put(PdfName.TYPE, PdfName.PAGES);
            this.pushPageAttributes(pdfDictionary);
            for (int i = 0; i < pdfObject2.size(); ++i) {
                pdfObject = pdfObject2.getPdfObject(i);
                if (!pdfObject.isIndirect()) {
                    while (i < pdfObject2.size()) {
                        pdfObject2.remove(i);
                    }
                    break;
                }
                this.iteratePages((PRIndirectReference)pdfObject);
            }
            this.popPageAttributes();
        }

        private void popPageAttributes() {
            this.pageInh.remove(this.pageInh.size() - 1);
        }

        private void pushPageAttributes(PdfDictionary pdfDictionary) {
            PdfDictionary pdfDictionary2 = new PdfDictionary();
            if (!this.pageInh.isEmpty()) {
                pdfDictionary2.putAll(this.pageInh.get(this.pageInh.size() - 1));
            }
            for (int i = 0; i < PdfReader.pageInhCandidates.length; ++i) {
                PdfObject pdfObject = pdfDictionary.get(PdfReader.pageInhCandidates[i]);
                if (pdfObject == null) continue;
                pdfDictionary2.put(PdfReader.pageInhCandidates[i], pdfObject);
            }
            this.pageInh.add(pdfDictionary2);
        }

        private void selectPages(List<Integer> object) {
            int n;
            int n2;
            Serializable serializable;
            long[] arrl;
            IntHashtable intHashtable = new IntHashtable();
            ArrayList<Integer> arrayList = new ArrayList<Integer>();
            int n3 = this.size();
            object = object.iterator();
            while (object.hasNext()) {
                serializable = (Integer)object.next();
                n2 = serializable.intValue();
                if (n2 < 1 || n2 > n3 || intHashtable.put(n2, 1) != 0) continue;
                arrayList.add((Integer)serializable);
            }
            if (this.reader.partial) {
                for (n2 = 1; n2 <= n3; ++n2) {
                    this.getPageOrigRef(n2);
                    this.resetReleasePage();
                }
            }
            Object object2 = (PRIndirectReference)this.reader.catalog.get(PdfName.PAGES);
            object = (PdfDictionary)PdfReader.getPdfObject((PdfObject)object2);
            serializable = new ArrayList(arrayList.size());
            PdfArray pdfArray = new PdfArray();
            int n4 = 0;
            for (n2 = 0; n2 < arrayList.size(); ++n2) {
                n = (Integer)arrayList.get(n2);
                arrl = this.getPageOrigRef(n);
                this.resetReleasePage();
                pdfArray.add((PdfObject)arrl);
                serializable.add(arrl);
                this.getPageN(n).put(PdfName.PARENT, (PdfObject)object2);
            }
            object2 = this.reader.getAcroFields();
            n2 = n4;
            if (object2.getFields().size() > 0) {
                n2 = 1;
            }
            for (n4 = 1; n4 <= n3; ++n4) {
                if (intHashtable.containsKey(n4)) continue;
                if (n2 != 0) {
                    object2.removeFieldsFromPage(n4);
                }
                n = this.getPageOrigRef(n4).getNumber();
                this.reader.xrefObj.set(n, null);
                if (!this.reader.partial) continue;
                arrl = this.reader.xref;
                arrl[n *= 2] = -1L;
                this.reader.xref[n + 1] = 0L;
            }
            object.put(PdfName.COUNT, new PdfNumber(arrayList.size()));
            object.put(PdfName.KIDS, pdfArray);
            this.refsp = null;
            this.refsn = serializable;
        }

        public PdfDictionary getPageN(int n) {
            return (PdfDictionary)PdfReader.getPdfObject(this.getPageOrigRef(n));
        }

        public PdfDictionary getPageNRelease(int n) {
            PdfDictionary pdfDictionary = this.getPageN(n);
            this.releasePage(n);
            return pdfDictionary;
        }

        public PRIndirectReference getPageOrigRef(int n) {
            PRIndirectReference pRIndirectReference;
            block11 : {
                block9 : {
                    if (--n >= 0) {
                        int n2;
                        block10 : {
                            try {
                                if (n >= this.size()) break block9;
                                if (this.refsn != null) {
                                    return this.refsn.get(n);
                                }
                                n2 = this.refsp.get(n);
                                if (n2 != 0) break block10;
                            }
                            catch (Exception exception) {
                                throw new ExceptionConverter(exception);
                            }
                            pRIndirectReference = this.getSinglePage(n);
                            this.lastPageRead = this.reader.lastXrefPartial == -1 ? -1 : n;
                            this.reader.lastXrefPartial = -1;
                            this.refsp.put(n, pRIndirectReference.getNumber());
                            if (this.keepPages) {
                                this.lastPageRead = -1;
                                return pRIndirectReference;
                            }
                            break block11;
                        }
                        if (this.lastPageRead != n) {
                            this.lastPageRead = -1;
                        }
                        if (this.keepPages) {
                            this.lastPageRead = -1;
                        }
                        PRIndirectReference pRIndirectReference2 = new PRIndirectReference(this.reader, n2);
                        return pRIndirectReference2;
                    }
                }
                return null;
            }
            return pRIndirectReference;
        }

        public PRIndirectReference getPageOrigRefRelease(int n) {
            PRIndirectReference pRIndirectReference = this.getPageOrigRef(n);
            this.releasePage(n);
            return pRIndirectReference;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        protected PRIndirectReference getSinglePage(int var1_1) {
            var6_2 = new PdfDictionary();
            var4_3 = this.reader.rootPages;
            var3_6 = 0;
            do lbl-1000: // 5 sources:
            {
                for (var2_7 = 0; var2_7 < PdfReader.pageInhCandidates.length; ++var2_7) {
                    var5_8 = var4_4.get(PdfReader.pageInhCandidates[var2_7]);
                    if (var5_8 == null) continue;
                    var6_2.put(PdfReader.pageInhCandidates[var2_7], var5_8);
                }
                var7_9 = ((PdfArray)PdfReader.getPdfObjectRelease(var4_4.get(PdfName.KIDS))).listIterator();
                var2_7 = var3_6;
                do {
                    var3_6 = var2_7;
                    if (!var7_9.hasNext()) ** continue;
                    var8_10 = (PRIndirectReference)var7_9.next();
                    var5_8 = (PdfDictionary)PdfReader.getPdfObject(var8_10);
                    var3_6 = PdfReader.access$300(this.reader);
                    var9_11 = PdfReader.getPdfObjectRelease(var5_8.get(PdfName.COUNT));
                    PdfReader.access$302(this.reader, var3_6);
                    var3_6 = var9_11 != null && var9_11.type() == 2 ? ((PdfNumber)var9_11).intValue() : 1;
                    if (var1_1 < (var3_6 += var2_7)) {
                        if (var9_11 == null) {
                            var5_8.mergeDifferent(var6_2);
                            return var8_10;
                        }
                        this.reader.releaseLastXrefPartial();
                        var4_5 = var5_8;
                        var3_6 = var2_7;
                        ** continue;
                    }
                    this.reader.releaseLastXrefPartial();
                    var2_7 = var3_6;
                } while (true);
                break;
            } while (true);
        }

        void insertPage(int n, PRIndirectReference pRIndirectReference) {
            int n2 = n - 1;
            if (this.refsn != null) {
                if (n2 >= this.refsn.size()) {
                    this.refsn.add(pRIndirectReference);
                    return;
                }
                this.refsn.add(n2, pRIndirectReference);
                return;
            }
            ++this.sizep;
            this.lastPageRead = -1;
            if (n2 >= this.size()) {
                this.refsp.put(this.size(), pRIndirectReference.getNumber());
                return;
            }
            IntHashtable intHashtable = new IntHashtable((this.refsp.size() + 1) * 2);
            Iterator<IntHashtable.Entry> iterator = this.refsp.getEntryIterator();
            while (iterator.hasNext()) {
                int n3;
                IntHashtable.Entry entry = iterator.next();
                n = n3 = entry.getKey();
                if (n3 >= n2) {
                    n = n3 + 1;
                }
                intHashtable.put(n, entry.getValue());
            }
            intHashtable.put(n2, pRIndirectReference.getNumber());
            this.refsp = intHashtable;
        }

        void keepPages() {
            if (this.refsp != null) {
                if (this.keepPages) {
                    return;
                }
                this.keepPages = true;
                this.refsp.clear();
                return;
            }
        }

        void reReadPages() throws IOException {
            this.refsn = null;
            this.readPages();
        }

        void readPages() throws IOException {
            if (this.refsn != null) {
                return;
            }
            this.refsp = null;
            this.refsn = new ArrayList();
            this.pageInh = new ArrayList();
            this.iteratePages((PRIndirectReference)this.reader.catalog.get(PdfName.PAGES));
            this.pageInh = null;
            this.reader.rootPages.put(PdfName.COUNT, new PdfNumber(this.refsn.size()));
        }

        public void releasePage(int n) {
            if (this.refsp == null) {
                return;
            }
            if (--n >= 0) {
                if (n >= this.size()) {
                    return;
                }
                if (n != this.lastPageRead) {
                    return;
                }
                this.lastPageRead = -1;
                this.reader.lastXrefPartial = this.refsp.get(n);
                this.reader.releaseLastXrefPartial();
                this.refsp.remove(n);
                return;
            }
        }

        public void resetReleasePage() {
            if (this.refsp == null) {
                return;
            }
            this.lastPageRead = -1;
        }

        int size() {
            if (this.refsn != null) {
                return this.refsn.size();
            }
            return this.sizep;
        }
    }

}

