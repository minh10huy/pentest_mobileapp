/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.spongycastle.asn1.ASN1Encodable
 *  org.spongycastle.asn1.ASN1EncodableVector
 *  org.spongycastle.asn1.ASN1Enumerated
 *  org.spongycastle.asn1.ASN1InputStream
 *  org.spongycastle.asn1.ASN1ObjectIdentifier
 *  org.spongycastle.asn1.ASN1Primitive
 *  org.spongycastle.asn1.DEROctetString
 *  org.spongycastle.asn1.DERSequence
 *  org.spongycastle.asn1.DERTaggedObject
 *  org.spongycastle.asn1.ocsp.OCSPObjectIdentifiers
 */
package com.itextpdf.text.pdf.security;

import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDeveloperExtension;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStamper;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.security.CrlClient;
import com.itextpdf.text.pdf.security.OcspClient;
import com.itextpdf.text.pdf.security.PdfPKCS7;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PublicKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.spongycastle.asn1.ASN1Encodable;
import org.spongycastle.asn1.ASN1EncodableVector;
import org.spongycastle.asn1.ASN1Enumerated;
import org.spongycastle.asn1.ASN1InputStream;
import org.spongycastle.asn1.ASN1ObjectIdentifier;
import org.spongycastle.asn1.ASN1Primitive;
import org.spongycastle.asn1.DEROctetString;
import org.spongycastle.asn1.DERSequence;
import org.spongycastle.asn1.DERTaggedObject;
import org.spongycastle.asn1.ocsp.OCSPObjectIdentifiers;

public class LtvVerification {
    private Logger LOGGER = LoggerFactory.getLogger(LtvVerification.class);
    private AcroFields acroFields;
    private PdfReader reader;
    private PdfStamper stp;
    private boolean used = false;
    private Map<PdfName, ValidationData> validated = new HashMap<PdfName, ValidationData>();
    private PdfWriter writer;

    public LtvVerification(PdfStamper pdfStamper) {
        this.stp = pdfStamper;
        this.writer = pdfStamper.getWriter();
        this.reader = pdfStamper.getReader();
        this.acroFields = pdfStamper.getAcroFields();
    }

    private static byte[] buildOCSPResponse(byte[] aSN1EncodableVector) throws IOException {
        DEROctetString dEROctetString = new DEROctetString((byte[])aSN1EncodableVector);
        aSN1EncodableVector = new ASN1EncodableVector();
        aSN1EncodableVector.add((ASN1Encodable)OCSPObjectIdentifiers.id_pkix_ocsp_basic);
        aSN1EncodableVector.add((ASN1Encodable)dEROctetString);
        dEROctetString = new ASN1Enumerated(0);
        ASN1EncodableVector aSN1EncodableVector2 = new ASN1EncodableVector();
        aSN1EncodableVector2.add((ASN1Encodable)dEROctetString);
        aSN1EncodableVector2.add((ASN1Encodable)new DERTaggedObject(true, 0, (ASN1Encodable)new DERSequence(aSN1EncodableVector)));
        return new DERSequence(aSN1EncodableVector2).getEncoded();
    }

    private void createDss() throws IOException {
        this.outputDss(new PdfDictionary(), new PdfDictionary(), new PdfArray(), new PdfArray(), new PdfArray());
    }

    private static void deleteOldReferences(PdfArray pdfArray, PdfArray object) {
        if (pdfArray != null) {
            if (object == null) {
                return;
            }
            object = object.iterator();
            while (object.hasNext()) {
                PdfObject pdfObject = (PdfObject)object.next();
                if (!pdfObject.isIndirect()) continue;
                pdfObject = (PRIndirectReference)pdfObject;
                int n = 0;
                while (n < pdfArray.size()) {
                    int n2;
                    PdfObject pdfObject2 = pdfArray.getPdfObject(n);
                    if (!pdfObject2.isIndirect()) {
                        n2 = n;
                    } else {
                        pdfObject2 = (PRIndirectReference)pdfObject2;
                        n2 = n;
                        if (pdfObject.getNumber() == pdfObject2.getNumber()) {
                            pdfArray.remove(n);
                            n2 = n - 1;
                        }
                    }
                    n = n2 + 1;
                }
            }
            return;
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private X509Certificate getParent(X509Certificate x509Certificate, Certificate[] arrcertificate) {
        int n = 0;
        while (n < arrcertificate.length) {
            X509Certificate x509Certificate2 = (X509Certificate)arrcertificate[n];
            if (x509Certificate.getIssuerDN().equals(x509Certificate2.getSubjectDN())) {
                try {
                    x509Certificate.verify(x509Certificate2.getPublicKey());
                    return x509Certificate2;
                }
                catch (Exception exception) {}
            }
            ++n;
        }
        return null;
    }

    private PdfName getSignatureHashKey(String arrby) throws NoSuchAlgorithmException, IOException {
        byte[] arrby2;
        PdfDictionary pdfDictionary = this.acroFields.getSignatureDictionary((String)arrby);
        arrby = arrby2 = pdfDictionary.getAsString(PdfName.CONTENTS).getOriginalBytes();
        if (PdfName.ETSI_RFC3161.equals(PdfReader.getPdfObject(pdfDictionary.get(PdfName.SUBFILTER)))) {
            arrby = new ASN1InputStream((InputStream)new ByteArrayInputStream(arrby2)).readObject().getEncoded();
        }
        return new PdfName(Utilities.convertToHex(LtvVerification.hashBytesSha1(arrby)));
    }

    private static byte[] hashBytesSha1(byte[] arrby) throws NoSuchAlgorithmException {
        return MessageDigest.getInstance("SHA1").digest(arrby);
    }

    private void outputDss(PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2, PdfArray pdfArray, PdfArray pdfArray2, PdfArray pdfArray3) throws IOException {
        this.writer.addDeveloperExtension(PdfDeveloperExtension.ESIC_1_7_EXTENSIONLEVEL5);
        PdfDictionary pdfDictionary3 = this.reader.getCatalog();
        this.stp.markUsed(pdfDictionary3);
        for (PdfName pdfName : this.validated.keySet()) {
            PdfObject pdfObject;
            PdfArray pdfArray4 = new PdfArray();
            PdfArray pdfArray5 = new PdfArray();
            PdfArray pdfArray6 = new PdfArray();
            PdfDictionary pdfDictionary4 = new PdfDictionary();
            Iterator<byte[]> iterator = this.validated.get((Object)pdfName).crls.iterator();
            while (iterator.hasNext()) {
                pdfObject = new PdfStream(iterator.next());
                pdfObject.flateCompress();
                pdfObject = this.writer.addToBody(pdfObject, false).getIndirectReference();
                pdfArray5.add(pdfObject);
                pdfArray2.add(pdfObject);
            }
            iterator = this.validated.get((Object)pdfName).ocsps.iterator();
            while (iterator.hasNext()) {
                pdfObject = new PdfStream(iterator.next());
                pdfObject.flateCompress();
                pdfObject = this.writer.addToBody(pdfObject, false).getIndirectReference();
                pdfArray4.add(pdfObject);
                pdfArray.add(pdfObject);
            }
            iterator = this.validated.get((Object)pdfName).certs.iterator();
            while (iterator.hasNext()) {
                pdfObject = new PdfStream(iterator.next());
                pdfObject.flateCompress();
                pdfObject = this.writer.addToBody(pdfObject, false).getIndirectReference();
                pdfArray6.add(pdfObject);
                pdfArray3.add(pdfObject);
            }
            if (pdfArray4.size() > 0) {
                pdfDictionary4.put(PdfName.OCSP, this.writer.addToBody((PdfObject)pdfArray4, false).getIndirectReference());
            }
            if (pdfArray5.size() > 0) {
                pdfDictionary4.put(PdfName.CRL, this.writer.addToBody((PdfObject)pdfArray5, false).getIndirectReference());
            }
            if (pdfArray6.size() > 0) {
                pdfDictionary4.put(PdfName.CERT, this.writer.addToBody((PdfObject)pdfArray6, false).getIndirectReference());
            }
            pdfDictionary2.put(pdfName, this.writer.addToBody((PdfObject)pdfDictionary4, false).getIndirectReference());
        }
        pdfDictionary.put(PdfName.VRI, this.writer.addToBody((PdfObject)pdfDictionary2, false).getIndirectReference());
        if (pdfArray.size() > 0) {
            pdfDictionary.put(PdfName.OCSPS, this.writer.addToBody((PdfObject)pdfArray, false).getIndirectReference());
        }
        if (pdfArray2.size() > 0) {
            pdfDictionary.put(PdfName.CRLS, this.writer.addToBody((PdfObject)pdfArray2, false).getIndirectReference());
        }
        if (pdfArray3.size() > 0) {
            pdfDictionary.put(PdfName.CERTS, this.writer.addToBody((PdfObject)pdfArray3, false).getIndirectReference());
        }
        pdfDictionary3.put(PdfName.DSS, this.writer.addToBody((PdfObject)pdfDictionary, false).getIndirectReference());
    }

    private void updateDss() throws IOException {
        Object object = this.reader.getCatalog();
        this.stp.markUsed((PdfObject)object);
        PdfDictionary pdfDictionary = object.getAsDict(PdfName.DSS);
        PdfArray pdfArray = pdfDictionary.getAsArray(PdfName.OCSPS);
        PdfArray pdfArray2 = pdfDictionary.getAsArray(PdfName.CRLS);
        PdfArray pdfArray3 = pdfDictionary.getAsArray(PdfName.CERTS);
        pdfDictionary.remove(PdfName.OCSPS);
        pdfDictionary.remove(PdfName.CRLS);
        pdfDictionary.remove(PdfName.CERTS);
        PdfDictionary pdfDictionary2 = pdfDictionary.getAsDict(PdfName.VRI);
        if (pdfDictionary2 != null) {
            for (PdfName pdfName : pdfDictionary2.getKeys()) {
                PdfDictionary pdfDictionary3;
                if (!this.validated.containsKey(pdfName) || (pdfDictionary3 = pdfDictionary2.getAsDict(pdfName)) == null) continue;
                LtvVerification.deleteOldReferences(pdfArray, pdfDictionary3.getAsArray(PdfName.OCSP));
                LtvVerification.deleteOldReferences(pdfArray2, pdfDictionary3.getAsArray(PdfName.CRL));
                LtvVerification.deleteOldReferences(pdfArray3, pdfDictionary3.getAsArray(PdfName.CERT));
            }
        }
        object = pdfArray;
        if (pdfArray == null) {
            object = new PdfArray();
        }
        if (pdfArray2 == null) {
            pdfArray2 = new PdfArray();
        }
        if (pdfArray3 == null) {
            pdfArray3 = new PdfArray();
        }
        this.outputDss(pdfDictionary, pdfDictionary2, (PdfArray)object, pdfArray2, pdfArray3);
    }

    public boolean addVerification(String string2, OcspClient ocspClient, CrlClient crlClient, CertificateOption certificateOption, Level level, CertificateInclusion certificateInclusion) throws IOException, GeneralSecurityException {
        if (this.used) {
            throw new IllegalStateException(MessageLocalization.getComposedMessage("verification.already.output", new Object[0]));
        }
        Object object = this.acroFields.verifySignature(string2);
        byte[] arrby = this.LOGGER;
        Certificate[] arrcertificate = new Certificate[]();
        arrcertificate.append("Adding verification for ");
        arrcertificate.append(string2);
        arrby.info(arrcertificate.toString());
        arrcertificate = object.getCertificates();
        X509Certificate x509Certificate = object.getSigningCertificate();
        ValidationData validationData = new ValidationData();
        for (int i = 0; i < arrcertificate.length; ++i) {
            X509Certificate x509Certificate2 = (X509Certificate)arrcertificate[i];
            object = this.LOGGER;
            arrby = new StringBuilder();
            arrby.append("Certificate: ");
            arrby.append(x509Certificate2.getSubjectDN());
            object.info(arrby.toString());
            if (certificateOption == CertificateOption.SIGNING_CERTIFICATE && !x509Certificate2.equals(x509Certificate)) continue;
            if (ocspClient != null && level != Level.CRL) {
                arrby = ocspClient.getEncoded(x509Certificate2, this.getParent(x509Certificate2, arrcertificate), null);
                object = arrby;
                if (arrby != null) {
                    validationData.ocsps.add(LtvVerification.buildOCSPResponse(arrby));
                    this.LOGGER.info("OCSP added");
                    object = arrby;
                }
            } else {
                object = null;
            }
            if (crlClient != null && (level == Level.CRL || level == Level.OCSP_CRL || level == Level.OCSP_OPTIONAL_CRL && object == null) && (object = crlClient.getEncoded(x509Certificate2, null)) != null) {
                object = object.iterator();
                while (object.hasNext()) {
                    boolean bl;
                    block9 : {
                        arrby = (byte[])object.next();
                        Iterator<byte[]> iterator = validationData.crls.iterator();
                        while (iterator.hasNext()) {
                            if (!Arrays.equals(iterator.next(), arrby)) continue;
                            bl = true;
                            break block9;
                        }
                        bl = false;
                    }
                    if (bl) continue;
                    validationData.crls.add(arrby);
                    this.LOGGER.info("CRL added");
                }
            }
            if (certificateInclusion != CertificateInclusion.YES) continue;
            validationData.certs.add(x509Certificate2.getEncoded());
        }
        if (validationData.crls.isEmpty() && validationData.ocsps.isEmpty()) {
            return false;
        }
        this.validated.put(this.getSignatureHashKey(string2), validationData);
        return true;
    }

    public boolean addVerification(String string2, Collection<byte[]> iterator, Collection<byte[]> arrby3, Collection<byte[]> collection) throws IOException, GeneralSecurityException {
        void var4_8;
        if (this.used) {
            throw new IllegalStateException(MessageLocalization.getComposedMessage("verification.already.output", new Object[0]));
        }
        ValidationData validationData = new ValidationData();
        if (iterator != null) {
            iterator = iterator.iterator();
            while (iterator.hasNext()) {
                byte[] arrby = (byte[])iterator.next();
                validationData.ocsps.add(LtvVerification.buildOCSPResponse(arrby));
            }
        }
        if (arrby3 != null) {
            for (byte[] arrby : arrby3) {
                validationData.crls.add(arrby);
            }
        }
        if (var4_8 != null) {
            for (byte[] arrby : var4_8) {
                validationData.certs.add(arrby);
            }
        }
        this.validated.put(this.getSignatureHashKey(string2), validationData);
        return true;
    }

    public void merge() throws IOException {
        if (!this.used) {
            if (this.validated.isEmpty()) {
                return;
            }
            this.used = true;
            if (this.reader.getCatalog().get(PdfName.DSS) == null) {
                this.createDss();
                return;
            }
            this.updateDss();
            return;
        }
    }

    public static enum CertificateInclusion {
        YES,
        NO;
        

        private CertificateInclusion() {
        }
    }

    public static enum CertificateOption {
        SIGNING_CERTIFICATE,
        WHOLE_CHAIN;
        

        private CertificateOption() {
        }
    }

    public static enum Level {
        OCSP,
        CRL,
        OCSP_CRL,
        OCSP_OPTIONAL_CRL;
        

        private Level() {
        }
    }

    private static class ValidationData {
        public List<byte[]> certs = new ArrayList<byte[]>();
        public List<byte[]> crls = new ArrayList<byte[]>();
        public List<byte[]> ocsps = new ArrayList<byte[]>();

        private ValidationData() {
        }
    }

}

