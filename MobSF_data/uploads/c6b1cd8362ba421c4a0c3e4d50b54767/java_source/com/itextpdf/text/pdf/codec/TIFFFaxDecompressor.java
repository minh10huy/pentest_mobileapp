/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.codec;

public class TIFFFaxDecompressor {
    static short[] additionalMakeup;
    static short[] black;
    static byte[] flipTable;
    static short[] initBlack;
    static int[] table1;
    static int[] table2;
    static short[] twoBitBlack;
    static byte[] twoDCodes;
    static short[] white;
    private int bitPointer;
    private int bitsPerScanline;
    private byte[] buffer;
    private int bytePointer;
    private int changingElemSize = 0;
    protected int compression;
    private int[] currChangingElems;
    private byte[] data;
    public int fails;
    protected int fillBits = 0;
    protected int fillOrder;
    private int h;
    private int lastChangingElement = 0;
    private int lineBitNum;
    protected int oneD;
    private int[] prevChangingElems;
    private int t4Options;
    private int t6Options;
    protected int uncompressedMode = 0;
    private int w;

    static {
        table1 = new int[]{0, 1, 3, 7, 15, 31, 63, 127, 255};
        table2 = new int[]{0, 128, 192, 224, 240, 248, 252, 254, 255};
        flipTable = new byte[]{0, -128, 64, -64, 32, -96, 96, -32, 16, -112, 80, -48, 48, -80, 112, -16, 8, -120, 72, -56, 40, -88, 104, -24, 24, -104, 88, -40, 56, -72, 120, -8, 4, -124, 68, -60, 36, -92, 100, -28, 20, -108, 84, -44, 52, -76, 116, -12, 12, -116, 76, -52, 44, -84, 108, -20, 28, -100, 92, -36, 60, -68, 124, -4, 2, -126, 66, -62, 34, -94, 98, -30, 18, -110, 82, -46, 50, -78, 114, -14, 10, -118, 74, -54, 42, -86, 106, -22, 26, -102, 90, -38, 58, -70, 122, -6, 6, -122, 70, -58, 38, -90, 102, -26, 22, -106, 86, -42, 54, -74, 118, -10, 14, -114, 78, -50, 46, -82, 110, -18, 30, -98, 94, -34, 62, -66, 126, -2, 1, -127, 65, -63, 33, -95, 97, -31, 17, -111, 81, -47, 49, -79, 113, -15, 9, -119, 73, -55, 41, -87, 105, -23, 25, -103, 89, -39, 57, -71, 121, -7, 5, -123, 69, -59, 37, -91, 101, -27, 21, -107, 85, -43, 53, -75, 117, -11, 13, -115, 77, -51, 45, -83, 109, -19, 29, -99, 93, -35, 61, -67, 125, -3, 3, -125, 67, -61, 35, -93, 99, -29, 19, -109, 83, -45, 51, -77, 115, -13, 11, -117, 75, -53, 43, -85, 107, -21, 27, -101, 91, -37, 59, -69, 123, -5, 7, -121, 71, -57, 39, -89, 103, -25, 23, -105, 87, -41, 55, -73, 119, -9, 15, -113, 79, -49, 47, -81, 111, -17, 31, -97, 95, -33, 63, -65, 127, -1};
        white = new short[]{6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225, 944, 944, 944, 944, 976, 976, 976, 976, 1456, 1456, 1456, 1456, 1488, 1488, 1488, 1488, 718, 718, 718, 718, 718, 718, 718, 718, 750, 750, 750, 750, 750, 750, 750, 750, 1520, 1520, 1520, 1520, 1552, 1552, 1552, 1552, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 428, 654, 654, 654, 654, 654, 654, 654, 654, 1072, 1072, 1072, 1072, 1104, 1104, 1104, 1104, 1136, 1136, 1136, 1136, 1168, 1168, 1168, 1168, 1200, 1200, 1200, 1200, 1232, 1232, 1232, 1232, 622, 622, 622, 622, 622, 622, 622, 622, 1008, 1008, 1008, 1008, 1040, 1040, 1040, 1040, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 1712, 1712, 1712, 1712, 1744, 1744, 1744, 1744, 846, 846, 846, 846, 846, 846, 846, 846, 1264, 1264, 1264, 1264, 1296, 1296, 1296, 1296, 1328, 1328, 1328, 1328, 1360, 1360, 1360, 1360, 1392, 1392, 1392, 1392, 1424, 1424, 1424, 1424, 686, 686, 686, 686, 686, 686, 686, 686, 910, 910, 910, 910, 910, 910, 910, 910, 1968, 1968, 1968, 1968, 2000, 2000, 2000, 2000, 2032, 2032, 2032, 2032, 16, 16, 16, 16, 10257, 10257, 10257, 10257, 12305, 12305, 12305, 12305, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 330, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 878, 878, 878, 878, 878, 878, 878, 878, 1904, 1904, 1904, 1904, 1936, 1936, 1936, 1936, -18413, -18413, -16365, -16365, -14317, -14317, -10221, -10221, 590, 590, 590, 590, 590, 590, 590, 590, 782, 782, 782, 782, 782, 782, 782, 782, 1584, 1584, 1584, 1584, 1616, 1616, 1616, 1616, 1648, 1648, 1648, 1648, 1680, 1680, 1680, 1680, 814, 814, 814, 814, 814, 814, 814, 814, 1776, 1776, 1776, 1776, 1808, 1808, 1808, 1808, 1840, 1840, 1840, 1840, 1872, 1872, 1872, 1872, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, 6157, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, -12275, 14353, 14353, 14353, 14353, 16401, 16401, 16401, 16401, 22547, 22547, 24595, 24595, 20497, 20497, 20497, 20497, 18449, 18449, 18449, 18449, 26643, 26643, 28691, 28691, 30739, 30739, -32749, -32749, -30701, -30701, -28653, -28653, -26605, -26605, -24557, -24557, -22509, -22509, -20461, -20461, 8207, 8207, 8207, 8207, 8207, 8207, 8207, 8207, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 72, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 4107, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 298, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 524, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 168, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 460, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 492, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 2059, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232, 232};
        additionalMakeup = new short[]{28679, 28679, 31752, -32759, -31735, -30711, -29687, -28663, 29703, 29703, 30727, 30727, -27639, -26615, -25591, -24567};
        initBlack = new short[]{3226, 6412, 200, 168, 38, 38, 134, 134, 100, 100, 100, 100, 68, 68, 68, 68};
        twoBitBlack = new short[]{292, 260, 226, 226};
        black = new short[]{62, 62, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 588, 588, 588, 588, 588, 588, 588, 588, 1680, 1680, 20499, 22547, 24595, 26643, 1776, 1776, 1808, 1808, -24557, -22509, -20461, -18413, 1904, 1904, 1936, 1936, -16365, -14317, 782, 782, 782, 782, 814, 814, 814, 814, -12269, -10221, 10257, 10257, 12305, 12305, 14353, 14353, 16403, 18451, 1712, 1712, 1744, 1744, 28691, 30739, -32749, -30701, -28653, -26605, 2061, 2061, 2061, 2061, 2061, 2061, 2061, 2061, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 750, 750, 750, 750, 1616, 1616, 1648, 1648, 1424, 1424, 1456, 1456, 1488, 1488, 1520, 1520, 1840, 1840, 1872, 1872, 1968, 1968, 8209, 8209, 524, 524, 524, 524, 524, 524, 524, 524, 556, 556, 556, 556, 556, 556, 556, 556, 1552, 1552, 1584, 1584, 2000, 2000, 2032, 2032, 976, 976, 1008, 1008, 1040, 1040, 1072, 1072, 1296, 1296, 1328, 1328, 718, 718, 718, 718, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 4113, 4113, 6161, 6161, 848, 848, 880, 880, 912, 912, 944, 944, 622, 622, 622, 622, 654, 654, 654, 654, 1104, 1104, 1136, 1136, 1168, 1168, 1200, 1200, 1232, 1232, 1264, 1264, 686, 686, 686, 686, 1360, 1360, 1392, 1392, 12, 12, 12, 12, 12, 12, 12, 12, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390};
        twoDCodes = new byte[]{80, 88, 23, 71, 30, 30, 62, 62, 4, 4, 4, 4, 4, 4, 4, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41};
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private int decodeBlackCodeWord() {
        int n;
        int n2;
        int n3;
        int n4;
        block6 : {
            n2 = 0;
            n4 = 0;
            while (n2 == 0) {
                n = this.nextLesserThan8Bits(4);
                n3 = (n = initBlack[n]) >>> 5 & 2047;
                if (n3 == 100) {
                    n = this.nextNBits(9);
                    n3 = black[n];
                    int n5 = n3 >>> 1 & 15;
                    if (n5 == 12) {
                        this.updatePointer(5);
                        n = this.nextLesserThan8Bits(4);
                        n = additionalMakeup[n];
                        n4 += n >>> 4 & 4095;
                        this.updatePointer(4 - (n >>> 1 & 7));
                        continue;
                    }
                    if (n5 == 15) {
                        throw new RuntimeException("Error 2");
                    }
                    n = n4 + (n3 >>> 5 & 2047);
                    this.updatePointer(9 - n5);
                    n4 = n;
                    if ((n3 & 1) == 0) return n;
                    continue;
                }
                break block6;
            }
            return n4;
        }
        if (n3 == 200) {
            n2 = this.nextLesserThan8Bits(2);
            n2 = twoBitBlack[n2];
            n4 += n2 >>> 5 & 2047;
            this.updatePointer(2 - (n2 >>> 1 & 15));
            do {
                return n4;
                break;
            } while (true);
        }
        n4 += n3;
        this.updatePointer(4 - (n >>> 1 & 15));
        return n4;
    }

    private int decodeWhiteCodeWord() {
        boolean bl = true;
        int n = 0;
        while (bl) {
            int n2 = this.nextNBits(10);
            int n3 = white[n2];
            int n4 = n3 >>> 1 & 15;
            if (n4 == 12) {
                n3 = this.nextLesserThan8Bits(2);
                n2 = additionalMakeup[n3 | n2 << 2 & 12];
                n += n2 >>> 4 & 4095;
                this.updatePointer(4 - (n2 >>> 1 & 7));
                continue;
            }
            if (n4 == 0) {
                throw new RuntimeException("Error 0");
            }
            if (n4 == 15) {
                throw new RuntimeException("Error 1");
            }
            n2 = n + (n3 >>> 5 & 2047);
            this.updatePointer(10 - n4);
            n = n2;
            if ((n3 & 1) != 0) continue;
            bl = false;
            n = n2;
        }
        return n;
    }

    private int findNextLine() {
        int n = this.data.length * 8 - 1;
        int n2 = this.bytePointer * 8 + this.bitPointer;
        while (n2 <= n - 12) {
            int n3;
            int n4 = this.nextNBits(12);
            for (n3 = n2 + 12; n4 != 1 && n3 < n; ++n3) {
                n4 = (n4 & 2047) << 1 | this.nextLesserThan8Bits(1) & 1;
            }
            n2 = n3;
            if (n4 != 1) continue;
            if (this.oneD == 1) {
                n2 = n3;
                if (n3 >= n) continue;
                return this.nextLesserThan8Bits(1);
            }
            return 1;
        }
        throw new RuntimeException();
    }

    private void getNextChangingElement(int n, boolean bl, int[] arrn) {
        int[] arrn2 = this.prevChangingElems;
        int n2 = this.changingElemSize;
        int n3 = this.lastChangingElement > 0 ? this.lastChangingElement - 1 : 0;
        n3 = bl ? (n3 &= -2) : (n3 |= 1);
        while (n3 < n2) {
            int n4 = arrn2[n3];
            if (n4 > n) {
                this.lastChangingElement = n3;
                arrn[0] = n4;
                break;
            }
            n3 += 2;
        }
        if ((n = n3 + 1) < n2) {
            arrn[1] = arrn2[n];
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private int nextLesserThan8Bits(int var1_1) {
        block4 : {
            block3 : {
                var2_2 = this.data.length - 1;
                var4_3 = this.bytePointer;
                if (this.fillOrder != 1) break block3;
                var3_4 = this.data[var4_3];
                if (var4_3 == var2_2) ** GOTO lbl-1000
                var2_2 = this.data[var4_3 + 1];
                break block4;
            }
            if (this.fillOrder != 2) throw new RuntimeException("Invalid FillOrder");
            var3_4 = TIFFFaxDecompressor.flipTable[this.data[var4_3] & 255];
            if (var4_3 == var2_2) lbl-1000: // 2 sources:
            {
                var2_2 = 0;
            } else {
                var2_2 = TIFFFaxDecompressor.flipTable[this.data[var4_3 + 1] & 255];
            }
        }
        var6_5 = 8 - this.bitPointer;
        var4_3 = var1_1 - var6_5;
        var5_6 = var6_5 - var1_1;
        if (var5_6 >= 0) {
            var2_2 = (TIFFFaxDecompressor.table1[var6_5] & var3_4) >>> var5_6;
            this.bitPointer += var1_1;
            var1_1 = var2_2;
            if (this.bitPointer != 8) return var1_1;
            this.bitPointer = 0;
            ++this.bytePointer;
            return var2_2;
        }
        var1_1 = TIFFFaxDecompressor.table1[var6_5];
        var5_6 = - var5_6;
        var1_1 = (var2_2 & TIFFFaxDecompressor.table2[var4_3]) >>> 8 - var4_3 | (var1_1 & var3_4) << var5_6;
        ++this.bytePointer;
        this.bitPointer = var4_3;
        return var1_1;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private int nextNBits(int var1_1) {
        block9 : {
            block10 : {
                block7 : {
                    block6 : {
                        block8 : {
                            var3_2 = this.data.length - 1;
                            var4_3 = this.bytePointer;
                            if (this.fillOrder != 1) break block6;
                            var2_4 = this.data[var4_3];
                            if (var4_3 == var3_2) break block7;
                            var5_5 = var4_3 + 1;
                            if (var5_5 != var3_2) break block8;
                            var3_2 = this.data[var5_5];
                            ** GOTO lbl25
                        }
                        var3_2 = this.data[var5_5];
                        var4_3 = this.data[var4_3 + 2];
                        break block9;
                    }
                    if (this.fillOrder != 2) throw new RuntimeException("Invalid FillOrder");
                    var2_4 = TIFFFaxDecompressor.flipTable[this.data[var4_3] & 255];
                    if (var4_3 != var3_2) break block10;
                }
                var3_2 = 0;
                ** GOTO lbl25
            }
            var5_5 = var4_3 + 1;
            if (var5_5 == var3_2) {
                var3_2 = TIFFFaxDecompressor.flipTable[this.data[var5_5] & 255];
lbl25: // 3 sources:
                var4_3 = 0;
            } else {
                var3_2 = TIFFFaxDecompressor.flipTable[this.data[var5_5] & 255];
                var4_3 = TIFFFaxDecompressor.flipTable[this.data[var4_3 + 2] & 255];
            }
        }
        var7_6 = 8 - this.bitPointer;
        var6_7 = var1_1 - var7_6;
        if (var6_7 > 8) {
            var1_1 = var6_7 - 8;
            var5_5 = 8;
        } else {
            var5_5 = var6_7;
            var1_1 = 0;
        }
        ++this.bytePointer;
        var7_6 = TIFFFaxDecompressor.table1[var7_6];
        var3_2 = (var3_2 & TIFFFaxDecompressor.table2[var5_5]) >>> 8 - var5_5;
        if (var1_1 != 0) {
            var3_2 = var3_2 << var1_1 | (var4_3 & TIFFFaxDecompressor.table2[var1_1]) >>> 8 - var1_1;
            ++this.bytePointer;
            this.bitPointer = var1_1;
            var1_1 = var3_2;
            return (var2_4 & var7_6) << var6_7 | var1_1;
        }
        if (var5_5 == 8) {
            this.bitPointer = 0;
            ++this.bytePointer;
            var1_1 = var3_2;
            return (var2_4 & var7_6) << var6_7 | var1_1;
        }
        this.bitPointer = var5_5;
        var1_1 = var3_2;
        return (var2_4 & var7_6) << var6_7 | var1_1;
    }

    private void setToBlack(int n, int n2) {
        int n3 = n + this.lineBitNum;
        int n4 = n2 + n3;
        int n5 = n3 >> 3;
        n2 = n3 & 7;
        n = n3;
        if (n2 > 0) {
            n2 = 1 << 7 - n2;
            byte by = this.buffer[n5];
            for (n = n3; n2 > 0 && n < n4; n2 >>= 1, ++n) {
                by = (byte)(by | n2);
            }
            this.buffer[n5] = by;
        }
        n2 = n >> 3;
        do {
            if (n >= n4 - 7) break;
            this.buffer[n2] = -1;
            n += 8;
            ++n2;
        } while (true);
        for (n3 = n; n3 < n4; ++n3) {
            n = n3 >> 3;
            byte[] arrby = this.buffer;
            arrby[n] = (byte)(arrby[n] | 1 << 7 - (n3 & 7));
        }
    }

    private void updatePointer(int n) {
        int n2 = n;
        if (n > 8) {
            this.bytePointer -= n / 8;
            n2 = n % 8;
        }
        if ((n = this.bitPointer - n2) < 0) {
            --this.bytePointer;
            this.bitPointer = n + 8;
            return;
        }
        this.bitPointer = n;
    }

    public void SetOptions(int n, int n2, int n3, int n4) {
        this.fillOrder = n;
        this.compression = n2;
        this.t4Options = n3;
        this.t6Options = n4;
        this.oneD = n3 & 1;
        this.uncompressedMode = (n3 & 2) >> 1;
        this.fillBits = (n3 & 4) >> 2;
    }

    /*
     * Enabled aggressive block sorting
     */
    public void decodeNextScanline() {
        int n;
        int n2;
        int[] arrn;
        block18 : {
            int n3;
            this.changingElemSize = 0;
            int n4 = 0;
            int n5 = 1;
            do {
                int n6;
                n = n4;
                if (n4 >= this.w) break block18;
                n = n4;
                n3 = n5;
                while (n3 != 0 && n < this.w) {
                    n2 = this.nextNBits(10);
                    n5 = white[n2];
                    n6 = n5 >>> 1 & 15;
                    if (n6 == 12) {
                        n5 = this.nextLesserThan8Bits(2);
                        n2 = additionalMakeup[12 & n2 << 2 | n5];
                        n += n2 >>> 4 & 4095;
                        this.updatePointer(4 - (n2 >>> 1 & 7));
                        continue;
                    }
                    if (n6 == 0) {
                        ++this.fails;
                        continue;
                    }
                    if (n6 == 15) {
                        ++this.fails;
                        return;
                    }
                    n2 = n + (n5 >>> 5 & 2047);
                    this.updatePointer(10 - n6);
                    n = n2;
                    if ((n5 & 1) != 0) continue;
                    arrn = this.currChangingElems;
                    n = this.changingElemSize;
                    this.changingElemSize = n + 1;
                    arrn[n] = n2;
                    n3 = 0;
                    n = n2;
                }
                if (n == this.w) {
                    n2 = n - n4;
                    if (n3 != 0 && n2 != 0 && n2 % 64 == 0 && this.nextNBits(8) != 53) {
                        ++this.fails;
                        this.updatePointer(8);
                    }
                    break block18;
                }
                n2 = n;
                while (n3 == 0 && n2 < this.w) {
                    n4 = this.nextLesserThan8Bits(4);
                    n5 = (n4 = initBlack[n4]) >>> 5 & 2047;
                    if (n5 == 100) {
                        n4 = this.nextNBits(9);
                        n5 = black[n4];
                        n6 = n5 >>> 1 & 15;
                        n4 = n5 >>> 5 & 2047;
                        if (n6 == 12) {
                            this.updatePointer(5);
                            n4 = this.nextLesserThan8Bits(4);
                            n4 = additionalMakeup[n4];
                            n5 = n4 >>> 4 & 4095;
                            this.setToBlack(n2, n5);
                            n2 += n5;
                            this.updatePointer(4 - (n4 >>> 1 & 7));
                            continue;
                        }
                        if (n6 == 15) {
                            ++this.fails;
                            return;
                        }
                        this.setToBlack(n2, n4);
                        n4 = n2 + n4;
                        this.updatePointer(9 - n6);
                        n2 = n4;
                        if ((n5 & 1) != 0) continue;
                        arrn = this.currChangingElems;
                        n2 = this.changingElemSize;
                        this.changingElemSize = n2 + 1;
                        arrn[n2] = n4;
                        n2 = n4;
                    } else if (n5 == 200) {
                        n4 = this.nextLesserThan8Bits(2);
                        n4 = twoBitBlack[n4];
                        n3 = n4 >>> 5 & 2047;
                        this.setToBlack(n2, n3);
                        this.updatePointer(2 - (n4 >>> 1 & 15));
                        arrn = this.currChangingElems;
                        n4 = this.changingElemSize;
                        this.changingElemSize = n4 + 1;
                        arrn[n4] = n2 += n3;
                    } else {
                        this.setToBlack(n2, n5);
                        this.updatePointer(4 - (n4 >>> 1 & 15));
                        arrn = this.currChangingElems;
                        n4 = this.changingElemSize;
                        this.changingElemSize = n4 + 1;
                        arrn[n4] = n2 += n5;
                    }
                    n3 = 1;
                }
                n4 = n2;
                n5 = n3;
            } while (n2 != this.w);
            n4 = n2 - n;
            n = n2;
            if (n3 == 0) {
                n = n2;
                if (n4 != 0) {
                    n = n2;
                    if (n4 % 64 == 0) {
                        n = n2;
                        if (this.nextNBits(10) != 55) {
                            ++this.fails;
                            this.updatePointer(10);
                            n = n2;
                        }
                    }
                }
            }
        }
        arrn = this.currChangingElems;
        n2 = this.changingElemSize;
        this.changingElemSize = n2 + 1;
        arrn[n2] = n;
    }

    public void decodeRLE() {
        for (int i = 0; i < this.h; ++i) {
            this.decodeNextScanline();
            if (this.bitPointer != 0) {
                ++this.bytePointer;
                this.bitPointer = 0;
            }
            this.lineBitNum += this.bitsPerScanline;
        }
    }

    public void decodeRaw(byte[] object, byte[] arrby, int n, int n2) {
        this.buffer = object;
        this.data = arrby;
        this.w = n;
        this.h = n2;
        this.bitsPerScanline = n++;
        this.lineBitNum = 0;
        this.bitPointer = 0;
        this.bytePointer = 0;
        this.prevChangingElems = new int[n];
        this.currChangingElems = new int[n];
        this.fails = 0;
        try {
            if (this.compression == 2) {
                this.decodeRLE();
                return;
            }
            if (this.compression == 3) {
                this.decodeT4();
                return;
            }
            if (this.compression == 4) {
                this.uncompressedMode = (this.t6Options & 2) >> 1;
                this.decodeT6();
                return;
            }
            object = new StringBuilder();
            object.append("Unknown compression type ");
            object.append(this.compression);
            throw new RuntimeException(object.toString());
        }
        catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {
            return;
        }
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void decodeT4() {
        int n3;
        int[] arrn;
        int n;
        int n2;
        block22 : {
            n3 = this.h;
            arrn = new int[2];
            if (this.data.length < 2) {
                throw new RuntimeException("Insufficient data to read initial EOL.");
            }
            if (this.nextNBits(12) != 1) {
                ++this.fails;
            }
            this.updatePointer(12);
            n2 = 0;
            n = -1;
            while (n2 != 1) {
                n2 = this.findNextLine();
                ++n;
            }
            this.decodeNextScanline();
            ++n;
            this.lineBitNum += this.bitsPerScanline;
            break block22;
            catch (Exception exception) {
                throw new RuntimeException("No reference line present.");
            }
        }
        while (n < n3) {
            block20 : {
                int n5;
                int n4;
                block21 : {
                    int n7;
                    int n6;
                    boolean bl;
                    int[] arrn2;
                    block19 : {
                        try {
                            n6 = this.findNextLine();
                            if (n6 == 0) {
                                arrn2 = this.prevChangingElems;
                                this.prevChangingElems = this.currChangingElems;
                                this.currChangingElems = arrn2;
                                this.lastChangingElement = 0;
                                n2 = 0;
                                n7 = -1;
                                bl = true;
                                n5 = 0;
                                break block19;
                            }
                            this.decodeNextScanline();
                            break block20;
                        }
                        catch (Exception exception) {}
                        ++this.fails;
                        return;
                    }
                    do {
                        n4 = n;
                        if (n2 >= this.w) break block21;
                        this.getNextChangingElement(n7, bl, arrn);
                        n4 = arrn[0];
                        n7 = arrn[1];
                        int n8 = this.nextLesserThan8Bits(7);
                        int n9 = twoDCodes[n8] & 255;
                        n8 = (n9 & 120) >>> 3;
                        n9 &= 7;
                        if (n8 == 0) {
                            if (!bl) {
                                this.setToBlack(n2, n7 - n2);
                            }
                            this.updatePointer(7 - n9);
                            n7 = n2 = n7;
                            continue;
                        }
                        if (n8 == 1) {
                            this.updatePointer(7 - n9);
                            if (bl) {
                                n7 = n2 + this.decodeWhiteCodeWord();
                                arrn2 = this.currChangingElems;
                                n2 = n5 + 1;
                                arrn2[n5] = n7;
                                n5 = this.decodeBlackCodeWord();
                                this.setToBlack(n7, n5);
                                arrn2 = this.currChangingElems;
                                n5 = n2 + 1;
                                arrn2[n2] = n7 += n5;
                            } else {
                                n7 = this.decodeBlackCodeWord();
                                this.setToBlack(n2, n7);
                                n7 = n2 + n7;
                                arrn2 = this.currChangingElems;
                                n2 = n5 + 1;
                                arrn2[n5] = n7;
                                arrn2 = this.currChangingElems;
                                n5 = n2 + 1;
                                arrn2[n2] = n7 += this.decodeWhiteCodeWord();
                            }
                            n2 = n7;
                            continue;
                        }
                        if (n8 > 8) break;
                        this.currChangingElems[n5] = n7 = n4 + (n8 - 5);
                        if (!bl) {
                            this.setToBlack(n2, n7 - n2);
                        }
                        bl ^= true;
                        this.updatePointer(7 - n9);
                        n2 = n7;
                        ++n5;
                    } while (true);
                    ++this.fails;
                    n7 = 0;
                    n4 = n6;
                    while (n4 != 1) {
                        n4 = this.findNextLine();
                        ++n7;
                    }
                    n4 = n + (n7 - 1);
                    this.updatePointer(13);
                }
                this.currChangingElems[n5] = n2;
                this.changingElemSize = n5 + 1;
                n = n4;
            }
            this.lineBitNum += this.bitsPerScanline;
            ++n;
        }
        return;
        catch (Exception exception) {
            return;
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Converted monitor instructions to comments
     * Lifted jumps to return sites
     */
    public void decodeT6() {
        // MONITORENTER : this
        var10_1 = this.h;
        var13_2 = new int[2];
        var14_3 = this.currChangingElems;
        var1_4 = this.changingElemSize = 0;
        this.changingElemSize = var1_4 + 1;
        var14_3[var1_4] = this.w;
        var1_4 = this.changingElemSize;
        this.changingElemSize = var1_4 + 1;
        var14_3[var1_4] = this.w;
        var6_5 = 0;
        block14 : do {
            if (var6_5 >= var10_1) {
                // MONITOREXIT : this
                return;
            }
            var14_3 = this.prevChangingElems;
            this.prevChangingElems = this.currChangingElems;
            this.currChangingElems = var14_3;
            this.lastChangingElement = 0;
            var2_6 = 0;
            var7_10 = -1;
            var11_13 = true;
            var1_4 = 0;
            do {
                block44 : {
                    block40 : {
                        block42 : {
                            block38 : {
                                block43 : {
                                    block41 : {
                                        block39 : {
                                            if (var2_6 >= this.w) break block38;
                                            this.getNextChangingElement(var7_10, var11_13, var13_2);
                                            var3_7 = var13_2[0];
                                            var4_8 = var13_2[1];
                                            var5_9 = this.nextLesserThan8Bits(7);
                                            var5_9 = TIFFFaxDecompressor.twoDCodes[var5_9] & 255;
                                            var8_11 = (var5_9 & 120) >>> 3;
                                            var5_9 &= 7;
                                            if (var8_11 != 0) break block39;
                                            var3_7 = var4_8;
                                            if (!var11_13) {
                                                var3_7 = var4_8;
                                                if (var4_8 > this.w) {
                                                    var3_7 = this.w;
                                                }
                                                this.setToBlack(var2_6, var3_7 - var2_6);
                                            }
                                            var2_6 = var3_7;
                                            this.updatePointer(7 - var5_9);
                                            break block40;
                                        }
                                        if (var8_11 != 1) break block41;
                                        this.updatePointer(7 - var5_9);
                                        if (var11_13) {
                                            var4_8 = var2_6 + this.decodeWhiteCodeWord();
                                            var3_7 = var1_4 + 1;
                                            var14_3[var1_4] = var4_8;
                                            var1_4 = var2_6 = this.decodeBlackCodeWord();
                                            if (var2_6 > this.w - var4_8) {
                                                var1_4 = this.w - var4_8;
                                            }
                                            this.setToBlack(var4_8, var1_4);
                                            var1_4 = var4_8 + var1_4;
                                            var2_6 = var3_7 + 1;
                                            var14_3[var3_7] = var1_4;
                                        } else {
                                            var3_7 = var4_8 = this.decodeBlackCodeWord();
                                            if (var4_8 > this.w - var2_6) {
                                                var3_7 = this.w - var2_6;
                                            }
                                            this.setToBlack(var2_6, var3_7);
                                            var3_7 = var1_4 + 1;
                                            var14_3[var1_4] = var2_6 += var3_7;
                                            var1_4 = var2_6 + this.decodeWhiteCodeWord();
                                            var2_6 = var3_7 + 1;
                                            var14_3[var3_7] = var1_4;
                                        }
                                        break block42;
                                    }
                                    if (var8_11 > 8) break block43;
                                    var14_3[var1_4] = var4_8 = var3_7 + (var8_11 - 5);
                                    var3_7 = var4_8;
                                    if (!var11_13) {
                                        var3_7 = var4_8;
                                        if (var4_8 > this.w) {
                                            var3_7 = this.w;
                                        }
                                        this.setToBlack(var2_6, var3_7 - var2_6);
                                    }
                                    var2_6 = var3_7;
                                    var11_13 ^= true;
                                    this.updatePointer(7 - var5_9);
                                    ++var1_4;
                                    break block40;
                                }
                                var4_8 = var2_6;
                                var5_9 = var7_10;
                                var12_14 = var11_13;
                                var3_7 = var1_4;
                                if (var8_11 != 11) break block44;
                                this.nextLesserThan8Bits(3);
                                var4_8 = 0;
                                var3_7 = 0;
                                ** GOTO lbl159
                            }
                            if (var1_4 <= this.w) {
                                var3_7 = var1_4 + 1;
                                var14_3[var1_4] = var2_6;
                                var1_4 = var3_7;
                            }
                            this.changingElemSize = var1_4;
                            this.lineBitNum += this.bitsPerScanline;
                            ++var6_5;
                            continue block14;
                        }
                        var3_7 = var2_6;
                        var2_6 = var1_4;
                        var1_4 = var3_7;
                    }
                    var4_8 = var2_6;
                    var3_7 = var1_4;
                    var12_14 = var11_13;
                    var5_9 = var2_6;
                    break block44;
lbl-1000: // 2 sources:
                    {
                        if (this.nextLesserThan8Bits(1) != 1) {
                            ++var5_9;
                            continue;
                        }
                        var8_11 = var4_8;
                        var3_7 = var5_9;
                        var9_12 = var2_6;
                        var12_14 = var11_13;
                        var4_8 = var1_4;
                        if (var5_9 > 5) {
                            var3_7 = var5_9 - 6;
                            if (!var11_13 && var3_7 > 0) {
                                var4_8 = var1_4 + 1;
                                var14_3[var1_4] = var2_6;
                                var1_4 = var4_8;
                            }
                            var9_12 = var2_6 + var3_7;
                            if (var3_7 > 0) {
                                var11_13 = true;
                            }
                            if (this.nextLesserThan8Bits(1) == 0) {
                                var2_6 = var1_4;
                                if (!var11_13) {
                                    var14_3[var1_4] = var9_12;
                                    var2_6 = var1_4 + 1;
                                }
                                var11_13 = true;
                                var4_8 = var2_6;
                            } else {
                                var2_6 = var1_4;
                                if (var11_13) {
                                    var14_3[var1_4] = var9_12;
                                    var2_6 = var1_4 + 1;
                                }
                                var11_13 = false;
                                var4_8 = var2_6;
                            }
                            var8_11 = 1;
                            var12_14 = var11_13;
                        }
                        if (var3_7 == 5) {
                            var1_4 = var4_8;
                            if (!var12_14) {
                                var14_3[var4_8] = var9_12;
                                var1_4 = var4_8 + 1;
                            }
                            var2_6 = var9_12 + var3_7;
                            var11_13 = true;
                            var4_8 = var8_11;
                        } else {
                            var14_3[var4_8] = var1_4 = var9_12 + var3_7;
                            this.setToBlack(var1_4, 1);
                            var2_6 = var1_4 + 1;
                            var1_4 = var4_8 + 1;
                            var11_13 = false;
                            var4_8 = var8_11;
                        }
lbl159: // 3 sources:
                        if (var4_8 != 0) break;
                        var5_9 = var3_7;
                        ** while (true)
                    }
                    var4_8 = var2_6;
                    var5_9 = var7_10;
                    var12_14 = var11_13;
                    var3_7 = var1_4;
                }
                var2_6 = var4_8;
                var7_10 = var5_9;
                var11_13 = var12_14;
                var1_4 = var3_7;
            } while (true);
            break;
        } while (true);
    }
}

