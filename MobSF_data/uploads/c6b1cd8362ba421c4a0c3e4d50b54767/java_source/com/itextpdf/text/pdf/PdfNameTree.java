/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import java.io.IOException;
import java.io.Serializable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Set;

public class PdfNameTree {
    private static final int leafSize = 64;

    private static PdfString iterateItems(PdfDictionary pdfObject, HashMap<String, PdfObject> hashMap, PdfString pdfObject2) {
        block6 : {
            int n;
            block5 : {
                PdfArray pdfArray = (PdfArray)PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.NAMES));
                int n2 = 0;
                if (pdfArray == null) break block5;
                for (n = 0; n < pdfArray.size(); ++n) {
                    if (pdfObject2 == null) {
                        n2 = n + 1;
                        PdfString pdfString = (PdfString)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(n));
                        pdfObject = pdfObject2;
                        pdfObject2 = pdfString;
                        n = n2;
                    } else {
                        pdfObject = null;
                    }
                    if (n < pdfArray.size()) {
                        hashMap.put(PdfEncodings.convertToString(pdfObject2.getBytes(), null), pdfArray.getPdfObject(n));
                        pdfObject2 = pdfObject;
                        continue;
                    }
                    return pdfObject2;
                }
                break block6;
            }
            if ((pdfObject = (PdfArray)PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.KIDS))) == null) break block6;
            for (n = n2; n < pdfObject.size(); ++n) {
                pdfObject2 = PdfNameTree.iterateItems((PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject.getPdfObject(n)), hashMap, pdfObject2);
            }
        }
        return null;
    }

    public static HashMap<String, PdfObject> readTree(PdfDictionary pdfDictionary) {
        HashMap<String, PdfObject> hashMap = new HashMap<String, PdfObject>();
        if (pdfDictionary != null) {
            PdfNameTree.iterateItems(pdfDictionary, hashMap, null);
        }
        return hashMap;
    }

    public static PdfDictionary writeTree(HashMap<String, ? extends PdfObject> serializable, PdfWriter object) throws IOException {
        PdfObject pdfObject;
        int n;
        int n2;
        if (serializable.isEmpty()) {
            return null;
        }
        Object[] arrobject = new String[serializable.size()];
        arrobject = serializable.keySet().toArray(arrobject);
        Arrays.sort(arrobject);
        int n3 = arrobject.length;
        int n4 = 64;
        if (n3 <= 64) {
            object = new PdfDictionary();
            PdfArray pdfArray = new PdfArray();
            for (n3 = 0; n3 < arrobject.length; ++n3) {
                pdfArray.add(new PdfString((String)arrobject[n3], null));
                pdfArray.add(serializable.get(arrobject[n3]));
            }
            object.put(PdfName.NAMES, pdfArray);
            return object;
        }
        PdfIndirectReference[] arrpdfIndirectReference = new PdfIndirectReference[(arrobject.length + 64 - 1) / 64];
        for (n3 = 0; n3 < arrpdfIndirectReference.length; ++n3) {
            n = Math.min(n2 + 64, arrobject.length);
            pdfObject = new PdfDictionary();
            PdfArray pdfArray = new PdfArray();
            pdfArray.add(new PdfString((String)arrobject[n2], null));
            pdfArray.add(new PdfString((String)arrobject[n - 1], null));
            pdfObject.put(PdfName.LIMITS, pdfArray);
            pdfArray = new PdfArray();
            for (n2 = n3 * 64; n2 < n; ++n2) {
                pdfArray.add(new PdfString((String)arrobject[n2], null));
                pdfArray.add((PdfObject)serializable.get(arrobject[n2]));
            }
            pdfObject.put(PdfName.NAMES, pdfArray);
            arrpdfIndirectReference[n3] = object.addToBody(pdfObject).getIndirectReference();
        }
        n3 = arrpdfIndirectReference.length;
        n2 = 64;
        do {
            if (n3 <= n4) {
                serializable = new PdfArray();
                for (n2 = 0; n2 < n3; ++n2) {
                    serializable.add(arrpdfIndirectReference[n2]);
                }
                object = new PdfDictionary();
                object.put(PdfName.KIDS, (PdfObject)serializable);
                return object;
            }
            n = n2 * 64;
            int n5 = (arrobject.length + n - 1) / n;
            n2 = 0;
            while (n2 < n5) {
                int n6 = Math.min(n4 + 64, n3);
                serializable = new PdfDictionary();
                pdfObject = new PdfArray();
                pdfObject.add(new PdfString((String)arrobject[n2 * n], null));
                int n7 = n2 + 1;
                pdfObject.add(new PdfString((String)arrobject[Math.min(n7 * n, arrobject.length) - 1], null));
                serializable.put(PdfName.LIMITS, pdfObject);
                pdfObject = new PdfArray();
                for (n4 = n2 * 64; n4 < n6; ++n4) {
                    pdfObject.add(arrpdfIndirectReference[n4]);
                }
                serializable.put(PdfName.KIDS, pdfObject);
                arrpdfIndirectReference[n2] = object.addToBody((PdfObject)serializable).getIndirectReference();
                n2 = n7;
                n4 = 64;
            }
            n3 = n5;
            n2 = n;
        } while (true);
    }
}

