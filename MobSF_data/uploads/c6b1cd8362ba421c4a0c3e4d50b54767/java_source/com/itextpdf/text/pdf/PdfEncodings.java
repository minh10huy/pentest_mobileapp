/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.pdf.ExtraEncoding;
import com.itextpdf.text.pdf.IntHashtable;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.nio.Buffer;
import java.nio.ByteBuffer;
import java.nio.CharBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.nio.charset.CodingErrorAction;
import java.util.HashMap;

public class PdfEncodings {
    static HashMap<String, ExtraEncoding> extraEncodings;
    static final IntHashtable pdfEncoding;
    static final char[] pdfEncodingByteToChar;
    static final IntHashtable winansi;
    static final char[] winansiByteToChar;

    static {
        int n;
        winansiByteToChar = new char[]{'\u0000', '\u0001', '\u0002', '\u0003', '\u0004', '\u0005', '\u0006', '\u0007', '\b', '\t', '\n', '\u000b', '\f', '\r', '\u000e', '\u000f', '\u0010', '\u0011', '\u0012', '\u0013', '\u0014', '\u0015', '\u0016', '\u0017', '\u0018', '\u0019', '\u001a', '\u001b', '\u001c', '\u001d', '\u001e', '\u001f', ' ', '!', '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '', '\u20ac', '\ufffffffd', '\u201a', '\u0192', '\u201e', '\u2026', '\u2020', '\u2021', '\u02c6', '\u2030', '\u0160', '\u2039', '\u0152', '\ufffffffd', '\u017d', '\ufffffffd', '\ufffffffd', '\u2018', '\u2019', '\u201c', '\u201d', '\u2022', '\u2013', '\u2014', '\u02dc', '\u2122', '\u0161', '\u203a', '\u0153', '\ufffffffd', '\u017e', '\u0178', '\u00a0', '\u00a1', '\u00a2', '\u00a3', '\u00a4', '\u00a5', '\u00a6', '\u00a7', '\u00a8', '\u00a9', '\u00aa', '\u00ab', '\u00ac', '\u00ad', '\u00ae', '\u00af', '\u00b0', '\u00b1', '\u00b2', '\u00b3', '\u00b4', '\u00b5', '\u00b6', '\u00b7', '\u00b8', '\u00b9', '\u00ba', '\u00bb', '\u00bc', '\u00bd', '\u00be', '\u00bf', '\u00c0', '\u00c1', '\u00c2', '\u00c3', '\u00c4', '\u00c5', '\u00c6', '\u00c7', '\u00c8', '\u00c9', '\u00ca', '\u00cb', '\u00cc', '\u00cd', '\u00ce', '\u00cf', '\u00d0', '\u00d1', '\u00d2', '\u00d3', '\u00d4', '\u00d5', '\u00d6', '\u00d7', '\u00d8', '\u00d9', '\u00da', '\u00db', '\u00dc', '\u00dd', '\u00de', '\u00df', '\u00e0', '\u00e1', '\u00e2', '\u00e3', '\u00e4', '\u00e5', '\u00e6', '\u00e7', '\u00e8', '\u00e9', '\u00ea', '\u00eb', '\u00ec', '\u00ed', '\u00ee', '\u00ef', '\u00f0', '\u00f1', '\u00f2', '\u00f3', '\u00f4', '\u00f5', '\u00f6', '\u00f7', '\u00f8', '\u00f9', '\u00fa', '\u00fb', '\u00fc', '\u00fd', '\u00fe', '\u00ff'};
        pdfEncodingByteToChar = new char[]{'\u0000', '\u0001', '\u0002', '\u0003', '\u0004', '\u0005', '\u0006', '\u0007', '\b', '\t', '\n', '\u000b', '\f', '\r', '\u000e', '\u000f', '\u0010', '\u0011', '\u0012', '\u0013', '\u0014', '\u0015', '\u0016', '\u0017', '\u0018', '\u0019', '\u001a', '\u001b', '\u001c', '\u001d', '\u001e', '\u001f', ' ', '!', '\"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_', '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', '', '\u2022', '\u2020', '\u2021', '\u2026', '\u2014', '\u2013', '\u0192', '\u2044', '\u2039', '\u203a', '\u2212', '\u2030', '\u201e', '\u201c', '\u201d', '\u2018', '\u2019', '\u201a', '\u2122', '\ufffffb01', '\ufffffb02', '\u0141', '\u0152', '\u0160', '\u0178', '\u017d', '\u0131', '\u0142', '\u0153', '\u0161', '\u017e', '\ufffffffd', '\u20ac', '\u00a1', '\u00a2', '\u00a3', '\u00a4', '\u00a5', '\u00a6', '\u00a7', '\u00a8', '\u00a9', '\u00aa', '\u00ab', '\u00ac', '\u00ad', '\u00ae', '\u00af', '\u00b0', '\u00b1', '\u00b2', '\u00b3', '\u00b4', '\u00b5', '\u00b6', '\u00b7', '\u00b8', '\u00b9', '\u00ba', '\u00bb', '\u00bc', '\u00bd', '\u00be', '\u00bf', '\u00c0', '\u00c1', '\u00c2', '\u00c3', '\u00c4', '\u00c5', '\u00c6', '\u00c7', '\u00c8', '\u00c9', '\u00ca', '\u00cb', '\u00cc', '\u00cd', '\u00ce', '\u00cf', '\u00d0', '\u00d1', '\u00d2', '\u00d3', '\u00d4', '\u00d5', '\u00d6', '\u00d7', '\u00d8', '\u00d9', '\u00da', '\u00db', '\u00dc', '\u00dd', '\u00de', '\u00df', '\u00e0', '\u00e1', '\u00e2', '\u00e3', '\u00e4', '\u00e5', '\u00e6', '\u00e7', '\u00e8', '\u00e9', '\u00ea', '\u00eb', '\u00ec', '\u00ed', '\u00ee', '\u00ef', '\u00f0', '\u00f1', '\u00f2', '\u00f3', '\u00f4', '\u00f5', '\u00f6', '\u00f7', '\u00f8', '\u00f9', '\u00fa', '\u00fb', '\u00fc', '\u00fd', '\u00fe', '\u00ff'};
        winansi = new IntHashtable();
        pdfEncoding = new IntHashtable();
        extraEncodings = new HashMap();
        int n2 = 128;
        int n3 = 128;
        do {
            if (n3 >= 161) break;
            n = winansiByteToChar[n3];
            if (n != 65533) {
                winansi.put(n, n3);
            }
            ++n3;
        } while (true);
        for (n = n2; n < 161; ++n) {
            n3 = pdfEncodingByteToChar[n];
            if (n3 == 65533) continue;
            pdfEncoding.put(n3, n);
        }
        PdfEncodings.addExtraEncoding("Wingdings", new WingdingsConversion());
        PdfEncodings.addExtraEncoding("Symbol", new SymbolConversion(true));
        PdfEncodings.addExtraEncoding("ZapfDingbats", new SymbolConversion(false));
        PdfEncodings.addExtraEncoding("SymbolTT", new SymbolTTConversion());
        PdfEncodings.addExtraEncoding("Cp437", new Cp437Conversion());
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static void addExtraEncoding(String string2, ExtraEncoding extraEncoding) {
        HashMap<String, ExtraEncoding> hashMap = extraEncodings;
        synchronized (hashMap) {
            HashMap hashMap2 = (HashMap)extraEncodings.clone();
            hashMap2.put(string2.toLowerCase(), extraEncoding);
            extraEncodings = hashMap2;
            return;
        }
    }

    public static final byte[] convertToBytes(char n, String object) {
        if (object != null && object.length() != 0) {
            Object object2 = extraEncodings.get(object.toLowerCase());
            if (object2 != null && (object2 = object2.charToByte((char)n, (String)object)) != null) {
                return object2;
            }
            object2 = null;
            if (object.equals("Cp1252")) {
                object2 = winansi;
            } else if (object.equals("PDF")) {
                object2 = pdfEncoding;
            }
            if (object2 != null) {
                int n2 = n;
                if (n >= 128) {
                    n2 = n > 160 && n <= 255 ? n : object2.get(n);
                }
                if (n2 != 0) {
                    return new byte[]{(byte)n2};
                }
                return new byte[0];
            }
            if (object.equals("UnicodeBig")) {
                return new byte[]{-2, -1, (byte)(n >> 8), (byte)(n & 255)};
            }
            try {
                object = Charset.forName((String)object).newEncoder();
                object.onUnmappableCharacter(CodingErrorAction.IGNORE);
                object = object.encode(CharBuffer.wrap(new char[]{n}));
                object.rewind();
                object2 = new byte[object.limit()];
                object.get((byte[])object2);
                return object2;
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
        }
        return new byte[]{(byte)n};
    }

    public static final byte[] convertToBytes(String object, String object2) {
        Object object3 = 0;
        int n = 0;
        if (object == null) {
            return new byte[0];
        }
        if (object2 != null && object2.length() != 0) {
            Object object4 = extraEncodings.get(object2.toLowerCase());
            if (object4 != null && (object4 = object4.charToByte((String)object, (String)object2)) != null) {
                return object4;
            }
            object4 = null;
            if (object2.equals("Cp1252")) {
                object4 = winansi;
            } else if (object2.equals("PDF")) {
                object4 = pdfEncoding;
            }
            if (object4 != null) {
                object2 = object.toCharArray();
                int n2 = ((byte[])object2).length;
                object = new byte[n2];
                object3 = 0;
                for (n = 0; n < n2; ++n) {
                    Object object5;
                    Object object6 = object5 = object2[n];
                    if (object5 >= 128) {
                        object6 = object5 > 160 && object5 <= 255 ? object5 : (Object)object4.get((int)object5);
                    }
                    object5 = object3;
                    if (object6 != false) {
                        object[object3] = (byte)object6;
                        object5 = object3 + 1;
                    }
                    object3 = object5;
                }
                if (object3 == n2) {
                    return object;
                }
                object2 = new byte[object3];
                System.arraycopy(object, 0, object2, 0, object3);
                return object2;
            }
            if (object2.equals("UnicodeBig")) {
                object = object.toCharArray();
                int n3 = ((char[])object).length;
                Object object7 = ((char[])object).length;
                object3 = 2;
                object2 = new byte[object7 * 2 + 2];
                object2[0] = -2;
                object2[1] = -1;
                while (n < n3) {
                    object7 = object[n];
                    int n4 = object3 + 1;
                    object2[object3] = (byte)(object7 >> 8);
                    object3 = n4 + 1;
                    object2[n4] = (byte)(object7 & 255);
                    ++n;
                }
                return object2;
            }
            try {
                object2 = Charset.forName((String)object2).newEncoder();
                object2.onUnmappableCharacter(CodingErrorAction.IGNORE);
                object = object2.encode(CharBuffer.wrap(object.toCharArray()));
                object.rewind();
                object2 = new byte[object.limit()];
                object.get((byte[])object2);
                return object2;
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
        }
        int n5 = object.length();
        object2 = new byte[n5];
        for (n = object3; n < n5; ++n) {
            object2[n] = (byte)object.charAt(n);
        }
        return object2;
    }

    public static final String convertToString(byte[] object, String arrc) {
        if (object == null) {
            return "";
        }
        int n = 0;
        int n2 = 0;
        if (arrc != null && arrc.length() != 0) {
            Object object2 = extraEncodings.get(arrc.toLowerCase());
            if (object2 != null && (object2 = object2.byteToChar((byte[])object, (String)arrc)) != null) {
                return object2;
            }
            object2 = null;
            if (arrc.equals("Cp1252")) {
                object2 = winansiByteToChar;
            } else if (arrc.equals("PDF")) {
                object2 = pdfEncodingByteToChar;
            }
            if (object2 != null) {
                n = ((byte[])object).length;
                arrc = new char[n];
                while (n2 < n) {
                    arrc[n2] = object2[object[n2] & 255];
                    ++n2;
                }
                return new String(arrc);
            }
            try {
                object = new String((byte[])object, (String)arrc);
                return object;
            }
            catch (UnsupportedEncodingException unsupportedEncodingException) {
                throw new ExceptionConverter(unsupportedEncodingException);
            }
        }
        arrc = new char[((byte[])object).length];
        for (n2 = n; n2 < ((byte[])object).length; ++n2) {
            arrc[n2] = (char)(object[n2] & 255);
        }
        return new String(arrc);
    }

    public static boolean isPdfDocEncoding(String string2) {
        if (string2 == null) {
            return true;
        }
        int n = string2.length();
        for (int i = 0; i < n; ++i) {
            char c = string2.charAt(i);
            if (c < '?' || c > '\u00a0' && c <= '\u00ff' || pdfEncoding.containsKey(c)) continue;
            return false;
        }
        return true;
    }

    private static class Cp437Conversion
    implements ExtraEncoding {
        private static IntHashtable c2b = new IntHashtable();
        private static final char[] table = new char[]{'\u00c7', '\u00fc', '\u00e9', '\u00e2', '\u00e4', '\u00e0', '\u00e5', '\u00e7', '\u00ea', '\u00eb', '\u00e8', '\u00ef', '\u00ee', '\u00ec', '\u00c4', '\u00c5', '\u00c9', '\u00e6', '\u00c6', '\u00f4', '\u00f6', '\u00f2', '\u00fb', '\u00f9', '\u00ff', '\u00d6', '\u00dc', '\u00a2', '\u00a3', '\u00a5', '\u20a7', '\u0192', '\u00e1', '\u00ed', '\u00f3', '\u00fa', '\u00f1', '\u00d1', '\u00aa', '\u00ba', '\u00bf', '\u2310', '\u00ac', '\u00bd', '\u00bc', '\u00a1', '\u00ab', '\u00bb', '\u2591', '\u2592', '\u2593', '\u2502', '\u2524', '\u2561', '\u2562', '\u2556', '\u2555', '\u2563', '\u2551', '\u2557', '\u255d', '\u255c', '\u255b', '\u2510', '\u2514', '\u2534', '\u252c', '\u251c', '\u2500', '\u253c', '\u255e', '\u255f', '\u255a', '\u2554', '\u2569', '\u2566', '\u2560', '\u2550', '\u256c', '\u2567', '\u2568', '\u2564', '\u2565', '\u2559', '\u2558', '\u2552', '\u2553', '\u256b', '\u256a', '\u2518', '\u250c', '\u2588', '\u2584', '\u258c', '\u2590', '\u2580', '\u03b1', '\u00df', '\u0393', '\u03c0', '\u03a3', '\u03c3', '\u00b5', '\u03c4', '\u03a6', '\u0398', '\u03a9', '\u03b4', '\u221e', '\u03c6', '\u03b5', '\u2229', '\u2261', '\u00b1', '\u2265', '\u2264', '\u2320', '\u2321', '\u00f7', '\u2248', '\u00b0', '\u2219', '\u00b7', '\u221a', '\u207f', '\u00b2', '\u25a0', '\u00a0'};

        static {
            for (int i = 0; i < table.length; ++i) {
                c2b.put(table[i], i + 128);
            }
        }

        private Cp437Conversion() {
        }

        @Override
        public String byteToChar(byte[] arrby, String arrc) {
            int n = arrby.length;
            arrc = new char[n];
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                int n3;
                int n4 = arrby[i] & 255;
                if (n4 < 32) continue;
                if (n4 < 128) {
                    n3 = n2 + 1;
                    arrc[n2] = (char)n4;
                    n2 = n3;
                    continue;
                }
                char c = table[n4 - 128];
                n3 = n2 + 1;
                arrc[n2] = c;
                n2 = n3;
            }
            return new String(arrc, 0, n2);
        }

        @Override
        public byte[] charToByte(char c, String string2) {
            if (c < '?') {
                return new byte[]{(byte)c};
            }
            byte by = (byte)c2b.get(c);
            if (by != 0) {
                return new byte[]{by};
            }
            return new byte[0];
        }

        /*
         * Enabled aggressive block sorting
         */
        @Override
        public byte[] charToByte(String arrby, String arrc) {
            arrc = arrby.toCharArray();
            arrby = new byte[arrc.length];
            int n = arrc.length;
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                int n3;
                block7 : {
                    block6 : {
                        char c;
                        block5 : {
                            c = arrc[i];
                            if (c >= '?') break block5;
                            n3 = n2 + 1;
                            arrby[n2] = (byte)c;
                            n2 = n3;
                            break block6;
                        }
                        byte by = (byte)c2b.get(c);
                        n3 = n2;
                        if (by == 0) break block7;
                        n3 = n2 + 1;
                        arrby[n2] = by;
                        n2 = n3;
                    }
                    n3 = n2;
                }
                n2 = n3;
            }
            if (n2 == n) {
                return arrby;
            }
            arrc = new byte[n2];
            System.arraycopy(arrby, 0, arrc, 0, n2);
            return arrc;
        }
    }

    private static class SymbolConversion
    implements ExtraEncoding {
        private static final IntHashtable t1;
        private static final IntHashtable t2;
        private static final char[] table1;
        private static final char[] table2;
        private final char[] byteToChar;
        private IntHashtable translation;

        static {
            int n;
            t1 = new IntHashtable();
            t2 = new IntHashtable();
            table1 = new char[]{'\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', ' ', '!', '\u2200', '#', '\u2203', '%', '&', '\u220b', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '\u2245', '\u0391', '\u0392', '\u03a7', '\u0394', '\u0395', '\u03a6', '\u0393', '\u0397', '\u0399', '\u03d1', '\u039a', '\u039b', '\u039c', '\u039d', '\u039f', '\u03a0', '\u0398', '\u03a1', '\u03a3', '\u03a4', '\u03a5', '\u03c2', '\u03a9', '\u039e', '\u03a8', '\u0396', '[', '\u2234', ']', '\u22a5', '_', '\u0305', '\u03b1', '\u03b2', '\u03c7', '\u03b4', '\u03b5', '\u03d5', '\u03b3', '\u03b7', '\u03b9', '\u03c6', '\u03ba', '\u03bb', '\u03bc', '\u03bd', '\u03bf', '\u03c0', '\u03b8', '\u03c1', '\u03c3', '\u03c4', '\u03c5', '\u03d6', '\u03c9', '\u03be', '\u03c8', '\u03b6', '{', '|', '}', '~', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u20ac', '\u03d2', '\u2032', '\u2264', '\u2044', '\u221e', '\u0192', '\u2663', '\u2666', '\u2665', '\u2660', '\u2194', '\u2190', '\u2191', '\u2192', '\u2193', '\u00b0', '\u00b1', '\u2033', '\u2265', '\u00d7', '\u221d', '\u2202', '\u2022', '\u00f7', '\u2260', '\u2261', '\u2248', '\u2026', '\u2502', '\u2500', '\u21b5', '\u2135', '\u2111', '\u211c', '\u2118', '\u2297', '\u2295', '\u2205', '\u2229', '\u222a', '\u2283', '\u2287', '\u2284', '\u2282', '\u2286', '\u2208', '\u2209', '\u2220', '\u2207', '\u00ae', '\u00a9', '\u2122', '\u220f', '\u221a', '\u22c5', '\u00ac', '\u2227', '\u2228', '\u21d4', '\u21d0', '\u21d1', '\u21d2', '\u21d3', '\u25ca', '\u2329', '\u0000', '\u0000', '\u0000', '\u2211', '\u239b', '\u239c', '\u239d', '\u23a1', '\u23a2', '\u23a3', '\u23a7', '\u23a8', '\u23a9', '\u23aa', '\u0000', '\u232a', '\u222b', '\u2320', '\u23ae', '\u2321', '\u239e', '\u239f', '\u23a0', '\u23a4', '\u23a5', '\u23a6', '\u23ab', '\u23ac', '\u23ad', '\u0000'};
            table2 = new char[]{'\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', ' ', '\u2701', '\u2702', '\u2703', '\u2704', '\u260e', '\u2706', '\u2707', '\u2708', '\u2709', '\u261b', '\u261e', '\u270c', '\u270d', '\u270e', '\u270f', '\u2710', '\u2711', '\u2712', '\u2713', '\u2714', '\u2715', '\u2716', '\u2717', '\u2718', '\u2719', '\u271a', '\u271b', '\u271c', '\u271d', '\u271e', '\u271f', '\u2720', '\u2721', '\u2722', '\u2723', '\u2724', '\u2725', '\u2726', '\u2727', '\u2605', '\u2729', '\u272a', '\u272b', '\u272c', '\u272d', '\u272e', '\u272f', '\u2730', '\u2731', '\u2732', '\u2733', '\u2734', '\u2735', '\u2736', '\u2737', '\u2738', '\u2739', '\u273a', '\u273b', '\u273c', '\u273d', '\u273e', '\u273f', '\u2740', '\u2741', '\u2742', '\u2743', '\u2744', '\u2745', '\u2746', '\u2747', '\u2748', '\u2749', '\u274a', '\u274b', '\u25cf', '\u274d', '\u25a0', '\u274f', '\u2750', '\u2751', '\u2752', '\u25b2', '\u25bc', '\u25c6', '\u2756', '\u25d7', '\u2758', '\u2759', '\u275a', '\u275b', '\u275c', '\u275d', '\u275e', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u0000', '\u2761', '\u2762', '\u2763', '\u2764', '\u2765', '\u2766', '\u2767', '\u2663', '\u2666', '\u2665', '\u2660', '\u2460', '\u2461', '\u2462', '\u2463', '\u2464', '\u2465', '\u2466', '\u2467', '\u2468', '\u2469', '\u2776', '\u2777', '\u2778', '\u2779', '\u277a', '\u277b', '\u277c', '\u277d', '\u277e', '\u277f', '\u2780', '\u2781', '\u2782', '\u2783', '\u2784', '\u2785', '\u2786', '\u2787', '\u2788', '\u2789', '\u278a', '\u278b', '\u278c', '\u278d', '\u278e', '\u278f', '\u2790', '\u2791', '\u2792', '\u2793', '\u2794', '\u2192', '\u2194', '\u2195', '\u2798', '\u2799', '\u279a', '\u279b', '\u279c', '\u279d', '\u279e', '\u279f', '\u27a0', '\u27a1', '\u27a2', '\u27a3', '\u27a4', '\u27a5', '\u27a6', '\u27a7', '\u27a8', '\u27a9', '\u27aa', '\u27ab', '\u27ac', '\u27ad', '\u27ae', '\u27af', '\u0000', '\u27b1', '\u27b2', '\u27b3', '\u27b4', '\u27b5', '\u27b6', '\u27b7', '\u27b8', '\u27b9', '\u27ba', '\u27bb', '\u27bc', '\u27bd', '\u27be', '\u0000'};
            int n2 = 0;
            int n3 = 0;
            do {
                if (n3 >= 256) break;
                n = table1[n3];
                if (n != 0) {
                    t1.put(n, n3);
                }
                ++n3;
            } while (true);
            for (n = n2; n < 256; ++n) {
                n3 = table2[n];
                if (n3 == 0) continue;
                t2.put(n3, n);
            }
        }

        SymbolConversion(boolean bl) {
            if (bl) {
                this.translation = t1;
                this.byteToChar = table1;
                return;
            }
            this.translation = t2;
            this.byteToChar = table2;
        }

        @Override
        public String byteToChar(byte[] arrby, String arrc) {
            int n = arrby.length;
            arrc = new char[n];
            int n2 = 0;
            int n3 = 0;
            while (n2 < n) {
                byte by = arrby[n2];
                arrc[n3] = this.byteToChar[by & 255];
                ++n2;
                ++n3;
            }
            return new String(arrc, 0, n3);
        }

        @Override
        public byte[] charToByte(char c, String string2) {
            byte by = (byte)this.translation.get(c);
            if (by != 0) {
                return new byte[]{by};
            }
            return new byte[0];
        }

        @Override
        public byte[] charToByte(String arrby, String arrc) {
            arrc = arrby.toCharArray();
            arrby = new byte[arrc.length];
            int n = arrc.length;
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                int n3 = arrc[i];
                byte by = (byte)this.translation.get(n3);
                n3 = n2;
                if (by != 0) {
                    arrby[n2] = by;
                    n3 = n2 + 1;
                }
                n2 = n3;
            }
            if (n2 == n) {
                return arrby;
            }
            arrc = new byte[n2];
            System.arraycopy(arrby, 0, arrc, 0, n2);
            return arrc;
        }
    }

    private static class SymbolTTConversion
    implements ExtraEncoding {
        private SymbolTTConversion() {
        }

        @Override
        public String byteToChar(byte[] arrby, String string2) {
            return null;
        }

        @Override
        public byte[] charToByte(char c, String string2) {
            int n = 65280 & c;
            if (n != 0 && n != 61440) {
                return new byte[0];
            }
            return new byte[]{(byte)c};
        }

        @Override
        public byte[] charToByte(String arrby, String arrc) {
            arrc = arrby.toCharArray();
            arrby = new byte[arrc.length];
            int n = arrc.length;
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                int n3;
                block6 : {
                    char c;
                    block5 : {
                        c = arrc[i];
                        int n4 = 65280 & c;
                        if (n4 == 0) break block5;
                        n3 = n2;
                        if (n4 != 61440) break block6;
                    }
                    arrby[n2] = (byte)c;
                    n3 = n2 + 1;
                }
                n2 = n3;
            }
            if (n2 == n) {
                return arrby;
            }
            arrc = new byte[n2];
            System.arraycopy(arrby, 0, arrc, 0, n2);
            return arrc;
        }
    }

    private static class WingdingsConversion
    implements ExtraEncoding {
        private static final byte[] table = new byte[]{0, 35, 34, 0, 0, 0, 41, 62, 81, 42, 0, 0, 65, 63, 0, 0, 0, 0, 0, -4, 0, 0, 0, -5, 0, 0, 0, 0, 0, 0, 86, 0, 88, 89, 0, 0, 0, 0, 0, 0, 0, 0, -75, 0, 0, 0, 0, 0, -74, 0, 0, 0, -83, -81, -84, 0, 0, 0, 0, 0, 0, 0, 0, 124, 123, 0, 0, 0, 84, 0, 0, 0, 0, 0, 0, 0, 0, -90, 0, 0, 0, 113, 114, 0, 0, 0, 117, 0, 0, 0, 0, 0, 0, 125, 126, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -127, -126, -125, -124, -123, -122, -121, -120, -119, -118, -116, -115, -114, -113, -112, -111, -110, -109, -108, -107, -24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -24, -40, 0, 0, -60, -58, 0, 0, -16, 0, 0, 0, 0, 0, 0, 0, 0, 0, -36, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

        private WingdingsConversion() {
        }

        @Override
        public String byteToChar(byte[] arrby, String string2) {
            return null;
        }

        @Override
        public byte[] charToByte(char c, String string2) {
            byte by;
            if (c == ' ') {
                return new byte[]{(byte)c};
            }
            if (c >= '\u2701' && c <= '\u27be' && (by = table[c - 9984]) != 0) {
                return new byte[]{by};
            }
            return new byte[0];
        }

        /*
         * Enabled aggressive block sorting
         */
        @Override
        public byte[] charToByte(String arrby, String arrc) {
            arrc = arrby.toCharArray();
            arrby = new byte[arrc.length];
            int n = arrc.length;
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                int n3;
                block7 : {
                    block6 : {
                        char c;
                        block5 : {
                            c = arrc[i];
                            if (c != ' ') break block5;
                            n3 = n2 + 1;
                            arrby[n2] = (byte)c;
                            n2 = n3;
                            break block6;
                        }
                        n3 = n2;
                        if (c < '\u2701') break block7;
                        n3 = n2;
                        if (c > '\u27be') break block7;
                        byte by = table[c - 9984];
                        n3 = n2;
                        if (by == 0) break block7;
                        n3 = n2 + 1;
                        arrby[n2] = by;
                        n2 = n3;
                    }
                    n3 = n2;
                }
                n2 = n3;
            }
            if (n2 == n) {
                return arrby;
            }
            arrc = new byte[n2];
            System.arraycopy(arrby, 0, arrc, 0, n2);
            return arrc;
        }
    }

}

