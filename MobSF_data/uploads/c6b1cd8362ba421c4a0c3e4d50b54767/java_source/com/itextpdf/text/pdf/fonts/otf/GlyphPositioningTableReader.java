/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.fonts.otf;

import com.itextpdf.text.log.Logger;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.fonts.otf.FontReadingException;
import com.itextpdf.text.pdf.fonts.otf.OpenTypeFontTableReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

public class GlyphPositioningTableReader
extends OpenTypeFontTableReader {
    public GlyphPositioningTableReader(RandomAccessFileOrArray randomAccessFileOrArray, int n) throws IOException {
        super(randomAccessFileOrArray, n);
    }

    private void readAnchorTable(int n) throws IOException {
        this.rf.seek(n);
        n = this.rf.readShort();
        if (n != 1) {
            PrintStream printStream = System.err;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("The extra features of the AnchorFormat ");
            stringBuilder.append(n);
            stringBuilder.append(" will not be used");
            printStream.println(stringBuilder.toString());
        }
        this.rf.readShort();
        this.rf.readShort();
    }

    private void readBaseArrayTable(int n, int n2) throws IOException {
        this.rf.seek(n);
        int n3 = this.rf.readShort();
        Object object = new HashSet();
        for (int i = 0; i < n3; ++i) {
            for (int j = 0; j < n2; ++j) {
                object.add(Integer.valueOf(this.rf.readShort()));
            }
        }
        object = object.iterator();
        while (object.hasNext()) {
            this.readAnchorTable((Integer)object.next() + n);
        }
    }

    private void readChainingContextPositioningFormat_3(int n) throws IOException {
        StringBuilder stringBuilder;
        int n2;
        int n3 = this.rf.readShort();
        Iterator<Integer> iterator = LOG;
        List<Integer> list = new StringBuilder();
        list.append("backtrackGlyphCount=");
        list.append(n3);
        iterator.debug(list.toString());
        Object object = new ArrayList<Integer>(n3);
        int n4 = 0;
        for (n2 = 0; n2 < n3; ++n2) {
            object.add(Integer.valueOf(this.rf.readShort()));
        }
        n3 = this.rf.readShort();
        iterator = LOG;
        list = new StringBuilder();
        list.append("inputGlyphCount=");
        list.append(n3);
        iterator.debug(list.toString());
        list = new ArrayList(n3);
        for (n2 = 0; n2 < n3; ++n2) {
            list.add(Integer.valueOf(this.rf.readShort()));
        }
        n3 = this.rf.readShort();
        iterator = LOG;
        Object object2 = new StringBuilder();
        object2.append("lookaheadGlyphCount=");
        object2.append(n3);
        iterator.debug(object2.toString());
        iterator = new ArrayList(n3);
        for (n2 = 0; n2 < n3; ++n2) {
            iterator.add(Integer.valueOf(this.rf.readShort()));
        }
        n3 = this.rf.readShort();
        object2 = LOG;
        Object object3 = new StringBuilder();
        object3.append("posCount=");
        object3.append(n3);
        object2.debug(object3.toString());
        object2 = new ArrayList(n3);
        for (n2 = n4; n2 < n3; ++n2) {
            n4 = this.rf.readShort();
            short s = this.rf.readShort();
            object3 = LOG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("sequenceIndex=");
            stringBuilder.append(n4);
            stringBuilder.append(", lookupListIndex=");
            stringBuilder.append(s);
            object3.debug(stringBuilder.toString());
            object2.add(new PosLookupRecord(n4, s));
        }
        object = object.iterator();
        while (object.hasNext()) {
            object2 = this.readCoverageFormat((Integer)object.next() + n);
            object3 = LOG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("backtrackGlyphs=");
            stringBuilder.append(object2);
            object3.debug(stringBuilder.toString());
        }
        list = list.iterator();
        while (list.hasNext()) {
            object = this.readCoverageFormat((Integer)list.next() + n);
            object2 = LOG;
            object3 = new StringBuilder();
            object3.append("inputGlyphs=");
            object3.append(object);
            object2.debug(object3.toString());
        }
        iterator = iterator.iterator();
        while (iterator.hasNext()) {
            list = this.readCoverageFormat((Integer)iterator.next() + n);
            object = LOG;
            object2 = new StringBuilder();
            object2.append("lookaheadGlyphs=");
            object2.append(list);
            object.debug(object2.toString());
        }
    }

    private void readLookUpType_1(int n) throws IOException {
        this.rf.seek(n);
        short s = this.rf.readShort();
        if (s == 1) {
            Object object;
            Object object2;
            LOG.debug("Reading `Look Up Type 1, Format 1` ....");
            s = this.rf.readShort();
            short s2 = this.rf.readShort();
            if ((s2 & 1) == 1) {
                short s3 = this.rf.readShort();
                object2 = LOG;
                object = new StringBuilder();
                object.append("xPlacement=");
                object.append(s3);
                object2.debug(object.toString());
            }
            if ((s2 & 2) == 2) {
                s2 = this.rf.readShort();
                object2 = LOG;
                object = new StringBuilder();
                object.append("yPlacement=");
                object.append(s2);
                object2.debug(object.toString());
            }
            object2 = this.readCoverageFormat(n + s);
            object = LOG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("glyphCodes=");
            stringBuilder.append(object2);
            object.debug(stringBuilder.toString());
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The PosFormat ");
        stringBuilder.append(s);
        stringBuilder.append(" for `LookupType 1` is not yet supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    private void readLookUpType_4(int n) throws IOException {
        this.rf.seek(n);
        short s = this.rf.readShort();
        if (s == 1) {
            LOG.debug("Reading `Look Up Type 4, Format 1` ....");
            s = this.rf.readShort();
            short s2 = this.rf.readShort();
            short s3 = this.rf.readShort();
            short s4 = this.rf.readShort();
            short s5 = this.rf.readShort();
            List<Integer> list = this.readCoverageFormat(s + n);
            Logger logger = LOG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("markCoverages=");
            stringBuilder.append(list);
            logger.debug(stringBuilder.toString());
            list = this.readCoverageFormat(s2 + n);
            logger = LOG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("baseCoverages=");
            stringBuilder.append(list);
            logger.debug(stringBuilder.toString());
            this.readMarkArrayTable(s4 + n);
            this.readBaseArrayTable(n + s5, s3);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The posFormat ");
        stringBuilder.append(s);
        stringBuilder.append(" is not supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    private void readLookUpType_8(int n) throws IOException {
        this.rf.seek(n);
        short s = this.rf.readShort();
        if (s == 3) {
            LOG.debug("Reading `Look Up Type 8, Format 3` ....");
            this.readChainingContextPositioningFormat_3(n);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The posFormat ");
        stringBuilder.append(s);
        stringBuilder.append(" for `Look Up Type 8` is not supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    private void readMarkArrayTable(int n) throws IOException {
        this.rf.seek(n);
        int n2 = this.rf.readShort();
        Object object = new ArrayList<MarkRecord>();
        for (int i = 0; i < n2; ++i) {
            object.add(this.readMarkRecord());
        }
        object = object.iterator();
        while (object.hasNext()) {
            this.readAnchorTable(((MarkRecord)object.next()).markAnchorOffset + n);
        }
    }

    private MarkRecord readMarkRecord() throws IOException {
        return new MarkRecord(this.rf.readShort(), this.rf.readShort());
    }

    public void read() throws FontReadingException {
        this.startReadingTable();
    }

    @Override
    protected void readSubTable(int n, int n2) throws IOException {
        if (n == 1) {
            this.readLookUpType_1(n2);
            return;
        }
        if (n == 4) {
            this.readLookUpType_4(n2);
            return;
        }
        if (n == 8) {
            this.readLookUpType_8(n2);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The lookupType ");
        stringBuilder.append(n);
        stringBuilder.append(" is not yet supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    static class MarkRecord {
        final int markAnchorOffset;
        final int markClass;

        public MarkRecord(int n, int n2) {
            this.markClass = n;
            this.markAnchorOffset = n2;
        }
    }

    static class PosLookupRecord {
        final int lookupListIndex;
        final int sequenceIndex;

        public PosLookupRecord(int n, int n2) {
            this.sequenceIndex = n;
            this.lookupListIndex = n2;
        }
    }

}

