/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.languages;

import com.itextpdf.text.pdf.BidiLine;
import com.itextpdf.text.pdf.BidiOrder;
import com.itextpdf.text.pdf.languages.LanguageProcessor;
import java.util.HashMap;

public class ArabicLigaturizer
implements LanguageProcessor {
    private static final char ALEF = '\u0627';
    private static final char ALEFHAMZA = '\u0623';
    private static final char ALEFHAMZABELOW = '\u0625';
    private static final char ALEFMADDA = '\u0622';
    private static final char ALEFMAKSURA = '\u0649';
    private static final char DAMMA = '\u064f';
    public static final int DIGITS_AN2EN = 64;
    public static final int DIGITS_EN2AN = 32;
    public static final int DIGITS_EN2AN_INIT_AL = 128;
    public static final int DIGITS_EN2AN_INIT_LR = 96;
    public static final int DIGITS_MASK = 224;
    private static final int DIGITS_RESERVED = 160;
    public static final int DIGIT_TYPE_AN = 0;
    public static final int DIGIT_TYPE_AN_EXTENDED = 256;
    public static final int DIGIT_TYPE_MASK = 256;
    private static final char FARSIYEH = '\u06cc';
    private static final char FATHA = '\u064e';
    private static final char HAMZA = '\u0621';
    private static final char HAMZAABOVE = '\u0654';
    private static final char HAMZABELOW = '\u0655';
    private static final char KASRA = '\u0650';
    private static final char LAM = '\u0644';
    private static final char LAM_ALEF = '\ufefb';
    private static final char LAM_ALEFHAMZA = '\ufef7';
    private static final char LAM_ALEFHAMZABELOW = '\ufef9';
    private static final char LAM_ALEFMADDA = '\ufef5';
    private static final char MADDA = '\u0653';
    private static final char SHADDA = '\u0651';
    private static final char TATWEEL = '\u0640';
    private static final char WAW = '\u0648';
    private static final char WAWHAMZA = '\u0624';
    private static final char YEH = '\u064a';
    private static final char YEHHAMZA = '\u0626';
    private static final char ZWJ = '\u200d';
    public static final int ar_composedtashkeel = 4;
    public static final int ar_lig = 8;
    public static final int ar_nothing = 0;
    public static final int ar_novowel = 1;
    private static final char[][] chartable;
    private static final HashMap<Character, char[]> maptable;
    private static final HashMap<Character, Character> reverseLigatureMapTable;
    protected int options = 0;
    protected int runDirection = 3;

    static {
        maptable = new HashMap();
        reverseLigatureMapTable = new HashMap();
        char[] arrc = new char[]{'\u0621', '\ufffffe80'};
        Object object = new char[]{'\u0622', '\ufffffe81', '\ufffffe82'};
        char[] arrc2 = new char[]{'\u0623', '\ufffffe83', '\ufffffe84'};
        char[] arrc3 = new char[]{'\u0625', '\ufffffe87', '\ufffffe88'};
        char[] arrc4 = new char[]{'\u0626', '\ufffffe89', '\ufffffe8a', '\ufffffe8b', '\ufffffe8c'};
        char[] arrc5 = new char[]{'\u0627', '\ufffffe8d', '\ufffffe8e'};
        char[] arrc6 = new char[]{'\u0628', '\ufffffe8f', '\ufffffe90', '\ufffffe91', '\ufffffe92'};
        char[] arrc7 = new char[]{'\u062a', '\ufffffe95', '\ufffffe96', '\ufffffe97', '\ufffffe98'};
        char[] arrc8 = new char[]{'\u062b', '\ufffffe99', '\ufffffe9a', '\ufffffe9b', '\ufffffe9c'};
        char[] arrc9 = new char[]{'\u062c', '\ufffffe9d', '\ufffffe9e', '\ufffffe9f', '\ufffffea0'};
        char[] arrc10 = new char[]{'\u0630', '\ufffffeab', '\ufffffeac'};
        char[] arrc11 = new char[]{'\u0631', '\ufffffead', '\ufffffeae'};
        char[] arrc12 = new char[]{'\u0632', '\ufffffeaf', '\ufffffeb0'};
        char[] arrc13 = new char[]{'\u0633', '\ufffffeb1', '\ufffffeb2', '\ufffffeb3', '\ufffffeb4'};
        char[] arrc14 = new char[]{'\u0634', '\ufffffeb5', '\ufffffeb6', '\ufffffeb7', '\ufffffeb8'};
        char[] arrc15 = new char[]{'\u0635', '\ufffffeb9', '\ufffffeba', '\ufffffebb', '\ufffffebc'};
        char[] arrc16 = new char[]{'\u0636', '\ufffffebd', '\ufffffebe', '\ufffffebf', '\ufffffec0'};
        char[] arrc17 = new char[]{'\u0637', '\ufffffec1', '\ufffffec2', '\ufffffec3', '\ufffffec4'};
        char[] arrc18 = new char[]{'\u0638', '\ufffffec5', '\ufffffec6', '\ufffffec7', '\ufffffec8'};
        char[] arrc19 = new char[]{'\u063a', '\ufffffecd', '\ufffffece', '\ufffffecf', '\ufffffed0'};
        char[] arrc20 = new char[]{'\u0640', '\u0640', '\u0640', '\u0640', '\u0640'};
        char[] arrc21 = new char[]{'\u0641', '\ufffffed1', '\ufffffed2', '\ufffffed3', '\ufffffed4'};
        char[] arrc22 = new char[]{'\u0642', '\ufffffed5', '\ufffffed6', '\ufffffed7', '\ufffffed8'};
        char[] arrc23 = new char[]{'\u0643', '\ufffffed9', '\ufffffeda', '\ufffffedb', '\ufffffedc'};
        char[] arrc24 = new char[]{'\u0644', '\ufffffedd', '\ufffffede', '\ufffffedf', '\ufffffee0'};
        char[] arrc25 = new char[]{'\u0645', '\ufffffee1', '\ufffffee2', '\ufffffee3', '\ufffffee4'};
        char[] arrc26 = new char[]{'\u0646', '\ufffffee5', '\ufffffee6', '\ufffffee7', '\ufffffee8'};
        char[] arrc27 = new char[]{'\u0647', '\ufffffee9', '\ufffffeea', '\ufffffeeb', '\ufffffeec'};
        char[] arrc28 = new char[]{'\u0649', '\ufffffeef', '\ufffffef0', '\ufffffbe8', '\ufffffbe9'};
        char[] arrc29 = new char[]{'\u064a', '\ufffffef1', '\ufffffef2', '\ufffffef3', '\ufffffef4'};
        char[] arrc30 = new char[]{'\u0679', '\ufffffb66', '\ufffffb67', '\ufffffb68', '\ufffffb69'};
        char[] arrc31 = new char[]{'\u067b', '\ufffffb52', '\ufffffb53', '\ufffffb54', '\ufffffb55'};
        char[] arrc32 = new char[]{'\u067e', '\ufffffb56', '\ufffffb57', '\ufffffb58', '\ufffffb59'};
        char[] arrc33 = new char[]{'\u067f', '\ufffffb62', '\ufffffb63', '\ufffffb64', '\ufffffb65'};
        char[] arrc34 = new char[]{'\u0680', '\ufffffb5a', '\ufffffb5b', '\ufffffb5c', '\ufffffb5d'};
        char[] arrc35 = new char[]{'\u0683', '\ufffffb76', '\ufffffb77', '\ufffffb78', '\ufffffb79'};
        char[] arrc36 = new char[]{'\u0684', '\ufffffb72', '\ufffffb73', '\ufffffb74', '\ufffffb75'};
        char[] arrc37 = new char[]{'\u0686', '\ufffffb7a', '\ufffffb7b', '\ufffffb7c', '\ufffffb7d'};
        char[] arrc38 = new char[]{'\u0687', '\ufffffb7e', '\ufffffb7f', '\ufffffb80', '\ufffffb81'};
        char[] arrc39 = new char[]{'\u0688', '\ufffffb88', '\ufffffb89'};
        char[] arrc40 = new char[]{'\u068c', '\ufffffb84', '\ufffffb85'};
        char[] arrc41 = new char[]{'\u068d', '\ufffffb82', '\ufffffb83'};
        char[] arrc42 = new char[]{'\u068e', '\ufffffb86', '\ufffffb87'};
        char[] arrc43 = new char[]{'\u0691', '\ufffffb8c', '\ufffffb8d'};
        char[] arrc44 = new char[]{'\u0698', '\ufffffb8a', '\ufffffb8b'};
        char[] arrc45 = new char[]{'\u06a4', '\ufffffb6a', '\ufffffb6b', '\ufffffb6c', '\ufffffb6d'};
        char[] arrc46 = new char[]{'\u06a6', '\ufffffb6e', '\ufffffb6f', '\ufffffb70', '\ufffffb71'};
        char[] arrc47 = new char[]{'\u06a9', '\ufffffb8e', '\ufffffb8f', '\ufffffb90', '\ufffffb91'};
        char[] arrc48 = new char[]{'\u06ad', '\ufffffbd3', '\ufffffbd4', '\ufffffbd5', '\ufffffbd6'};
        char[] arrc49 = new char[]{'\u06af', '\ufffffb92', '\ufffffb93', '\ufffffb94', '\ufffffb95'};
        char[] arrc50 = new char[]{'\u06b1', '\ufffffb9a', '\ufffffb9b', '\ufffffb9c', '\ufffffb9d'};
        char[] arrc51 = new char[]{'\u06b3', '\ufffffb96', '\ufffffb97', '\ufffffb98', '\ufffffb99'};
        char[] arrc52 = new char[]{'\u06ba', '\ufffffb9e', '\ufffffb9f'};
        char[] arrc53 = new char[]{'\u06bb', '\ufffffba0', '\ufffffba1', '\ufffffba2', '\ufffffba3'};
        char[] arrc54 = new char[]{'\u06be', '\ufffffbaa', '\ufffffbab', '\ufffffbac', '\ufffffbad'};
        char[] arrc55 = new char[]{'\u06c0', '\ufffffba4', '\ufffffba5'};
        char[] arrc56 = new char[]{'\u06c1', '\ufffffba6', '\ufffffba7', '\ufffffba8', '\ufffffba9'};
        char[] arrc57 = new char[]{'\u06c5', '\ufffffbe0', '\ufffffbe1'};
        char[] arrc58 = new char[]{'\u06c6', '\ufffffbd9', '\ufffffbda'};
        char[] arrc59 = new char[]{'\u06c7', '\ufffffbd7', '\ufffffbd8'};
        char[] arrc60 = new char[]{'\u06c8', '\ufffffbdb', '\ufffffbdc'};
        char[] arrc61 = new char[]{'\u06c9', '\ufffffbe2', '\ufffffbe3'};
        char[] arrc62 = new char[]{'\u06cb', '\ufffffbde', '\ufffffbdf'};
        char[] arrc63 = new char[]{'\u06d0', '\ufffffbe4', '\ufffffbe5', '\ufffffbe6', '\ufffffbe7'};
        char[] arrc64 = new char[]{'\u06d2', '\ufffffbae', '\ufffffbaf'};
        char[] arrc65 = new char[]{'\u06d3', '\ufffffbb0', '\ufffffbb1'};
        chartable = new char[][]{arrc, object, arrc2, {'\u0624', '\ufffffe85', '\ufffffe86'}, arrc3, arrc4, arrc5, arrc6, {'\u0629', '\ufffffe93', '\ufffffe94'}, arrc7, arrc8, arrc9, {'\u062d', '\ufffffea1', '\ufffffea2', '\ufffffea3', '\ufffffea4'}, {'\u062e', '\ufffffea5', '\ufffffea6', '\ufffffea7', '\ufffffea8'}, {'\u062f', '\ufffffea9', '\ufffffeaa'}, arrc10, arrc11, arrc12, arrc13, arrc14, arrc15, arrc16, arrc17, arrc18, {'\u0639', '\ufffffec9', '\ufffffeca', '\ufffffecb', '\ufffffecc'}, arrc19, arrc20, arrc21, arrc22, arrc23, arrc24, arrc25, arrc26, arrc27, {'\u0648', '\ufffffeed', '\ufffffeee'}, arrc28, arrc29, {'\u0671', '\ufffffb50', '\ufffffb51'}, arrc30, {'\u067a', '\ufffffb5e', '\ufffffb5f', '\ufffffb60', '\ufffffb61'}, arrc31, arrc32, arrc33, arrc34, arrc35, arrc36, arrc37, arrc38, arrc39, arrc40, arrc41, arrc42, arrc43, arrc44, arrc45, arrc46, arrc47, arrc48, arrc49, arrc50, arrc51, arrc52, arrc53, arrc54, arrc55, arrc56, arrc57, arrc58, arrc59, arrc60, arrc61, arrc62, {'\u06cc', '\ufffffbfc', '\ufffffbfd', '\ufffffbfe', '\ufffffbff'}, arrc63, arrc64, arrc65};
        arrc = chartable;
        int n = arrc.length;
        for (int i = 0; i < n; ++i) {
            block4 : {
                block3 : {
                    object = arrc[i];
                    maptable.put(Character.valueOf(object[0]), (char[])object);
                    int n2 = ((char[])object).length;
                    if (n2 == 3) break block3;
                    if (n2 != 5) break block4;
                    reverseLigatureMapTable.put(Character.valueOf(object[4]), Character.valueOf(object[3]));
                }
                reverseLigatureMapTable.put(Character.valueOf(object[2]), Character.valueOf(object[1]));
                reverseLigatureMapTable.put(Character.valueOf(object[1]), Character.valueOf(object[0]));
            }
            if (object[0] != '\u0637' && object[0] != '\u0638') continue;
            reverseLigatureMapTable.put(Character.valueOf(object[4]), Character.valueOf(object[1]));
            reverseLigatureMapTable.put(Character.valueOf(object[3]), Character.valueOf(object[1]));
        }
    }

    public ArabicLigaturizer() {
    }

    public ArabicLigaturizer(int n, int n2) {
        this.runDirection = n;
        this.options = n2;
    }

    public static int arabic_shape(char[] object, int n, int n2, char[] arrc, int n3, int n4, int n5) {
        char[] arrc2 = new char[n2];
        for (n4 = n2 + n - 1; n4 >= n; --n4) {
            arrc2[n4 - n] = object[n4];
        }
        object = new StringBuffer(n2);
        ArabicLigaturizer.shape(arrc2, (StringBuffer)object, n5);
        if ((n5 & 12) != 0) {
            ArabicLigaturizer.doublelig((StringBuffer)object, n5);
        }
        System.arraycopy(object.toString().toCharArray(), 0, arrc, n3, object.length());
        return object.length();
    }

    static char charshape(char c, int n) {
        if (c >= '\u0621' && c <= '\u06d3') {
            char[] arrc = maptable.get(Character.valueOf(c));
            if (arrc != null) {
                return arrc[n + 1];
            }
        } else if (c >= '\ufef5' && c <= '\ufefb') {
            return (char)(c + n);
        }
        return c;
    }

    static boolean connects_to_left(charstruct charstruct2) {
        if (charstruct2.numshapes > 2) {
            return true;
        }
        return false;
    }

    static void copycstostring(StringBuffer stringBuffer, charstruct charstruct2, int n) {
        if (charstruct2.basechar == '\u0000') {
            return;
        }
        stringBuffer.append(charstruct2.basechar);
        --charstruct2.lignum;
        if (charstruct2.mark1 != '\u0000') {
            if ((n & 1) == 0) {
                stringBuffer.append(charstruct2.mark1);
                --charstruct2.lignum;
            } else {
                --charstruct2.lignum;
            }
        }
        if (charstruct2.vowel != '\u0000') {
            if ((n & 1) == 0) {
                stringBuffer.append(charstruct2.vowel);
                --charstruct2.lignum;
                return;
            }
            --charstruct2.lignum;
        }
    }

    /*
     * Exception decompiling
     */
    static void doublelig(StringBuffer var0, int var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Extractable last case doesn't follow previous
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:486)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.rebuildSwitches(SwitchReplacer.java:334)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:517)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public static Character getReverseMapping(char c) {
        return reverseLigatureMapTable.get(Character.valueOf(c));
    }

    static boolean isVowel(char c) {
        if (c >= '\u064b' && c <= '\u0655' || c == '\u0670') {
            return true;
        }
        return false;
    }

    /*
     * Exception decompiling
     */
    static int ligature(char var0, charstruct var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Extractable last case doesn't follow previous
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:486)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public static void processNumbers(char[] arrc, int n, int n2, int n3) {
        block9 : {
            int n4 = n + n2;
            int n5 = n3 & 224;
            if (n5 == 0) break block9;
            int n6 = (n3 &= 256) != 0 ? (n3 != 256 ? 48 : 1776) : 1632;
            if (n5 != 32) {
                if (n5 != 64) {
                    if (n5 != 96) {
                        if (n5 != 128) {
                            return;
                        }
                        ArabicLigaturizer.shapeToArabicDigitsWithContext(arrc, 0, n2, (char)n6, true);
                        return;
                    }
                    ArabicLigaturizer.shapeToArabicDigitsWithContext(arrc, 0, n2, (char)n6, false);
                    return;
                }
                n2 = (char)(n6 + 9);
                while (n < n4) {
                    n3 = arrc[n];
                    if (n3 <= n2 && n3 >= n6) {
                        arrc[n] = (char)(arrc[n] + (48 - n6));
                    }
                    ++n;
                }
            } else {
                while (n < n4) {
                    n2 = arrc[n];
                    if (n2 <= 57 && n2 >= 48) {
                        arrc[n] = (char)(arrc[n] + (n6 - 48));
                    }
                    ++n;
                }
            }
        }
    }

    static void shape(char[] arrc, StringBuffer stringBuffer, int n) {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    /*
     * Unable to fully structure code
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    static void shapeToArabicDigitsWithContext(char[] var0, int var1_1, int var2_2, char var3_3, boolean var4_4) {
        var6_5 = (char)(var3_3 - 48);
        var8_6 = var4_4;
        for (var3_3 = (char)var1_1; var3_3 < var2_2 + var1_1; var3_3 = (char)(var3_3 + '\u0001')) {
            var5_7 = var0[var3_3];
            var7_8 = BidiOrder.getDirection(var5_7);
            if (var7_8 == 0) ** GOTO lbl-1000
            if (var7_8 == 8) ** GOTO lbl15
            switch (var7_8) {
                default: {
                    var4_4 = var8_6;
                    break;
                }
                case 4: {
                    var4_4 = true;
                    break;
                }
lbl15: // 1 sources:
                var4_4 = var8_6;
                if (!var8_6) break;
                var4_4 = var8_6;
                if (var5_7 > '9') break;
                var0[var3_3] = (char)(var5_7 + var6_5);
                var4_4 = var8_6;
                break;
                case 3: lbl-1000: // 2 sources:
                {
                    var4_4 = false;
                }
            }
            var8_6 = var4_4;
        }
    }

    static int shapecount(char c) {
        if (c >= '\u0621' && c <= '\u06d3' && !ArabicLigaturizer.isVowel(c)) {
            char[] arrc = maptable.get(Character.valueOf(c));
            if (arrc != null) {
                return arrc.length - 1;
            }
        } else if (c == '\u200d') {
            return 4;
        }
        return 1;
    }

    @Override
    public boolean isRTL() {
        return true;
    }

    @Override
    public String process(String string2) {
        return BidiLine.processLTR(string2, this.runDirection, this.options);
    }

    static class charstruct {
        char basechar;
        int lignum;
        char mark1;
        int numshapes = 1;
        char vowel;

        charstruct() {
        }
    }

}

