/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.text.pdf.parser.ImageRenderInfo;
import com.itextpdf.text.pdf.parser.LineSegment;
import com.itextpdf.text.pdf.parser.TextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TextRenderInfo;
import com.itextpdf.text.pdf.parser.Vector;

public class SimpleTextExtractionStrategy
implements TextExtractionStrategy {
    private Vector lastEnd;
    private Vector lastStart;
    private final StringBuffer result = new StringBuffer();

    protected final void appendTextChunk(CharSequence charSequence) {
        this.result.append(charSequence);
    }

    @Override
    public void beginTextBlock() {
    }

    @Override
    public void endTextBlock() {
    }

    @Override
    public String getResultantText() {
        return this.result.toString();
    }

    @Override
    public void renderImage(ImageRenderInfo imageRenderInfo) {
    }

    @Override
    public void renderText(TextRenderInfo textRenderInfo) {
        Vector vector;
        Vector vector2;
        boolean bl = this.result.length() == 0;
        Object object = textRenderInfo.getBaseline();
        Vector vector3 = object.getStartPoint();
        object = object.getEndPoint();
        boolean bl2 = !bl && (vector = this.lastEnd).subtract(vector2 = this.lastStart).cross(vector2.subtract(vector3)).lengthSquared() / vector.subtract(vector2).lengthSquared() > 1.0f;
        if (bl2) {
            this.appendTextChunk("\n");
        } else if (!bl && this.result.charAt(this.result.length() - 1) != ' ' && textRenderInfo.getText().length() > 0 && textRenderInfo.getText().charAt(0) != ' ' && this.lastEnd.subtract(vector3).length() > textRenderInfo.getSingleSpaceWidth() / 2.0f) {
            this.appendTextChunk(" ");
        }
        this.appendTextChunk(textRenderInfo.getText());
        this.lastStart = vector3;
        this.lastEnd = object;
    }
}

