/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocListener;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.BadPasswordException;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfCopy;
import com.itextpdf.text.pdf.PdfCopyFields;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfDocument;
import com.itextpdf.text.pdf.PdfFormField;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfPages;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

@Deprecated
class PdfCopyFieldsImp
extends PdfWriter {
    protected static final HashMap<PdfName, Integer> fieldKeys;
    private static final PdfName iTextTag;
    protected static final HashMap<PdfName, Integer> widgetKeys;
    private static final Integer zero;
    protected Counter COUNTER = CounterFactory.getCounter(PdfCopyFields.class);
    private ArrayList<String> calculationOrder = new ArrayList();
    private ArrayList<Object> calculationOrderRefs;
    boolean closing = false;
    HashMap<String, Object> fieldTree = new HashMap();
    ArrayList<AcroFields> fields = new ArrayList();
    RandomAccessFileOrArray file;
    PdfDictionary form;
    private boolean hasSignature;
    private HashSet<Object> mergedRadioButtons = new HashSet();
    Document nd;
    private boolean needAppearances = false;
    ArrayList<PdfDictionary> pageDics = new ArrayList();
    ArrayList<PdfIndirectReference> pageRefs = new ArrayList();
    HashMap<PdfReader, IntHashtable> pages2intrefs = new HashMap();
    ArrayList<PdfReader> readers = new ArrayList();
    HashMap<PdfReader, IntHashtable> readers2intrefs = new HashMap();
    PdfDictionary resources = new PdfDictionary();
    private HashMap<PdfArray, ArrayList<Integer>> tabOrder;
    HashMap<PdfReader, IntHashtable> visited = new HashMap();

    static {
        iTextTag = new PdfName("_iTextTag_");
        zero = 0;
        widgetKeys = new HashMap();
        fieldKeys = new HashMap();
        Integer n = 1;
        widgetKeys.put(PdfName.SUBTYPE, n);
        widgetKeys.put(PdfName.CONTENTS, n);
        widgetKeys.put(PdfName.RECT, n);
        widgetKeys.put(PdfName.NM, n);
        widgetKeys.put(PdfName.M, n);
        widgetKeys.put(PdfName.F, n);
        widgetKeys.put(PdfName.BS, n);
        widgetKeys.put(PdfName.BORDER, n);
        widgetKeys.put(PdfName.AP, n);
        widgetKeys.put(PdfName.AS, n);
        widgetKeys.put(PdfName.C, n);
        widgetKeys.put(PdfName.A, n);
        widgetKeys.put(PdfName.STRUCTPARENT, n);
        widgetKeys.put(PdfName.OC, n);
        widgetKeys.put(PdfName.H, n);
        widgetKeys.put(PdfName.MK, n);
        widgetKeys.put(PdfName.DA, n);
        widgetKeys.put(PdfName.Q, n);
        widgetKeys.put(PdfName.P, n);
        fieldKeys.put(PdfName.AA, n);
        fieldKeys.put(PdfName.FT, n);
        fieldKeys.put(PdfName.TU, n);
        fieldKeys.put(PdfName.TM, n);
        fieldKeys.put(PdfName.FF, n);
        fieldKeys.put(PdfName.V, n);
        fieldKeys.put(PdfName.DV, n);
        fieldKeys.put(PdfName.DS, n);
        fieldKeys.put(PdfName.RV, n);
        fieldKeys.put(PdfName.OPT, n);
        fieldKeys.put(PdfName.MAXLEN, n);
        fieldKeys.put(PdfName.TI, n);
        fieldKeys.put(PdfName.I, n);
        fieldKeys.put(PdfName.LOCK, n);
        fieldKeys.put(PdfName.SV, n);
    }

    PdfCopyFieldsImp(OutputStream outputStream) throws DocumentException {
        this(outputStream, '\u0000');
    }

    PdfCopyFieldsImp(OutputStream outputStream, char c) throws DocumentException {
        super(new PdfDocument(), outputStream);
        this.pdf.addWriter(this);
        if (c != '\u0000') {
            super.setPdfVersion(c);
        }
        this.nd = new Document();
        this.nd.addDocListener(this.pdf);
    }

    private void adjustTabOrder(PdfArray pdfArray, PdfIndirectReference pdfIndirectReference, PdfNumber serializable) {
        int n;
        int n2;
        int n3 = serializable.intValue();
        serializable = this.tabOrder.get(pdfArray);
        if (serializable == null) {
            serializable = new ArrayList();
            int n4 = pdfArray.size();
            for (n = 0; n < n4 - 1; ++n) {
                serializable.add(zero);
            }
            serializable.add(n3);
            this.tabOrder.put(pdfArray, (ArrayList<Integer>)serializable);
            pdfArray.add(pdfIndirectReference);
            return;
        }
        int n5 = n = serializable.size() - 1;
        do {
            n2 = n;
            if (n5 < 0) break;
            if ((Integer)serializable.get(n5) <= n3) {
                n = n5 + 1;
                serializable.add(n, n3);
                pdfArray.add(n, pdfIndirectReference);
                n2 = -2;
                break;
            }
            --n5;
        } while (true);
        if (n2 != -2) {
            serializable.add(0, n3);
            pdfArray.add(0, pdfIndirectReference);
        }
    }

    private static String getCOName(PdfReader object, PRIndirectReference object2) {
        object = "";
        while (object2 != null && (object2 = PdfReader.getPdfObject((PdfObject)object2)) != null && object2.type() == 6) {
            PdfObject pdfObject = (PdfDictionary)object2;
            PdfString pdfString = pdfObject.getAsString(PdfName.T);
            object2 = object;
            if (pdfString != null) {
                object2 = new StringBuilder();
                object2.append(pdfString.toUnicodeString());
                object2.append(".");
                object2.append((String)object);
                object2 = object2.toString();
            }
            pdfObject = (PRIndirectReference)pdfObject.get(PdfName.PARENT);
            object = object2;
            object2 = pdfObject;
        }
        object2 = object;
        if (object.endsWith(".")) {
            object2 = object.substring(0, object.length() - 1);
        }
        return object2;
    }

    void addDocument(PdfReader pdfReader) throws DocumentException, IOException {
        if (!pdfReader.isOpenedWithFullPermissions()) {
            throw new BadPasswordException(MessageLocalization.getComposedMessage("pdfreader.not.opened.with.owner.password", new Object[0]));
        }
        this.openDoc();
        if (this.readers2intrefs.containsKey(pdfReader)) {
            pdfReader = new PdfReader(pdfReader);
        } else {
            if (pdfReader.isTampered()) {
                throw new DocumentException(MessageLocalization.getComposedMessage("the.document.was.reused", new Object[0]));
            }
            pdfReader.consolidateNamedDestinations();
            pdfReader.setTampered(true);
        }
        pdfReader.shuffleSubsetNames();
        this.readers2intrefs.put(pdfReader, new IntHashtable());
        this.readers.add(pdfReader);
        int n = pdfReader.getNumberOfPages();
        Object object = new IntHashtable();
        for (int i = 1; i <= n; ++i) {
            object.put(pdfReader.getPageOrigRef(i).getNumber(), 1);
            pdfReader.releasePage(i);
        }
        this.pages2intrefs.put(pdfReader, (IntHashtable)object);
        this.visited.put(pdfReader, new IntHashtable());
        object = pdfReader.getAcroFields();
        if (object.isGenerateAppearances() ^ true) {
            this.needAppearances = true;
        }
        this.fields.add((AcroFields)object);
        this.updateCalculationOrder(pdfReader);
    }

    void addDocument(PdfReader pdfReader, List<Integer> list) throws DocumentException, IOException {
        if (!this.readers2intrefs.containsKey(pdfReader) && pdfReader.isTampered()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("the.document.was.reused", new Object[0]));
        }
        pdfReader = new PdfReader(pdfReader);
        pdfReader.selectPages(list);
        if (pdfReader.getNumberOfPages() == 0) {
            return;
        }
        pdfReader.setTampered(false);
        this.addDocument(pdfReader);
    }

    void addPageOffsetToField(Map<String, AcroFields.Item> object, int n) {
        if (n == 0) {
            return;
        }
        for (AcroFields.Item item : object.values()) {
            for (int i = 0; i < item.size(); ++i) {
                item.forcePage(i, item.getPage(i) + n);
            }
        }
    }

    protected PdfArray branchForm(HashMap<String, Object> object, PdfIndirectReference pdfIndirectReference, String string2) throws IOException {
        PdfArray pdfArray = new PdfArray();
        Iterator<Map.Entry<String, Object>> iterator2 = object.entrySet().iterator();
        do {
            object = pdfIndirectReference;
            if (!iterator2.hasNext()) break;
            Object object2 = iterator2.next();
            Object object3 = object2.getKey();
            Object object4 = object2.getValue();
            object2 = this.getPdfIndirectReference();
            PdfDictionary pdfDictionary = new PdfDictionary();
            if (object != null) {
                pdfDictionary.put(PdfName.PARENT, (PdfObject)object);
            }
            pdfDictionary.put(PdfName.T, new PdfString((String)object3, "UnicodeBig"));
            object = new StringBuilder();
            object.append(string2);
            object.append(".");
            object.append((String)object3);
            object = object.toString();
            int n = this.calculationOrder.indexOf(object);
            if (n >= 0) {
                this.calculationOrderRefs.set(n, object2);
            }
            if (object4 instanceof HashMap) {
                pdfDictionary.put(PdfName.KIDS, this.branchForm((HashMap)object4, (PdfIndirectReference)object2, (String)object));
                pdfArray.add((PdfObject)object2);
                this.addToBody((PdfObject)pdfDictionary, (PdfIndirectReference)object2);
                continue;
            }
            object4 = (ArrayList)object4;
            pdfDictionary.mergeDifferent((PdfDictionary)object4.get(0));
            if (object4.size() == 3) {
                pdfDictionary.mergeDifferent((PdfDictionary)object4.get(2));
                n = (Integer)object4.get(1);
                object4 = this.pageDics.get(n - 1);
                object = object3 = object4.getAsArray(PdfName.ANNOTS);
                if (object3 == null) {
                    object = new PdfArray();
                    object4.put(PdfName.ANNOTS, (PdfObject)object);
                }
                object3 = (PdfNumber)pdfDictionary.get(iTextTag);
                pdfDictionary.remove(iTextTag);
                this.adjustTabOrder((PdfArray)object, (PdfIndirectReference)object2, (PdfNumber)object3);
            } else {
                PdfDictionary pdfDictionary2 = (PdfDictionary)object4.get(0);
                PdfName pdfName = pdfDictionary2.getAsName(PdfName.V);
                PdfArray pdfArray2 = new PdfArray();
                for (n = 1; n < object4.size(); n += 2) {
                    PdfObject pdfObject;
                    int n2 = (Integer)object4.get(n);
                    PdfObject pdfObject2 = this.pageDics.get(n2 - 1);
                    object = object3 = pdfObject2.getAsArray(PdfName.ANNOTS);
                    if (object3 == null) {
                        object = new PdfArray();
                        pdfObject2.put(PdfName.ANNOTS, (PdfObject)object);
                    }
                    object3 = new PdfDictionary();
                    object3.merge((PdfDictionary)object4.get(n + 1));
                    object3.put(PdfName.PARENT, (PdfObject)object2);
                    pdfObject2 = (PdfNumber)object3.get(iTextTag);
                    object3.remove(iTextTag);
                    if (PdfCopy.isCheckButton(pdfDictionary2)) {
                        pdfObject = object3.getAsName(PdfName.AS);
                        if (pdfName != null && pdfObject != null) {
                            object3.put(PdfName.AS, pdfName);
                        }
                    } else if (PdfCopy.isRadioButton(pdfDictionary2)) {
                        pdfObject = object3.getAsName(PdfName.AS);
                        if (pdfName != null && pdfObject != null && !pdfObject.equals(this.getOffStateName((PdfDictionary)object3))) {
                            if (!this.mergedRadioButtons.contains(object4)) {
                                this.mergedRadioButtons.add(object4);
                                object3.put(PdfName.AS, pdfName);
                            } else {
                                object3.put(PdfName.AS, this.getOffStateName((PdfDictionary)object3));
                            }
                        }
                    }
                    pdfObject = this.addToBody((PdfObject)object3).getIndirectReference();
                    this.adjustTabOrder((PdfArray)object, (PdfIndirectReference)pdfObject, (PdfNumber)pdfObject2);
                    pdfArray2.add(pdfObject);
                    this.propagate((PdfObject)object3, null, false);
                }
                pdfDictionary.put(PdfName.KIDS, pdfArray2);
            }
            pdfArray.add((PdfObject)object2);
            this.addToBody((PdfObject)pdfDictionary, (PdfIndirectReference)object2);
            this.propagate(pdfDictionary, null, false);
        } while (true);
        return pdfArray;
    }

    @Override
    public void close() {
        if (this.closing) {
            super.close();
            return;
        }
        this.closing = true;
        try {
            this.closeIt();
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void closeIt() throws IOException {
        Object object2;
        Object object3;
        Object object;
        int n;
        int[] arrn;
        int n2;
        for (n = 0; n < this.readers.size(); ++n) {
            this.readers.get(n).removeFields();
        }
        n = 0;
        do {
            int n3 = this.readers.size();
            if (n >= n3) break;
            object = this.readers.get(n);
            for (n2 = 1; n2 <= object.getNumberOfPages(); ++n2) {
                this.pageRefs.add(this.getNewReference(object.getPageOrigRef(n2)));
                this.pageDics.add(object.getPageN(n2));
            }
            ++n;
        } while (true);
        this.mergeFields();
        this.createAcroForms();
        for (n = 0; n < this.readers.size(); ++n) {
            object = this.readers.get(n);
            for (n2 = 1; n2 <= object.getNumberOfPages(); ++n2) {
                object3 = object.getPageN(n2);
                object2 = this.getNewReference(object.getPageOrigRef(n2));
                arrn = this.root.addPageRef((PdfIndirectReference)object2);
                object3.put(PdfName.PARENT, (PdfObject)arrn);
                this.propagate((PdfObject)object3, (PdfIndirectReference)object2, false);
            }
        }
        object = this.readers2intrefs.entrySet().iterator();
        do {
            if (!object.hasNext()) {
                this.pdf.close();
                return;
            }
            object2 = (Map.Entry)object.next();
            object3 = (PdfReader)object2.getKey();
            try {
                this.file = object3.getSafeFile();
                this.file.reOpen();
                object2 = (IntHashtable)object2.getValue();
                arrn = object2.toOrderedKeys();
            }
            catch (Throwable throwable2) {
                try {
                    this.file.close();
                }
                catch (Exception exception) {
                    throw throwable2;
                }
                throw throwable2;
            }
            for (n = 0; n < arrn.length; ++n) {
                this.addToBody(PdfReader.getPdfObjectRelease(new PRIndirectReference((PdfReader)object3, arrn[n])), object2.get(arrn[n]));
            }
            try {
                this.file.close();
            }
            catch (Exception exception) {
            }
        } while (true);
    }

    protected void createAcroForms() throws IOException {
        if (this.fieldTree.isEmpty()) {
            return;
        }
        this.form = new PdfDictionary();
        this.form.put(PdfName.DR, this.resources);
        PdfObject pdfObject = this.resources;
        int n = 0;
        this.propagate(pdfObject, null, false);
        if (this.needAppearances) {
            this.form.put(PdfName.NEEDAPPEARANCES, PdfBoolean.PDFTRUE);
        }
        this.form.put(PdfName.DA, new PdfString("/Helv 0 Tf 0 g "));
        this.tabOrder = new HashMap();
        this.calculationOrderRefs = new ArrayList<String>(this.calculationOrder);
        this.form.put(PdfName.FIELDS, this.branchForm(this.fieldTree, null, ""));
        if (this.hasSignature) {
            this.form.put(PdfName.SIGFLAGS, new PdfNumber(3));
        }
        pdfObject = new PdfArray();
        while (n < this.calculationOrderRefs.size()) {
            Object object = this.calculationOrderRefs.get(n);
            if (object instanceof PdfIndirectReference) {
                pdfObject.add((PdfIndirectReference)object);
            }
            ++n;
        }
        if (pdfObject.size() > 0) {
            this.form.put(PdfName.CO, pdfObject);
        }
    }

    void createWidgets(ArrayList<Object> arrayList, AcroFields.Item item) {
        for (int i = 0; i < item.size(); ++i) {
            arrayList.add(item.getPage(i));
            PdfDictionary pdfDictionary = item.getMerged(i);
            PdfObject pdfObject = pdfDictionary.get(PdfName.DR);
            if (pdfObject != null) {
                PdfFormField.mergeResources(this.resources, (PdfDictionary)PdfReader.getPdfObject(pdfObject));
            }
            pdfObject = new PdfDictionary();
            for (PdfName pdfName : pdfDictionary.getKeys()) {
                if (!widgetKeys.containsKey(pdfName)) continue;
                pdfObject.put(pdfName, pdfDictionary.get(pdfName));
            }
            pdfObject.put(iTextTag, new PdfNumber(item.getTabOrder(i) + 1));
            arrayList.add(pdfObject);
        }
    }

    @Override
    protected PdfDictionary getCatalog(PdfIndirectReference pdfObject) {
        try {
            pdfObject = this.pdf.getCatalog((PdfIndirectReference)pdfObject);
            if (this.form != null) {
                PdfIndirectReference pdfIndirectReference = this.addToBody(this.form).getIndirectReference();
                pdfObject.put(PdfName.ACROFORM, pdfIndirectReference);
            }
            return pdfObject;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    @Override
    protected Counter getCounter() {
        return this.COUNTER;
    }

    @Override
    protected int getNewObjectNumber(PdfReader object, int n, int n2) {
        int n3;
        object = this.readers2intrefs.get(object);
        n2 = n3 = object.get(n);
        if (n3 == 0) {
            n2 = this.getIndirectReferenceNumber();
            object.put(n, n2);
        }
        return n2;
    }

    protected PdfIndirectReference getNewReference(PRIndirectReference pRIndirectReference) {
        return new PdfIndirectReference(0, this.getNewObjectNumber(pRIndirectReference.getReader(), pRIndirectReference.getNumber(), 0));
    }

    protected PdfName getOffStateName(PdfDictionary pdfDictionary) {
        return PdfName.Off;
    }

    @Override
    public PdfIndirectReference getPageReference(int n) {
        return this.pageRefs.get(n - 1);
    }

    @Override
    RandomAccessFileOrArray getReaderFile(PdfReader pdfReader) {
        return this.file;
    }

    protected boolean isPage(PRIndirectReference pRIndirectReference) {
        IntHashtable intHashtable = this.pages2intrefs.get(pRIndirectReference.getReader());
        if (intHashtable != null) {
            return intHashtable.containsKey(pRIndirectReference.getNumber());
        }
        return false;
    }

    protected boolean isVisited(PRIndirectReference pRIndirectReference) {
        IntHashtable intHashtable = this.visited.get(pRIndirectReference.getReader());
        if (intHashtable != null) {
            return intHashtable.containsKey(pRIndirectReference.getNumber());
        }
        return false;
    }

    protected boolean isVisited(PdfReader pdfReader, int n, int n2) {
        return this.readers2intrefs.get(pdfReader).containsKey(n);
    }

    void mergeField(String serializable, AcroFields.Item item) {
        Object object;
        Object object2;
        Object object3;
        Serializable serializable2;
        block16 : {
            serializable2 = this.fieldTree;
            object2 = new StringTokenizer((String)((Object)serializable), ".");
            serializable = serializable2;
            if (!object2.hasMoreTokens()) {
                return;
            }
            do {
                object = object2.nextToken();
                object3 = serializable.get(object);
                if (!object2.hasMoreTokens()) break block16;
                if (object3 == null) {
                    serializable2 = new HashMap();
                    serializable.put(object, serializable2);
                    serializable = serializable2;
                    continue;
                }
                if (!(object3 instanceof HashMap)) break;
                serializable = (HashMap)object3;
            } while (true);
            return;
        }
        if (object3 instanceof HashMap) {
            return;
        }
        int n = 0;
        serializable2 = item.getMerged(0);
        if (object3 == null) {
            object2 = new PdfDictionary();
            if (PdfName.SIG.equals(serializable2.get(PdfName.FT))) {
                this.hasSignature = true;
            }
            for (PdfName pdfName : serializable2.getKeys()) {
                if (!fieldKeys.containsKey(pdfName)) continue;
                object2.put(pdfName, serializable2.get(pdfName));
            }
            serializable2 = new ArrayList();
            serializable2.add(object2);
            this.createWidgets((ArrayList<Object>)serializable2, item);
            serializable.put(object, serializable2);
            return;
        }
        serializable = (ArrayList)object3;
        object2 = (PdfDictionary)serializable.get(0);
        object = (PdfName)object2.get(PdfName.FT);
        object3 = (PdfName)serializable2.get(PdfName.FT);
        if (object != null) {
            if (!object.equals(object3)) {
                return;
            }
            int n2 = (object2 = object2.get(PdfName.FF)) != null && object2.isNumber() ? ((PdfNumber)object2).intValue() : 0;
            serializable2 = serializable2.get(PdfName.FF);
            int n3 = n;
            if (serializable2 != null) {
                n3 = n;
                if (serializable2.isNumber()) {
                    n3 = ((PdfNumber)serializable2).intValue();
                }
            }
            if (object.equals(PdfName.BTN)) {
                if (((n3 = n2 ^ n3) & 65536) != 0) {
                    return;
                }
                if ((n2 & 65536) == 0 && (32768 & n3) != 0) {
                    return;
                }
            } else if (object.equals(PdfName.CH) && ((n2 ^ n3) & 131072) != 0) {
                return;
            }
            this.createWidgets((ArrayList<Object>)serializable, item);
            return;
        }
    }

    void mergeFields() {
        int n = 0;
        for (int i = 0; i < this.fields.size(); ++i) {
            Map<String, AcroFields.Item> map = this.fields.get(i).getFields();
            this.addPageOffsetToField(map, n);
            this.mergeWithMaster(map);
            n += this.readers.get(i).getNumberOfPages();
        }
    }

    void mergeWithMaster(Map<String, AcroFields.Item> object) {
        for (Map.Entry entry : object.entrySet()) {
            this.mergeField((String)entry.getKey(), (AcroFields.Item)entry.getValue());
        }
    }

    public void openDoc() {
        if (!this.nd.isOpen()) {
            this.nd.open();
        }
    }

    void propagate(PdfObject object, PdfIndirectReference object2, boolean bl) throws IOException {
        if (object == null) {
            return;
        }
        if (object instanceof PdfIndirectReference) {
            return;
        }
        int n = object.type();
        if (n != 10) {
            switch (n) {
                default: {
                    return;
                }
                case 6: 
                case 7: {
                    object = (PdfDictionary)((Object)object);
                    for (PdfName pdfIndirectReference : object.getKeys()) {
                        if (bl && (pdfIndirectReference.equals(PdfName.PARENT) || pdfIndirectReference.equals(PdfName.KIDS))) continue;
                        PdfObject pdfObject = object.get(pdfIndirectReference);
                        if (pdfObject != null && pdfObject.isIndirect()) {
                            PRIndirectReference pRIndirectReference = (PRIndirectReference)pdfObject;
                            if (this.setVisited(pRIndirectReference) || this.isPage(pRIndirectReference)) continue;
                            PdfIndirectReference pdfIndirectReference2 = this.getNewReference(pRIndirectReference);
                            this.propagate(PdfReader.getPdfObjectRelease(pRIndirectReference), pdfIndirectReference2, bl);
                            continue;
                        }
                        this.propagate(pdfObject, null, bl);
                    }
                    break;
                }
                case 5: {
                    object = ((PdfArray)((Object)object)).listIterator();
                    while (object.hasNext()) {
                        object2 = object.next();
                        if (object2 != null && object2.isIndirect()) {
                            if (this.isVisited((PRIndirectReference)(object2 = (PRIndirectReference)object2)) || this.isPage((PRIndirectReference)object2)) continue;
                            PdfIndirectReference pdfIndirectReference = this.getNewReference((PRIndirectReference)object2);
                            this.propagate(PdfReader.getPdfObjectRelease((PdfObject)object2), pdfIndirectReference, bl);
                            continue;
                        }
                        this.propagate((PdfObject)object2, null, bl);
                    }
                    break block0;
                }
            }
            return;
        }
        throw new RuntimeException(MessageLocalization.getComposedMessage("reference.pointing.to.reference", new Object[0]));
    }

    protected boolean setVisited(PRIndirectReference pRIndirectReference) {
        IntHashtable intHashtable = this.visited.get(pRIndirectReference.getReader());
        boolean bl = false;
        if (intHashtable != null) {
            if (intHashtable.put(pRIndirectReference.getNumber(), 1) != 0) {
                bl = true;
            }
            return bl;
        }
        return false;
    }

    protected void updateCalculationOrder(PdfReader pdfReader) {
        PdfObject pdfObject = pdfReader.getCatalog().getAsDict(PdfName.ACROFORM);
        if (pdfObject == null) {
            return;
        }
        if ((pdfObject = pdfObject.getAsArray(PdfName.CO)) != null) {
            if (pdfObject.size() == 0) {
                return;
            }
            AcroFields acroFields = pdfReader.getAcroFields();
            for (int i = 0; i < pdfObject.size(); ++i) {
                Object object = pdfObject.getPdfObject(i);
                if (object == null || !object.isIndirect() || acroFields.getFieldItem((String)(object = PdfCopyFieldsImp.getCOName(pdfReader, (PRIndirectReference)object))) == null) continue;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(".");
                stringBuilder.append((String)object);
                object = stringBuilder.toString();
                if (this.calculationOrder.contains(object)) continue;
                this.calculationOrder.add((String)object);
            }
            return;
        }
    }
}

