/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.Element;
import com.itextpdf.text.Font;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BaseFont;
import java.util.ArrayList;

public class FontSelector {
    protected Font currentFont = null;
    protected ArrayList<Font> fonts = new ArrayList();

    public void addFont(Font font) {
        if (font.getBaseFont() != null) {
            this.fonts.add(font);
            return;
        }
        font = new Font(font.getCalculatedBaseFont(true), font.getSize(), font.getCalculatedStyle(), font.getColor());
        this.fonts.add(font);
    }

    public Phrase process(String object) {
        if (this.fonts.size() == 0) {
            throw new IndexOutOfBoundsException(MessageLocalization.getComposedMessage("no.font.is.defined", new Object[0]));
        }
        object = object.toCharArray();
        int n = ((char[])object).length;
        CharSequence charSequence = new StringBuffer();
        Phrase phrase = new Phrase();
        this.currentFont = null;
        for (int i = 0; i < n; ++i) {
            Chunk chunk = this.processChar((char[])object, i, (StringBuffer)charSequence);
            if (chunk == null) continue;
            phrase.add(chunk);
        }
        if (charSequence.length() > 0) {
            charSequence = charSequence.toString();
            object = this.currentFont != null ? this.currentFont : this.fonts.get(0);
            phrase.add(new Chunk((String)charSequence, (Font)object));
        }
        return phrase;
    }

    protected Chunk processChar(char[] object, int n, StringBuffer stringBuffer) {
        char c = object[n];
        Font font = null;
        Object object2 = null;
        Font font2 = null;
        Font font3 = null;
        if (c != '\n' && c != '\r') {
            if (Utilities.isSurrogatePair(object, n)) {
                int n2 = Utilities.convertToUtf32(object, n);
                for (int i = 0; i < this.fonts.size(); ++i) {
                    font2 = this.fonts.get(i);
                    if (!font2.getBaseFont().charExists(n2) && Character.getType(n2) != 16) {
                        continue;
                    }
                    object2 = font;
                    if (this.currentFont != font2) {
                        object2 = font3;
                        if (stringBuffer.length() > 0) {
                            object2 = font3;
                            if (this.currentFont != null) {
                                object2 = new Chunk(stringBuffer.toString(), this.currentFont);
                                stringBuffer.setLength(0);
                            }
                        }
                        this.currentFont = font2;
                    }
                    stringBuffer.append(c);
                    stringBuffer.append(object[n + 1]);
                    return object2;
                }
            } else {
                for (n = 0; n < this.fonts.size(); ++n) {
                    font3 = this.fonts.get(n);
                    if (!font3.getBaseFont().charExists(c) && Character.getType(c) != 16) {
                        continue;
                    }
                    object = font2;
                    if (this.currentFont != font3) {
                        object = object2;
                        if (stringBuffer.length() > 0) {
                            object = object2;
                            if (this.currentFont != null) {
                                object = new Chunk(stringBuffer.toString(), this.currentFont);
                                stringBuffer.setLength(0);
                            }
                        }
                        this.currentFont = font3;
                    }
                    stringBuffer.append(c);
                    return object;
                }
            }
        } else {
            stringBuffer.append(c);
        }
        return null;
    }
}

