/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.AccessibleElementId;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Image;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.ColumnText;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfDiv;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfPCellEvent;
import com.itextpdf.text.pdf.PdfPHeaderCell;
import com.itextpdf.text.pdf.PdfPRow;
import com.itextpdf.text.pdf.PdfPTable;
import com.itextpdf.text.pdf.events.PdfPCellEventForwarder;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

public class PdfPCell
extends Rectangle
implements IAccessibleElement {
    protected HashMap<PdfName, PdfObject> accessibleAttributes = null;
    private float cachedMaxHeight;
    private float calculatedHeight = 0.0f;
    private PdfPCellEvent cellEvent;
    private int colspan = 1;
    private ColumnText column = new ColumnText(null);
    private float fixedHeight = 0.0f;
    protected ArrayList<PdfPHeaderCell> headers = null;
    protected AccessibleElementId id = new AccessibleElementId();
    private Image image;
    private float minimumHeight;
    private boolean noWrap = false;
    private float paddingBottom = 2.0f;
    private float paddingLeft = 2.0f;
    private float paddingRight = 2.0f;
    private float paddingTop = 2.0f;
    protected Phrase phrase;
    protected PdfName role = PdfName.TD;
    private int rotation;
    private int rowspan = 1;
    private PdfPTable table;
    private boolean useBorderPadding = false;
    private boolean useDescender = false;
    private int verticalAlignment = 4;

    public PdfPCell() {
        super(0.0f, 0.0f, 0.0f, 0.0f);
        this.borderWidth = 0.5f;
        this.border = 15;
        this.column.setLeading(0.0f, 1.0f);
    }

    public PdfPCell(Image image) {
        this(image, false);
    }

    public PdfPCell(Image element, boolean bl) {
        super(0.0f, 0.0f, 0.0f, 0.0f);
        this.borderWidth = 0.5f;
        this.border = 15;
        this.column.setLeading(0.0f, 1.0f);
        if (bl) {
            this.image = element;
            this.setPadding(this.borderWidth / 2.0f);
            return;
        }
        element.setScaleToFitLineWhenOverflow(false);
        ColumnText columnText = this.column;
        element = new Phrase(new Chunk((Image)element, 0.0f, 0.0f, true));
        this.phrase = element;
        columnText.addText((Phrase)element);
        this.setPadding(0.0f);
    }

    public PdfPCell(Phrase phrase) {
        super(0.0f, 0.0f, 0.0f, 0.0f);
        this.borderWidth = 0.5f;
        this.border = 15;
        ColumnText columnText = this.column;
        this.phrase = phrase;
        columnText.addText(phrase);
        this.column.setLeading(0.0f, 1.0f);
    }

    public PdfPCell(PdfPCell pdfPCell) {
        super(pdfPCell.llx, pdfPCell.lly, pdfPCell.urx, pdfPCell.ury);
        this.cloneNonPositionParameters(pdfPCell);
        this.verticalAlignment = pdfPCell.verticalAlignment;
        this.paddingLeft = pdfPCell.paddingLeft;
        this.paddingRight = pdfPCell.paddingRight;
        this.paddingTop = pdfPCell.paddingTop;
        this.paddingBottom = pdfPCell.paddingBottom;
        this.phrase = pdfPCell.phrase;
        this.fixedHeight = pdfPCell.fixedHeight;
        this.minimumHeight = pdfPCell.minimumHeight;
        this.noWrap = pdfPCell.noWrap;
        this.colspan = pdfPCell.colspan;
        this.rowspan = pdfPCell.rowspan;
        if (pdfPCell.table != null) {
            this.table = new PdfPTable(pdfPCell.table);
        }
        this.image = Image.getInstance(pdfPCell.image);
        this.cellEvent = pdfPCell.cellEvent;
        this.useDescender = pdfPCell.useDescender;
        this.column = ColumnText.duplicate(pdfPCell.column);
        this.useBorderPadding = pdfPCell.useBorderPadding;
        this.rotation = pdfPCell.rotation;
        this.id = pdfPCell.id;
        this.role = pdfPCell.role;
        if (pdfPCell.accessibleAttributes != null) {
            this.accessibleAttributes = new HashMap<PdfName, PdfObject>(pdfPCell.accessibleAttributes);
        }
        this.headers = pdfPCell.headers;
    }

    public PdfPCell(PdfPTable pdfPTable) {
        this(pdfPTable, null);
    }

    public PdfPCell(PdfPTable pdfPTable, PdfPCell pdfPCell) {
        super(0.0f, 0.0f, 0.0f, 0.0f);
        this.borderWidth = 0.5f;
        this.border = 15;
        this.column.setLeading(0.0f, 1.0f);
        this.table = pdfPTable;
        pdfPTable.setWidthPercentage(100.0f);
        pdfPTable.setExtendLastRow(true);
        this.column.addElement(pdfPTable);
        if (pdfPCell != null) {
            this.cloneNonPositionParameters(pdfPCell);
            this.verticalAlignment = pdfPCell.verticalAlignment;
            this.paddingLeft = pdfPCell.paddingLeft;
            this.paddingRight = pdfPCell.paddingRight;
            this.paddingTop = pdfPCell.paddingTop;
            this.paddingBottom = pdfPCell.paddingBottom;
            this.colspan = pdfPCell.colspan;
            this.rowspan = pdfPCell.rowspan;
            this.cellEvent = pdfPCell.cellEvent;
            this.useDescender = pdfPCell.useDescender;
            this.useBorderPadding = pdfPCell.useBorderPadding;
            this.rotation = pdfPCell.rotation;
            return;
        }
        this.setPadding(0.0f);
    }

    public void addElement(Element element) {
        if (this.table != null) {
            this.table = null;
            this.column.setText(null);
        }
        if (element instanceof PdfPTable) {
            ((PdfPTable)element).setSplitLate(false);
        } else if (element instanceof PdfDiv) {
            for (Element element2 : ((PdfDiv)element).getContent()) {
                if (!(element2 instanceof PdfPTable)) continue;
                ((PdfPTable)element2).setSplitLate(false);
            }
        }
        this.column.addElement(element);
    }

    public void addHeader(PdfPHeaderCell pdfPHeaderCell) {
        if (this.headers == null) {
            this.headers = new ArrayList();
        }
        this.headers.add(pdfPHeaderCell);
    }

    @Override
    public PdfObject getAccessibleAttribute(PdfName pdfName) {
        if (this.accessibleAttributes != null) {
            return this.accessibleAttributes.get(pdfName);
        }
        return null;
    }

    @Override
    public HashMap<PdfName, PdfObject> getAccessibleAttributes() {
        return this.accessibleAttributes;
    }

    public int getArabicOptions() {
        return this.column.getArabicOptions();
    }

    public float getCachedMaxHeight() {
        return this.cachedMaxHeight;
    }

    public float getCalculatedHeight() {
        return this.calculatedHeight;
    }

    public PdfPCellEvent getCellEvent() {
        return this.cellEvent;
    }

    public int getColspan() {
        return this.colspan;
    }

    public ColumnText getColumn() {
        return this.column;
    }

    public List<Element> getCompositeElements() {
        return this.getColumn().compositeElements;
    }

    public float getEffectivePaddingBottom() {
        if (this.isUseBorderPadding()) {
            float f = this.getBorderWidthBottom();
            float f2 = this.isUseVariableBorders() ? 1.0f : 2.0f;
            f2 = f / f2;
            return this.paddingBottom + f2;
        }
        return this.paddingBottom;
    }

    public float getEffectivePaddingLeft() {
        if (this.isUseBorderPadding()) {
            float f = this.getBorderWidthLeft();
            float f2 = this.isUseVariableBorders() ? 1.0f : 2.0f;
            f2 = f / f2;
            return this.paddingLeft + f2;
        }
        return this.paddingLeft;
    }

    public float getEffectivePaddingRight() {
        if (this.isUseBorderPadding()) {
            float f = this.getBorderWidthRight();
            float f2 = this.isUseVariableBorders() ? 1.0f : 2.0f;
            f2 = f / f2;
            return this.paddingRight + f2;
        }
        return this.paddingRight;
    }

    public float getEffectivePaddingTop() {
        if (this.isUseBorderPadding()) {
            float f = this.getBorderWidthTop();
            float f2 = this.isUseVariableBorders() ? 1.0f : 2.0f;
            f2 = f / f2;
            return this.paddingTop + f2;
        }
        return this.paddingTop;
    }

    public float getExtraParagraphSpace() {
        return this.column.getExtraParagraphSpace();
    }

    public float getFixedHeight() {
        return this.fixedHeight;
    }

    public float getFollowingIndent() {
        return this.column.getFollowingIndent();
    }

    public ArrayList<PdfPHeaderCell> getHeaders() {
        return this.headers;
    }

    public int getHorizontalAlignment() {
        return this.column.getAlignment();
    }

    @Override
    public AccessibleElementId getId() {
        return this.id;
    }

    public Image getImage() {
        return this.image;
    }

    public float getIndent() {
        return this.column.getIndent();
    }

    public float getLeading() {
        return this.column.getLeading();
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public float getMaxHeight() {
        float f;
        float f2;
        block16 : {
            Object object;
            block15 : {
                boolean bl = this.getRotation() == 90 || this.getRotation() == 270;
                object = this.getImage();
                if (object != null) {
                    object.scalePercent(100.0f);
                    f2 = bl ? object.getScaledHeight() : object.getScaledWidth();
                    object.scalePercent((this.getRight() - this.getEffectivePaddingRight() - this.getEffectivePaddingLeft() - this.getLeft()) / f2 * 100.0f);
                    f2 = bl ? object.getScaledWidth() : object.getScaledHeight();
                    this.setBottom(this.getTop() - this.getEffectivePaddingTop() - this.getEffectivePaddingBottom() - f2);
                } else if (bl && this.hasFixedHeight() || this.getColumn() == null) {
                    this.setBottom(this.getTop() - this.getFixedHeight());
                } else {
                    float f4;
                    float f3;
                    object = ColumnText.duplicate(this.getColumn());
                    f2 = 20000.0f;
                    if (bl) {
                        f3 = this.getRight() - this.getEffectivePaddingRight();
                        f = this.getLeft() + this.getEffectivePaddingLeft();
                        f4 = 0.0f;
                    } else {
                        if (!this.isNoWrap()) {
                            f2 = this.getRight() - this.getEffectivePaddingRight();
                        }
                        f3 = this.getTop() - this.getEffectivePaddingTop();
                        f4 = this.getLeft() + this.getEffectivePaddingLeft();
                        f = this.hasCalculatedHeight() ? this.getTop() + this.getEffectivePaddingBottom() - this.getCalculatedHeight() : -1.07374182E9f;
                    }
                    PdfPRow.setColumn((ColumnText)object, f4, f, f2, f3);
                    object.go(true);
                    if (!bl) break block15;
                    this.setBottom(this.getTop() - this.getEffectivePaddingTop() - this.getEffectivePaddingBottom() - object.getFilledWidth());
                }
                break block16;
            }
            f2 = f = object.getYLine();
            if (this.isUseDescender()) {
                f2 = f + object.getDescender();
            }
            this.setBottom(f2 - this.getEffectivePaddingBottom());
        }
        f2 = f = this.getHeight();
        if (f == this.getEffectivePaddingTop() + this.getEffectivePaddingBottom()) {
            f2 = 0.0f;
        }
        if (this.hasFixedHeight()) {
            f = this.getFixedHeight();
        } else {
            f = f2;
            if (this.hasMinimumHeight()) {
                f = f2;
                if (f2 < this.getMinimumHeight()) {
                    f = this.getMinimumHeight();
                }
            }
        }
        this.cachedMaxHeight = f;
        return f;
        catch (DocumentException documentException) {
            throw new ExceptionConverter(documentException);
        }
    }

    public float getMinimumHeight() {
        return this.minimumHeight;
    }

    public float getMultipliedLeading() {
        return this.column.getMultipliedLeading();
    }

    public float getPaddingBottom() {
        return this.paddingBottom;
    }

    public float getPaddingLeft() {
        return this.paddingLeft;
    }

    public float getPaddingRight() {
        return this.paddingRight;
    }

    public float getPaddingTop() {
        return this.paddingTop;
    }

    public Phrase getPhrase() {
        return this.phrase;
    }

    public float getRightIndent() {
        return this.column.getRightIndent();
    }

    @Override
    public PdfName getRole() {
        return this.role;
    }

    @Override
    public int getRotation() {
        return this.rotation;
    }

    public int getRowspan() {
        return this.rowspan;
    }

    public int getRunDirection() {
        return this.column.getRunDirection();
    }

    public float getSpaceCharRatio() {
        return this.column.getSpaceCharRatio();
    }

    public PdfPTable getTable() {
        return this.table;
    }

    public int getVerticalAlignment() {
        return this.verticalAlignment;
    }

    public boolean hasCachedMaxHeight() {
        if (this.cachedMaxHeight > 0.0f) {
            return true;
        }
        return false;
    }

    public boolean hasCalculatedHeight() {
        if (this.getCalculatedHeight() > 0.0f) {
            return true;
        }
        return false;
    }

    public boolean hasFixedHeight() {
        if (this.getFixedHeight() > 0.0f) {
            return true;
        }
        return false;
    }

    public boolean hasMinimumHeight() {
        if (this.getMinimumHeight() > 0.0f) {
            return true;
        }
        return false;
    }

    @Override
    public boolean isInline() {
        return false;
    }

    public boolean isNoWrap() {
        return this.noWrap;
    }

    public boolean isUseAscender() {
        return this.column.isUseAscender();
    }

    public boolean isUseBorderPadding() {
        return this.useBorderPadding;
    }

    public boolean isUseDescender() {
        return this.useDescender;
    }

    @Override
    public void setAccessibleAttribute(PdfName pdfName, PdfObject pdfObject) {
        if (this.accessibleAttributes == null) {
            this.accessibleAttributes = new HashMap();
        }
        this.accessibleAttributes.put(pdfName, pdfObject);
    }

    public void setArabicOptions(int n) {
        this.column.setArabicOptions(n);
    }

    public void setCalculatedHeight(float f) {
        this.calculatedHeight = f;
    }

    public void setCellEvent(PdfPCellEvent pdfPCellEvent) {
        if (pdfPCellEvent == null) {
            this.cellEvent = null;
            return;
        }
        if (this.cellEvent == null) {
            this.cellEvent = pdfPCellEvent;
            return;
        }
        if (this.cellEvent instanceof PdfPCellEventForwarder) {
            ((PdfPCellEventForwarder)this.cellEvent).addCellEvent(pdfPCellEvent);
            return;
        }
        PdfPCellEventForwarder pdfPCellEventForwarder = new PdfPCellEventForwarder();
        pdfPCellEventForwarder.addCellEvent(this.cellEvent);
        pdfPCellEventForwarder.addCellEvent(pdfPCellEvent);
        this.cellEvent = pdfPCellEventForwarder;
    }

    public void setColspan(int n) {
        this.colspan = n;
    }

    public void setColumn(ColumnText columnText) {
        this.column = columnText;
    }

    public void setExtraParagraphSpace(float f) {
        this.column.setExtraParagraphSpace(f);
    }

    public void setFixedHeight(float f) {
        this.fixedHeight = f;
        this.minimumHeight = 0.0f;
    }

    public void setFollowingIndent(float f) {
        this.column.setFollowingIndent(f);
    }

    public void setHorizontalAlignment(int n) {
        this.column.setAlignment(n);
    }

    @Override
    public void setId(AccessibleElementId accessibleElementId) {
        this.id = accessibleElementId;
    }

    public void setImage(Image image) {
        this.column.setText(null);
        this.table = null;
        this.image = image;
    }

    public void setIndent(float f) {
        this.column.setIndent(f);
    }

    public void setLeading(float f, float f2) {
        this.column.setLeading(f, f2);
    }

    public void setMinimumHeight(float f) {
        this.minimumHeight = f;
        this.fixedHeight = 0.0f;
    }

    public void setNoWrap(boolean bl) {
        this.noWrap = bl;
    }

    public void setPadding(float f) {
        this.paddingBottom = f;
        this.paddingTop = f;
        this.paddingLeft = f;
        this.paddingRight = f;
    }

    public void setPaddingBottom(float f) {
        this.paddingBottom = f;
    }

    public void setPaddingLeft(float f) {
        this.paddingLeft = f;
    }

    public void setPaddingRight(float f) {
        this.paddingRight = f;
    }

    public void setPaddingTop(float f) {
        this.paddingTop = f;
    }

    public void setPhrase(Phrase phrase) {
        this.table = null;
        this.image = null;
        ColumnText columnText = this.column;
        this.phrase = phrase;
        columnText.setText(phrase);
    }

    public void setRightIndent(float f) {
        this.column.setRightIndent(f);
    }

    @Override
    public void setRole(PdfName pdfName) {
        this.role = pdfName;
    }

    @Override
    public void setRotation(int n) {
        int n2;
        n = n2 = n % 360;
        if (n2 < 0) {
            n = n2 + 360;
        }
        if (n % 90 != 0) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("rotation.must.be.a.multiple.of.90", new Object[0]));
        }
        this.rotation = n;
    }

    public void setRowspan(int n) {
        this.rowspan = n;
    }

    public void setRunDirection(int n) {
        this.column.setRunDirection(n);
    }

    public void setSpaceCharRatio(float f) {
        this.column.setSpaceCharRatio(f);
    }

    void setTable(PdfPTable pdfPTable) {
        this.table = pdfPTable;
        this.column.setText(null);
        this.image = null;
        if (pdfPTable != null) {
            boolean bl = this.verticalAlignment == 4;
            pdfPTable.setExtendLastRow(bl);
            this.column.addElement(pdfPTable);
            pdfPTable.setWidthPercentage(100.0f);
        }
    }

    public void setUseAscender(boolean bl) {
        this.column.setUseAscender(bl);
    }

    public void setUseBorderPadding(boolean bl) {
        this.useBorderPadding = bl;
    }

    public void setUseDescender(boolean bl) {
        this.useDescender = bl;
    }

    public void setVerticalAlignment(int n) {
        if (this.table != null) {
            PdfPTable pdfPTable = this.table;
            boolean bl = n == 4;
            pdfPTable.setExtendLastRow(bl);
        }
        this.verticalAlignment = n;
    }
}

