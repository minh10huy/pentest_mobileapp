/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.text.pdf.parser.ImageRenderInfo;
import com.itextpdf.text.pdf.parser.LineSegment;
import com.itextpdf.text.pdf.parser.Matrix;
import com.itextpdf.text.pdf.parser.TextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TextRenderInfo;
import com.itextpdf.text.pdf.parser.Vector;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

public class LocationTextExtractionStrategy
implements TextExtractionStrategy {
    static boolean DUMP_STATE = false;
    private final List<TextChunk> locationalResult = new ArrayList<TextChunk>();
    private final TextChunkLocationStrategy tclStrat;

    public LocationTextExtractionStrategy() {
        this(new TextChunkLocationStrategy(){

            @Override
            public TextChunkLocation createLocation(TextRenderInfo textRenderInfo, LineSegment lineSegment) {
                return new TextChunkLocationDefaultImp(lineSegment.getStartPoint(), lineSegment.getEndPoint(), textRenderInfo.getSingleSpaceWidth());
            }
        });
    }

    public LocationTextExtractionStrategy(TextChunkLocationStrategy textChunkLocationStrategy) {
        this.tclStrat = textChunkLocationStrategy;
    }

    private static int compareInts(int n, int n2) {
        if (n == n2) {
            return 0;
        }
        if (n < n2) {
            return -1;
        }
        return 1;
    }

    private void dumpState() {
        Iterator<TextChunk> iterator = this.locationalResult.iterator();
        while (iterator.hasNext()) {
            iterator.next().printDiagnostics();
            System.out.println();
        }
    }

    private boolean endsWithSpace(String string2) {
        int n = string2.length();
        boolean bl = false;
        if (n == 0) {
            return false;
        }
        if (string2.charAt(string2.length() - 1) == ' ') {
            bl = true;
        }
        return bl;
    }

    private List<TextChunk> filterTextChunks(List<TextChunk> object, TextChunkFilter textChunkFilter) {
        if (textChunkFilter == null) {
            return object;
        }
        ArrayList<TextChunk> arrayList = new ArrayList<TextChunk>();
        object = object.iterator();
        while (object.hasNext()) {
            TextChunk textChunk = (TextChunk)object.next();
            if (!textChunkFilter.accept(textChunk)) continue;
            arrayList.add(textChunk);
        }
        return arrayList;
    }

    private boolean startsWithSpace(String string2) {
        int n = string2.length();
        boolean bl = false;
        if (n == 0) {
            return false;
        }
        if (string2.charAt(0) == ' ') {
            bl = true;
        }
        return bl;
    }

    @Override
    public void beginTextBlock() {
    }

    @Override
    public void endTextBlock() {
    }

    @Override
    public String getResultantText() {
        return this.getResultantText(null);
    }

    public String getResultantText(TextChunkFilter object) {
        if (DUMP_STATE) {
            this.dumpState();
        }
        Object object2 = this.filterTextChunks(this.locationalResult, (TextChunkFilter)object);
        Collections.sort(object2);
        StringBuilder stringBuilder = new StringBuilder();
        object = null;
        Iterator<TextChunk> iterator = object2.iterator();
        while (iterator.hasNext()) {
            object2 = iterator.next();
            if (object == null) {
                stringBuilder.append(((TextChunk)object2).text);
            } else if (((TextChunk)object2).sameLine((TextChunk)object)) {
                if (this.isChunkAtWordBoundary((TextChunk)object2, (TextChunk)object) && !this.startsWithSpace(((TextChunk)object2).text) && !this.endsWithSpace(((TextChunk)object).text)) {
                    stringBuilder.append(' ');
                }
                stringBuilder.append(((TextChunk)object2).text);
            } else {
                stringBuilder.append('\n');
                stringBuilder.append(((TextChunk)object2).text);
            }
            object = object2;
        }
        return stringBuilder.toString();
    }

    protected boolean isChunkAtWordBoundary(TextChunk textChunk, TextChunk textChunk2) {
        return textChunk.getLocation().isAtWordBoundary(textChunk2.getLocation());
    }

    @Override
    public void renderImage(ImageRenderInfo imageRenderInfo) {
    }

    @Override
    public void renderText(TextRenderInfo object) {
        LineSegment lineSegment;
        LineSegment lineSegment2 = lineSegment = object.getBaseline();
        if (object.getRise() != 0.0f) {
            lineSegment2 = lineSegment.transformBy(new Matrix(0.0f, - object.getRise()));
        }
        object = new TextChunk(object.getText(), this.tclStrat.createLocation((TextRenderInfo)object, lineSegment2));
        this.locationalResult.add((TextChunk)object);
    }

    public static class TextChunk
    implements Comparable<TextChunk> {
        private final TextChunkLocation location;
        private final String text;

        public TextChunk(String string2, TextChunkLocation textChunkLocation) {
            this.text = string2;
            this.location = textChunkLocation;
        }

        public TextChunk(String string2, Vector vector, Vector vector2, float f) {
            this(string2, new TextChunkLocationDefaultImp(vector, vector2, f));
        }

        private void printDiagnostics() {
            PrintStream printStream = System.out;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Text (@");
            stringBuilder.append(this.location.getStartLocation());
            stringBuilder.append(" -> ");
            stringBuilder.append(this.location.getEndLocation());
            stringBuilder.append("): ");
            stringBuilder.append(this.text);
            printStream.println(stringBuilder.toString());
            printStream = System.out;
            stringBuilder = new StringBuilder();
            stringBuilder.append("orientationMagnitude: ");
            stringBuilder.append(this.location.orientationMagnitude());
            printStream.println(stringBuilder.toString());
            printStream = System.out;
            stringBuilder = new StringBuilder();
            stringBuilder.append("distPerpendicular: ");
            stringBuilder.append(this.location.distPerpendicular());
            printStream.println(stringBuilder.toString());
            printStream = System.out;
            stringBuilder = new StringBuilder();
            stringBuilder.append("distParallel: ");
            stringBuilder.append(this.location.distParallelStart());
            printStream.println(stringBuilder.toString());
        }

        private boolean sameLine(TextChunk textChunk) {
            return this.getLocation().sameLine(textChunk.getLocation());
        }

        @Override
        public int compareTo(TextChunk textChunk) {
            return this.location.compareTo(textChunk.location);
        }

        public float distanceFromEndOf(TextChunk textChunk) {
            return this.location.distanceFromEndOf(textChunk.location);
        }

        public float getCharSpaceWidth() {
            return this.location.getCharSpaceWidth();
        }

        public Vector getEndLocation() {
            return this.location.getEndLocation();
        }

        public TextChunkLocation getLocation() {
            return this.location;
        }

        public Vector getStartLocation() {
            return this.location.getStartLocation();
        }

        public String getText() {
            return this.text;
        }
    }

    public static interface TextChunkFilter {
        public boolean accept(TextChunk var1);
    }

    public static interface TextChunkLocation
    extends Comparable<TextChunkLocation> {
        public float distParallelEnd();

        public float distParallelStart();

        public int distPerpendicular();

        public float distanceFromEndOf(TextChunkLocation var1);

        public float getCharSpaceWidth();

        public Vector getEndLocation();

        public Vector getStartLocation();

        public boolean isAtWordBoundary(TextChunkLocation var1);

        public int orientationMagnitude();

        public boolean sameLine(TextChunkLocation var1);
    }

    public static class TextChunkLocationDefaultImp
    implements TextChunkLocation {
        private final float charSpaceWidth;
        private final float distParallelEnd;
        private final float distParallelStart;
        private final int distPerpendicular;
        private final Vector endLocation;
        private final int orientationMagnitude;
        private final Vector orientationVector;
        private final Vector startLocation;

        public TextChunkLocationDefaultImp(Vector vector, Vector vector2, float f) {
            Vector vector3;
            this.startLocation = vector;
            this.endLocation = vector2;
            this.charSpaceWidth = f;
            Vector vector4 = vector3 = vector2.subtract(vector);
            if (vector3.length() == 0.0f) {
                vector4 = new Vector(1.0f, 0.0f, 0.0f);
            }
            this.orientationVector = vector4.normalize();
            this.orientationMagnitude = (int)(Math.atan2(this.orientationVector.get(1), this.orientationVector.get(0)) * 1000.0);
            this.distPerpendicular = (int)vector.subtract(new Vector(0.0f, 0.0f, 1.0f)).cross(this.orientationVector).get(2);
            this.distParallelStart = this.orientationVector.dot(vector);
            this.distParallelEnd = this.orientationVector.dot(vector2);
        }

        @Override
        public int compareTo(TextChunkLocation textChunkLocation) {
            if (this == textChunkLocation) {
                return 0;
            }
            int n = LocationTextExtractionStrategy.compareInts(this.orientationMagnitude(), textChunkLocation.orientationMagnitude());
            if (n != 0) {
                return n;
            }
            n = LocationTextExtractionStrategy.compareInts(this.distPerpendicular(), textChunkLocation.distPerpendicular());
            if (n != 0) {
                return n;
            }
            return Float.compare(this.distParallelStart(), textChunkLocation.distParallelStart());
        }

        @Override
        public float distParallelEnd() {
            return this.distParallelEnd;
        }

        @Override
        public float distParallelStart() {
            return this.distParallelStart;
        }

        @Override
        public int distPerpendicular() {
            return this.distPerpendicular;
        }

        @Override
        public float distanceFromEndOf(TextChunkLocation textChunkLocation) {
            return this.distParallelStart() - textChunkLocation.distParallelEnd();
        }

        @Override
        public float getCharSpaceWidth() {
            return this.charSpaceWidth;
        }

        @Override
        public Vector getEndLocation() {
            return this.endLocation;
        }

        @Override
        public Vector getStartLocation() {
            return this.startLocation;
        }

        @Override
        public boolean isAtWordBoundary(TextChunkLocation textChunkLocation) {
            float f = this.getCharSpaceWidth();
            boolean bl = false;
            if (f < 0.1f) {
                return false;
            }
            f = this.distanceFromEndOf(textChunkLocation);
            if (f < - this.getCharSpaceWidth() || f > this.getCharSpaceWidth() / 2.0f) {
                bl = true;
            }
            return bl;
        }

        @Override
        public int orientationMagnitude() {
            return this.orientationMagnitude;
        }

        @Override
        public boolean sameLine(TextChunkLocation textChunkLocation) {
            if (this.orientationMagnitude() == textChunkLocation.orientationMagnitude() && this.distPerpendicular() == textChunkLocation.distPerpendicular()) {
                return true;
            }
            return false;
        }
    }

    public static interface TextChunkLocationStrategy {
        public TextChunkLocation createLocation(TextRenderInfo var1, LineSegment var2);
    }

}

