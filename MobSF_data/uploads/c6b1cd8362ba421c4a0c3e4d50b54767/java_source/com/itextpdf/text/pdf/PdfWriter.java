/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.AccessibleElementId;
import com.itextpdf.text.BaseColor;
import com.itextpdf.text.DocListener;
import com.itextpdf.text.DocWriter;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Image;
import com.itextpdf.text.ImgJBIG2;
import com.itextpdf.text.ImgWMF;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.Version;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.io.TempFileCache;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.pdf.BadPdfFormatException;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.ColorDetails;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.FontDetails;
import com.itextpdf.text.pdf.ICC_Profile;
import com.itextpdf.text.pdf.ICachedColorSpace;
import com.itextpdf.text.pdf.IPdfSpecialColorSpace;
import com.itextpdf.text.pdf.OutputStreamCounter;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfAcroForm;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfContents;
import com.itextpdf.text.pdf.PdfDestination;
import com.itextpdf.text.pdf.PdfDeveloperExtension;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfDocument;
import com.itextpdf.text.pdf.PdfEncryption;
import com.itextpdf.text.pdf.PdfException;
import com.itextpdf.text.pdf.PdfFileSpecification;
import com.itextpdf.text.pdf.PdfFormField;
import com.itextpdf.text.pdf.PdfICCBased;
import com.itextpdf.text.pdf.PdfImage;
import com.itextpdf.text.pdf.PdfImportedPage;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLayer;
import com.itextpdf.text.pdf.PdfLayerMembership;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfOCG;
import com.itextpdf.text.pdf.PdfOCProperties;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfOutline;
import com.itextpdf.text.pdf.PdfPage;
import com.itextpdf.text.pdf.PdfPageEvent;
import com.itextpdf.text.pdf.PdfPageLabels;
import com.itextpdf.text.pdf.PdfPages;
import com.itextpdf.text.pdf.PdfPattern;
import com.itextpdf.text.pdf.PdfPatternPainter;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfReaderInstance;
import com.itextpdf.text.pdf.PdfShading;
import com.itextpdf.text.pdf.PdfShadingPattern;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfStructureElement;
import com.itextpdf.text.pdf.PdfStructureTreeRoot;
import com.itextpdf.text.pdf.PdfTemplate;
import com.itextpdf.text.pdf.PdfTransition;
import com.itextpdf.text.pdf.PdfXConformanceException;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.SimpleBookmark;
import com.itextpdf.text.pdf.TtfUnicodeWriter;
import com.itextpdf.text.pdf.collection.PdfCollection;
import com.itextpdf.text.pdf.events.PdfPageEventForwarder;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import com.itextpdf.text.pdf.interfaces.PdfAnnotations;
import com.itextpdf.text.pdf.interfaces.PdfDocumentActions;
import com.itextpdf.text.pdf.interfaces.PdfEncryptionSettings;
import com.itextpdf.text.pdf.interfaces.PdfIsoConformance;
import com.itextpdf.text.pdf.interfaces.PdfPageActions;
import com.itextpdf.text.pdf.interfaces.PdfRunDirection;
import com.itextpdf.text.pdf.interfaces.PdfVersion;
import com.itextpdf.text.pdf.interfaces.PdfViewerPreferences;
import com.itextpdf.text.pdf.interfaces.PdfXConformance;
import com.itextpdf.text.pdf.internal.PdfVersionImp;
import com.itextpdf.text.pdf.internal.PdfXConformanceImp;
import com.itextpdf.text.xml.xmp.XmpWriter;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.options.PropertyOptions;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Serializable;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class PdfWriter
extends DocWriter
implements PdfViewerPreferences,
PdfEncryptionSettings,
PdfVersion,
PdfDocumentActions,
PdfPageActions,
PdfRunDirection,
PdfAnnotations {
    public static final int ALLOW_ASSEMBLY = 1024;
    public static final int ALLOW_COPY = 16;
    public static final int ALLOW_DEGRADED_PRINTING = 4;
    public static final int ALLOW_FILL_IN = 256;
    public static final int ALLOW_MODIFY_ANNOTATIONS = 32;
    public static final int ALLOW_MODIFY_CONTENTS = 8;
    public static final int ALLOW_PRINTING = 2052;
    public static final int ALLOW_SCREENREADERS = 512;
    @Deprecated
    public static final int AllowAssembly = 1024;
    @Deprecated
    public static final int AllowCopy = 16;
    @Deprecated
    public static final int AllowDegradedPrinting = 4;
    @Deprecated
    public static final int AllowFillIn = 256;
    @Deprecated
    public static final int AllowModifyAnnotations = 32;
    @Deprecated
    public static final int AllowModifyContents = 8;
    @Deprecated
    public static final int AllowPrinting = 2052;
    @Deprecated
    public static final int AllowScreenReaders = 512;
    protected static Counter COUNTER = CounterFactory.getCounter(PdfWriter.class);
    public static final int CenterWindow = 65536;
    public static final PdfName DID_PRINT;
    public static final PdfName DID_SAVE;
    public static final PdfName DOCUMENT_CLOSE;
    public static final int DO_NOT_ENCRYPT_METADATA = 8;
    public static final int DirectionL2R = 4194304;
    public static final int DirectionR2L = 8388608;
    public static final int DisplayDocTitle = 131072;
    public static final int EMBEDDED_FILES_ONLY = 24;
    public static final int ENCRYPTION_AES_128 = 2;
    public static final int ENCRYPTION_AES_256 = 3;
    static final int ENCRYPTION_MASK = 7;
    public static final int FitWindow = 32768;
    public static final int GENERATION_MAX = 65535;
    public static final int HideMenubar = 8192;
    public static final int HideToolbar = 4096;
    public static final int HideWindowUI = 16384;
    public static final float NO_SPACE_CHAR_RATIO = 1.0E7f;
    public static final int NonFullScreenPageModeUseNone = 262144;
    public static final int NonFullScreenPageModeUseOC = 2097152;
    public static final int NonFullScreenPageModeUseOutlines = 524288;
    public static final int NonFullScreenPageModeUseThumbs = 1048576;
    public static final PdfName PAGE_CLOSE;
    public static final PdfName PAGE_OPEN;
    public static final int PDFX1A2001 = 1;
    public static final int PDFX32002 = 2;
    public static final int PDFXNONE = 0;
    public static final PdfName PDF_VERSION_1_2;
    public static final PdfName PDF_VERSION_1_3;
    public static final PdfName PDF_VERSION_1_4;
    public static final PdfName PDF_VERSION_1_5;
    public static final PdfName PDF_VERSION_1_6;
    public static final PdfName PDF_VERSION_1_7;
    public static final int PageLayoutOneColumn = 2;
    public static final int PageLayoutSinglePage = 1;
    public static final int PageLayoutTwoColumnLeft = 4;
    public static final int PageLayoutTwoColumnRight = 8;
    public static final int PageLayoutTwoPageLeft = 16;
    public static final int PageLayoutTwoPageRight = 32;
    public static final int PageModeFullScreen = 512;
    public static final int PageModeUseAttachments = 2048;
    public static final int PageModeUseNone = 64;
    public static final int PageModeUseOC = 1024;
    public static final int PageModeUseOutlines = 128;
    public static final int PageModeUseThumbs = 256;
    public static final int PrintScalingNone = 16777216;
    public static final int RUN_DIRECTION_DEFAULT = 0;
    public static final int RUN_DIRECTION_LTR = 2;
    public static final int RUN_DIRECTION_NO_BIDI = 1;
    public static final int RUN_DIRECTION_RTL = 3;
    public static final int SIGNATURE_APPEND_ONLY = 2;
    public static final int SIGNATURE_EXISTS = 1;
    public static final float SPACE_CHAR_RATIO_DEFAULT = 2.5f;
    public static final int STANDARD_ENCRYPTION_128 = 1;
    public static final int STANDARD_ENCRYPTION_40 = 0;
    @Deprecated
    public static final boolean STRENGTH128BITS = true;
    @Deprecated
    public static final boolean STRENGTH40BITS = false;
    public static final char VERSION_1_2 = '2';
    public static final char VERSION_1_3 = '3';
    public static final char VERSION_1_4 = '4';
    public static final char VERSION_1_5 = '5';
    public static final char VERSION_1_6 = '6';
    public static final char VERSION_1_7 = '7';
    public static final PdfName WILL_PRINT;
    public static final PdfName WILL_SAVE;
    public static final int markAll = 0;
    public static final int markInlineElementsOnly = 1;
    private static final List<PdfName> standardStructElems_1_4;
    private static final List<PdfName> standardStructElems_1_7;
    protected HashMap<PdfStream, PdfIndirectReference> JBIG2Globals = new HashMap();
    protected PdfArray OCGLocked = new PdfArray();
    protected PdfArray OCGRadioGroup = new PdfArray();
    protected PdfOCProperties OCProperties;
    protected PdfBody body;
    protected int colorNumber = 1;
    protected ICC_Profile colorProfile;
    protected int compressionLevel = -1;
    protected PdfEncryption crypto;
    protected int currentPageNumber = 1;
    protected PdfReaderInstance currentPdfReaderInstance;
    protected PdfDictionary defaultColorspace = new PdfDictionary();
    protected PdfContentByte directContent;
    protected PdfContentByte directContentUnder;
    protected HashMap<ICachedColorSpace, ColorDetails> documentColors = new HashMap();
    protected HashMap<PdfDictionary, PdfObject[]> documentExtGState = new HashMap();
    protected LinkedHashMap<BaseFont, FontDetails> documentFonts = new LinkedHashMap();
    protected LinkedHashSet<PdfOCG> documentOCG = new LinkedHashSet();
    protected ArrayList<PdfOCG> documentOCGorder = new ArrayList();
    protected HashMap<PdfPatternPainter, PdfName> documentPatterns = new HashMap();
    protected HashMap<Object, PdfObject[]> documentProperties = new HashMap();
    protected HashSet<PdfShadingPattern> documentShadingPatterns = new HashSet();
    protected HashSet<PdfShading> documentShadings = new HashSet();
    protected HashMap<ColorDetails, ColorDetails> documentSpotPatterns = new HashMap();
    protected PdfDictionary extraCatalog;
    protected int fontNumber = 1;
    protected HashMap<PdfIndirectReference, Object[]> formXObjects = new HashMap();
    protected int formXObjectsCounter = 1;
    protected boolean fullCompression = false;
    protected PdfDictionary group;
    protected PdfDictionary imageDictionary = new PdfDictionary();
    private final HashMap<Long, PdfName> images = new HashMap();
    protected List<HashMap<String, Object>> newBookmarks;
    protected byte[] originalFileID = null;
    protected PdfDictionary pageDictEntries = new PdfDictionary();
    private PdfPageEvent pageEvent;
    protected ArrayList<PdfIndirectReference> pageReferences = new ArrayList();
    protected ColorDetails patternColorspaceCMYK;
    protected ColorDetails patternColorspaceGRAY;
    protected ColorDetails patternColorspaceRGB;
    protected int patternNumber = 1;
    protected PdfDocument pdf;
    protected PdfIsoConformance pdfIsoConformance = this.initPdfIsoConformance();
    protected PdfVersionImp pdf_version = new PdfVersionImp();
    protected long prevxref = 0L;
    protected HashMap<PdfReader, PdfReaderInstance> readerInstances = new HashMap();
    private boolean rgbTransparencyBlending;
    protected PdfPages root = new PdfPages(this);
    protected int runDirection = 1;
    private float spaceCharRatio = 2.5f;
    protected PdfStructureTreeRoot structureTreeRoot;
    protected PdfName tabs = null;
    protected boolean tagged = false;
    protected int taggingMode = 1;
    protected TtfUnicodeWriter ttfUnicodeWriter = null;
    private boolean userProperties;
    protected byte[] xmpMetadata = null;
    protected XmpWriter xmpWriter = null;

    static {
        PDF_VERSION_1_2 = new PdfName("1.2");
        PDF_VERSION_1_3 = new PdfName("1.3");
        PDF_VERSION_1_4 = new PdfName("1.4");
        PDF_VERSION_1_5 = new PdfName("1.5");
        PDF_VERSION_1_6 = new PdfName("1.6");
        PDF_VERSION_1_7 = new PdfName("1.7");
        DOCUMENT_CLOSE = PdfName.WC;
        WILL_SAVE = PdfName.WS;
        DID_SAVE = PdfName.DS;
        WILL_PRINT = PdfName.WP;
        DID_PRINT = PdfName.DP;
        PAGE_OPEN = PdfName.O;
        PAGE_CLOSE = PdfName.C;
        standardStructElems_1_4 = Arrays.asList(PdfName.DOCUMENT, PdfName.PART, PdfName.ART, PdfName.SECT, PdfName.DIV, PdfName.BLOCKQUOTE, PdfName.CAPTION, PdfName.TOC, PdfName.TOCI, PdfName.INDEX, PdfName.NONSTRUCT, PdfName.PRIVATE, PdfName.P, PdfName.H, PdfName.H1, PdfName.H2, PdfName.H3, PdfName.H4, PdfName.H5, PdfName.H6, PdfName.L, PdfName.LBL, PdfName.LI, PdfName.LBODY, PdfName.TABLE, PdfName.TR, PdfName.TH, PdfName.TD, PdfName.SPAN, PdfName.QUOTE, PdfName.NOTE, PdfName.REFERENCE, PdfName.BIBENTRY, PdfName.CODE, PdfName.LINK, PdfName.FIGURE, PdfName.FORMULA, PdfName.FORM);
        standardStructElems_1_7 = Arrays.asList(PdfName.DOCUMENT, PdfName.PART, PdfName.ART, PdfName.SECT, PdfName.DIV, PdfName.BLOCKQUOTE, PdfName.CAPTION, PdfName.TOC, PdfName.TOCI, PdfName.INDEX, PdfName.NONSTRUCT, PdfName.PRIVATE, PdfName.P, PdfName.H, PdfName.H1, PdfName.H2, PdfName.H3, PdfName.H4, PdfName.H5, PdfName.H6, PdfName.L, PdfName.LBL, PdfName.LI, PdfName.LBODY, PdfName.TABLE, PdfName.TR, PdfName.TH, PdfName.TD, PdfName.THEAD, PdfName.TBODY, PdfName.TFOOT, PdfName.SPAN, PdfName.QUOTE, PdfName.NOTE, PdfName.REFERENCE, PdfName.BIBENTRY, PdfName.CODE, PdfName.LINK, PdfName.ANNOT, PdfName.RUBY, PdfName.RB, PdfName.RT, PdfName.RP, PdfName.WARICHU, PdfName.WT, PdfName.WP, PdfName.FIGURE, PdfName.FORMULA, PdfName.FORM);
    }

    protected PdfWriter() {
    }

    protected PdfWriter(PdfDocument pdfDocument, OutputStream outputStream) {
        super(pdfDocument, outputStream);
        this.pdf = pdfDocument;
        this.directContentUnder = new PdfContentByte(this);
        this.directContent = this.directContentUnder.getDuplicate();
    }

    private void addASEvent(PdfName pdfName, PdfName pdfName2) {
        PdfDictionary pdfDictionary;
        PdfArray pdfArray = new PdfArray();
        for (PdfLayer pdfObject2 : this.documentOCG) {
            pdfDictionary = pdfObject2.getAsDict(PdfName.USAGE);
            if (pdfDictionary == null || pdfDictionary.get(pdfName2) == null) continue;
            pdfArray.add(pdfObject2.getRef());
        }
        if (pdfArray.size() == 0) {
            return;
        }
        pdfDictionary = this.OCProperties.getAsDict(PdfName.D);
        PdfArray pdfArray2 = pdfDictionary.getAsArray(PdfName.AS);
        Object object = pdfArray2;
        if (pdfArray2 == null) {
            object = new PdfArray();
            pdfDictionary.put(PdfName.AS, (PdfObject)object);
        }
        PdfDictionary pdfDictionary2 = new PdfDictionary();
        pdfDictionary2.put(PdfName.EVENT, pdfName);
        pdfDictionary2.put(PdfName.CATEGORY, new PdfArray(pdfName2));
        pdfDictionary2.put(PdfName.OCGS, pdfArray);
        object.add(pdfDictionary2);
    }

    public static void checkPdfIsoConformance(PdfWriter pdfWriter, int n, Object object) {
        if (pdfWriter != null) {
            pdfWriter.checkPdfIsoConformance(n, object);
        }
    }

    private void completeExtraCatalog(PdfDictionary pdfDictionary) {
        if (this.isPdfX() && pdfDictionary.get(PdfName.OUTPUTINTENTS) == null) {
            PdfDictionary pdfDictionary2 = new PdfDictionary(PdfName.OUTPUTINTENT);
            pdfDictionary2.put(PdfName.OUTPUTCONDITION, new PdfString("SWOP CGATS TR 001-1995"));
            pdfDictionary2.put(PdfName.OUTPUTCONDITIONIDENTIFIER, new PdfString("CGATS TR 001"));
            pdfDictionary2.put(PdfName.REGISTRYNAME, new PdfString("http://www.color.org"));
            pdfDictionary2.put(PdfName.INFO, new PdfString(""));
            pdfDictionary2.put(PdfName.S, PdfName.GTS_PDFX);
            pdfDictionary.put(PdfName.OUTPUTINTENTS, new PdfArray(pdfDictionary2));
        }
    }

    private void completeInfoDictionary(PdfDictionary pdfDictionary) {
        if (this.isPdfX()) {
            if (pdfDictionary.get(PdfName.GTS_PDFXVERSION) == null) {
                if (((PdfXConformanceImp)this.pdfIsoConformance).isPdfX1A2001()) {
                    pdfDictionary.put(PdfName.GTS_PDFXVERSION, new PdfString("PDF/X-1:2001"));
                    pdfDictionary.put(new PdfName("GTS_PDFXConformance"), new PdfString("PDF/X-1a:2001"));
                } else if (((PdfXConformanceImp)this.pdfIsoConformance).isPdfX32002()) {
                    pdfDictionary.put(PdfName.GTS_PDFXVERSION, new PdfString("PDF/X-3:2002"));
                }
            }
            if (pdfDictionary.get(PdfName.TITLE) == null) {
                pdfDictionary.put(PdfName.TITLE, new PdfString("Pdf document"));
            }
            if (pdfDictionary.get(PdfName.CREATOR) == null) {
                pdfDictionary.put(PdfName.CREATOR, new PdfString("Unknown"));
            }
            if (pdfDictionary.get(PdfName.TRAPPED) == null) {
                pdfDictionary.put(PdfName.TRAPPED, new PdfName("False"));
            }
        }
    }

    public static PdfWriter getInstance(Document docListener, OutputStream outputStream) throws DocumentException {
        PdfDocument pdfDocument = new PdfDocument();
        docListener.addDocListener(pdfDocument);
        docListener = new PdfWriter(pdfDocument, outputStream);
        pdfDocument.addWriter((PdfWriter)docListener);
        return docListener;
    }

    public static PdfWriter getInstance(Document docListener, OutputStream outputStream, DocListener docListener2) throws DocumentException {
        PdfDocument pdfDocument = new PdfDocument();
        pdfDocument.addDocListener(docListener2);
        docListener.addDocListener(pdfDocument);
        docListener = new PdfWriter(pdfDocument, outputStream);
        pdfDocument.addWriter((PdfWriter)docListener);
        return docListener;
    }

    protected static String getNameString(PdfDictionary pdfObject, PdfName pdfName) {
        if ((pdfObject = PdfReader.getPdfObject(pdfObject.get(pdfName))) != null && pdfObject.isString()) {
            return ((PdfString)pdfObject).toUnicodeString();
        }
        return null;
    }

    private static void getOCGOrder(PdfArray pdfArray, PdfLayer pdfLayer) {
        ArrayList<PdfLayer> arrayList;
        if (!pdfLayer.isOnPanel()) {
            return;
        }
        if (pdfLayer.getTitle() == null) {
            pdfArray.add(pdfLayer.getRef());
        }
        if ((arrayList = pdfLayer.getChildren()) == null) {
            return;
        }
        PdfArray pdfArray2 = new PdfArray();
        if (pdfLayer.getTitle() != null) {
            pdfArray2.add(new PdfString(pdfLayer.getTitle(), "UnicodeBig"));
        }
        for (int i = 0; i < arrayList.size(); ++i) {
            PdfWriter.getOCGOrder(pdfArray2, arrayList.get(i));
        }
        if (pdfArray2.size() > 0) {
            pdfArray.add(pdfArray2);
        }
    }

    protected static void writeKeyInfo(OutputStream outputStream) throws IOException {
        String string2;
        Version version = Version.getInstance();
        String string3 = string2 = version.getKey();
        if (string2 == null) {
            string3 = "iText";
        }
        outputStream.write(PdfWriter.getISOBytes(String.format("%%%s-%s\n", string3, version.getRelease())));
    }

    protected PdfIndirectReference add(PdfICCBased object) {
        try {
            object = this.addToBody((PdfObject)object);
            return object.getIndirectReference();
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    PdfIndirectReference add(PdfImage var1_1, PdfIndirectReference var2_3) throws PdfException {
        if (this.imageDictionary.contains(var1_1.name()) != false) return (PdfIndirectReference)this.imageDictionary.get(var1_1.name());
        PdfWriter.checkPdfIsoConformance(this, 5, var1_1);
        var3_4 = var2_3;
        if (var2_3 instanceof PRIndirectReference) {
            var2_3 = (PRIndirectReference)var2_3;
            var3_4 = new PdfIndirectReference(0, this.getNewObjectNumber(var2_3.getReader(), var2_3.getNumber(), var2_3.getGeneration()));
        }
        if (var3_4 != null) ** GOTO lbl11
        try {
            block3 : {
                var3_4 = this.addToBody(var1_1).getIndirectReference();
                break block3;
lbl11: // 1 sources:
                this.addToBody((PdfObject)var1_1, var3_4);
            }
            this.imageDictionary.put(var1_1.name(), var3_4);
            return var3_4;
        }
        catch (IOException var1_2) {
            throw new ExceptionConverter(var1_2);
        }
    }

    PdfIndirectReference add(PdfPage pdfPage, PdfContents object) throws PdfException {
        block5 : {
            block4 : {
                if (!this.open) {
                    throw new PdfException(MessageLocalization.getComposedMessage("the.document.is.not.open", new Object[0]));
                }
                try {
                    object = this.addToBody((PdfObject)object);
                    pdfPage.add(object.getIndirectReference());
                    if (this.group == null) break block4;
                }
                catch (IOException iOException) {
                    throw new ExceptionConverter(iOException);
                }
                pdfPage.put(PdfName.GROUP, this.group);
                this.group = null;
                break block5;
            }
            if (this.rgbTransparencyBlending) {
                object = new PdfDictionary();
                object.put(PdfName.TYPE, PdfName.GROUP);
                object.put(PdfName.S, PdfName.TRANSPARENCY);
                object.put(PdfName.CS, PdfName.DEVICERGB);
                pdfPage.put(PdfName.GROUP, (PdfObject)object);
            }
        }
        this.root.addPage(pdfPage);
        ++this.currentPageNumber;
        return null;
    }

    @Override
    public void addAnnotation(PdfAnnotation pdfAnnotation) {
        this.pdf.addAnnotation(pdfAnnotation);
    }

    void addAnnotation(PdfAnnotation pdfAnnotation, int n) {
        this.addAnnotation(pdfAnnotation);
    }

    @Override
    public void addCalculationOrder(PdfFormField pdfFormField) {
        this.pdf.addCalculationOrder(pdfFormField);
    }

    @Override
    public void addDeveloperExtension(PdfDeveloperExtension pdfDeveloperExtension) {
        this.pdf_version.addDeveloperExtension(pdfDeveloperExtension);
    }

    public PdfName addDirectImageSimple(Image image) throws PdfException, DocumentException {
        return this.addDirectImageSimple(image, null);
    }

    public PdfName addDirectImageSimple(Image image, PdfIndirectReference serializable) throws PdfException, DocumentException {
        if (this.images.containsKey(image.getMySerialId())) {
            return this.images.get(image.getMySerialId());
        }
        if (image.isImgTemplate()) {
            serializable = new StringBuilder();
            serializable.append("img");
            serializable.append(this.images.size());
            PdfName pdfName = new PdfName(serializable.toString());
            serializable = pdfName;
            if (image instanceof ImgWMF) {
                try {
                    ((ImgWMF)image).readWMF(PdfTemplate.createTemplate(this, 0.0f, 0.0f));
                    serializable = pdfName;
                }
                catch (Exception exception) {
                    throw new DocumentException(exception);
                }
            }
        } else {
            PdfObject pdfObject;
            PdfObject pdfObject2 = image.getDirectReference();
            if (pdfObject2 != null) {
                serializable = new StringBuilder();
                serializable.append("img");
                serializable.append(this.images.size());
                serializable = new PdfName(serializable.toString());
                this.images.put(image.getMySerialId(), (PdfName)serializable);
                this.imageDictionary.put((PdfName)serializable, pdfObject2);
                return serializable;
            }
            Object object = image.getImageMask();
            pdfObject2 = null;
            if (object != null) {
                pdfObject2 = this.getImageReference(this.images.get(object.getMySerialId()));
            }
            object = new StringBuilder();
            object.append("img");
            object.append(this.images.size());
            pdfObject2 = new PdfImage(image, object.toString(), (PdfIndirectReference)pdfObject2);
            if (image instanceof ImgJBIG2 && (object = ((ImgJBIG2)image).getGlobalBytes()) != null) {
                pdfObject = new PdfDictionary();
                pdfObject.put(PdfName.JBIG2GLOBALS, this.getReferenceJBIG2Globals((byte[])object));
                pdfObject2.put(PdfName.DECODEPARMS, pdfObject);
            }
            if (image.hasICCProfile()) {
                pdfObject = this.add(new PdfICCBased(image.getICCProfile(), image.getCompressionLevel()));
                object = new PdfArray();
                object.add(PdfName.ICCBASED);
                object.add(pdfObject);
                pdfObject = pdfObject2.getAsArray(PdfName.COLORSPACE);
                if (pdfObject != null) {
                    if (pdfObject.size() > 1 && PdfName.INDEXED.equals(pdfObject.getPdfObject(0))) {
                        pdfObject.set(1, (PdfObject)object);
                    } else {
                        pdfObject2.put(PdfName.COLORSPACE, (PdfObject)object);
                    }
                } else {
                    pdfObject2.put(PdfName.COLORSPACE, (PdfObject)object);
                }
            }
            this.add((PdfImage)pdfObject2, (PdfIndirectReference)serializable);
            serializable = pdfObject2.name();
        }
        this.images.put(image.getMySerialId(), (PdfName)serializable);
        return serializable;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    PdfName addDirectTemplateSimple(PdfTemplate var1_1, PdfName var2_3) {
        block3 : {
            var4_4 = var1_1.getIndirectReference();
            var3_5 = this.formXObjects.get(var4_4);
            if (var3_5 != null) return (PdfName)var3_5[0];
            var3_6 = var2_3;
            if (var2_3 != null) ** GOTO lbl12
            try {
                var2_3 = new StringBuilder();
                var2_3.append("Xf");
                var2_3.append(this.formXObjectsCounter);
                var3_7 = new PdfName(var2_3.toString());
                ++this.formXObjectsCounter;
lbl12: // 2 sources:
                var2_3 = var1_1;
                if (var1_1.getType() != 2) break block3;
                var2_3 = (var1_1 = (PdfImportedPage)var1_1).getPdfReaderInstance().getReader();
                if (!this.readerInstances.containsKey(var2_3)) {
                    this.readerInstances.put((PdfReader)var2_3, var1_1.getPdfReaderInstance());
                }
            }
            catch (Exception var1_2) {
                throw new ExceptionConverter(var1_2);
            }
            var2_3 = null;
        }
        this.formXObjects.put(var4_4, new Object[]{var3_8, var2_3});
        return var3_8;
    }

    public void addFileAttachment(PdfFileSpecification pdfFileSpecification) throws IOException {
        this.addFileAttachment(null, pdfFileSpecification);
    }

    public void addFileAttachment(String string2, PdfFileSpecification pdfFileSpecification) throws IOException {
        this.pdf.addFileAttachment(string2, pdfFileSpecification);
    }

    public void addFileAttachment(String string2, byte[] arrby, String string3, String string4) throws IOException {
        this.addFileAttachment(string2, PdfFileSpecification.fileEmbedded(this, string3, string4, arrby));
    }

    public void addJavaScript(PdfAction pdfAction) {
        this.pdf.addJavaScript(pdfAction);
    }

    public void addJavaScript(String string2) {
        this.addJavaScript(string2, false);
    }

    public void addJavaScript(String string2, PdfAction pdfAction) {
        this.pdf.addJavaScript(string2, pdfAction);
    }

    public void addJavaScript(String string2, String string3) {
        this.addJavaScript(string2, string3, false);
    }

    public void addJavaScript(String string2, String string3, boolean bl) {
        this.addJavaScript(string2, PdfAction.javaScript(string3, this, bl));
    }

    public void addJavaScript(String string2, boolean bl) {
        this.addJavaScript(PdfAction.javaScript(string2, this, bl));
    }

    void addLocalDestinations(TreeMap<String, PdfDocument.Destination> object) throws IOException {
        for (Map.Entry entry : object.entrySet()) {
            String string2 = (String)entry.getKey();
            PdfDocument.Destination object2 = (PdfDocument.Destination)entry.getValue();
            Serializable serializable = object2.destination;
            if (object2.reference == null) {
                object2.reference = this.getPdfIndirectReference();
            }
            if (serializable == null) {
                serializable = new StringBuilder();
                serializable.append("invalid_");
                serializable.append(string2);
                this.addToBody((PdfObject)new PdfString(serializable.toString()), object2.reference);
                continue;
            }
            this.addToBody((PdfObject)serializable, object2.reference);
        }
    }

    public void addNamedDestination(String string2, int n, PdfDestination pdfDestination) {
        pdfDestination = new PdfDestination(pdfDestination);
        pdfDestination.addPage(this.getPageReference(n));
        this.pdf.localDestination(string2, pdfDestination);
    }

    public void addNamedDestinations(Map<String, String> object, int n) {
        for (Map.Entry entry : object.entrySet()) {
            Object object2 = (String)entry.getValue();
            int n2 = Integer.parseInt(object2.substring(0, object2.indexOf(" ")));
            object2 = new PdfDestination(object2.substring(object2.indexOf(" ") + 1));
            this.addNamedDestination((String)entry.getKey(), n2 + n, (PdfDestination)object2);
        }
    }

    public void addOCGRadioGroup(ArrayList<PdfLayer> arrayList) {
        PdfArray pdfArray = new PdfArray();
        for (int i = 0; i < arrayList.size(); ++i) {
            PdfLayer pdfLayer = arrayList.get(i);
            if (pdfLayer.getTitle() != null) continue;
            pdfArray.add(pdfLayer.getRef());
        }
        if (pdfArray.size() == 0) {
            return;
        }
        this.OCGRadioGroup.add(pdfArray);
    }

    public void addPageDictEntry(PdfName pdfName, PdfObject pdfObject) {
        this.pageDictEntries.put(pdfName, pdfObject);
    }

    protected void addSharedObjectsToBody() throws IOException {
        Iterator<Object> iterator = this.documentFonts.values().iterator();
        while (iterator.hasNext()) {
            iterator.next().writeFont(this);
        }
        this.addXFormsToBody();
        for (PdfReaderInstance this.currentPdfReaderInstance : this.readerInstances.values()) {
            this.currentPdfReaderInstance.writeAllPages();
        }
        this.currentPdfReaderInstance = null;
        for (ColorDetails object : this.documentColors.values()) {
            this.addToBody(object.getPdfObject(this), object.getIndirectReference());
        }
        for (PdfPatternPainter pdfPatternPainter : this.documentPatterns.keySet()) {
            this.addToBody((PdfObject)pdfPatternPainter.getPattern(this.compressionLevel), pdfPatternPainter.getIndirectReference());
        }
        iterator = this.documentShadingPatterns.iterator();
        while (iterator.hasNext()) {
            ((PdfShadingPattern)iterator.next()).addToBody();
        }
        iterator = this.documentShadings.iterator();
        while (iterator.hasNext()) {
            ((PdfShading)iterator.next()).addToBody();
        }
        for (Map.Entry entry : this.documentExtGState.entrySet()) {
            this.addToBody((PdfObject)((PdfDictionary)entry.getKey()), (PdfIndirectReference)((PdfObject[])entry.getValue())[1]);
        }
        for (Map.Entry entry : this.documentProperties.entrySet()) {
            Object k = entry.getKey();
            PdfObject[] arrpdfObject = (PdfObject[])entry.getValue();
            if (k instanceof PdfLayerMembership) {
                PdfLayerMembership pdfLayerMembership = (PdfLayerMembership)k;
                this.addToBody(pdfLayerMembership.getPdfObject(), pdfLayerMembership.getRef());
                continue;
            }
            if (!(k instanceof PdfDictionary) || k instanceof PdfLayer) continue;
            this.addToBody((PdfObject)((PdfDictionary)k), (PdfIndirectReference)arrpdfObject[1]);
        }
    }

    ColorDetails addSimple(ICachedColorSpace iCachedColorSpace) {
        ColorDetails colorDetails;
        ColorDetails colorDetails2 = colorDetails = this.documentColors.get(iCachedColorSpace);
        if (colorDetails == null) {
            colorDetails2 = new ColorDetails(this.getColorspaceName(), this.body.getPdfIndirectReference(), iCachedColorSpace);
            if (iCachedColorSpace instanceof IPdfSpecialColorSpace) {
                ((IPdfSpecialColorSpace)((Object)iCachedColorSpace)).getColorantDetails(this);
            }
            this.documentColors.put(iCachedColorSpace, colorDetails2);
        }
        return colorDetails2;
    }

    FontDetails addSimple(BaseFont baseFont) {
        FontDetails fontDetails = this.documentFonts.get(baseFont);
        Object object = fontDetails;
        if (fontDetails == null) {
            PdfWriter.checkPdfIsoConformance(this, 4, baseFont);
            if (baseFont.getFontType() == 4) {
                object = new StringBuilder();
                object.append("F");
                int n = this.fontNumber;
                this.fontNumber = n + 1;
                object.append(n);
                object = new FontDetails(new PdfName(object.toString()), ((DocumentFont)baseFont).getIndirectReference(), baseFont);
            } else {
                object = new StringBuilder();
                object.append("F");
                int n = this.fontNumber;
                this.fontNumber = n + 1;
                object.append(n);
                object = new FontDetails(new PdfName(object.toString()), this.body.getPdfIndirectReference(), baseFont);
            }
            this.documentFonts.put(baseFont, (FontDetails)object);
        }
        return object;
    }

    PdfObject[] addSimpleExtGState(PdfDictionary pdfDictionary) {
        if (!this.documentExtGState.containsKey(pdfDictionary)) {
            HashMap<PdfDictionary, PdfObject[]> hashMap = this.documentExtGState;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("GS");
            stringBuilder.append(this.documentExtGState.size() + 1);
            hashMap.put(pdfDictionary, new PdfObject[]{new PdfName(stringBuilder.toString()), this.getPdfIndirectReference()});
        }
        return this.documentExtGState.get(pdfDictionary);
    }

    PdfName addSimplePattern(PdfPatternPainter pdfPatternPainter) {
        Serializable serializable = this.documentPatterns.get(pdfPatternPainter);
        if (serializable == null) {
            try {
                serializable = new StringBuilder();
                serializable.append("P");
                serializable.append(this.patternNumber);
                serializable = new PdfName(serializable.toString());
                ++this.patternNumber;
                this.documentPatterns.put(pdfPatternPainter, (PdfName)serializable);
                return serializable;
            }
            catch (Exception exception) {
                throw new ExceptionConverter(exception);
            }
        }
        return serializable;
    }

    /*
     * Exception decompiling
     */
    ColorDetails addSimplePatternColorspace(BaseColor var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [3[CASE]], but top level block is 0[TRYBLOCK]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    PdfObject[] addSimpleProperty(Object object, PdfIndirectReference pdfIndirectReference) {
        if (!this.documentProperties.containsKey(object)) {
            if (object instanceof PdfOCG) {
                PdfWriter.checkPdfIsoConformance(this, 7, object);
            }
            HashMap<Object, PdfObject[]> hashMap = this.documentProperties;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Pr");
            stringBuilder.append(this.documentProperties.size() + 1);
            hashMap.put(object, new PdfObject[]{new PdfName(stringBuilder.toString()), pdfIndirectReference});
        }
        return this.documentProperties.get(object);
    }

    void addSimpleShading(PdfShading pdfShading) {
        if (!this.documentShadings.contains(pdfShading)) {
            this.documentShadings.add(pdfShading);
            pdfShading.setName(this.documentShadings.size());
        }
    }

    void addSimpleShadingPattern(PdfShadingPattern pdfShadingPattern) {
        if (!this.documentShadingPatterns.contains(pdfShadingPattern)) {
            pdfShadingPattern.setName(this.patternNumber);
            ++this.patternNumber;
            this.documentShadingPatterns.add(pdfShadingPattern);
            this.addSimpleShading(pdfShadingPattern.getShading());
        }
    }

    public PdfIndirectObject addToBody(PdfObject object) throws IOException {
        object = this.body.add((PdfObject)object);
        this.cacheObject((PdfIndirectObject)object);
        return object;
    }

    public PdfIndirectObject addToBody(PdfObject object, int n) throws IOException {
        object = this.body.add((PdfObject)object, n);
        this.cacheObject((PdfIndirectObject)object);
        return object;
    }

    public PdfIndirectObject addToBody(PdfObject object, int n, boolean bl) throws IOException {
        object = this.body.add((PdfObject)object, n, 0, bl);
        this.cacheObject((PdfIndirectObject)object);
        return object;
    }

    public PdfIndirectObject addToBody(PdfObject object, PdfIndirectReference pdfIndirectReference) throws IOException {
        object = this.body.add((PdfObject)object, pdfIndirectReference);
        this.cacheObject((PdfIndirectObject)object);
        return object;
    }

    public PdfIndirectObject addToBody(PdfObject object, PdfIndirectReference pdfIndirectReference, boolean bl) throws IOException {
        object = this.body.add((PdfObject)object, pdfIndirectReference, bl);
        this.cacheObject((PdfIndirectObject)object);
        return object;
    }

    public PdfIndirectObject addToBody(PdfObject object, boolean bl) throws IOException {
        object = this.body.add((PdfObject)object, bl);
        this.cacheObject((PdfIndirectObject)object);
        return object;
    }

    @Override
    public void addViewerPreference(PdfName pdfName, PdfObject pdfObject) {
        this.pdf.addViewerPreference(pdfName, pdfObject);
    }

    protected void addXFormsToBody() throws IOException {
        Iterator<Object[]> iterator = this.formXObjects.values().iterator();
        while (iterator.hasNext()) {
            PdfTemplate pdfTemplate = (PdfTemplate)iterator.next()[1];
            if (pdfTemplate != null && pdfTemplate.getIndirectReference() instanceof PRIndirectReference || pdfTemplate == null || pdfTemplate.getType() != 1) continue;
            this.addToBody((PdfObject)pdfTemplate.getFormXObject(this.compressionLevel), pdfTemplate.getIndirectReference());
        }
    }

    protected void buildStructTreeRootForTagged(PdfDictionary pdfDictionary) {
        if (this.tagged) {
            try {
                this.getStructureTreeRoot().buildTree();
                for (AccessibleElementId accessibleElementId : this.pdf.getStructElements()) {
                    PdfStructureElement serializable = this.pdf.getStructElement(accessibleElementId, false);
                    this.addToBody((PdfObject)serializable, serializable.getReference());
                }
                pdfDictionary.put(PdfName.STRUCTTREEROOT, this.structureTreeRoot.getReference());
                PdfDictionary pdfDictionary2 = new PdfDictionary();
                pdfDictionary2.put(PdfName.MARKED, PdfBoolean.PDFTRUE);
                if (this.userProperties) {
                    pdfDictionary2.put(PdfName.USERPROPERTIES, PdfBoolean.PDFTRUE);
                }
                pdfDictionary.put(PdfName.MARKINFO, pdfDictionary2);
                return;
            }
            catch (Exception exception) {
                throw new ExceptionConverter(exception);
            }
        }
    }

    protected void cacheObject(PdfIndirectObject pdfIndirectObject) {
    }

    public void checkElementRole(IAccessibleElement iAccessibleElement, IAccessibleElement iAccessibleElement2) {
        if (iAccessibleElement2 != null && (iAccessibleElement2.getRole() == null || PdfName.ARTIFACT.equals(iAccessibleElement2.getRole()))) {
            iAccessibleElement.setRole(null);
            return;
        }
        if ((this.taggingMode & 1) != 0 && iAccessibleElement.isInline() && iAccessibleElement.getRole() == null && (iAccessibleElement2 == null || !iAccessibleElement2.isInline())) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("inline.elements.with.role.null.are.not.allowed", new Object[0]));
        }
    }

    public void checkPdfIsoConformance(int n, Object object) {
        this.pdfIsoConformance.checkPdfIsoConformance(n, object);
    }

    public void clearTextWrap() throws DocumentException {
        this.pdf.clearTextWrap();
    }

    /*
     * Exception decompiling
     */
    @Override
    public void close() {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // java.lang.IllegalStateException: Backjump on non jumping statement [0, 6] lbl80 : TryStatement: try { 4[TRYBLOCK]

        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Cleaner$1.call(Cleaner.java:44)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Cleaner$1.call(Cleaner.java:22)
        // org.benf.cfr.reader.util.graph.GraphVisitorDFS.process(GraphVisitorDFS.java:67)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Cleaner.removeUnreachableCode(Cleaner.java:54)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.RemoveDeterministicJumps.apply(RemoveDeterministicJumps.java:35)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:497)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public PdfAnnotation createAnnotation(float f, float f2, float f3, float f4, PdfAction pdfDictionary, PdfName pdfName) {
        pdfDictionary = new PdfAnnotation(this, f, f2, f3, f4, (PdfAction)pdfDictionary);
        if (pdfName != null) {
            pdfDictionary.put(PdfName.SUBTYPE, pdfName);
        }
        return pdfDictionary;
    }

    public PdfAnnotation createAnnotation(float f, float f2, float f3, float f4, PdfString pdfObject, PdfString pdfString, PdfName pdfName) {
        pdfObject = new PdfAnnotation(this, f, f2, f3, f4, (PdfString)pdfObject, pdfString);
        if (pdfName != null) {
            pdfObject.put(PdfName.SUBTYPE, pdfName);
        }
        return pdfObject;
    }

    public PdfAnnotation createAnnotation(Rectangle object, PdfName pdfName) {
        object = new PdfAnnotation(this, (Rectangle)object);
        if (pdfName != null) {
            object.put(PdfName.SUBTYPE, pdfName);
        }
        return object;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void createXmpMetadata() {
        try {
            this.xmpWriter = this.createXmpWriter(null, this.pdf.getInfo());
            boolean bl = this.isTagged();
            if (bl) {
                try {
                    this.xmpWriter.getXmpMeta().setPropertyInteger("http://www.aiim.org/pdfua/ns/id/", "part", 1, new PropertyOptions(1073741824));
                }
                catch (XMPException xMPException) {
                    throw new ExceptionConverter(xMPException);
                }
            }
            this.xmpMetadata = null;
            return;
        }
        catch (IOException iOException) {
            iOException.printStackTrace();
            return;
        }
    }

    protected XmpWriter createXmpWriter(ByteArrayOutputStream byteArrayOutputStream, PdfDictionary pdfDictionary) throws IOException {
        return new XmpWriter((OutputStream)byteArrayOutputStream, pdfDictionary);
    }

    protected XmpWriter createXmpWriter(ByteArrayOutputStream byteArrayOutputStream, HashMap<String, String> hashMap) throws IOException {
        return new XmpWriter((OutputStream)byteArrayOutputStream, hashMap);
    }

    void eliminateFontSubset(PdfDictionary pdfDictionary) {
        for (FontDetails fontDetails : this.documentFonts.values()) {
            if (pdfDictionary.get(fontDetails.getFontName()) == null) continue;
            fontDetails.setSubset(false);
        }
    }

    protected void fillOCProperties(boolean bl) {
        Object object2;
        Object object;
        if (this.OCProperties == null) {
            this.OCProperties = new PdfOCProperties();
        }
        if (bl) {
            this.OCProperties.remove(PdfName.OCGS);
            this.OCProperties.remove(PdfName.D);
        }
        if (this.OCProperties.get(PdfName.OCGS) == null) {
            object = new PdfArray();
            object2 = this.documentOCG.iterator();
            while (object2.hasNext()) {
                object.add(((PdfLayer)object2.next()).getRef());
            }
            this.OCProperties.put(PdfName.OCGS, (PdfObject)object);
        }
        if (this.OCProperties.get(PdfName.D) != null) {
            return;
        }
        object2 = new ArrayList<PdfOCG>(this.documentOCGorder);
        object = object2.iterator();
        while (object.hasNext()) {
            if (((PdfLayer)object.next()).getParent() == null) continue;
            object.remove();
        }
        PdfArray pdfArray = new PdfArray();
        object = object2.iterator();
        while (object.hasNext()) {
            PdfWriter.getOCGOrder(pdfArray, (PdfLayer)object.next());
        }
        object = new PdfDictionary();
        this.OCProperties.put(PdfName.D, (PdfObject)object);
        object.put(PdfName.ORDER, pdfArray);
        if (object2.size() > 0 && object2.get(0) instanceof PdfLayer && (object2 = ((PdfLayer)object2.get(0)).getAsString(PdfName.NAME)) != null) {
            object.put(PdfName.NAME, (PdfObject)object2);
        }
        object2 = new PdfArray();
        for (PdfLayer pdfLayer : this.documentOCG) {
            if (pdfLayer.isOn()) continue;
            object2.add(pdfLayer.getRef());
        }
        if (object2.size() > 0) {
            object.put(PdfName.OFF, (PdfObject)object2);
        }
        if (this.OCGRadioGroup.size() > 0) {
            object.put(PdfName.RBGROUPS, this.OCGRadioGroup);
        }
        if (this.OCGLocked.size() > 0) {
            object.put(PdfName.LOCKED, this.OCGLocked);
        }
        this.addASEvent(PdfName.VIEW, PdfName.ZOOM);
        this.addASEvent(PdfName.VIEW, PdfName.VIEW);
        this.addASEvent(PdfName.PRINT, PdfName.PRINT);
        this.addASEvent(PdfName.EXPORT, PdfName.EXPORT);
        object.put(PdfName.LISTMODE, PdfName.VISIBLEPAGES);
    }

    protected void flushAcroFields() throws IOException, BadPdfFormatException {
    }

    protected void flushTaggedObjects() throws IOException {
    }

    public void freeReader(PdfReader pdfReader) throws IOException {
        this.currentPdfReaderInstance = this.readerInstances.get(pdfReader);
        if (this.currentPdfReaderInstance == null) {
            return;
        }
        this.currentPdfReaderInstance.writeAllPages();
        this.currentPdfReaderInstance = null;
        this.readerInstances.remove(pdfReader);
    }

    @Override
    public PdfAcroForm getAcroForm() {
        return this.pdf.getAcroForm();
    }

    public Rectangle getBoxSize(String string2) {
        return this.pdf.getBoxSize(string2);
    }

    public Rectangle getBoxSize(String object, Rectangle rectangle) {
        if ((object = this.pdf.getBoxSize((String)object)) != null) {
            if (rectangle == null) {
                return null;
            }
            if ((object = new com.itextpdf.awt.geom.Rectangle((Rectangle)object).intersection(new com.itextpdf.awt.geom.Rectangle(rectangle))).isEmpty()) {
                return null;
            }
            object = new Rectangle((float)object.getX(), (float)object.getY(), (float)(object.getX() + object.getWidth()), (float)(object.getY() + object.getHeight()));
            object.normalize();
            return object;
        }
        return null;
    }

    protected PdfDictionary getCatalog(PdfIndirectReference pdfObject) {
        pdfObject = this.pdf.getCatalog((PdfIndirectReference)pdfObject);
        this.buildStructTreeRootForTagged((PdfDictionary)pdfObject);
        if (!this.documentOCG.isEmpty()) {
            this.fillOCProperties(false);
            pdfObject.put(PdfName.OCPROPERTIES, this.OCProperties);
        }
        return pdfObject;
    }

    public ICC_Profile getColorProfile() {
        return this.colorProfile;
    }

    PdfName getColorspaceName() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("CS");
        int n = this.colorNumber;
        this.colorNumber = n + 1;
        stringBuilder.append(n);
        return new PdfName(stringBuilder.toString());
    }

    public int getCompressionLevel() {
        return this.compressionLevel;
    }

    protected Counter getCounter() {
        return COUNTER;
    }

    public long getCurrentDocumentSize() {
        return this.body.offset() + (long)(this.body.size() * 20) + 72L;
    }

    PdfIndirectReference getCurrentPage() {
        return this.getPageReference(this.currentPageNumber);
    }

    public int getCurrentPageNumber() {
        return this.currentPageNumber;
    }

    public PdfDictionary getDefaultColorspace() {
        return this.defaultColorspace;
    }

    public PdfContentByte getDirectContent() {
        if (!this.open) {
            throw new RuntimeException(MessageLocalization.getComposedMessage("the.document.is.not.open", new Object[0]));
        }
        return this.directContent;
    }

    public PdfContentByte getDirectContentUnder() {
        if (!this.open) {
            throw new RuntimeException(MessageLocalization.getComposedMessage("the.document.is.not.open", new Object[0]));
        }
        return this.directContentUnder;
    }

    PdfEncryption getEncryption() {
        return this.crypto;
    }

    public PdfDictionary getExtraCatalog() {
        if (this.extraCatalog == null) {
            this.extraCatalog = new PdfDictionary();
        }
        return this.extraCatalog;
    }

    public PdfDictionary getGroup() {
        return this.group;
    }

    PdfIndirectReference getImageReference(PdfName pdfName) {
        return (PdfIndirectReference)this.imageDictionary.get(pdfName);
    }

    public PdfImportedPage getImportedPage(PdfReader pdfReader, int n) {
        return this.getPdfReaderInstance(pdfReader).getImportedPage(n);
    }

    protected int getIndirectReferenceNumber() {
        return this.body.getIndirectReferenceNumber();
    }

    public PdfDictionary getInfo() {
        return this.pdf.getInfo();
    }

    protected int getNewObjectNumber(PdfReader pdfReader, int n, int n2) {
        if (this.currentPdfReaderInstance == null || this.currentPdfReaderInstance.getReader() != pdfReader) {
            this.currentPdfReaderInstance = this.getPdfReaderInstance(pdfReader);
        }
        return this.currentPdfReaderInstance.getNewObjectNumber(n, n2);
    }

    public PdfOCProperties getOCProperties() {
        this.fillOCProperties(true);
        return this.OCProperties;
    }

    public OutputStreamCounter getOs() {
        return this.os;
    }

    public int getPDFXConformance() {
        if (this.pdfIsoConformance instanceof PdfXConformanceImp) {
            return ((PdfXConformance)this.pdfIsoConformance).getPDFXConformance();
        }
        return 0;
    }

    public PdfDictionary getPageDictEntries() {
        return this.pageDictEntries;
    }

    public PdfPageEvent getPageEvent() {
        return this.pageEvent;
    }

    public int getPageNumber() {
        return this.pdf.getPageNumber();
    }

    public PdfIndirectReference getPageReference(int n) {
        PdfIndirectReference pdfIndirectReference;
        int n2 = n - 1;
        if (n2 < 0) {
            throw new IndexOutOfBoundsException(MessageLocalization.getComposedMessage("the.page.number.must.be.gt.eq.1", new Object[0]));
        }
        if (n2 < this.pageReferences.size()) {
            PdfIndirectReference pdfIndirectReference2;
            pdfIndirectReference = pdfIndirectReference2 = this.pageReferences.get(n2);
            if (pdfIndirectReference2 == null) {
                pdfIndirectReference = this.body.getPdfIndirectReference();
                this.pageReferences.set(n2, pdfIndirectReference);
                return pdfIndirectReference;
            }
        } else {
            int n3 = this.pageReferences.size();
            for (n = 0; n < n2 - n3; ++n) {
                this.pageReferences.add(null);
            }
            pdfIndirectReference = this.body.getPdfIndirectReference();
            this.pageReferences.add(pdfIndirectReference);
        }
        return pdfIndirectReference;
    }

    public Rectangle getPageSize() {
        return this.pdf.getPageSize();
    }

    PdfDocument getPdfDocument() {
        return this.pdf;
    }

    public PdfIndirectReference getPdfIndirectReference() {
        return this.body.getPdfIndirectReference();
    }

    protected PdfReaderInstance getPdfReaderInstance(PdfReader pdfReader) {
        PdfReaderInstance pdfReaderInstance;
        PdfReaderInstance pdfReaderInstance2 = pdfReaderInstance = this.readerInstances.get(pdfReader);
        if (pdfReaderInstance == null) {
            pdfReaderInstance2 = pdfReader.getPdfReaderInstance(this);
            this.readerInstances.put(pdfReader, pdfReaderInstance2);
        }
        return pdfReaderInstance2;
    }

    PdfVersionImp getPdfVersion() {
        return this.pdf_version;
    }

    RandomAccessFileOrArray getReaderFile(PdfReader pdfReader) {
        return this.currentPdfReaderInstance.getReaderFile();
    }

    protected PdfIndirectReference getReferenceJBIG2Globals(byte[] object) {
        if (object == null) {
            return null;
        }
        for (PdfStream pdfStream : this.JBIG2Globals.keySet()) {
            if (!Arrays.equals(object, pdfStream.getBytes())) continue;
            return this.JBIG2Globals.get(pdfStream);
        }
        object = new PdfStream((byte[])object);
        try {
            PdfIndirectObject pdfIndirectObject = this.addToBody((PdfObject)object);
            this.JBIG2Globals.put((PdfStream)object, pdfIndirectObject.getIndirectReference());
            return pdfIndirectObject.getIndirectReference();
        }
        catch (IOException iOException) {
            return null;
        }
    }

    public PdfOutline getRootOutline() {
        return this.directContent.getRootOutline();
    }

    @Override
    public int getRunDirection() {
        return this.runDirection;
    }

    public float getSpaceCharRatio() {
        return this.spaceCharRatio;
    }

    public List<PdfName> getStandardStructElems() {
        if (this.pdf_version.getVersion() < '7') {
            return standardStructElems_1_4;
        }
        return standardStructElems_1_7;
    }

    public PdfStructureTreeRoot getStructureTreeRoot() {
        if (this.tagged && this.structureTreeRoot == null) {
            this.structureTreeRoot = new PdfStructureTreeRoot(this);
        }
        return this.structureTreeRoot;
    }

    public PdfName getTabs() {
        return this.tabs;
    }

    protected TtfUnicodeWriter getTtfUnicodeWriter() {
        if (this.ttfUnicodeWriter == null) {
            this.ttfUnicodeWriter = new TtfUnicodeWriter(this);
        }
        return this.ttfUnicodeWriter;
    }

    public float getVerticalPosition(boolean bl) {
        return this.pdf.getVerticalPosition(bl);
    }

    public XmpWriter getXmpWriter() {
        return this.xmpWriter;
    }

    protected PdfIsoConformance initPdfIsoConformance() {
        return new PdfXConformanceImp(this);
    }

    public boolean isFullCompression() {
        return this.fullCompression;
    }

    public boolean isPageEmpty() {
        return this.pdf.isPageEmpty();
    }

    public boolean isPdfIso() {
        return this.pdfIsoConformance.isPdfIso();
    }

    public boolean isPdfX() {
        if (this.pdfIsoConformance instanceof PdfXConformanceImp) {
            return ((PdfXConformance)this.pdfIsoConformance).isPdfX();
        }
        return false;
    }

    public boolean isRgbTransparencyBlending() {
        return this.rgbTransparencyBlending;
    }

    public boolean isStrictImageSequence() {
        return this.pdf.isStrictImageSequence();
    }

    public boolean isTagged() {
        return this.tagged;
    }

    public boolean isUserProperties() {
        return this.userProperties;
    }

    public void lockLayer(PdfLayer pdfLayer) {
        this.OCGLocked.add(pdfLayer.getRef());
    }

    public boolean needToBeMarkedInContent(IAccessibleElement iAccessibleElement) {
        if ((this.taggingMode & 1) != 0) {
            if (!iAccessibleElement.isInline()) {
                if (PdfName.ARTIFACT.equals(iAccessibleElement.getRole())) {
                    return true;
                }
                return false;
            }
            return true;
        }
        return true;
    }

    @Override
    public void open() {
        super.open();
        try {
            this.pdf_version.writeHeader(this.os);
            this.body = new PdfBody(this);
            if (this.isPdfX() && ((PdfXConformanceImp)this.pdfIsoConformance).isPdfX32002()) {
                PdfDictionary pdfDictionary = new PdfDictionary();
                pdfDictionary.put(PdfName.GAMMA, new PdfArray(new float[]{2.2f, 2.2f, 2.2f}));
                pdfDictionary.put(PdfName.MATRIX, new PdfArray(new float[]{0.4124f, 0.2126f, 0.0193f, 0.3576f, 0.7152f, 0.1192f, 0.1805f, 0.0722f, 0.9505f}));
                pdfDictionary.put(PdfName.WHITEPOINT, new PdfArray(new float[]{0.9505f, 1.0f, 1.089f}));
                PdfArray pdfArray = new PdfArray(PdfName.CALRGB);
                pdfArray.add(pdfDictionary);
                this.setDefaultColorspace(PdfName.DEFAULTRGB, this.addToBody(pdfArray).getIndirectReference());
            }
            return;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    boolean propertyExists(Object object) {
        return this.documentProperties.containsKey(object);
    }

    void registerLayer(PdfOCG pdfOCG) {
        PdfWriter.checkPdfIsoConformance(this, 7, pdfOCG);
        if (pdfOCG instanceof PdfLayer) {
            if (((PdfLayer)pdfOCG).getTitle() == null) {
                if (!this.documentOCG.contains(pdfOCG)) {
                    this.documentOCG.add(pdfOCG);
                    this.documentOCGorder.add(pdfOCG);
                    return;
                }
            } else {
                this.documentOCGorder.add(pdfOCG);
            }
            return;
        }
        throw new IllegalArgumentException(MessageLocalization.getComposedMessage("only.pdflayer.is.accepted", new Object[0]));
    }

    public void releaseTemplate(PdfTemplate arrobject) throws IOException {
        arrobject = arrobject.getIndirectReference();
        if ((arrobject = this.formXObjects.get(arrobject)) != null) {
            if (arrobject[1] == null) {
                return;
            }
            PdfTemplate pdfTemplate = (PdfTemplate)arrobject[1];
            if (pdfTemplate.getIndirectReference() instanceof PRIndirectReference) {
                return;
            }
            if (pdfTemplate.getType() == 1) {
                this.addToBody((PdfObject)pdfTemplate.getFormXObject(this.compressionLevel), pdfTemplate.getIndirectReference());
                arrobject[1] = null;
            }
            return;
        }
    }

    public int reorderPages(int[] arrn) throws DocumentException {
        return this.root.reorderPages(arrn);
    }

    void resetContent() {
        this.directContent.reset();
        this.directContentUnder.reset();
    }

    public void resetPageDictEntries() {
        this.pageDictEntries = new PdfDictionary();
    }

    @Override
    public void setAdditionalAction(PdfName pdfName, PdfAction pdfAction) throws DocumentException {
        if (!(pdfName.equals(DOCUMENT_CLOSE) || pdfName.equals(WILL_SAVE) || pdfName.equals(DID_SAVE) || pdfName.equals(WILL_PRINT) || pdfName.equals(DID_PRINT))) {
            throw new DocumentException(MessageLocalization.getComposedMessage("invalid.additional.action.type.1", pdfName.toString()));
        }
        this.pdf.addAdditionalAction(pdfName, pdfAction);
    }

    @Override
    public void setAtLeastPdfVersion(char c) {
        this.pdf_version.setAtLeastPdfVersion(c);
    }

    public void setBoxSize(String string2, Rectangle rectangle) {
        this.pdf.setBoxSize(string2, rectangle);
    }

    public void setCollection(PdfCollection pdfCollection) {
        this.setAtLeastPdfVersion('7');
        this.pdf.setCollection(pdfCollection);
    }

    public void setCompressionLevel(int n) {
        if (n >= 0 && n <= 9) {
            this.compressionLevel = n;
            return;
        }
        this.compressionLevel = -1;
    }

    public void setCropBoxSize(Rectangle rectangle) {
        this.pdf.setCropBoxSize(rectangle);
    }

    public void setDefaultColorspace(PdfName pdfName, PdfObject pdfObject) {
        if (pdfObject == null || pdfObject.isNull()) {
            this.defaultColorspace.remove(pdfName);
        }
        this.defaultColorspace.put(pdfName, pdfObject);
    }

    @Override
    public void setDuration(int n) {
        this.pdf.setDuration(n);
    }

    @Deprecated
    public void setEncryption(int n, String string2, String string3, int n2) throws DocumentException {
        this.setEncryption(PdfWriter.getISOBytes(string2), PdfWriter.getISOBytes(string3), n2, n);
    }

    @Deprecated
    public void setEncryption(boolean bl, String string2, String string3, int n) throws DocumentException {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    @Override
    public void setEncryption(byte[] arrby, byte[] arrby2, int n, int n2) throws DocumentException {
        if (this.pdf.isOpen()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("encryption.can.only.be.added.before.opening.the.document", new Object[0]));
        }
        this.crypto = new PdfEncryption();
        this.crypto.setCryptoMode(n2, 0);
        this.crypto.setupAllKeys(arrby, arrby2, n);
    }

    @Deprecated
    public void setEncryption(byte[] arrby, byte[] arrby2, int n, boolean bl) throws DocumentException {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    @Override
    public void setEncryption(Certificate[] arrcertificate, int[] arrn, int n) throws DocumentException {
        if (this.pdf.isOpen()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("encryption.can.only.be.added.before.opening.the.document", new Object[0]));
        }
        this.crypto = new PdfEncryption();
        if (arrcertificate != null) {
            for (int i = 0; i < arrcertificate.length; ++i) {
                this.crypto.addRecipient(arrcertificate[i], arrn[i]);
            }
        }
        this.crypto.setCryptoMode(n, 0);
        this.crypto.getEncryptionDictionary();
    }

    public void setFullCompression() throws DocumentException {
        if (this.open) {
            throw new DocumentException(MessageLocalization.getComposedMessage("you.can.t.set.the.full.compression.if.the.document.is.already.open", new Object[0]));
        }
        this.fullCompression = true;
        this.setAtLeastPdfVersion('5');
    }

    public void setGroup(PdfDictionary pdfDictionary) {
        this.group = pdfDictionary;
    }

    public void setInitialLeading(float f) throws DocumentException {
        if (this.open) {
            throw new DocumentException(MessageLocalization.getComposedMessage("you.can.t.set.the.initial.leading.if.the.document.is.already.open", new Object[0]));
        }
        this.pdf.setLeading(f);
    }

    public void setLanguage(String string2) {
        this.pdf.setLanguage(string2);
    }

    public void setLinearPageMode() {
        this.root.setLinearMode(null);
    }

    @Override
    public void setOpenAction(PdfAction pdfAction) {
        this.pdf.setOpenAction(pdfAction);
    }

    @Override
    public void setOpenAction(String string2) {
        this.pdf.setOpenAction(string2);
    }

    public void setOutlines(List<HashMap<String, Object>> list) {
        this.newBookmarks = list;
    }

    public void setOutputIntents(String object, String string2, String string3, String string4, ICC_Profile iCC_Profile) throws IOException {
        PdfWriter.checkPdfIsoConformance(this, 19, iCC_Profile);
        this.getExtraCatalog();
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.OUTPUTINTENT);
        if (string2 != null) {
            pdfDictionary.put(PdfName.OUTPUTCONDITION, new PdfString(string2, "UnicodeBig"));
        }
        if (object != null) {
            pdfDictionary.put(PdfName.OUTPUTCONDITIONIDENTIFIER, new PdfString((String)object, "UnicodeBig"));
        }
        if (string3 != null) {
            pdfDictionary.put(PdfName.REGISTRYNAME, new PdfString(string3, "UnicodeBig"));
        }
        if (string4 != null) {
            pdfDictionary.put(PdfName.INFO, new PdfString(string4, "UnicodeBig"));
        }
        if (iCC_Profile != null) {
            object = new PdfICCBased(iCC_Profile, this.compressionLevel);
            pdfDictionary.put(PdfName.DESTOUTPUTPROFILE, this.addToBody((PdfObject)object).getIndirectReference());
        }
        pdfDictionary.put(PdfName.S, PdfName.GTS_PDFX);
        this.extraCatalog.put(PdfName.OUTPUTINTENTS, new PdfArray(pdfDictionary));
        this.colorProfile = iCC_Profile;
    }

    public void setOutputIntents(String string2, String string3, String string4, String string5, byte[] object) throws IOException {
        object = object == null ? null : ICC_Profile.getInstance(object);
        this.setOutputIntents(string2, string3, string4, string5, (ICC_Profile)object);
    }

    public boolean setOutputIntents(PdfReader object, boolean bl) throws IOException {
        if ((object = object.getCatalog().getAsArray(PdfName.OUTPUTINTENTS)) == null) {
            return false;
        }
        if (object.isEmpty()) {
            return false;
        }
        PdfDictionary pdfDictionary = object.getAsDict(0);
        object = PdfReader.getPdfObject(pdfDictionary.get(PdfName.S));
        if (object != null) {
            if (!PdfName.GTS_PDFX.equals(object)) {
                return false;
            }
            if (bl) {
                return true;
            }
            PRStream pRStream = (PRStream)PdfReader.getPdfObject(pdfDictionary.get(PdfName.DESTOUTPUTPROFILE));
            object = null;
            if (pRStream != null) {
                object = PdfReader.getStreamBytes(pRStream);
            }
            this.setOutputIntents(PdfWriter.getNameString(pdfDictionary, PdfName.OUTPUTCONDITIONIDENTIFIER), PdfWriter.getNameString(pdfDictionary, PdfName.OUTPUTCONDITION), PdfWriter.getNameString(pdfDictionary, PdfName.REGISTRYNAME), PdfWriter.getNameString(pdfDictionary, PdfName.INFO), (byte[])object);
            return true;
        }
        return false;
    }

    public void setPDFXConformance(int n) {
        if (!(this.pdfIsoConformance instanceof PdfXConformanceImp)) {
            return;
        }
        if (((PdfXConformance)this.pdfIsoConformance).getPDFXConformance() == n) {
            return;
        }
        if (this.pdf.isOpen()) {
            throw new PdfXConformanceException(MessageLocalization.getComposedMessage("pdfx.conformance.can.only.be.set.before.opening.the.document", new Object[0]));
        }
        if (this.crypto != null) {
            throw new PdfXConformanceException(MessageLocalization.getComposedMessage("a.pdfx.conforming.document.cannot.be.encrypted", new Object[0]));
        }
        if (n != 0) {
            this.setPdfVersion('3');
        }
        ((PdfXConformance)this.pdfIsoConformance).setPDFXConformance(n);
    }

    @Override
    public void setPageAction(PdfName pdfName, PdfAction pdfAction) throws DocumentException {
        if (!pdfName.equals(PAGE_OPEN) && !pdfName.equals(PAGE_CLOSE)) {
            throw new DocumentException(MessageLocalization.getComposedMessage("invalid.page.additional.action.type.1", pdfName.toString()));
        }
        this.pdf.setPageAction(pdfName, pdfAction);
    }

    public void setPageEmpty(boolean bl) {
        if (bl) {
            return;
        }
        this.pdf.setPageEmpty(bl);
    }

    public void setPageEvent(PdfPageEvent pdfPageEvent) {
        if (pdfPageEvent == null) {
            this.pageEvent = null;
            return;
        }
        if (this.pageEvent == null) {
            this.pageEvent = pdfPageEvent;
            return;
        }
        if (this.pageEvent instanceof PdfPageEventForwarder) {
            ((PdfPageEventForwarder)this.pageEvent).addPageEvent(pdfPageEvent);
            return;
        }
        PdfPageEventForwarder pdfPageEventForwarder = new PdfPageEventForwarder();
        pdfPageEventForwarder.addPageEvent(this.pageEvent);
        pdfPageEventForwarder.addPageEvent(pdfPageEvent);
        this.pageEvent = pdfPageEventForwarder;
    }

    public void setPageLabels(PdfPageLabels pdfPageLabels) {
        this.pdf.setPageLabels(pdfPageLabels);
    }

    public void setPageViewport(PdfArray pdfArray) {
        this.addPageDictEntry(PdfName.VP, pdfArray);
    }

    public void setPageXmpMetadata(byte[] arrby) throws IOException {
        this.pdf.setXmpMetadata(arrby);
    }

    @Override
    public void setPdfVersion(char c) {
        this.pdf_version.setPdfVersion(c);
    }

    @Override
    public void setPdfVersion(PdfName pdfName) {
        this.pdf_version.setPdfVersion(pdfName);
    }

    public void setRgbTransparencyBlending(boolean bl) {
        this.rgbTransparencyBlending = bl;
    }

    @Override
    public void setRunDirection(int n) {
        if (n >= 1 && n <= 3) {
            this.runDirection = n;
            return;
        }
        throw new RuntimeException(MessageLocalization.getComposedMessage("invalid.run.direction.1", n));
    }

    @Override
    public void setSigFlags(int n) {
        this.pdf.setSigFlags(n);
    }

    public void setSpaceCharRatio(float f) {
        if (f < 0.001f) {
            this.spaceCharRatio = 0.001f;
            return;
        }
        this.spaceCharRatio = f;
    }

    public void setStrictImageSequence(boolean bl) {
        this.pdf.setStrictImageSequence(bl);
    }

    public void setTabs(PdfName pdfName) {
        this.tabs = pdfName;
    }

    public void setTagged() {
        this.setTagged(1);
    }

    public void setTagged(int n) {
        if (this.open) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("tagging.must.be.set.before.opening.the.document", new Object[0]));
        }
        this.tagged = true;
        this.taggingMode = n;
    }

    public void setThumbnail(Image image) throws PdfException, DocumentException {
        this.pdf.setThumbnail(image);
    }

    @Override
    public void setTransition(PdfTransition pdfTransition) {
        this.pdf.setTransition(pdfTransition);
    }

    public void setUserProperties(boolean bl) {
        this.userProperties = bl;
    }

    public void setUserunit(float f) throws DocumentException {
        if (f >= 1.0f && f <= 75000.0f) {
            this.addPageDictEntry(PdfName.USERUNIT, new PdfNumber(f));
            this.setAtLeastPdfVersion('6');
            return;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("userunit.should.be.a.value.between.1.and.75000", new Object[0]));
    }

    @Override
    public void setViewerPreferences(int n) {
        this.pdf.setViewerPreferences(n);
    }

    public void setXmpMetadata(byte[] arrby) {
        this.xmpMetadata = arrby;
    }

    public void useExternalCacheForTagStructure(TempFileCache tempFileCache) {
        this.pdf.useExternalCache(tempFileCache);
    }

    protected void writeOutlines(PdfDictionary pdfDictionary, boolean bl) throws IOException {
        if (this.newBookmarks != null) {
            if (this.newBookmarks.isEmpty()) {
                return;
            }
            PdfDictionary pdfDictionary2 = new PdfDictionary();
            PdfIndirectReference pdfIndirectReference = this.getPdfIndirectReference();
            Object[] arrobject = SimpleBookmark.iterateOutlines(this, pdfIndirectReference, this.newBookmarks, bl);
            pdfDictionary2.put(PdfName.FIRST, (PdfIndirectReference)arrobject[0]);
            pdfDictionary2.put(PdfName.LAST, (PdfIndirectReference)arrobject[1]);
            pdfDictionary2.put(PdfName.COUNT, new PdfNumber((Integer)arrobject[2]));
            this.addToBody((PdfObject)pdfDictionary2, pdfIndirectReference);
            pdfDictionary.put(PdfName.OUTLINES, pdfIndirectReference);
            return;
        }
    }

    public static class PdfBody {
        private static final int OBJSINSTREAM = 200;
        protected int currentObjNum;
        protected ByteBuffer index;
        protected int numObj = 0;
        protected long position;
        protected int refnum;
        protected ByteBuffer streamObjects;
        protected final PdfWriter writer;
        protected final TreeSet<PdfCrossReference> xrefs = new TreeSet();

        protected PdfBody(PdfWriter pdfWriter) {
            this.xrefs.add(new PdfCrossReference(0, 0L, 65535));
            this.position = pdfWriter.getOs().getCounter();
            this.refnum = 1;
            this.writer = pdfWriter;
        }

        PdfIndirectObject add(PdfObject pdfObject) throws IOException {
            return this.add(pdfObject, this.getIndirectReferenceNumber());
        }

        PdfIndirectObject add(PdfObject pdfObject, int n) throws IOException {
            return this.add(pdfObject, n, 0, true);
        }

        protected PdfIndirectObject add(PdfObject object, int n, int n2, boolean bl) throws IOException {
            if (bl && object.canBeInObjStm() && this.writer.isFullCompression()) {
                PdfCrossReference pdfCrossReference = this.addToObjStm((PdfObject)object, n);
                object = new PdfIndirectObject(n, (PdfObject)object, this.writer);
                if (!this.xrefs.add(pdfCrossReference)) {
                    this.xrefs.remove(pdfCrossReference);
                    this.xrefs.add(pdfCrossReference);
                }
                return object;
            }
            if (this.writer.isFullCompression()) {
                object = new PdfIndirectObject(n, (PdfObject)object, this.writer);
                this.write((PdfIndirectObject)object, n);
                return object;
            }
            object = new PdfIndirectObject(n, n2, (PdfObject)object, this.writer);
            this.write((PdfIndirectObject)object, n, n2);
            return object;
        }

        PdfIndirectObject add(PdfObject pdfObject, PdfIndirectReference pdfIndirectReference) throws IOException {
            return this.add(pdfObject, pdfIndirectReference, true);
        }

        PdfIndirectObject add(PdfObject pdfObject, PdfIndirectReference pdfIndirectReference, boolean bl) throws IOException {
            return this.add(pdfObject, pdfIndirectReference.getNumber(), pdfIndirectReference.getGeneration(), bl);
        }

        PdfIndirectObject add(PdfObject pdfObject, boolean bl) throws IOException {
            return this.add(pdfObject, this.getIndirectReferenceNumber(), 0, bl);
        }

        protected PdfCrossReference addToObjStm(PdfObject pdfObject, int n) throws IOException {
            if (this.numObj >= 200) {
                this.flushObjStm();
            }
            if (this.index == null) {
                this.index = new ByteBuffer();
                this.streamObjects = new ByteBuffer();
                this.currentObjNum = this.getIndirectReferenceNumber();
                this.numObj = 0;
            }
            int n2 = this.streamObjects.size();
            int n3 = this.numObj;
            this.numObj = n3 + 1;
            PdfEncryption pdfEncryption = this.writer.crypto;
            this.writer.crypto = null;
            pdfObject.toPdf(this.writer, this.streamObjects);
            this.writer.crypto = pdfEncryption;
            this.streamObjects.append(' ');
            this.index.append(n).append(' ').append(n2).append(' ');
            return new PdfCrossReference(2, n, this.currentObjNum, n3);
        }

        public void flushObjStm() throws IOException {
            if (this.numObj == 0) {
                return;
            }
            int n = this.index.size();
            this.index.append(this.streamObjects);
            PdfStream pdfStream = new PdfStream(this.index.toByteArray());
            pdfStream.flateCompress(this.writer.getCompressionLevel());
            pdfStream.put(PdfName.TYPE, PdfName.OBJSTM);
            pdfStream.put(PdfName.N, new PdfNumber(this.numObj));
            pdfStream.put(PdfName.FIRST, new PdfNumber(n));
            this.add((PdfObject)pdfStream, this.currentObjNum);
            this.index = null;
            this.streamObjects = null;
            this.numObj = 0;
        }

        protected int getIndirectReferenceNumber() {
            int n = this.refnum;
            this.refnum = n + 1;
            this.xrefs.add(new PdfCrossReference(n, 0L, 65535));
            return n;
        }

        public PdfIndirectReference getPdfIndirectReference() {
            return new PdfIndirectReference(0, this.getIndirectReferenceNumber());
        }

        public long offset() {
            return this.position;
        }

        void setRefnum(int n) {
            this.refnum = n;
        }

        public int size() {
            return Math.max(this.xrefs.last().getRefnum() + 1, this.refnum);
        }

        protected void write(PdfIndirectObject pdfIndirectObject, int n) throws IOException {
            PdfCrossReference pdfCrossReference = new PdfCrossReference(n, this.position);
            if (!this.xrefs.add(pdfCrossReference)) {
                this.xrefs.remove(pdfCrossReference);
                this.xrefs.add(pdfCrossReference);
            }
            pdfIndirectObject.writeTo(this.writer.getOs());
            this.position = this.writer.getOs().getCounter();
        }

        protected void write(PdfIndirectObject pdfIndirectObject, int n, int n2) throws IOException {
            PdfCrossReference pdfCrossReference = new PdfCrossReference(n, this.position, n2);
            if (!this.xrefs.add(pdfCrossReference)) {
                this.xrefs.remove(pdfCrossReference);
                this.xrefs.add(pdfCrossReference);
            }
            pdfIndirectObject.writeTo(this.writer.getOs());
            this.position = this.writer.getOs().getCounter();
        }

        public void writeCrossReferenceTable(OutputStream object, PdfIndirectReference object2, PdfIndirectReference pdfIndirectReference, PdfIndirectReference pdfIndirectReference2, PdfObject pdfObject, long l) throws IOException {
            int n;
            if (this.writer.isFullCompression()) {
                this.flushObjStm();
                n = this.getIndirectReferenceNumber();
                this.xrefs.add(new PdfCrossReference(n, this.position));
            } else {
                n = 0;
            }
            int n2 = this.xrefs.first().getRefnum();
            ArrayList<Integer> arrayList = new ArrayList<Integer>();
            Iterator<PdfCrossReference> iterator = this.xrefs.iterator();
            int n3 = 0;
            while (iterator.hasNext()) {
                PdfCrossReference pdfCrossReference = iterator.next();
                if (n2 + n3 == pdfCrossReference.getRefnum()) {
                    ++n3;
                    continue;
                }
                arrayList.add(n2);
                arrayList.add(n3);
                n2 = pdfCrossReference.getRefnum();
                n3 = 1;
            }
            arrayList.add(n2);
            arrayList.add(n3);
            if (this.writer.isFullCompression()) {
                long l2 = 0xFF00000000L;
                for (n3 = 5; n3 > 1 && (l2 & this.position) == 0L; --n3) {
                    l2 >>>= 8;
                }
                object = new ByteBuffer();
                iterator = this.xrefs.iterator();
                while (iterator.hasNext()) {
                    iterator.next().toPdf(n3, (OutputStream)object);
                }
                object = new PdfStream(object.toByteArray());
                object.flateCompress(this.writer.getCompressionLevel());
                object.put(PdfName.SIZE, new PdfNumber(this.size()));
                object.put(PdfName.ROOT, (PdfObject)object2);
                if (pdfIndirectReference != null) {
                    object.put(PdfName.INFO, pdfIndirectReference);
                }
                if (pdfIndirectReference2 != null) {
                    object.put(PdfName.ENCRYPT, pdfIndirectReference2);
                }
                if (pdfObject != null) {
                    object.put(PdfName.ID, pdfObject);
                }
                object2 = PdfName.W;
                n2 = 0;
                object.put((PdfName)object2, new PdfArray(new int[]{1, n3, 2}));
                object.put(PdfName.TYPE, PdfName.XREF);
                object2 = new PdfArray();
                for (n3 = n2; n3 < arrayList.size(); ++n3) {
                    object2.add(new PdfNumber((Integer)arrayList.get(n3)));
                }
                object.put(PdfName.INDEX, (PdfObject)object2);
                if (l > 0L) {
                    object.put(PdfName.PREV, new PdfNumber(l));
                }
                object2 = this.writer.crypto;
                this.writer.crypto = null;
                new PdfIndirectObject(n, (PdfObject)object, this.writer).writeTo(this.writer.getOs());
                this.writer.crypto = object2;
                return;
            }
            object.write(DocWriter.getISOBytes("xref\n"));
            object2 = this.xrefs.iterator();
            for (n3 = 0; n3 < arrayList.size(); n3 += 2) {
                n2 = (Integer)arrayList.get(n3);
                object.write(DocWriter.getISOBytes(String.valueOf(n2)));
                object.write(DocWriter.getISOBytes(" "));
                object.write(DocWriter.getISOBytes(String.valueOf(n)));
                object.write(10);
                for (n = ((Integer)arrayList.get((int)(n3 + 1))).intValue(); n > 0; --n) {
                    ((PdfCrossReference)object2.next()).toPdf((OutputStream)object);
                }
            }
        }

        public static class PdfCrossReference
        implements Comparable<PdfCrossReference> {
            private final int generation;
            private final long offset;
            private final int refnum;
            private final int type;

            public PdfCrossReference(int n, int n2, long l, int n3) {
                this.type = n;
                this.offset = l;
                this.refnum = n2;
                this.generation = n3;
            }

            public PdfCrossReference(int n, long l) {
                this.type = 1;
                this.offset = l;
                this.refnum = n;
                this.generation = 0;
            }

            public PdfCrossReference(int n, long l, int n2) {
                this.type = 0;
                this.offset = l;
                this.refnum = n;
                this.generation = n2;
            }

            @Override
            public int compareTo(PdfCrossReference pdfCrossReference) {
                if (this.refnum < pdfCrossReference.refnum) {
                    return -1;
                }
                if (this.refnum == pdfCrossReference.refnum) {
                    return 0;
                }
                return 1;
            }

            public boolean equals(Object object) {
                boolean bl = object instanceof PdfCrossReference;
                boolean bl2 = false;
                if (bl) {
                    object = (PdfCrossReference)object;
                    if (this.refnum == object.refnum) {
                        bl2 = true;
                    }
                    return bl2;
                }
                return false;
            }

            public int getRefnum() {
                return this.refnum;
            }

            public int hashCode() {
                return this.refnum;
            }

            public void toPdf(int n, OutputStream outputStream) throws IOException {
                outputStream.write((byte)this.type);
                while (--n >= 0) {
                    outputStream.write((byte)(this.offset >>> n * 8 & 255L));
                }
                outputStream.write((byte)(this.generation >>> 8 & 255));
                outputStream.write((byte)(this.generation & 255));
            }

            public void toPdf(OutputStream outputStream) throws IOException {
                StringBuffer stringBuffer = new StringBuffer("0000000000");
                stringBuffer.append(this.offset);
                stringBuffer.delete(0, stringBuffer.length() - 10);
                CharSequence charSequence = new StringBuffer("00000");
                charSequence.append(this.generation);
                charSequence.delete(0, charSequence.length() - 5);
                stringBuffer.append(' ');
                stringBuffer.append((StringBuffer)charSequence);
                charSequence = this.generation == 65535 ? " f \n" : " n \n";
                stringBuffer.append((String)charSequence);
                outputStream.write(DocWriter.getISOBytes(stringBuffer.toString()));
            }
        }

    }

    public static class PdfTrailer
    extends PdfDictionary {
        long offset;

        public PdfTrailer(int n, long l, PdfIndirectReference pdfIndirectReference, PdfIndirectReference pdfIndirectReference2, PdfIndirectReference pdfIndirectReference3, PdfObject pdfObject, long l2) {
            this.offset = l;
            this.put(PdfName.SIZE, new PdfNumber(n));
            this.put(PdfName.ROOT, pdfIndirectReference);
            if (pdfIndirectReference2 != null) {
                this.put(PdfName.INFO, pdfIndirectReference2);
            }
            if (pdfIndirectReference3 != null) {
                this.put(PdfName.ENCRYPT, pdfIndirectReference3);
            }
            if (pdfObject != null) {
                this.put(PdfName.ID, pdfObject);
            }
            if (l2 > 0L) {
                this.put(PdfName.PREV, new PdfNumber(l2));
            }
        }

        @Override
        public void toPdf(PdfWriter pdfWriter, OutputStream outputStream) throws IOException {
            PdfWriter.checkPdfIsoConformance(pdfWriter, 8, this);
            outputStream.write(DocWriter.getISOBytes("trailer\n"));
            super.toPdf(null, outputStream);
            outputStream.write(10);
            PdfWriter.writeKeyInfo(outputStream);
            outputStream.write(DocWriter.getISOBytes("startxref\n"));
            outputStream.write(DocWriter.getISOBytes(String.valueOf(this.offset)));
            outputStream.write(DocWriter.getISOBytes("\n%%EOF\n"));
        }
    }

}

