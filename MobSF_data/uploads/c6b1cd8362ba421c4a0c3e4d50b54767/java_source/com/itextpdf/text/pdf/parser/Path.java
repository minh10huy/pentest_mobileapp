/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.awt.geom.Point2D;
import com.itextpdf.text.pdf.parser.BezierCurve;
import com.itextpdf.text.pdf.parser.Line;
import com.itextpdf.text.pdf.parser.Shape;
import com.itextpdf.text.pdf.parser.Subpath;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

public class Path {
    private static final String START_PATH_ERR_MSG = "Path shall start with \"re\" or \"m\" operator";
    private Point2D currentPoint;
    private List<Subpath> subpaths = new ArrayList<Subpath>();

    public Path() {
    }

    public Path(List<? extends Subpath> list) {
        this.addSubpaths(list);
    }

    private Subpath getLastSubpath() {
        if (this.subpaths.size() > 0) {
            return this.subpaths.get(this.subpaths.size() - 1);
        }
        return null;
    }

    public void addSubpath(Subpath subpath) {
        this.subpaths.add(subpath);
        this.currentPoint = subpath.getLastPoint();
    }

    public void addSubpaths(List<? extends Subpath> list) {
        if (list.size() > 0) {
            this.subpaths.addAll(list);
            this.currentPoint = this.subpaths.get(list.size() - 1).getLastPoint();
        }
    }

    public void closeAllSubpaths() {
        Iterator<Subpath> iterator = this.subpaths.iterator();
        while (iterator.hasNext()) {
            iterator.next().setClosed(true);
        }
    }

    public void closeSubpath() {
        Object object = this.getLastSubpath();
        object.setClosed(true);
        object = object.getStartPoint();
        this.moveTo((float)object.getX(), (float)object.getY());
    }

    public void curveFromTo(float f, float f2, float f3, float f4) {
        if (this.currentPoint == null) {
            throw new RuntimeException(START_PATH_ERR_MSG);
        }
        this.curveTo(f, f2, f3, f4, f3, f4);
    }

    public void curveTo(float f, float f2, float f3, float f4) {
        if (this.currentPoint == null) {
            throw new RuntimeException(START_PATH_ERR_MSG);
        }
        this.curveTo((float)this.currentPoint.getX(), (float)this.currentPoint.getY(), f, f2, f3, f4);
    }

    public void curveTo(float f, float f2, float f3, float f4, float f5, float f6) {
        if (this.currentPoint == null) {
            throw new RuntimeException(START_PATH_ERR_MSG);
        }
        Cloneable cloneable = new Point2D.Float(f, f2);
        Point2D.Float float_ = new Point2D.Float(f3, f4);
        Point2D.Float float_2 = new Point2D.Float(f5, f6);
        cloneable = new ArrayList<Point2D>(Arrays.asList(this.currentPoint, cloneable, float_, float_2));
        this.getLastSubpath().addSegment(new BezierCurve((List<Point2D>)((Object)cloneable)));
        this.currentPoint = float_2;
    }

    public Point2D getCurrentPoint() {
        return this.currentPoint;
    }

    public List<Subpath> getSubpaths() {
        return this.subpaths;
    }

    public boolean isEmpty() {
        if (this.subpaths.size() == 0) {
            return true;
        }
        return false;
    }

    public void lineTo(float f, float f2) {
        if (this.currentPoint == null) {
            throw new RuntimeException(START_PATH_ERR_MSG);
        }
        Point2D.Float float_ = new Point2D.Float(f, f2);
        this.getLastSubpath().addSegment(new Line(this.currentPoint, float_));
        this.currentPoint = float_;
    }

    public void moveTo(float f, float f2) {
        this.currentPoint = new Point2D.Float(f, f2);
        Subpath subpath = this.getLastSubpath();
        if (subpath != null && subpath.isSinglePointOpen()) {
            subpath.setStartPoint(this.currentPoint);
            return;
        }
        this.subpaths.add(new Subpath(this.currentPoint));
    }

    public void rectangle(float f, float f2, float f3, float f4) {
        this.moveTo(f, f2);
        this.lineTo(f3 += f, f2);
        this.lineTo(f3, f2 += f4);
        this.lineTo(f, f2);
        this.closeSubpath();
    }

    public List<Integer> replaceCloseWithLine() {
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        Iterator<Subpath> iterator = this.subpaths.iterator();
        int n = 0;
        while (iterator.hasNext()) {
            Subpath subpath = iterator.next();
            if (subpath.isClosed()) {
                subpath.setClosed(false);
                subpath.addSegment(new Line(subpath.getLastPoint(), subpath.getStartPoint()));
                arrayList.add(n);
            }
            ++n;
        }
        return arrayList;
    }
}

