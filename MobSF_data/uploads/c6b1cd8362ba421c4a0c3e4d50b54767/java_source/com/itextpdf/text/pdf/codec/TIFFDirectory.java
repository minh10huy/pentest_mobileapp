/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.codec;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.codec.TIFFField;
import java.io.EOFException;
import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;

public class TIFFDirectory
implements Serializable {
    private static final long serialVersionUID = -168636766193675380L;
    private static final int[] sizeOfType = new int[]{0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};
    long IFDOffset = 8L;
    Hashtable<Integer, Integer> fieldIndex = new Hashtable();
    TIFFField[] fields;
    boolean isBigEndian;
    long nextIFDOffset = 0L;
    int numEntries;

    TIFFDirectory() {
    }

    public TIFFDirectory(RandomAccessFileOrArray randomAccessFileOrArray, int n) throws IOException {
        long l = randomAccessFileOrArray.getFilePointer();
        randomAccessFileOrArray.seek(0L);
        int n2 = randomAccessFileOrArray.readUnsignedShort();
        if (!TIFFDirectory.isValidEndianTag(n2)) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("bad.endianness.tag.not.0x4949.or.0x4d4d", new Object[0]));
        }
        boolean bl = n2 == 19789;
        this.isBigEndian = bl;
        if (this.readUnsignedShort(randomAccessFileOrArray) != 42) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("bad.magic.number.should.be.42", new Object[0]));
        }
        long l2 = this.readUnsignedInt(randomAccessFileOrArray);
        for (n2 = 0; n2 < n; ++n2) {
            if (l2 == 0L) {
                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("directory.number.too.large", new Object[0]));
            }
            randomAccessFileOrArray.seek(l2);
            randomAccessFileOrArray.skip(this.readUnsignedShort(randomAccessFileOrArray) * 12);
            l2 = this.readUnsignedInt(randomAccessFileOrArray);
        }
        randomAccessFileOrArray.seek(l2);
        this.initialize(randomAccessFileOrArray);
        randomAccessFileOrArray.seek(l);
    }

    public TIFFDirectory(RandomAccessFileOrArray randomAccessFileOrArray, long l, int n) throws IOException {
        long l2 = randomAccessFileOrArray.getFilePointer();
        randomAccessFileOrArray.seek(0L);
        int n2 = randomAccessFileOrArray.readUnsignedShort();
        boolean bl = TIFFDirectory.isValidEndianTag(n2);
        if (!bl) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("bad.endianness.tag.not.0x4949.or.0x4d4d", new Object[0]));
        }
        bl = n2 == 19789;
        this.isBigEndian = bl;
        randomAccessFileOrArray.seek(l);
        for (int i = 0; i < n; ++i) {
            randomAccessFileOrArray.seek(l + (long)(this.readUnsignedShort(randomAccessFileOrArray) * 12));
            l = this.readUnsignedInt(randomAccessFileOrArray);
            randomAccessFileOrArray.seek(l);
        }
        this.initialize(randomAccessFileOrArray);
        randomAccessFileOrArray.seek(l2);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static int getNumDirectories(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        long l;
        int n;
        block5 : {
            l = randomAccessFileOrArray.getFilePointer();
            randomAccessFileOrArray.seek(0L);
            n = randomAccessFileOrArray.readUnsignedShort();
            boolean bl = TIFFDirectory.isValidEndianTag(n);
            int n2 = 0;
            if (!bl) {
                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("bad.endianness.tag.not.0x4949.or.0x4d4d", new Object[0]));
            }
            bl = n == 19789;
            if (TIFFDirectory.readUnsignedShort(randomAccessFileOrArray, bl) != 42) {
                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("bad.magic.number.should.be.42", new Object[0]));
            }
            randomAccessFileOrArray.seek(4L);
            long l2 = TIFFDirectory.readUnsignedInt(randomAccessFileOrArray, bl);
            do {
                n = n2++;
                if (l2 == 0L) break block5;
                try {
                    randomAccessFileOrArray.seek(l2);
                    randomAccessFileOrArray.skip(TIFFDirectory.readUnsignedShort(randomAccessFileOrArray, bl) * 12);
                    l2 = TIFFDirectory.readUnsignedInt(randomAccessFileOrArray, bl);
                    continue;
                }
                catch (EOFException eOFException) {}
                break;
            } while (true);
            n = n2 - 1;
        }
        randomAccessFileOrArray.seek(l);
        return n;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void initialize(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        long l = randomAccessFileOrArray.length();
        this.IFDOffset = randomAccessFileOrArray.getFilePointer();
        this.numEntries = this.readUnsignedShort(randomAccessFileOrArray);
        this.fields = new TIFFField[this.numEntries];
        int n = 0;
        long l2 = 0L;
        do {
            int n4;
            int n5;
            int n3;
            int n2;
            block31 : {
                block30 : {
                    if (n < this.numEntries && l2 < l) {
                        n3 = this.readUnsignedShort(randomAccessFileOrArray);
                        n2 = this.readUnsignedShort(randomAccessFileOrArray);
                        n5 = (int)this.readUnsignedInt(randomAccessFileOrArray);
                        l2 = randomAccessFileOrArray.getFilePointer() + 4L;
                        if (sizeOfType[n2] * n5 > 4) {
                            long l3 = this.readUnsignedInt(randomAccessFileOrArray);
                            if (l3 >= l) break block30;
                            randomAccessFileOrArray.seek(l3);
                        }
                        n4 = 1;
                        break block31;
                    }
                    this.nextIFDOffset = this.readUnsignedInt(randomAccessFileOrArray);
                    return;
                    catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {}
                }
                n4 = 0;
            }
            if (n4 != 0) {
                this.fieldIndex.put(n3, n);
                Object[] arrobject = null;
                block2 : switch (n2) {
                    int n6;
                    default: {
                        n4 = n5;
                        break;
                    }
                    case 12: {
                        double[] arrd = new double[n5];
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrd;
                            if (n6 >= n5) break block2;
                            arrd[n6] = this.readDouble(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 11: {
                        float[] arrf = new float[n5];
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrf;
                            if (n6 >= n5) break block2;
                            arrf[n6] = this.readFloat(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 10: {
                        int[][] arrn = (int[][])Array.newInstance(Integer.TYPE, n5, 2);
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrn;
                            if (n6 >= n5) break block2;
                            arrn[n6][0] = this.readInt(randomAccessFileOrArray);
                            arrn[n6][1] = this.readInt(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 9: {
                        int[] arrn = new int[n5];
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrn;
                            if (n6 >= n5) break block2;
                            arrn[n6] = this.readInt(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 8: {
                        short[] arrs = new short[n5];
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrs;
                            if (n6 >= n5) break block2;
                            arrs[n6] = this.readShort(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 5: {
                        long[][] arrl = (long[][])Array.newInstance(Long.TYPE, n5, 2);
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrl;
                            if (n6 >= n5) break block2;
                            arrl[n6][0] = this.readUnsignedInt(randomAccessFileOrArray);
                            arrl[n6][1] = this.readUnsignedInt(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 4: {
                        long[] arrl = new long[n5];
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrl;
                            if (n6 >= n5) break block2;
                            arrl[n6] = this.readUnsignedInt(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 3: {
                        char[] arrc = new char[n5];
                        n6 = 0;
                        do {
                            n4 = n5;
                            arrobject = arrc;
                            if (n6 >= n5) break block2;
                            arrc[n6] = (char)this.readUnsignedShort(randomAccessFileOrArray);
                            ++n6;
                        } while (true);
                    }
                    case 1: 
                    case 2: 
                    case 6: 
                    case 7: {
                        byte[] arrby = new byte[n5];
                        randomAccessFileOrArray.readFully(arrby, 0, n5);
                        n4 = n5;
                        arrobject = arrby;
                        if (n2 != 2) break;
                        ArrayList<String> arrayList = new ArrayList<String>();
                        n4 = 0;
                        int n7 = 0;
                        while (n4 < n5) {
                            n6 = n4;
                            do {
                                n4 = n6;
                                if (n6 >= n5) break;
                                n4 = n6 + 1;
                                if (arrby[n6] == 0) break;
                                n6 = n4;
                            } while (true);
                            arrayList.add(new String(arrby, n7, n4 - n7));
                            n7 = n4;
                        }
                        n7 = arrayList.size();
                        String[] arrstring = new String[n7];
                        n6 = 0;
                        do {
                            n4 = n7;
                            arrobject = arrstring;
                            if (n6 >= n7) break block2;
                            arrstring[n6] = (String)arrayList.get(n6);
                            ++n6;
                        } while (true);
                    }
                }
                this.fields[n] = new TIFFField(n3, n2, n4, arrobject);
            }
            randomAccessFileOrArray.seek(l2);
            ++n;
        } while (true);
        catch (Exception exception) {}
        this.nextIFDOffset = 0L;
    }

    private static boolean isValidEndianTag(int n) {
        if (n != 18761 && n != 19789) {
            return false;
        }
        return true;
    }

    private double readDouble(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        if (this.isBigEndian) {
            return randomAccessFileOrArray.readDouble();
        }
        return randomAccessFileOrArray.readDoubleLE();
    }

    private float readFloat(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        if (this.isBigEndian) {
            return randomAccessFileOrArray.readFloat();
        }
        return randomAccessFileOrArray.readFloatLE();
    }

    private int readInt(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        if (this.isBigEndian) {
            return randomAccessFileOrArray.readInt();
        }
        return randomAccessFileOrArray.readIntLE();
    }

    private long readLong(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        if (this.isBigEndian) {
            return randomAccessFileOrArray.readLong();
        }
        return randomAccessFileOrArray.readLongLE();
    }

    private short readShort(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        if (this.isBigEndian) {
            return randomAccessFileOrArray.readShort();
        }
        return randomAccessFileOrArray.readShortLE();
    }

    private long readUnsignedInt(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        if (this.isBigEndian) {
            return randomAccessFileOrArray.readUnsignedInt();
        }
        return randomAccessFileOrArray.readUnsignedIntLE();
    }

    private static long readUnsignedInt(RandomAccessFileOrArray randomAccessFileOrArray, boolean bl) throws IOException {
        if (bl) {
            return randomAccessFileOrArray.readUnsignedInt();
        }
        return randomAccessFileOrArray.readUnsignedIntLE();
    }

    private int readUnsignedShort(RandomAccessFileOrArray randomAccessFileOrArray) throws IOException {
        if (this.isBigEndian) {
            return randomAccessFileOrArray.readUnsignedShort();
        }
        return randomAccessFileOrArray.readUnsignedShortLE();
    }

    private static int readUnsignedShort(RandomAccessFileOrArray randomAccessFileOrArray, boolean bl) throws IOException {
        if (bl) {
            return randomAccessFileOrArray.readUnsignedShort();
        }
        return randomAccessFileOrArray.readUnsignedShortLE();
    }

    public TIFFField getField(int n) {
        Integer n2 = this.fieldIndex.get(n);
        if (n2 == null) {
            return null;
        }
        return this.fields[n2];
    }

    public byte getFieldAsByte(int n) {
        return this.getFieldAsByte(n, 0);
    }

    public byte getFieldAsByte(int n, int n2) {
        Integer n3 = this.fieldIndex.get(n);
        return this.fields[n3].getAsBytes()[n2];
    }

    public double getFieldAsDouble(int n) {
        return this.getFieldAsDouble(n, 0);
    }

    public double getFieldAsDouble(int n, int n2) {
        Integer n3 = this.fieldIndex.get(n);
        return this.fields[n3].getAsDouble(n2);
    }

    public float getFieldAsFloat(int n) {
        return this.getFieldAsFloat(n, 0);
    }

    public float getFieldAsFloat(int n, int n2) {
        Integer n3 = this.fieldIndex.get(n);
        return this.fields[n3].getAsFloat(n2);
    }

    public long getFieldAsLong(int n) {
        return this.getFieldAsLong(n, 0);
    }

    public long getFieldAsLong(int n, int n2) {
        Integer n3 = this.fieldIndex.get(n);
        return this.fields[n3].getAsLong(n2);
    }

    public TIFFField[] getFields() {
        return this.fields;
    }

    public long getIFDOffset() {
        return this.IFDOffset;
    }

    public long getNextIFDOffset() {
        return this.nextIFDOffset;
    }

    public int getNumEntries() {
        return this.numEntries;
    }

    public int[] getTags() {
        int[] arrn = new int[this.fieldIndex.size()];
        Enumeration<Integer> enumeration = this.fieldIndex.keys();
        int n = 0;
        while (enumeration.hasMoreElements()) {
            arrn[n] = enumeration.nextElement();
            ++n;
        }
        return arrn;
    }

    public boolean isBigEndian() {
        return this.isBigEndian;
    }

    public boolean isTagPresent(int n) {
        return this.fieldIndex.containsKey(n);
    }
}

