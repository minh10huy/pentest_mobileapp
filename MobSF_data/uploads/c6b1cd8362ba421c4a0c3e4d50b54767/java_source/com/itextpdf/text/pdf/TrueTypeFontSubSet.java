/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;

class TrueTypeFontSubSet {
    static final int ARG_1_AND_2_ARE_WORDS = 1;
    static final int HEAD_LOCA_FORMAT_OFFSET = 51;
    static final int MORE_COMPONENTS = 32;
    static final int TABLE_CHECKSUM = 0;
    static final int TABLE_LENGTH = 2;
    static final int TABLE_OFFSET = 1;
    static final int WE_HAVE_AN_X_AND_Y_SCALE = 64;
    static final int WE_HAVE_A_SCALE = 8;
    static final int WE_HAVE_A_TWO_BY_TWO = 128;
    static final int[] entrySelectors;
    static final String[] tableNamesCmap;
    static final String[] tableNamesExtra;
    static final String[] tableNamesSimple;
    protected int directoryOffset;
    protected String fileName;
    protected int fontPtr;
    protected int glyfTableRealSize;
    protected ArrayList<Integer> glyphsInList;
    protected HashSet<Integer> glyphsUsed;
    protected boolean includeCmap;
    protected boolean includeExtras;
    protected boolean locaShortTable;
    protected int[] locaTable;
    protected int locaTableRealSize;
    protected byte[] newGlyfTable;
    protected int[] newLocaTable;
    protected byte[] newLocaTableOut;
    protected byte[] outFont;
    protected RandomAccessFileOrArray rf;
    protected HashMap<String, int[]> tableDirectory;
    protected int tableGlyphOffset;

    static {
        tableNamesSimple = new String[]{"cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "prep"};
        tableNamesCmap = new String[]{"cmap", "cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "prep"};
        tableNamesExtra = new String[]{"OS/2", "cmap", "cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "name, prep"};
        entrySelectors = new int[]{0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4};
    }

    TrueTypeFontSubSet(String string2, RandomAccessFileOrArray randomAccessFileOrArray, HashSet<Integer> hashSet, int n, boolean bl, boolean bl2) {
        this.fileName = string2;
        this.rf = randomAccessFileOrArray;
        this.glyphsUsed = hashSet;
        this.includeCmap = bl;
        this.includeExtras = bl2;
        this.directoryOffset = n;
        this.glyphsInList = new ArrayList<Integer>(hashSet);
    }

    protected void assembleFont() throws IOException {
        int n;
        int[] arrn;
        Object object;
        int n2;
        int n3;
        String[] arrstring = this.includeExtras ? tableNamesExtra : (this.includeCmap ? tableNamesCmap : tableNamesSimple);
        int n4 = 0;
        int n5 = 2;
        for (n = 0; n < arrstring.length; ++n) {
            object = arrstring[n];
            n2 = n4;
            n3 = n5;
            if (!object.equals("glyf")) {
                if (object.equals("loca")) {
                    n2 = n4;
                    n3 = n5;
                } else if ((object = this.tableDirectory.get(object)) == null) {
                    n2 = n4;
                    n3 = n5;
                } else {
                    n3 = n5 + 1;
                    n2 = n4 + (object[2] + 3 & -4);
                }
            }
            n4 = n2;
            n5 = n3;
        }
        n3 = this.newLocaTableOut.length;
        n2 = this.newGlyfTable.length;
        n = n5 * 16 + 12;
        this.outFont = new byte[n4 + n3 + n2 + n];
        this.fontPtr = 0;
        this.writeFontInt(65536);
        this.writeFontShort(n5);
        n4 = entrySelectors[n5];
        n3 = 1 << n4;
        this.writeFontShort(n3 * 16);
        this.writeFontShort(n4);
        this.writeFontShort((n5 - n3) * 16);
        for (n4 = 0; n4 < arrstring.length; ++n4) {
            object = arrstring[n4];
            arrn = this.tableDirectory.get(object);
            if (arrn == null) continue;
            this.writeFontString((String)object);
            if (object.equals("glyf")) {
                this.writeFontInt(this.calculateChecksum(this.newGlyfTable));
                n5 = this.glyfTableRealSize;
            } else if (object.equals("loca")) {
                this.writeFontInt(this.calculateChecksum(this.newLocaTableOut));
                n5 = this.locaTableRealSize;
            } else {
                this.writeFontInt(arrn[0]);
                n5 = arrn[2];
            }
            this.writeFontInt(n);
            this.writeFontInt(n5);
            n += n5 + 3 & -4;
        }
        for (n5 = 0; n5 < arrstring.length; ++n5) {
            object = arrstring[n5];
            arrn = this.tableDirectory.get(object);
            if (arrn == null) continue;
            if (object.equals("glyf")) {
                System.arraycopy(this.newGlyfTable, 0, this.outFont, this.fontPtr, this.newGlyfTable.length);
                this.fontPtr += this.newGlyfTable.length;
                this.newGlyfTable = null;
                continue;
            }
            if (object.equals("loca")) {
                System.arraycopy(this.newLocaTableOut, 0, this.outFont, this.fontPtr, this.newLocaTableOut.length);
                this.fontPtr += this.newLocaTableOut.length;
                this.newLocaTableOut = null;
                continue;
            }
            this.rf.seek(arrn[1]);
            this.rf.readFully(this.outFont, this.fontPtr, arrn[2]);
            this.fontPtr += arrn[2] + 3 & -4;
        }
    }

    protected int calculateChecksum(byte[] arrby) {
        int n = arrby.length / 4;
        int n2 = 0;
        int n3 = 0;
        int n4 = 0;
        int n5 = 0;
        int n6 = 0;
        for (int i = 0; i < n; ++i) {
            int n7 = n3 + 1;
            n2 += arrby[n3] & 255;
            n3 = n7 + 1;
            n4 += arrby[n7] & 255;
            n7 = n3 + 1;
            n5 += arrby[n3] & 255;
            n3 = n7 + 1;
            n6 += arrby[n7] & 255;
        }
        return n6 + (n5 << 8) + (n4 << 16) + (n2 << 24);
    }

    protected void checkGlyphComposite(int n) throws IOException {
        int n2 = this.locaTable[n];
        if (n2 == this.locaTable[n + 1]) {
            return;
        }
        this.rf.seek(this.tableGlyphOffset + n2);
        if (this.rf.readShort() >= 0) {
            return;
        }
        this.rf.skipBytes(8);
        do {
            int n3 = this.rf.readUnsignedShort();
            Integer n4 = this.rf.readUnsignedShort();
            if (!this.glyphsUsed.contains(n4)) {
                this.glyphsUsed.add(n4);
                this.glyphsInList.add(n4);
            }
            if ((n3 & 32) == 0) {
                return;
            }
            n2 = (n3 & 1) != 0 ? 4 : 2;
            if ((n3 & 8) != 0) {
                n = n2 + 2;
            } else {
                n = n2;
                if ((n3 & 64) != 0) {
                    n = n2 + 4;
                }
            }
            n2 = n;
            if ((n3 & 128) != 0) {
                n2 = n + 8;
            }
            this.rf.skipBytes(n2);
        } while (true);
    }

    protected void createNewGlyphTables() throws IOException {
        int n;
        int n2;
        this.newLocaTable = new int[this.locaTable.length];
        int[] arrn = new int[this.glyphsInList.size()];
        int n3 = 0;
        for (n2 = 0; n2 < arrn.length; ++n2) {
            arrn[n2] = this.glyphsInList.get(n2);
        }
        Arrays.sort(arrn);
        int n4 = 0;
        for (n2 = 0; n2 < arrn.length; ++n2) {
            n = arrn[n2];
            n4 += this.locaTable[n + 1] - this.locaTable[n];
        }
        this.glyfTableRealSize = n4;
        this.newGlyfTable = new byte[n4 + 3 & -4];
        n = 0;
        int n5 = 0;
        for (n4 = n3; n4 < this.newLocaTable.length; ++n4) {
            this.newLocaTable[n4] = n;
            n3 = n;
            n2 = n5;
            if (n5 < arrn.length) {
                n3 = n;
                n2 = n5;
                if (arrn[n5] == n4) {
                    this.newLocaTable[n4] = n;
                    int n6 = this.locaTable[n4];
                    int n7 = this.locaTable[n4 + 1] - n6;
                    n3 = n;
                    n2 = ++n5;
                    if (n7 > 0) {
                        this.rf.seek(this.tableGlyphOffset + n6);
                        this.rf.readFully(this.newGlyfTable, n, n7);
                        n3 = n + n7;
                        n2 = n5;
                    }
                }
            }
            n = n3;
            n5 = n2;
        }
    }

    protected void createTableDirectory() throws IOException, DocumentException {
        this.tableDirectory = new HashMap();
        this.rf.seek(this.directoryOffset);
        if (this.rf.readInt() != 65536) {
            throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.true.type.file", this.fileName));
        }
        int n = this.rf.readUnsignedShort();
        this.rf.skipBytes(6);
        for (int i = 0; i < n; ++i) {
            String string2 = this.readStandardString(4);
            int n2 = this.rf.readInt();
            int n3 = this.rf.readInt();
            int n4 = this.rf.readInt();
            this.tableDirectory.put(string2, new int[]{n2, n3, n4});
        }
    }

    protected void flatGlyphs() throws IOException, DocumentException {
        int[] arrn = this.tableDirectory.get("glyf");
        int n = 0;
        if (arrn == null) {
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "glyf", this.fileName));
        }
        Integer n2 = 0;
        if (!this.glyphsUsed.contains(n2)) {
            this.glyphsUsed.add(n2);
            this.glyphsInList.add(n2);
        }
        this.tableGlyphOffset = arrn[1];
        while (n < this.glyphsInList.size()) {
            this.checkGlyphComposite(this.glyphsInList.get(n));
            ++n;
        }
    }

    protected void locaTobytes() {
        this.locaTableRealSize = this.locaShortTable ? this.newLocaTable.length * 2 : this.newLocaTable.length * 4;
        this.newLocaTableOut = new byte[this.locaTableRealSize + 3 & -4];
        this.outFont = this.newLocaTableOut;
        this.fontPtr = 0;
        for (int i = 0; i < this.newLocaTable.length; ++i) {
            if (this.locaShortTable) {
                this.writeFontShort(this.newLocaTable[i] / 2);
                continue;
            }
            this.writeFontInt(this.newLocaTable[i]);
        }
    }

    byte[] process() throws IOException, DocumentException {
        try {
            this.rf.reOpen();
            this.createTableDirectory();
            this.readLoca();
            this.flatGlyphs();
            this.createNewGlyphTables();
            this.locaTobytes();
            this.assembleFont();
            byte[] arrby = this.outFont;
            return arrby;
        }
        finally {
            this.rf.close();
        }
    }

    protected void readLoca() throws IOException, DocumentException {
        int n;
        int[] arrn = this.tableDirectory.get("head");
        int n2 = 0;
        if (arrn == null) {
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "head", this.fileName));
        }
        this.rf.seek(arrn[1] + 51);
        boolean bl = this.rf.readUnsignedShort() == 0;
        this.locaShortTable = bl;
        arrn = this.tableDirectory.get("loca");
        if (arrn == null) {
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "loca", this.fileName));
        }
        this.rf.seek(arrn[1]);
        if (this.locaShortTable) {
            n2 = arrn[2] / 2;
            this.locaTable = new int[n2];
            for (n = 0; n < n2; ++n) {
                this.locaTable[n] = this.rf.readUnsignedShort() * 2;
            }
        } else {
            int n3 = arrn[2] / 4;
            this.locaTable = new int[n3];
            for (n = n2; n < n3; ++n) {
                this.locaTable[n] = this.rf.readInt();
            }
        }
    }

    protected String readStandardString(int n) throws IOException {
        Object object = new byte[n];
        this.rf.readFully((byte[])object);
        try {
            object = new String((byte[])object, "Cp1252");
            return object;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    protected void writeFontInt(int n) {
        byte[] arrby = this.outFont;
        int n2 = this.fontPtr;
        this.fontPtr = n2 + 1;
        arrby[n2] = (byte)(n >> 24);
        arrby = this.outFont;
        n2 = this.fontPtr;
        this.fontPtr = n2 + 1;
        arrby[n2] = (byte)(n >> 16);
        arrby = this.outFont;
        n2 = this.fontPtr;
        this.fontPtr = n2 + 1;
        arrby[n2] = (byte)(n >> 8);
        arrby = this.outFont;
        n2 = this.fontPtr;
        this.fontPtr = n2 + 1;
        arrby[n2] = (byte)n;
    }

    protected void writeFontShort(int n) {
        byte[] arrby = this.outFont;
        int n2 = this.fontPtr;
        this.fontPtr = n2 + 1;
        arrby[n2] = (byte)(n >> 8);
        arrby = this.outFont;
        n2 = this.fontPtr;
        this.fontPtr = n2 + 1;
        arrby[n2] = (byte)n;
    }

    protected void writeFontString(String arrby) {
        arrby = PdfEncodings.convertToBytes((String)arrby, "Cp1252");
        System.arraycopy(arrby, 0, this.outFont, this.fontPtr, arrby.length);
        this.fontPtr += arrby.length;
    }
}

