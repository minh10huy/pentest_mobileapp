/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.BadPdfFormatException;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfCopy;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfImportedPage;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfReaderInstance;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RefKey;
import java.io.IOException;
import java.io.OutputStream;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Set;

public class PdfSmartCopy
extends PdfCopy {
    private static final Logger LOGGER = LoggerFactory.getLogger(PdfSmartCopy.class);
    protected Counter COUNTER = CounterFactory.getCounter(PdfSmartCopy.class);
    private final HashMap<RefKey, Integer> serialized = new HashMap();
    private HashMap<ByteStore, PdfIndirectReference> streamMap = new HashMap();

    public PdfSmartCopy(Document document, OutputStream outputStream) throws DocumentException {
        super(document, outputStream);
    }

    @Override
    public void addPage(PdfImportedPage pdfImportedPage) throws IOException, BadPdfFormatException {
        if (this.currentPdfReaderInstance.getReader() != this.reader) {
            this.serialized.clear();
        }
        super.addPage(pdfImportedPage);
    }

    @Override
    protected PdfIndirectReference copyIndirect(PRIndirectReference object) throws IOException, BadPdfFormatException {
        ByteStore byteStore;
        PdfIndirectReference pdfIndirectReference;
        PdfObject pdfObject = PdfReader.getPdfObjectRelease((PdfObject)object);
        boolean bl = pdfObject.isStream();
        boolean bl2 = true;
        if (bl) {
            byteStore = new ByteStore((PRStream)pdfObject, this.serialized);
            pdfIndirectReference = this.streamMap.get(byteStore);
            if (pdfIndirectReference != null) {
                return pdfIndirectReference;
            }
        } else if (pdfObject.isDictionary()) {
            byteStore = new ByteStore((PdfDictionary)pdfObject, this.serialized);
            pdfIndirectReference = this.streamMap.get(byteStore);
            if (pdfIndirectReference != null) {
                return pdfIndirectReference;
            }
        } else {
            byteStore = null;
            bl2 = false;
        }
        Object object2 = new RefKey((PRIndirectReference)object);
        object = (PdfCopy.IndirectReferences)this.indirects.get(object2);
        if (object != null) {
            pdfIndirectReference = object.getRef();
            if (object.getCopied()) {
                return pdfIndirectReference;
            }
        } else {
            pdfIndirectReference = this.body.getPdfIndirectReference();
            object = new PdfCopy.IndirectReferences(pdfIndirectReference);
            this.indirects.put(object2, object);
        }
        if (pdfObject.isDictionary() && (object2 = PdfReader.getPdfObjectRelease(((PdfDictionary)pdfObject).get(PdfName.TYPE))) != null) {
            if (PdfName.PAGE.equals(object2)) {
                return pdfIndirectReference;
            }
            if (PdfName.CATALOG.equals(object2)) {
                LOGGER.warn(MessageLocalization.getComposedMessage("make.copy.of.catalog.dictionary.is.forbidden", new Object[0]));
                return null;
            }
        }
        object.setCopied();
        if (bl2) {
            this.streamMap.put(byteStore, pdfIndirectReference);
        }
        this.addToBody(this.copyObject(pdfObject), pdfIndirectReference);
        return pdfIndirectReference;
    }

    @Override
    public void freeReader(PdfReader pdfReader) throws IOException {
        this.serialized.clear();
        super.freeReader(pdfReader);
    }

    @Override
    protected Counter getCounter() {
        return this.COUNTER;
    }

    static class ByteStore {
        private final byte[] b;
        private final int hash;
        private MessageDigest md5;

        ByteStore(PRStream pRStream, HashMap<RefKey, Integer> hashMap) throws IOException {
            ByteBuffer byteBuffer;
            try {
                this.md5 = MessageDigest.getInstance("MD5");
                byteBuffer = new ByteBuffer();
            }
            catch (Exception exception) {
                throw new ExceptionConverter(exception);
            }
            this.serObject(pRStream, 100, byteBuffer, hashMap);
            this.b = byteBuffer.toByteArray();
            this.hash = ByteStore.calculateHash(this.b);
            this.md5 = null;
        }

        ByteStore(PdfDictionary pdfDictionary, HashMap<RefKey, Integer> hashMap) throws IOException {
            ByteBuffer byteBuffer;
            try {
                this.md5 = MessageDigest.getInstance("MD5");
                byteBuffer = new ByteBuffer();
            }
            catch (Exception exception) {
                throw new ExceptionConverter(exception);
            }
            this.serObject(pdfDictionary, 100, byteBuffer, hashMap);
            this.b = byteBuffer.toByteArray();
            this.hash = ByteStore.calculateHash(this.b);
            this.md5 = null;
        }

        private static int calculateHash(byte[] arrby) {
            int n = arrby.length;
            int n2 = 0;
            for (int i = 0; i < n; ++i) {
                n2 = n2 * 31 + (arrby[i] & 255);
            }
            return n2;
        }

        private void serArray(PdfArray pdfArray, int n, ByteBuffer byteBuffer, HashMap<RefKey, Integer> hashMap) throws IOException {
            byteBuffer.append("$A");
            if (n <= 0) {
                return;
            }
            for (int i = 0; i < pdfArray.size(); ++i) {
                this.serObject(pdfArray.getPdfObject(i), n, byteBuffer, hashMap);
            }
        }

        private void serDic(PdfDictionary pdfDictionary, int n, ByteBuffer byteBuffer, HashMap<RefKey, Integer> hashMap) throws IOException {
            byteBuffer.append("$D");
            if (n <= 0) {
                return;
            }
            Object[] arrobject = pdfDictionary.getKeys().toArray();
            Arrays.sort(arrobject);
            for (int i = 0; i < arrobject.length; ++i) {
                if (arrobject[i].equals(PdfName.P) && (pdfDictionary.get((PdfName)arrobject[i]).isIndirect() || pdfDictionary.get((PdfName)arrobject[i]).isDictionary())) continue;
                this.serObject((PdfObject)arrobject[i], n, byteBuffer, hashMap);
                this.serObject(pdfDictionary.get((PdfName)arrobject[i]), n, byteBuffer, hashMap);
            }
        }

        private void serObject(PdfObject object, int n, ByteBuffer byteBuffer, HashMap<RefKey, Integer> hashMap) throws IOException {
            Object object2;
            if (n <= 0) {
                return;
            }
            if (object == null) {
                byteBuffer.append("$Lnull");
                return;
            }
            boolean bl = object.isIndirect();
            PdfIndirectReference pdfIndirectReference = null;
            if (bl) {
                pdfIndirectReference = (PdfIndirectReference)object;
                object2 = new RefKey(pdfIndirectReference);
                if (hashMap.containsKey(object2)) {
                    byteBuffer.append(hashMap.get(object2));
                    return;
                }
                object2 = new ByteBuffer();
            } else {
                Object var8_8 = null;
                object2 = byteBuffer;
                byteBuffer = var8_8;
            }
            object = PdfReader.getPdfObject((PdfObject)object);
            if (object.isStream()) {
                object2.append("$B");
                this.serDic((PdfDictionary)object, n - 1, (ByteBuffer)object2, hashMap);
                if (n > 0) {
                    this.md5.reset();
                    object2.append(this.md5.digest(PdfReader.getStreamBytesRaw((PRStream)object)));
                }
            } else if (object.isDictionary()) {
                this.serDic((PdfDictionary)object, n - 1, (ByteBuffer)object2, hashMap);
            } else if (object.isArray()) {
                this.serArray((PdfArray)object, n - 1, (ByteBuffer)object2, hashMap);
            } else if (object.isString()) {
                object2.append("$S").append(object.toString());
            } else if (object.isName()) {
                object2.append("$N").append(object.toString());
            } else {
                object2.append("$L").append(object.toString());
            }
            if (byteBuffer != null) {
                object = new RefKey(pdfIndirectReference);
                if (!hashMap.containsKey(object)) {
                    hashMap.put((RefKey)object, ByteStore.calculateHash(object2.getBuffer()));
                }
                byteBuffer.append((ByteBuffer)object2);
            }
        }

        public boolean equals(Object object) {
            if (!(object instanceof ByteStore)) {
                return false;
            }
            if (this.hashCode() != object.hashCode()) {
                return false;
            }
            return Arrays.equals(this.b, ((ByteStore)object).b);
        }

        public int hashCode() {
            return this.hash;
        }
    }

}

