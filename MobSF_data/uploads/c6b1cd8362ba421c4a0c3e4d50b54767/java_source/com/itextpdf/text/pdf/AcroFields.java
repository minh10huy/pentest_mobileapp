/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Image;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.io.RASInputStream;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.io.WindowRandomAccessSource;
import com.itextpdf.text.pdf.BaseField;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.CMYKColor;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.ExtendedColor;
import com.itextpdf.text.pdf.FdfReader;
import com.itextpdf.text.pdf.FdfWriter;
import com.itextpdf.text.pdf.FontDetails;
import com.itextpdf.text.pdf.GrayColor;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfAppearance;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDate;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfFormField;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStamperImp;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfTemplate;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.PushbuttonField;
import com.itextpdf.text.pdf.RadioCheckField;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.TextField;
import com.itextpdf.text.pdf.XfaForm;
import com.itextpdf.text.pdf.XfdfReader;
import com.itextpdf.text.pdf.codec.Base64;
import com.itextpdf.text.pdf.security.PdfPKCS7;
import com.itextpdf.text.xml.XmlToTxt;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import org.w3c.dom.Node;

public class AcroFields {
    public static final int DA_COLOR = 2;
    public static final int DA_FONT = 0;
    public static final int DA_SIZE = 1;
    public static final int FIELD_TYPE_CHECKBOX = 2;
    public static final int FIELD_TYPE_COMBO = 6;
    public static final int FIELD_TYPE_LIST = 5;
    public static final int FIELD_TYPE_NONE = 0;
    public static final int FIELD_TYPE_PUSHBUTTON = 1;
    public static final int FIELD_TYPE_RADIOBUTTON = 3;
    public static final int FIELD_TYPE_SIGNATURE = 7;
    public static final int FIELD_TYPE_TEXT = 4;
    private static final PdfName[] buttonRemove;
    private static final HashMap<String, String[]> stdFieldFontNames;
    private boolean append;
    private HashMap<Integer, BaseFont> extensionFonts = new HashMap();
    private float extraMarginLeft;
    private float extraMarginTop;
    private Map<String, TextField> fieldCache;
    Map<String, Item> fields;
    private boolean generateAppearances = true;
    private boolean lastWasString;
    private HashMap<String, BaseFont> localFonts = new HashMap();
    private ArrayList<String> orderedSignatureNames;
    PdfReader reader;
    private HashMap<String, int[]> sigNames;
    private ArrayList<BaseFont> substitutionFonts;
    private int topFirst;
    private int totalRevisions;
    PdfWriter writer;
    private XfaForm xfa;

    static {
        stdFieldFontNames = new HashMap();
        stdFieldFontNames.put("CoBO", new String[]{"Courier-BoldOblique"});
        stdFieldFontNames.put("CoBo", new String[]{"Courier-Bold"});
        stdFieldFontNames.put("CoOb", new String[]{"Courier-Oblique"});
        stdFieldFontNames.put("Cour", new String[]{"Courier"});
        stdFieldFontNames.put("HeBO", new String[]{"Helvetica-BoldOblique"});
        stdFieldFontNames.put("HeBo", new String[]{"Helvetica-Bold"});
        stdFieldFontNames.put("HeOb", new String[]{"Helvetica-Oblique"});
        stdFieldFontNames.put("Helv", new String[]{"Helvetica"});
        stdFieldFontNames.put("Symb", new String[]{"Symbol"});
        stdFieldFontNames.put("TiBI", new String[]{"Times-BoldItalic"});
        stdFieldFontNames.put("TiBo", new String[]{"Times-Bold"});
        stdFieldFontNames.put("TiIt", new String[]{"Times-Italic"});
        stdFieldFontNames.put("TiRo", new String[]{"Times-Roman"});
        stdFieldFontNames.put("ZaDb", new String[]{"ZapfDingbats"});
        stdFieldFontNames.put("HySm", new String[]{"HYSMyeongJo-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("HyGo", new String[]{"HYGoThic-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaGo", new String[]{"HeiseiKakuGo-W5", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaMi", new String[]{"HeiseiMin-W3", "UniJIS-UCS2-H"});
        stdFieldFontNames.put("MHei", new String[]{"MHei-Medium", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("MSun", new String[]{"MSung-Light", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("STSo", new String[]{"STSong-Light", "UniGB-UCS2-H"});
        buttonRemove = new PdfName[]{PdfName.MK, PdfName.F, PdfName.FF, PdfName.Q, PdfName.BS, PdfName.BORDER};
    }

    AcroFields(PdfReader pdfReader, PdfWriter pdfWriter) {
        this.reader = pdfReader;
        this.writer = pdfWriter;
        try {
            this.xfa = new XfaForm(pdfReader);
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
        if (pdfWriter instanceof PdfStamperImp) {
            this.append = ((PdfStamperImp)pdfWriter).isAppend();
        }
        this.fill();
    }

    private static void clearSigDic(PdfDictionary pdfDictionary) {
        pdfDictionary.remove(PdfName.AP);
        pdfDictionary.remove(PdfName.AS);
        pdfDictionary.remove(PdfName.V);
        pdfDictionary.remove(PdfName.DV);
        pdfDictionary.remove(PdfName.SV);
        pdfDictionary.remove(PdfName.FF);
        pdfDictionary.put(PdfName.F, new PdfNumber(4));
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private String[] getListOption(String object, int n) {
        if ((object = this.getFieldItem((String)object)) == null) {
            return null;
        }
        int n2 = 0;
        PdfArray pdfArray = object.getMerged(0).getAsArray(PdfName.OPT);
        if (pdfArray == null) {
            return null;
        }
        String[] arrstring = new String[pdfArray.size()];
        do {
            block7 : {
                if (n2 >= pdfArray.size()) {
                    return arrstring;
                }
                PdfObject pdfObject = pdfArray.getDirectObject(n2);
                object = pdfObject;
                try {
                    if (pdfObject.isArray()) {
                        object = ((PdfArray)pdfObject).getDirectObject(n);
                    }
                    arrstring[n2] = object.isString() ? ((PdfString)object).toUnicodeString() : object.toString();
                    break block7;
                }
                catch (Exception exception) {}
                arrstring[n2] = "";
            }
            ++n2;
        } while (true);
    }

    private void markUsed(PdfObject pdfObject) {
        if (!this.append) {
            return;
        }
        ((PdfStamperImp)this.writer).markUsed(pdfObject);
    }

    private int removeRefFromArray(PdfArray pdfArray, PdfObject pdfObject) {
        if (pdfObject != null && pdfObject.isIndirect()) {
            pdfObject = (PdfIndirectReference)pdfObject;
            int n = 0;
            while (n < pdfArray.size()) {
                int n2;
                PdfObject pdfObject2 = pdfArray.getPdfObject(n);
                if (!pdfObject2.isIndirect()) {
                    n2 = n;
                } else {
                    n2 = n;
                    if (((PdfIndirectReference)pdfObject2).getNumber() == pdfObject.getNumber()) {
                        pdfArray.remove(n);
                        n2 = n - 1;
                    }
                }
                n = n2 + 1;
            }
            return pdfArray.size();
        }
        return pdfArray.size();
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static Object[] splitDAelements(String object) {
        try {
            object = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(PdfEncodings.convertToBytes((String)object, null))));
            ArrayList<String> arrayList = new ArrayList<String>();
            Object[] arrobject = new Object[3];
            while (object.nextToken()) {
                if (object.getTokenType() == PRTokeniser.TokenType.COMMENT) continue;
                if (object.getTokenType() == PRTokeniser.TokenType.OTHER) {
                    String string2 = object.getStringValue();
                    if (string2.equals("Tf")) {
                        if (arrayList.size() >= 2) {
                            arrobject[0] = arrayList.get(arrayList.size() - 2);
                            arrobject[1] = new Float((String)arrayList.get(arrayList.size() - 1));
                        }
                    } else if (string2.equals("g")) {
                        float f;
                        if (arrayList.size() >= 1 && (f = new Float((String)arrayList.get(arrayList.size() - 1)).floatValue()) != 0.0f) {
                            arrobject[2] = new GrayColor(f);
                        }
                    } else if (string2.equals("rg")) {
                        if (arrayList.size() >= 3) {
                            arrobject[2] = new BaseColor(new Float((String)arrayList.get(arrayList.size() - 3)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 2)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 1)).floatValue());
                        }
                    } else if (string2.equals("k") && arrayList.size() >= 4) {
                        arrobject[2] = new CMYKColor(new Float((String)arrayList.get(arrayList.size() - 4)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 3)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 2)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 1)).floatValue());
                    }
                    arrayList.clear();
                    continue;
                }
                arrayList.add(object.getStringValue());
            }
            return arrobject;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void updateByteRange(PdfPKCS7 pdfPKCS7, PdfDictionary object) {
        void var1_7;
        block12 : {
            int n;
            Object object2 = object.getAsArray(PdfName.BYTERANGE);
            RandomAccessFileOrArray randomAccessFileOrArray = this.reader.getSafeFile();
            Object var5_12 = null;
            object = null;
            object2 = new RASInputStream(new RandomAccessSourceFactory().createRanged(randomAccessFileOrArray.createSourceView(), object2.asLongArray()));
            object = new byte[8192];
            while ((n = object2.read((byte[])object, 0, ((Object)object).length)) > 0) {
                pdfPKCS7.update((byte[])object, 0, n);
            }
            if (object2 == null) return;
            try {
                object2.close();
                return;
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
            catch (Throwable throwable) {
                object = object2;
                break block12;
            }
            catch (Exception exception) {
                object = object2;
                throw new ExceptionConverter((Exception)((Object)pdfPKCS7));
            }
            catch (Throwable throwable) {
                break block12;
            }
            catch (Exception exception) {
                object = var5_12;
            }
            {
                throw new ExceptionConverter((Exception)((Object)pdfPKCS7));
            }
        }
        if (object == null) throw var1_7;
        try {
            object.close();
            throw var1_7;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public void addSubstitutionFont(BaseFont baseFont) {
        if (this.substitutionFonts == null) {
            this.substitutionFonts = new ArrayList();
        }
        this.substitutionFonts.add(baseFont);
    }

    public boolean clearSignatureField(String object) {
        this.sigNames = null;
        this.getSignatureNames();
        boolean bl = this.sigNames.containsKey(object);
        if (!bl) {
            return false;
        }
        object = this.fields.get(object);
        object.markUsed(this, 6);
        int n = object.size();
        for (int i = 0; i < n; ++i) {
            AcroFields.clearSigDic(object.getMerged(i));
            AcroFields.clearSigDic(object.getWidget(i));
            AcroFields.clearSigDic(object.getValue(i));
        }
        return true;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void decodeGenericDictionary(PdfDictionary pdfObject, BaseField baseField) throws IOException, DocumentException {
        int n;
        Object object2;
        int n2;
        Object object;
        block36 : {
            Object[] arrobject;
            block41 : {
                block37 : {
                    block39 : {
                        Integer n3;
                        block34 : {
                            block38 : {
                                block40 : {
                                    PdfObject pdfObject2;
                                    object = pdfObject.getAsString(PdfName.DA);
                                    n2 = 0;
                                    if (object == null) break block36;
                                    arrobject = AcroFields.splitDAelements(object.toUnicodeString());
                                    if (arrobject[1] != null) {
                                        baseField.setFontSize(((Float)arrobject[1]).floatValue());
                                    }
                                    if (arrobject[2] != null) {
                                        baseField.setTextColor((BaseColor)arrobject[2]);
                                    }
                                    if (arrobject[0] == null) break block37;
                                    object = pdfObject.getAsDict(PdfName.DR);
                                    if (object == null || (object2 = object.getAsDict(PdfName.FONT)) == null || (pdfObject2 = object2.get(new PdfName((String)arrobject[0]))) == null || pdfObject2.type() != 10) break block38;
                                    object2 = (PRIndirectReference)pdfObject2;
                                    baseField.setFont(new DocumentFont((PRIndirectReference)object2, object.getAsDict(PdfName.ENCODING)));
                                    n3 = object2.getNumber();
                                    object2 = object = this.extensionFonts.get(n3);
                                    if (object != null) break block39;
                                    object2 = object;
                                    if (this.extensionFonts.containsKey(n3)) break block39;
                                    PdfDictionary pdfDictionary = ((PdfDictionary)PdfReader.getPdfObject(pdfObject2)).getAsDict(PdfName.FONTDESCRIPTOR);
                                    object2 = object;
                                    if (pdfDictionary == null) break block39;
                                    pdfObject2 = (PRStream)PdfReader.getPdfObject(pdfDictionary.get(PdfName.FONTFILE2));
                                    object2 = pdfObject2;
                                    if (pdfObject2 == null) {
                                        object2 = (PRStream)PdfReader.getPdfObject(pdfDictionary.get(PdfName.FONTFILE3));
                                    }
                                    if (object2 != null) break block40;
                                    this.extensionFonts.put(n3, null);
                                    object2 = object;
                                    break block39;
                                }
                                try {
                                    object = object2 = BaseFont.createFont("font.ttf", "Identity-H", true, false, PdfReader.getStreamBytes((PRStream)object2), null);
                                    break block34;
                                }
                                catch (Exception exception) {}
                            }
                            n = 1;
                            break block41;
                        }
                        this.extensionFonts.put(n3, (BaseFont)object);
                        object2 = object;
                    }
                    if (baseField instanceof TextField) {
                        ((TextField)baseField).setExtensionFont((BaseFont)object2);
                    }
                }
                n = 0;
            }
            if (n != 0) {
                object = this.localFonts.get(arrobject[0]);
                if (object == null) {
                    object2 = stdFieldFontNames.get(arrobject[0]);
                    if (object2 != null) {
                        block35 : {
                            object = "winansi";
                            if (((String[])object2).length <= 1) break block35;
                            object = object2[1];
                        }
                        baseField.setFont(BaseFont.createFont(object2[0], (String)object, false));
                    }
                } else {
                    baseField.setFont((BaseFont)object);
                }
                break block36;
                catch (Exception exception) {}
            }
        }
        if ((object = pdfObject.getAsDict(PdfName.MK)) != null) {
            object2 = this.getMKColor(object.getAsArray(PdfName.BC));
            baseField.setBorderColor((BaseColor)object2);
            if (object2 != null) {
                baseField.setBorderWidth(1.0f);
            }
            baseField.setBackgroundColor(this.getMKColor(object.getAsArray(PdfName.BG)));
            object = object.getAsNumber(PdfName.R);
            if (object != null) {
                baseField.setRotation(object.intValue());
            }
        }
        object = pdfObject.getAsNumber(PdfName.F);
        baseField.setVisibility(2);
        if (object != null) {
            n = object.intValue();
            int n4 = n & 4;
            if (n4 != 0 && (n & 2) != 0) {
                baseField.setVisibility(1);
            } else if (n4 != 0 && (n & 32) != 0) {
                baseField.setVisibility(3);
            } else if (n4 != 0) {
                baseField.setVisibility(0);
            }
        }
        n = (object = pdfObject.getAsNumber(PdfName.FF)) != null ? object.intValue() : 0;
        baseField.setOptions(n);
        if ((n & 16777216) != 0) {
            object = pdfObject.getAsNumber(PdfName.MAXLEN);
            n = n2;
            if (object != null) {
                n = object.intValue();
            }
            baseField.setMaxCharacterLength(n);
        }
        if ((object = pdfObject.getAsNumber(PdfName.Q)) != null) {
            if (object.intValue() == 1) {
                baseField.setAlignment(1);
            } else if (object.intValue() == 2) {
                baseField.setAlignment(2);
            }
        }
        if ((object = pdfObject.getAsDict(PdfName.BS)) != null) {
            pdfObject = object.getAsNumber(PdfName.W);
            if (pdfObject != null) {
                baseField.setBorderWidth(pdfObject.floatValue());
            }
            if (PdfName.D.equals(pdfObject = object.getAsName(PdfName.S))) {
                baseField.setBorderStyle(1);
                return;
            }
            if (PdfName.B.equals(pdfObject)) {
                baseField.setBorderStyle(2);
                return;
            }
            if (PdfName.I.equals(pdfObject)) {
                baseField.setBorderStyle(3);
                return;
            }
            if (!PdfName.U.equals(pdfObject)) return;
            baseField.setBorderStyle(4);
            return;
        }
        if ((pdfObject = pdfObject.getAsArray(PdfName.BORDER)) == null) return;
        if (pdfObject.size() >= 3) {
            baseField.setBorderWidth(pdfObject.getAsNumber(2).floatValue());
        }
        if (pdfObject.size() < 4) return;
        baseField.setBorderStyle(1);
    }

    public boolean doesSignatureFieldExist(String string2) {
        if (!this.getBlankSignatureNames().contains(string2) && !this.getSignatureNames().contains(string2)) {
            return false;
        }
        return true;
    }

    public void exportAsFdf(FdfWriter fdfWriter) {
        for (Map.Entry<String, Item> entry : this.fields.entrySet()) {
            Object object2 = entry.getValue();
            String object = entry.getKey();
            if (object2.getMerged(0).get(PdfName.V) == null) continue;
            object2 = this.getField(object);
            if (this.lastWasString) {
                fdfWriter.setFieldAsString(object, (String)object2);
                continue;
            }
            fdfWriter.setFieldAsName(object, (String)object2);
        }
    }

    public InputStream extractRevision(String string2) throws IOException {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        if (!this.sigNames.containsKey(string2)) {
            return null;
        }
        int n = this.sigNames.get(string2)[0];
        return new RASInputStream(new WindowRandomAccessSource(this.reader.getSafeFile().createSourceView(), 0L, n));
    }

    void fill() {
        this.fields = new LinkedHashMap<String, Item>();
        PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObjectRelease(this.reader.getCatalog().get(PdfName.ACROFORM));
        if (pdfDictionary == null) {
            return;
        }
        Object object = pdfDictionary.getAsBoolean(PdfName.NEEDAPPEARANCES);
        if (object != null && object.booleanValue()) {
            this.setGenerateAppearances(false);
        } else {
            this.setGenerateAppearances(true);
        }
        PdfArray pdfArray = (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.FIELDS));
        if (pdfArray != null) {
            Item item;
            int n;
            Object object2;
            if (pdfArray.size() == 0) {
                return;
            }
            for (n = 1; n <= this.reader.getNumberOfPages(); ++n) {
                object = this.reader.getPageNRelease(n);
                PdfArray pdfArray2 = (PdfArray)PdfReader.getPdfObjectRelease(object.get(PdfName.ANNOTS), (PdfObject)object);
                if (pdfArray2 == null) continue;
                for (int i = 0; i < pdfArray2.size(); ++i) {
                    PdfDictionary pdfDictionary2 = pdfArray2.getAsDict(i);
                    if (pdfDictionary2 == null) {
                        PdfReader.releaseLastXrefPartial(pdfArray2.getAsIndirectObject(i));
                        continue;
                    }
                    if (!PdfName.WIDGET.equals(pdfDictionary2.getAsName(PdfName.SUBTYPE))) {
                        PdfReader.releaseLastXrefPartial(pdfArray2.getAsIndirectObject(i));
                        continue;
                    }
                    PdfDictionary pdfDictionary3 = new PdfDictionary();
                    pdfDictionary3.putAll(pdfDictionary2);
                    Object object3 = null;
                    item = object3;
                    object2 = "";
                    for (object = pdfDictionary2; object != null; object = object.getAsDict((PdfName)PdfName.PARENT)) {
                        pdfDictionary3.mergeDifferent((PdfDictionary)object);
                        PdfString pdfString = object.getAsString(PdfName.T);
                        Object object4 = object2;
                        if (pdfString != null) {
                            object4 = new StringBuilder();
                            object4.append(pdfString.toUnicodeString());
                            object4.append(".");
                            object4.append((String)object2);
                            object4 = object4.toString();
                        }
                        Object object5 = object3;
                        if (object3 == null) {
                            object5 = object3;
                            if (object.get(PdfName.V) != null) {
                                object5 = PdfReader.getPdfObjectRelease(object.get(PdfName.V));
                            }
                        }
                        Object object6 = item;
                        if (item == null) {
                            object6 = item;
                            if (pdfString != null) {
                                if (object.get(PdfName.V) == null && object5 != null) {
                                    object.put(PdfName.V, (PdfObject)object5);
                                }
                                object6 = object;
                            }
                        }
                        object2 = object4;
                        object3 = object5;
                        item = object6;
                    }
                    if (object2.length() > 0) {
                        object2 = object2.substring(0, object2.length() - 1);
                    }
                    object = object3 = this.fields.get(object2);
                    if (object3 == null) {
                        object = new Item();
                        this.fields.put((String)object2, (Item)object);
                    }
                    if (item == null) {
                        object.addValue(pdfDictionary2);
                    } else {
                        object.addValue((PdfDictionary)((Object)item));
                    }
                    object.addWidget(pdfDictionary2);
                    object.addWidgetRef(pdfArray2.getAsIndirectObject(i));
                    if (pdfDictionary != null) {
                        pdfDictionary3.mergeDifferent(pdfDictionary);
                    }
                    object.addMerged(pdfDictionary3);
                    object.addPage(n);
                    object.addTabOrder(i);
                }
            }
            object = pdfDictionary.getAsNumber(PdfName.SIGFLAGS);
            if (object != null) {
                if ((object.intValue() & 1) != 1) {
                    return;
                }
                for (n = 0; n < pdfArray.size(); ++n) {
                    object2 = pdfArray.getAsDict(n);
                    if (object2 == null) {
                        PdfReader.releaseLastXrefPartial(pdfArray.getAsIndirectObject(n));
                        continue;
                    }
                    if (!PdfName.WIDGET.equals(object2.getAsName(PdfName.SUBTYPE))) {
                        PdfReader.releaseLastXrefPartial(pdfArray.getAsIndirectObject(n));
                        continue;
                    }
                    if ((PdfArray)PdfReader.getPdfObjectRelease(object2.get(PdfName.KIDS)) != null) continue;
                    object = new PdfDictionary();
                    object.putAll((PdfDictionary)object2);
                    object2 = object2.getAsString(PdfName.T);
                    if (object2 == null || this.fields.containsKey(object2 = object2.toUnicodeString())) continue;
                    item = new Item();
                    this.fields.put((String)object2, item);
                    item.addValue((PdfDictionary)object);
                    item.addWidget((PdfDictionary)object);
                    item.addWidgetRef(pdfArray.getAsIndirectObject(n));
                    item.addMerged((PdfDictionary)object);
                    item.addPage(-1);
                    item.addTabOrder(-1);
                }
                return;
            }
            return;
        }
    }

    PdfAppearance getAppearance(PdfDictionary pdfDictionary, String string2, String string3) throws IOException, DocumentException {
        return this.getAppearance(pdfDictionary, new String[]{string2}, string3);
    }

    PdfAppearance getAppearance(PdfDictionary object, String[] object2, String object3) throws IOException, DocumentException {
        String[] arrstring;
        Object object4;
        PdfName pdfName;
        int n;
        String[] arrstring2;
        String[] arrstring3;
        block26 : {
            block28 : {
                block27 : {
                    block25 : {
                        block22 : {
                            RadioCheckField radioCheckField;
                            boolean bl;
                            block24 : {
                                block23 : {
                                    pdfName = object.getAsName(PdfName.FT);
                                    bl = PdfName.BTN.equals(pdfName);
                                    n = 0;
                                    boolean bl2 = false;
                                    if (!bl) break block22;
                                    object2 = object.getAsNumber(PdfName.FF);
                                    bl = bl2;
                                    if (object2 != null) {
                                        bl = bl2;
                                        if ((object2.intValue() & 32768) != 0) {
                                            bl = true;
                                        }
                                    }
                                    radioCheckField = new RadioCheckField(this.writer, null, null, null);
                                    this.decodeGenericDictionary((PdfDictionary)object, radioCheckField);
                                    object3 = PdfReader.getNormalizedRectangle(object.getAsArray(PdfName.RECT));
                                    if (radioCheckField.getRotation() == 90) break block23;
                                    object2 = object3;
                                    if (radioCheckField.getRotation() != 270) break block24;
                                }
                                object2 = object3.rotate();
                            }
                            radioCheckField.setBox((Rectangle)object2);
                            if (!bl) {
                                radioCheckField.setCheckType(3);
                            }
                            return radioCheckField.getAppearance(bl, object.getAsName(PdfName.AS).equals(PdfName.Off) ^ true);
                        }
                        this.topFirst = 0;
                        object4 = ((String[])object2).length > 0 ? object2[0] : null;
                        if (this.fieldCache == null || !this.fieldCache.containsKey(object3)) break block25;
                        object3 = this.fieldCache.get(object3);
                        object3.setWriter(this.writer);
                        break block26;
                    }
                    arrstring = new String[](this.writer, null, null);
                    arrstring.setExtraMargin(this.extraMarginLeft, this.extraMarginTop);
                    arrstring.setBorderWidth(0.0f);
                    arrstring.setSubstitutionFonts(this.substitutionFonts);
                    this.decodeGenericDictionary((PdfDictionary)object, (BaseField)arrstring);
                    arrstring2 = PdfReader.getNormalizedRectangle(object.getAsArray(PdfName.RECT));
                    if (arrstring.getRotation() == 90) break block27;
                    arrstring3 = arrstring2;
                    if (arrstring.getRotation() != 270) break block28;
                }
                arrstring3 = arrstring2.rotate();
            }
            arrstring.setBox((Rectangle)arrstring3);
            if (this.fieldCache != null) {
                this.fieldCache.put((String)object3, (TextField)arrstring);
            }
            object3 = arrstring;
        }
        if (PdfName.TX.equals(pdfName)) {
            if (((Object)object2).length > 0 && object2[0] != null) {
                object3.setText((String)object2[0]);
            }
            return object3.getAppearance();
        }
        if (!PdfName.CH.equals(pdfName)) {
            throw new DocumentException(MessageLocalization.getComposedMessage("an.appearance.was.requested.without.a.variable.text.field", new Object[0]));
        }
        arrstring2 = object.getAsArray(PdfName.OPT);
        int n2 = (object = object.getAsNumber(PdfName.FF)) != null ? object.intValue() : 0;
        int n3 = n2 & 131072;
        if (n3 != 0 && arrstring2 == null) {
            object3.setText((String)object4);
            return object3.getAppearance();
        }
        if (arrstring2 != null) {
            arrstring3 = new String[arrstring2.size()];
            arrstring = new String[arrstring2.size()];
            for (n2 = 0; n2 < arrstring2.size(); ++n2) {
                object = arrstring2.getPdfObject(n2);
                if (object.isString()) {
                    arrstring[n2] = object = ((PdfString)object).toUnicodeString();
                    arrstring3[n2] = object;
                    continue;
                }
                object = (PdfArray)object;
                arrstring[n2] = object.getAsString(0).toUnicodeString();
                arrstring3[n2] = object.getAsString(1).toUnicodeString();
            }
            if (n3 != 0) {
                n2 = n;
                do {
                    object = object4;
                    if (n2 >= arrstring3.length) break;
                    if (object4.equals(arrstring[n2])) {
                        object = arrstring3[n2];
                        break;
                    }
                    ++n2;
                } while (true);
                object3.setText((String)object);
                return object3.getAppearance();
            }
            object = new ArrayList();
            block2 : for (n2 = 0; n2 < arrstring.length; ++n2) {
                for (n = 0; n < ((Object)object2).length; ++n) {
                    object4 = object2[n];
                    if (object4 == null || !object4.equals(arrstring[n2])) continue;
                    object.add(n2);
                    continue block2;
                }
            }
            object3.setChoices(arrstring3);
            object3.setChoiceExports(arrstring);
            object3.setChoiceSelections((ArrayList<Integer>)object);
        }
        object = object3.getListAppearance();
        this.topFirst = object3.getTopFirst();
        return object;
    }

    public String[] getAppearanceStates(String object) {
        int n;
        Item item = this.fields.get(object);
        if (item == null) {
            return null;
        }
        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<String>();
        int n2 = 0;
        object = item.getValue(0);
        PdfObject pdfObject = object.getAsString(PdfName.OPT);
        if (pdfObject != null) {
            linkedHashSet.add(pdfObject.toUnicodeString());
            n = n2;
        } else {
            pdfObject = object.getAsArray(PdfName.OPT);
            n = n2;
            if (pdfObject != null) {
                int n3 = 0;
                do {
                    n = n2;
                    if (n3 >= pdfObject.size()) break;
                    object = pdfObject.getDirectObject(n3);
                    n = object.type();
                    object = n != 3 ? (n != 5 ? null : ((PdfArray)object).getAsString(1)) : (PdfString)object;
                    if (object != null) {
                        linkedHashSet.add(object.toUnicodeString());
                    }
                    ++n3;
                } while (true);
            }
        }
        while (n < item.size()) {
            object = item.getWidget(n).getAsDict(PdfName.AP);
            if (object != null && (object = object.getAsDict(PdfName.N)) != null) {
                object = object.getKeys().iterator();
                while (object.hasNext()) {
                    linkedHashSet.add(PdfName.decodeName(((PdfName)object.next()).toString()));
                }
            }
            ++n;
        }
        return linkedHashSet.toArray(new String[linkedHashSet.size()]);
    }

    public ArrayList<String> getBlankSignatureNames() {
        this.getSignatureNames();
        ArrayList<String> arrayList = new ArrayList<String>();
        for (Map.Entry<String, Item> entry : this.fields.entrySet()) {
            PdfDictionary pdfDictionary = entry.getValue().getMerged(0);
            if (!PdfName.SIG.equals(pdfDictionary.getAsName(PdfName.FT)) || this.sigNames.containsKey(entry.getKey())) continue;
            arrayList.add(entry.getKey());
        }
        return arrayList;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public String getField(String object) {
        if (this.xfa.isXfaPresent()) {
            if ((object = this.xfa.findFieldName((String)object, this)) == null) {
                return null;
            }
            object = XfaForm.Xml2Som.getShortName((String)object);
            return XfaForm.getNodeText(this.xfa.findDatasetsNode((String)object));
        }
        Object object2 = this.fields.get(object);
        if (object2 == null) {
            return null;
        }
        this.lastWasString = false;
        object = object2.getMerged(0);
        PdfObject pdfObject = PdfReader.getPdfObject(object.get(PdfName.V));
        if (pdfObject == null) {
            return "";
        }
        if (pdfObject instanceof PRStream) {
            try {
                return new String(PdfReader.getStreamBytes((PRStream)pdfObject));
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
        }
        PdfName pdfName = object.getAsName(PdfName.FT);
        if (PdfName.BTN.equals(pdfName)) {
            int n = (object = object.getAsNumber(PdfName.FF)) != null ? object.intValue() : 0;
            if ((n & 65536) != 0) {
                return "";
            }
            object = "";
            if (pdfObject instanceof PdfName) {
                object = PdfName.decodeName(pdfObject.toString());
            } else if (pdfObject instanceof PdfString) {
                object = ((PdfString)pdfObject).toUnicodeString();
            }
            pdfObject = object2.getValue(0).getAsArray(PdfName.OPT);
            object2 = object;
            if (pdfObject == null) return object2;
            object2 = pdfObject.getAsString(Integer.parseInt((String)object)).toUnicodeString();
            this.lastWasString = true;
            return object2;
        }
        if (pdfObject instanceof PdfString) {
            this.lastWasString = true;
            return ((PdfString)pdfObject).toUnicodeString();
        }
        if (!(pdfObject instanceof PdfName)) return "";
        return PdfName.decodeName(pdfObject.toString());
        catch (Exception exception) {
            return object;
        }
        catch (Exception exception) {
            return object2;
        }
    }

    public Map<String, TextField> getFieldCache() {
        return this.fieldCache;
    }

    public Item getFieldItem(String string2) {
        String string3 = string2;
        if (this.xfa.isXfaPresent()) {
            string3 = string2 = this.xfa.findFieldName(string2, this);
            if (string2 == null) {
                return null;
            }
        }
        return this.fields.get(string3);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public List<FieldPosition> getFieldPositions(String object) {
        Item item = this.getFieldItem((String)object);
        if (item == null) {
            return null;
        }
        ArrayList<FieldPosition> arrayList = new ArrayList<FieldPosition>();
        int n = 0;
        while (n < item.size()) {
            try {
                object = item.getWidget(n).getAsArray(PdfName.RECT);
                if (object != null) {
                    object = PdfReader.getNormalizedRectangle((PdfArray)object);
                    int n2 = item.getPage(n);
                    int n3 = this.reader.getPageRotation(n2);
                    FieldPosition fieldPosition = new FieldPosition();
                    fieldPosition.page = n2;
                    Object object2 = object;
                    if (n3 != 0) {
                        object2 = this.reader.getPageSize(n2);
                        if (n3 != 90) {
                            if (n3 != 180) {
                                if (n3 == 270) {
                                    object = new Rectangle(object2.getTop() - object.getBottom(), object.getLeft(), object2.getTop() - object.getTop(), object.getRight());
                                }
                            } else {
                                object = new Rectangle(object2.getRight() - object.getLeft(), object2.getTop() - object.getBottom(), object2.getRight() - object.getRight(), object2.getTop() - object.getTop());
                            }
                        } else {
                            object = new Rectangle(object.getBottom(), object2.getRight() - object.getLeft(), object.getTop(), object2.getRight() - object.getRight());
                        }
                        object.normalize();
                        object2 = object;
                    }
                    fieldPosition.position = object2;
                    arrayList.add(fieldPosition);
                }
            }
            catch (Exception exception) {}
            ++n;
        }
        return arrayList;
    }

    public String getFieldRichValue(String object) {
        boolean bl = this.xfa.isXfaPresent();
        Object var3_3 = null;
        if (bl) {
            return null;
        }
        if ((object = this.fields.get(object)) == null) {
            return null;
        }
        PdfString pdfString = object.getMerged(0).getAsString(PdfName.RV);
        object = var3_3;
        if (pdfString != null) {
            object = pdfString.toString();
        }
        return object;
    }

    public int getFieldType(String object) {
        if ((object = this.getFieldItem((String)object)) == null) {
            return 0;
        }
        PdfObject pdfObject = object.getMerged(0);
        object = pdfObject.getAsName(PdfName.FT);
        if (object == null) {
            return 0;
        }
        int n = (pdfObject = pdfObject.getAsNumber(PdfName.FF)) != null ? pdfObject.intValue() : 0;
        if (PdfName.BTN.equals(object)) {
            if ((65536 & n) != 0) {
                return 1;
            }
            if ((n & 32768) != 0) {
                return 3;
            }
            return 2;
        }
        if (PdfName.TX.equals(object)) {
            return 4;
        }
        if (PdfName.CH.equals(object)) {
            if ((n & 131072) != 0) {
                return 6;
            }
            return 5;
        }
        if (PdfName.SIG.equals(object)) {
            return 7;
        }
        return 0;
    }

    public Map<String, Item> getFields() {
        return this.fields;
    }

    public String[] getListOptionDisplay(String string2) {
        return this.getListOption(string2, 1);
    }

    public String[] getListOptionExport(String string2) {
        return this.getListOption(string2, 0);
    }

    public String[] getListSelection(String arrstring) {
        String[] arrstring2 = this.getField((String)arrstring);
        int n = 0;
        arrstring2 = arrstring2 == null ? new String[]{} : new String[]{arrstring2};
        Object object = this.fields.get(arrstring);
        if (object == null) {
            return arrstring2;
        }
        if ((object = object.getMerged(0).getAsArray(PdfName.I)) == null) {
            return arrstring2;
        }
        arrstring2 = new String[object.size()];
        arrstring = this.getListOptionExport((String)arrstring);
        object = object.listIterator();
        while (object.hasNext()) {
            arrstring2[n] = arrstring[((PdfNumber)object.next()).intValue()];
            ++n;
        }
        return arrstring2;
    }

    BaseColor getMKColor(PdfArray pdfArray) {
        if (pdfArray == null) {
            return null;
        }
        int n = pdfArray.size();
        if (n != 1) {
            switch (n) {
                default: {
                    return null;
                }
                case 4: {
                    return new CMYKColor(pdfArray.getAsNumber(0).floatValue(), pdfArray.getAsNumber(1).floatValue(), pdfArray.getAsNumber(2).floatValue(), pdfArray.getAsNumber(3).floatValue());
                }
                case 3: 
            }
            return new BaseColor(ExtendedColor.normalize(pdfArray.getAsNumber(0).floatValue()), ExtendedColor.normalize(pdfArray.getAsNumber(1).floatValue()), ExtendedColor.normalize(pdfArray.getAsNumber(2).floatValue()));
        }
        return new GrayColor(pdfArray.getAsNumber(0).floatValue());
    }

    public PushbuttonField getNewPushbuttonFromField(String string2) {
        return this.getNewPushbuttonFromField(string2, 0);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public PushbuttonField getNewPushbuttonFromField(String object, int n) {
        try {
            if (this.getFieldType((String)object) != 1) {
                return null;
            }
            Object object2 = this.getFieldItem((String)object);
            if (n >= object2.size()) {
                return null;
            }
            object = this.getFieldPositions((String)object).get((int)n).position;
            object = new PushbuttonField(this.writer, (Rectangle)object, null);
            object2 = object2.getMerged(n);
            this.decodeGenericDictionary((PdfDictionary)object2, (BaseField)object);
            object2 = object2.getAsDict(PdfName.MK);
            if (object2 != null) {
                PdfObject pdfObject = object2.getAsString(PdfName.CA);
                if (pdfObject != null) {
                    object.setText(pdfObject.toUnicodeString());
                }
                if ((pdfObject = object2.getAsNumber(PdfName.TP)) != null) {
                    object.setLayout(pdfObject.intValue() + 1);
                }
                if ((pdfObject = object2.getAsDict(PdfName.IF)) != null) {
                    PdfObject pdfObject2 = pdfObject.getAsName(PdfName.SW);
                    if (pdfObject2 != null) {
                        n = pdfObject2.equals(PdfName.B) ? 3 : (pdfObject2.equals(PdfName.S) ? 4 : (pdfObject2.equals(PdfName.N) ? 2 : 1));
                        object.setScaleIcon(n);
                    }
                    if ((pdfObject2 = pdfObject.getAsName(PdfName.S)) != null && pdfObject2.equals(PdfName.A)) {
                        object.setProportionalIcon(false);
                    }
                    if ((pdfObject2 = pdfObject.getAsArray(PdfName.A)) != null && pdfObject2.size() == 2) {
                        float f = pdfObject2.getAsNumber(0).floatValue();
                        float f2 = pdfObject2.getAsNumber(1).floatValue();
                        object.setIconHorizontalAdjustment(f);
                        object.setIconVerticalAdjustment(f2);
                    }
                    if ((pdfObject = pdfObject.getAsBoolean(PdfName.FB)) != null && pdfObject.booleanValue()) {
                        object.setIconFitToBounds(true);
                    }
                }
                if ((object2 = object2.get(PdfName.I)) != null && object2.isIndirect()) {
                    object.setIconReference((PRIndirectReference)object2);
                }
            }
            return object;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public PdfIndirectReference getNormalAppearance(String object) {
        this.getSignatureNames();
        object = this.getTranslatedFieldName((String)object);
        object = this.fields.get(object);
        if (object == null) {
            return null;
        }
        if ((object = object.getMerged(0).getAsDict(PdfName.AP)) == null) {
            return null;
        }
        if ((object = object.getAsIndirectObject(PdfName.N)) == null) {
            return null;
        }
        return object;
    }

    public int getRevision(String string2) {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        if (!this.sigNames.containsKey(string2)) {
            return 0;
        }
        return this.sigNames.get(string2)[1];
    }

    public PdfDictionary getSignatureDictionary(String string2) {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        if (!this.sigNames.containsKey(string2)) {
            return null;
        }
        return this.fields.get(string2).getMerged(0).getAsDict(PdfName.V);
    }

    public ArrayList<String> getSignatureNames() {
        int n;
        if (this.sigNames != null) {
            return new ArrayList<String>(this.orderedSignatureNames);
        }
        this.sigNames = new HashMap();
        this.orderedSignatureNames = new ArrayList();
        ArrayList<Object[]> arrayList = new ArrayList<Object[]>();
        for (Map.Entry<String, Item> arrobject : this.fields.entrySet()) {
            int n2;
            PdfObject pdfObject = arrobject.getValue().getMerged(0);
            if (!PdfName.SIG.equals(pdfObject.get(PdfName.FT)) || (pdfObject = pdfObject.getAsDict(PdfName.V)) == null || pdfObject.getAsString(PdfName.CONTENTS) == null || (pdfObject = pdfObject.getAsArray(PdfName.BYTERANGE)) == null || (n2 = pdfObject.size()) < 2) continue;
            n = pdfObject.getAsNumber(n2 - 1).intValue();
            n2 = pdfObject.getAsNumber(n2 - 2).intValue();
            arrayList.add(new Object[]{arrobject.getKey(), new int[]{n + n2, 0}});
        }
        Collections.sort(arrayList, new SorterComparator());
        if (!arrayList.isEmpty()) {
            this.totalRevisions = (long)((int[])((Object[])arrayList.get(arrayList.size() - 1))[1])[0] == this.reader.getFileLength() ? arrayList.size() : arrayList.size() + 1;
            n = 0;
            while (n < arrayList.size()) {
                Object[] arrobject = (Object[])arrayList.get(n);
                String string2 = (String)arrobject[0];
                int[] arrn = (int[])arrobject[1];
                arrn[1] = ++n;
                this.sigNames.put(string2, arrn);
                this.orderedSignatureNames.add(string2);
            }
        }
        return new ArrayList<String>(this.orderedSignatureNames);
    }

    public ArrayList<BaseFont> getSubstitutionFonts() {
        return this.substitutionFonts;
    }

    public int getTotalRevisions() {
        this.getSignatureNames();
        return this.totalRevisions;
    }

    public String getTranslatedFieldName(String string2) {
        String string3 = string2;
        if (this.xfa.isXfaPresent()) {
            String string4 = this.xfa.findFieldName(string2, this);
            string3 = string2;
            if (string4 != null) {
                string3 = string4;
            }
        }
        return string3;
    }

    public XfaForm getXfa() {
        return this.xfa;
    }

    public boolean isGenerateAppearances() {
        return this.generateAppearances;
    }

    boolean isInAP(PdfDictionary pdfDictionary, PdfName pdfName) {
        if (pdfDictionary != null && pdfDictionary.get(pdfName) != null) {
            return true;
        }
        return false;
    }

    public void mergeXfaData(Node object) throws IOException, DocumentException {
        object = new XfaForm.Xml2SomDatasets((Node)object);
        for (String string2 : object.getOrder()) {
            this.setField(string2, XfaForm.getNodeText(object.getName2Node().get(string2)));
        }
    }

    public boolean regenerateField(String string2) throws IOException, DocumentException {
        String string3 = this.getField(string2);
        return this.setField(string2, string3, string3);
    }

    public boolean removeField(String string2) {
        return this.removeField(string2, -1);
    }

    public boolean removeField(String string2, int n) {
        Item item = this.getFieldItem(string2);
        int n2 = 0;
        if (item == null) {
            return false;
        }
        PdfObject pdfObject = (PdfDictionary)PdfReader.getPdfObject(this.reader.getCatalog().get(PdfName.ACROFORM), this.reader.getCatalog());
        if (pdfObject == null) {
            return false;
        }
        PdfArray pdfArray = pdfObject.getAsArray(PdfName.FIELDS);
        if (pdfArray == null) {
            return false;
        }
        while (n2 < item.size()) {
            int n3 = item.getPage(n2);
            if (n != -1 && n != n3) {
                n3 = n2;
            } else {
                PdfIndirectReference pdfIndirectReference = item.getWidgetRef(n2);
                PdfDictionary pdfDictionary = item.getWidget(n2);
                PdfDictionary pdfDictionary2 = this.reader.getPageN(n3);
                pdfObject = pdfDictionary2 != null ? pdfDictionary2.getAsArray(PdfName.ANNOTS) : null;
                if (pdfObject != null) {
                    if (this.removeRefFromArray((PdfArray)pdfObject, pdfIndirectReference) == 0) {
                        pdfDictionary2.remove(PdfName.ANNOTS);
                        this.markUsed(pdfDictionary2);
                    } else {
                        this.markUsed(pdfObject);
                    }
                }
                PdfReader.killIndirect(pdfIndirectReference);
                pdfObject = pdfIndirectReference;
                while ((pdfIndirectReference = pdfDictionary.getAsIndirectObject(PdfName.PARENT)) != null && this.removeRefFromArray((pdfDictionary = pdfDictionary.getAsDict(PdfName.PARENT)).getAsArray(PdfName.KIDS), pdfObject) == 0) {
                    PdfReader.killIndirect(pdfIndirectReference);
                    pdfObject = pdfIndirectReference;
                }
                if (pdfIndirectReference == null) {
                    this.removeRefFromArray(pdfArray, pdfObject);
                    this.markUsed(pdfArray);
                }
                n3 = n2;
                if (n != -1) {
                    item.remove(n2);
                    n3 = n2 - 1;
                }
            }
            n2 = n3 + 1;
        }
        if (n == -1 || item.size() == 0) {
            this.fields.remove(string2);
        }
        return true;
    }

    public boolean removeFieldsFromPage(int n) {
        if (n < 1) {
            return false;
        }
        String[] arrstring = new String[this.fields.size()];
        this.fields.keySet().toArray(arrstring);
        boolean bl = false;
        for (int i = 0; i < arrstring.length; ++i) {
            boolean bl2 = this.removeField(arrstring[i], n);
            if (!bl && !bl2) {
                bl = false;
                continue;
            }
            bl = true;
        }
        return bl;
    }

    public void removeXfa() {
        this.reader.getCatalog().getAsDict(PdfName.ACROFORM).remove(PdfName.XFA);
        try {
            this.xfa = new XfaForm(this.reader);
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public boolean renameField(String string2, String string3) {
        int n;
        int n2 = string2.lastIndexOf(46) + 1;
        if (n2 != (n = string3.lastIndexOf(46) + 1)) {
            return false;
        }
        if (!string2.substring(0, n2).equals(string3.substring(0, n))) {
            return false;
        }
        if (this.fields.containsKey(string3)) {
            return false;
        }
        Item item = this.fields.get(string2);
        if (item == null) {
            return false;
        }
        string3 = string3.substring(n);
        PdfString pdfString = new PdfString(string3, "UnicodeBig");
        item.writeToAll(PdfName.T, pdfString, 5);
        item.markUsed(this, 4);
        this.fields.remove(string2);
        this.fields.put(string3, item);
        return true;
    }

    public boolean replacePushbuttonField(String string2, PdfFormField pdfFormField) {
        return this.replacePushbuttonField(string2, pdfFormField, 0);
    }

    public boolean replacePushbuttonField(String object, PdfFormField pdfFormField, int n) {
        int n2 = this.getFieldType((String)object);
        int n3 = 0;
        if (n2 != 1) {
            return false;
        }
        Object object2 = this.getFieldItem((String)object);
        if (n >= object2.size()) {
            return false;
        }
        object = object2.getMerged(n);
        PdfDictionary pdfDictionary = object2.getValue(n);
        object2 = object2.getWidget(n);
        for (n = n3; n < buttonRemove.length; ++n) {
            object.remove(buttonRemove[n]);
            pdfDictionary.remove(buttonRemove[n]);
            object2.remove(buttonRemove[n]);
        }
        for (PdfName pdfName : pdfFormField.getKeys()) {
            if (pdfName.equals(PdfName.T)) continue;
            if (pdfName.equals(PdfName.FF)) {
                pdfDictionary.put(pdfName, pdfFormField.get(pdfName));
            } else {
                object2.put(pdfName, pdfFormField.get(pdfName));
            }
            object.put(pdfName, pdfFormField.get(pdfName));
            this.markUsed(pdfDictionary);
            this.markUsed((PdfObject)object2);
        }
        return true;
    }

    public void setExtraMargin(float f, float f2) {
        this.extraMarginLeft = f;
        this.extraMarginTop = f2;
    }

    public boolean setField(String string2, String string3) throws IOException, DocumentException {
        return this.setField(string2, string3, null);
    }

    public boolean setField(String string2, String string3, String string4) throws IOException, DocumentException {
        return this.setField(string2, string3, string4, false);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public boolean setField(String object, String object2, String object3, boolean bl) throws IOException, DocumentException {
        PdfObject pdfObject;
        Object object5;
        Object object4;
        int n;
        Object object6;
        int n2;
        block26 : {
            PdfObject pdfObject2;
            block27 : {
                block28 : {
                    object6 = this.writer;
                    n2 = 0;
                    if (object6 == null) {
                        throw new DocumentException(MessageLocalization.getComposedMessage("this.acrofields.instance.is.read.only", new Object[0]));
                    }
                    object6 = object;
                    if (this.xfa.isXfaPresent()) {
                        object6 = this.xfa.findFieldName((String)object, this);
                        if (object6 == null) {
                            return false;
                        }
                        object5 = XfaForm.Xml2Som.getShortName((String)object6);
                        object = object4 = this.xfa.findDatasetsNode((String)object5);
                        if (object4 == null) {
                            object = this.xfa.getDatasetsSom().insertNode(this.xfa.getDatasetsNode(), (String)object5);
                        }
                        this.xfa.setNodeText((Node)object, (String)object2);
                    }
                    if ((object4 = this.fields.get(object6)) == null) {
                        return false;
                    }
                    pdfObject = object4.getMerged(0);
                    object5 = pdfObject.getAsName(PdfName.FT);
                    object = object2;
                    if (PdfName.TX.equals(object5)) {
                        object = pdfObject.getAsNumber(PdfName.MAXLEN);
                        n = object != null ? object.intValue() : 0;
                        object = object2;
                        if (n > 0) {
                            object = object2.substring(0, Math.min(n, object2.length()));
                        }
                    }
                    object2 = object3;
                    if (object3 == null) {
                        object2 = object;
                    }
                    if (PdfName.TX.equals(object5) || PdfName.CH.equals(object5)) break block26;
                    if (!PdfName.BTN.equals(object5)) return false;
                    object3 = object4.getMerged(0).getAsNumber(PdfName.FF);
                    n = object3 != null ? object3.intValue() : 0;
                    if ((n & 65536) != 0) {
                        object = Image.getInstance(Base64.decode((String)object));
                        object2 = this.getNewPushbuttonFromField((String)object6);
                        object2.setImage((Image)object);
                        this.replacePushbuttonField((String)object6, object2.getField());
                        return true;
                    }
                    object3 = new PdfName((String)object);
                    object5 = new ArrayList<String>();
                    pdfObject = object4.getValue(0).getAsArray(PdfName.OPT);
                    if (pdfObject == null) break block27;
                    break block28;
                    catch (Exception exception) {
                        return false;
                    }
                }
                for (n = 0; n < pdfObject.size(); ++n) {
                    pdfObject2 = pdfObject.getAsString(n);
                    if (pdfObject2 != null) {
                        object5.add(pdfObject2.toUnicodeString());
                        continue;
                    }
                    object5.add(null);
                }
            }
            n = object5.indexOf(object);
            object = object3;
            if (n >= 0) {
                object = new PdfName(String.valueOf(n));
            }
            n = 0;
            while (n < object4.size()) {
                object3 = object4.getMerged(n);
                object5 = object4.getWidget(n);
                pdfObject = object4.getValue(n);
                this.markUsed(object4.getValue(n));
                pdfObject.put(PdfName.V, (PdfObject)object);
                object3.put(PdfName.V, (PdfObject)object);
                this.markUsed((PdfObject)object5);
                pdfObject = object5.getAsDict(PdfName.AP);
                if (pdfObject == null) {
                    return false;
                }
                pdfObject2 = pdfObject.getAsDict(PdfName.N);
                if (!this.isInAP((PdfDictionary)pdfObject2, (PdfName)object) && pdfObject2 != null) {
                    object3.put(PdfName.AS, PdfName.Off);
                    object5.put(PdfName.AS, PdfName.Off);
                } else {
                    object3.put(PdfName.AS, (PdfObject)object);
                    object5.put(PdfName.AS, (PdfObject)object);
                }
                if (this.generateAppearances && !bl) {
                    object5 = this.getAppearance((PdfDictionary)object3, (String)object2, (String)object6);
                    if (pdfObject2 != null) {
                        pdfObject2.put(object3.getAsName(PdfName.AS), object5.getIndirectReference());
                    } else {
                        pdfObject.put(PdfName.N, object5.getIndirectReference());
                    }
                    this.writer.releaseTemplate((PdfTemplate)object5);
                }
                ++n;
            }
            return true;
        }
        pdfObject = new PdfString((String)object, "UnicodeBig");
        n = n2;
        while (n < object4.size()) {
            object = object4.getValue(n);
            object.put(PdfName.V, pdfObject);
            object.remove(PdfName.I);
            this.markUsed((PdfObject)object);
            PdfDictionary pdfDictionary = object4.getMerged(n);
            pdfDictionary.remove(PdfName.I);
            pdfDictionary.put(PdfName.V, pdfObject);
            PdfDictionary pdfDictionary2 = object4.getWidget(n);
            if (this.generateAppearances) {
                PdfAppearance pdfAppearance = this.getAppearance(pdfDictionary, (String)object2, (String)object6);
                if (PdfName.CH.equals(object5)) {
                    object = new PdfNumber(this.topFirst);
                    pdfDictionary2.put(PdfName.TI, (PdfObject)object);
                    pdfDictionary.put(PdfName.TI, (PdfObject)object);
                }
                object = object3 = pdfDictionary2.getAsDict(PdfName.AP);
                if (object3 == null) {
                    object = new PdfDictionary();
                    pdfDictionary2.put(PdfName.AP, (PdfObject)object);
                    pdfDictionary.put(PdfName.AP, (PdfObject)object);
                }
                object.put(PdfName.N, pdfAppearance.getIndirectReference());
                this.writer.releaseTemplate(pdfAppearance);
            } else {
                pdfDictionary2.remove(PdfName.AP);
                pdfDictionary.remove(PdfName.AP);
            }
            this.markUsed(pdfDictionary2);
            ++n;
        }
        return true;
    }

    public boolean setField(String string2, String string3, boolean bl) throws IOException, DocumentException {
        return this.setField(string2, string3, null, bl);
    }

    public void setFieldCache(Map<String, TextField> map) {
        this.fieldCache = map;
    }

    public boolean setFieldProperty(String object, String object2, int n, int[] object3) {
        block15 : {
            block10 : {
                Object object4;
                int n2;
                int n3;
                block14 : {
                    block13 : {
                        block12 : {
                            block11 : {
                                block9 : {
                                    object4 = this.writer;
                                    n3 = 0;
                                    n2 = 0;
                                    if (object4 == null) {
                                        throw new RuntimeException(MessageLocalization.getComposedMessage("this.acrofields.instance.is.read.only", new Object[0]));
                                    }
                                    if ((object = this.fields.get(object)) == null) {
                                        return false;
                                    }
                                    object3 = new InstHit((int[])object3);
                                    if (!object2.equalsIgnoreCase("flags")) break block9;
                                    object2 = new PdfNumber(n);
                                    for (n = n2; n < object.size(); ++n) {
                                        if (!object3.isHit(n)) continue;
                                        object.getMerged(n).put(PdfName.F, (PdfObject)object2);
                                        object.getWidget(n).put(PdfName.F, (PdfObject)object2);
                                        this.markUsed(object.getWidget(n));
                                    }
                                    break block10;
                                }
                                if (!object2.equalsIgnoreCase("setflags")) break block11;
                                for (n2 = 0; n2 < object.size(); ++n2) {
                                    if (!object3.isHit(n2)) continue;
                                    object2 = object.getWidget(n2).getAsNumber(PdfName.F);
                                    n3 = object2 != null ? object2.intValue() : 0;
                                    object2 = new PdfNumber(n3 | n);
                                    object.getMerged(n2).put(PdfName.F, (PdfObject)object2);
                                    object.getWidget(n2).put(PdfName.F, (PdfObject)object2);
                                    this.markUsed(object.getWidget(n2));
                                }
                                break block10;
                            }
                            if (!object2.equalsIgnoreCase("clrflags")) break block12;
                            for (n2 = 0; n2 < object.size(); ++n2) {
                                if (!object3.isHit(n2)) continue;
                                object2 = object.getWidget(n2);
                                object4 = object2.getAsNumber(PdfName.F);
                                n3 = object4 != null ? object4.intValue() : 0;
                                object4 = new PdfNumber(n3 & ~ n);
                                object.getMerged(n2).put(PdfName.F, (PdfObject)object4);
                                object2.put(PdfName.F, (PdfObject)object4);
                                this.markUsed((PdfObject)object2);
                            }
                            break block10;
                        }
                        if (!object2.equalsIgnoreCase("fflags")) break block13;
                        object2 = new PdfNumber(n);
                        for (n = n3; n < object.size(); ++n) {
                            if (!object3.isHit(n)) continue;
                            object.getMerged(n).put(PdfName.FF, (PdfObject)object2);
                            object.getValue(n).put(PdfName.FF, (PdfObject)object2);
                            this.markUsed(object.getValue(n));
                        }
                        break block10;
                    }
                    if (!object2.equalsIgnoreCase("setfflags")) break block14;
                    for (n2 = 0; n2 < object.size(); ++n2) {
                        if (!object3.isHit(n2)) continue;
                        object2 = object.getValue(n2);
                        object4 = object2.getAsNumber(PdfName.FF);
                        n3 = object4 != null ? object4.intValue() : 0;
                        object4 = new PdfNumber(n3 | n);
                        object.getMerged(n2).put(PdfName.FF, (PdfObject)object4);
                        object2.put(PdfName.FF, (PdfObject)object4);
                        this.markUsed((PdfObject)object2);
                    }
                    break block10;
                }
                if (object2.equalsIgnoreCase("clrfflags")) {
                    for (n2 = 0; n2 < object.size(); ++n2) {
                        if (!object3.isHit(n2)) continue;
                        object2 = object.getValue(n2);
                        object4 = object2.getAsNumber(PdfName.FF);
                        n3 = object4 != null ? object4.intValue() : 0;
                        object4 = new PdfNumber(n3 & ~ n);
                        object.getMerged(n2).put(PdfName.FF, (PdfObject)object4);
                        object2.put(PdfName.FF, (PdfObject)object4);
                        this.markUsed((PdfObject)object2);
                    }
                }
                break block15;
            }
            return true;
        }
        return false;
    }

    /*
     * Unable to fully structure code
     */
    public boolean setFieldProperty(String var1_1, String var2_3, Object var3_4, int[] var4_5) {
        block39 : {
            block38 : {
                block37 : {
                    block34 : {
                        block35 : {
                            block36 : {
                                block33 : {
                                    if (this.writer == null) {
                                        throw new RuntimeException(MessageLocalization.getComposedMessage("this.acrofields.instance.is.read.only", new Object[0]));
                                    }
                                    var8_6 = this.fields.get(var1_1);
                                    if (var8_6 != null) break block33;
                                    return false;
                                }
                                var9_7 = new InstHit((int[])var4_5);
                                if (!var2_3.equalsIgnoreCase("textfont")) ** GOTO lbl80
                                var5_8 = 0;
lbl13: // 3 sources:
                                if (var5_8 >= var8_6.size()) break block34;
                                if (!var9_7.isHit(var5_8)) break block35;
                                var2_3 = var8_6.getMerged(var5_8);
                                var6_12 = var2_3.getAsString(PdfName.DA);
                                var1_1 = var2_3.getAsDict(PdfName.DR);
                                if (var6_12 == null) break block35;
                                var4_5 = var1_1;
                                if (var1_1 != null) ** GOTO lbl24
                                var4_5 = new PdfDictionary();
                                var2_3.put(PdfName.DR, (PdfObject)var4_5);
lbl24: // 2 sources:
                                var10_14 = AcroFields.splitDAelements(var6_12.toUnicodeString());
                                var11_15 = new PdfAppearance();
                                if (var10_14[0] == null) break block35;
                                var12_16 = (BaseFont)var3_4;
                                var1_1 = var2_3 = PdfAppearance.stdFieldFontNames.get(var12_16.getPostscriptFontName());
                                if (var2_3 != null) ** GOTO lbl33
                                var1_1 = new PdfName(var12_16.getPostscriptFontName());
lbl33: // 2 sources:
                                var2_3 = var6_12 = var4_5.getAsDict(PdfName.FONT);
                                if (var6_12 != null) ** GOTO lbl38
                                var2_3 = new PdfDictionary();
                                var4_5.put(PdfName.FONT, (PdfObject)var2_3);
lbl38: // 2 sources:
                                var13_17 = (PdfIndirectReference)var2_3.get((PdfName)var1_1);
                                var7_13 = this.reader.getCatalog().getAsDict(PdfName.ACROFORM);
                                this.markUsed(var7_13);
                                var6_12 = var4_5 = var7_13.getAsDict(PdfName.DR);
                                if (var4_5 != null) ** GOTO lbl46
                                var6_12 = new PdfDictionary();
                                var7_13.put(PdfName.DR, (PdfObject)var6_12);
lbl46: // 2 sources:
                                this.markUsed((PdfObject)var6_12);
                                var7_13 = var6_12.getAsDict(PdfName.FONT);
                                var4_5 = var7_13;
                                if (var7_13 != null) ** GOTO lbl53
                                var4_5 = new PdfDictionary();
                                var6_12.put(PdfName.FONT, (PdfObject)var4_5);
lbl53: // 2 sources:
                                this.markUsed((PdfObject)var4_5);
                                var6_12 = (PdfIndirectReference)var4_5.get((PdfName)var1_1);
                                if (var6_12 == null) break block36;
                                ** if (var13_17 != null) goto lbl59
lbl-1000: // 1 sources:
                                {
                                    var2_3.put((PdfName)var1_1, (PdfObject)var6_12);
                                }
lbl59: // 2 sources:
                                ** GOTO lbl71
                            }
                            if (var13_17 != null) ** GOTO lbl71
                            if (var12_16.getFontType() == 4) {
                                var6_12 = new FontDetails(null, ((DocumentFont)var12_16).getIndirectReference(), var12_16);
                            } else {
                                var12_16.setSubset(false);
                                var6_12 = this.writer.addSimple(var12_16);
                                this.localFonts.put(var1_1.toString().substring(1), var12_16);
                            }
                            var4_5.put((PdfName)var1_1, var6_12.getIndirectReference());
                            var2_3.put((PdfName)var1_1, var6_12.getIndirectReference());
lbl71: // 3 sources:
                            var11_15.getInternalBuffer().append(var1_1.getBytes()).append(' ').append(((Float)var10_14[1]).floatValue()).append(" Tf ");
                            if (var10_14[2] == null) ** GOTO lbl75
                            var11_15.setColorFill((BaseColor)var10_14[2]);
lbl75: // 2 sources:
                            var1_1 = new PdfString(var11_15.toString());
                            var8_6.getMerged(var5_8).put(PdfName.DA, (PdfObject)var1_1);
                            var8_6.getWidget(var5_8).put(PdfName.DA, (PdfObject)var1_1);
                            this.markUsed(var8_6.getWidget(var5_8));
                            break block35;
lbl80: // 1 sources:
                            if (!var2_3.equalsIgnoreCase("textcolor")) ** GOTO lbl-1000
                            var5_9 = 0;
lbl83: // 3 sources:
                            if (var5_9 >= var8_6.size()) break block34;
                            ** if (!var9_7.isHit((int)var5_9) || (var1_1 = var8_6.getMerged((int)var5_9).getAsString((PdfName)PdfName.DA)) == null) goto lbl-1000
lbl-1000: // 1 sources:
                            {
                                var1_1 = AcroFields.splitDAelements(var1_1.toUnicodeString());
                                var2_3 = new PdfAppearance();
                                if (var1_1[0] != null) {
                                    var2_3.getInternalBuffer().append(new PdfName((String)var1_1[0]).getBytes()).append(' ').append(((Float)var1_1[1]).floatValue()).append(" Tf ");
                                    var2_3.setColorFill((BaseColor)var3_4);
                                    var1_1 = new PdfString(var2_3.toString());
                                    var8_6.getMerged(var5_9).put(PdfName.DA, (PdfObject)var1_1);
                                    var8_6.getWidget(var5_9).put(PdfName.DA, (PdfObject)var1_1);
                                    this.markUsed(var8_6.getWidget(var5_9));
                                }
                            }
lbl-1000: // 4 sources:
                            {
                                break block37;
                            }
lbl-1000: // 1 sources:
                            {
                                if (!var2_3.equalsIgnoreCase("textsize")) ** GOTO lbl116
                                var5_10 = 0;
                            }
lbl100: // 3 sources:
                            if (var5_10 >= var8_6.size()) break block34;
                            if (!var9_7.isHit(var5_10) || (var1_1 = var8_6.getMerged(var5_10).getAsString(PdfName.DA)) == null) break block38;
                            var1_1 = AcroFields.splitDAelements(var1_1.toUnicodeString());
                            var2_3 = new PdfAppearance();
                            if (var1_1[0] == null) break block38;
                            var2_3.getInternalBuffer().append(new PdfName((String)var1_1[0]).getBytes()).append(' ').append(((Float)var3_4).floatValue()).append(" Tf ");
                            if (var1_1[2] == null) ** GOTO lbl111
                            var2_3.setColorFill((BaseColor)var1_1[2]);
lbl111: // 2 sources:
                            var1_1 = new PdfString(var2_3.toString());
                            var8_6.getMerged(var5_10).put(PdfName.DA, (PdfObject)var1_1);
                            var8_6.getWidget(var5_10).put(PdfName.DA, (PdfObject)var1_1);
                            this.markUsed(var8_6.getWidget(var5_10));
                            break block38;
lbl116: // 1 sources:
                            if (!var2_3.equalsIgnoreCase("bgcolor") && !var2_3.equalsIgnoreCase("bordercolor")) break block39;
                            var1_1 = var2_3.equalsIgnoreCase("bgcolor") != false ? PdfName.BG : PdfName.BC;
                            for (var5_11 = 0; var5_11 < var8_6.size(); ++var5_11) {
                                if (!var9_7.isHit(var5_11)) continue;
                                var2_3 = var8_6.getMerged(var5_11).getAsDict(PdfName.MK);
                                if (var2_3 != null) ** GOTO lbl133
                                if (var3_4 != null) ** break block40
                                return true;
                            }
                            break block34;
                            {
                                block41 : {
                                    
                                    var2_3 = new PdfDictionary();
                                    var8_6.getMerged(var5_11).put(PdfName.MK, (PdfObject)var2_3);
                                    var8_6.getWidget(var5_11).put(PdfName.MK, (PdfObject)var2_3);
                                    this.markUsed(var8_6.getWidget(var5_11));
                                    break block41;
lbl133: // 1 sources:
                                    this.markUsed((PdfObject)var2_3);
                                }
                                if (var3_4 != null) ** GOTO lbl139
                                try {
                                    var2_3.remove((PdfName)var1_1);
                                    continue;
lbl139: // 1 sources:
                                    var2_3.put((PdfName)var1_1, PdfFormField.getMKColor((BaseColor)var3_4));
                                }
                                catch (Exception var1_2) {
                                    throw new ExceptionConverter(var1_2);
                                    break;
                                }
                                continue;
                            }
                        }
                        ++var5_8;
                        ** GOTO lbl13
                    }
                    return true;
                }
                ++var5_9;
                ** GOTO lbl83
            }
            ++var5_10;
            ** GOTO lbl100
        }
        return false;
    }

    public boolean setFieldRichValue(String object, String string2) throws DocumentException, IOException {
        if (this.writer == null) {
            throw new DocumentException(MessageLocalization.getComposedMessage("this.acrofields.instance.is.read.only", new Object[0]));
        }
        Item item = this.getFieldItem((String)object);
        if (item == null) {
            return false;
        }
        if (this.getFieldType((String)object) != 4) {
            return false;
        }
        object = item.getMerged(0).getAsNumber(PdfName.FF);
        int n = object != null ? object.intValue() : 0;
        if ((n & 33554432) == 0) {
            return false;
        }
        object = new PdfString(string2);
        item.writeToAll(PdfName.RV, (PdfObject)object, 5);
        object = new PdfString(XmlToTxt.parse(new ByteArrayInputStream(string2.getBytes())));
        item.writeToAll(PdfName.V, (PdfObject)object, 5);
        return true;
    }

    public void setFields(FdfReader fdfReader) throws IOException, DocumentException {
        for (String string2 : fdfReader.getFields().keySet()) {
            String string3 = fdfReader.getFieldValue(string2);
            if (string3 == null) continue;
            this.setField(string2, string3);
        }
    }

    public void setFields(XfdfReader xfdfReader) throws IOException, DocumentException {
        for (String string2 : xfdfReader.getFields().keySet()) {
            List<String> object;
            String string22 = xfdfReader.getFieldValue(string2);
            if (string22 != null) {
                this.setField(string2, string22);
            }
            if ((object = xfdfReader.getListValues(string2)) == null) continue;
            this.setListSelection(string22, object.toArray(new String[object.size()]));
        }
    }

    public void setGenerateAppearances(boolean bl) {
        this.generateAppearances = bl;
        PdfDictionary pdfDictionary = this.reader.getCatalog().getAsDict(PdfName.ACROFORM);
        if (bl) {
            pdfDictionary.remove(PdfName.NEEDAPPEARANCES);
            return;
        }
        pdfDictionary.put(PdfName.NEEDAPPEARANCES, PdfBoolean.PDFTRUE);
    }

    public boolean setListOption(String object, String[] arrstring, String[] arrstring2) {
        int n = 0;
        int n2 = 0;
        if (arrstring == null && arrstring2 == null) {
            return false;
        }
        if (arrstring != null && arrstring2 != null && arrstring.length != arrstring2.length) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.export.and.the.display.array.must.have.the.same.size", new Object[0]));
        }
        int n3 = this.getFieldType((String)object);
        if (n3 != 6 && n3 != 5) {
            return false;
        }
        Item item = this.fields.get(object);
        PdfArray pdfArray = null;
        if (arrstring == null && arrstring2 != null) {
            object = arrstring2;
        } else {
            object = pdfArray;
            if (arrstring != null) {
                object = pdfArray;
                if (arrstring2 == null) {
                    object = arrstring;
                }
            }
        }
        pdfArray = new PdfArray();
        if (object != null) {
            for (n = n2; n < ((String[])object).length; ++n) {
                pdfArray.add(new PdfString(object[n], "UnicodeBig"));
            }
        } else {
            while (n < arrstring.length) {
                object = new PdfArray();
                object.add(new PdfString(arrstring[n], "UnicodeBig"));
                object.add(new PdfString(arrstring2[n], "UnicodeBig"));
                pdfArray.add((PdfObject)object);
                ++n;
            }
        }
        item.writeToAll(PdfName.OPT, pdfArray, 5);
        return true;
    }

    public boolean setListSelection(String object, String[] object2) throws IOException, DocumentException {
        int n;
        Item item = this.getFieldItem((String)object);
        int n2 = 0;
        if (item == null) {
            return false;
        }
        PdfDictionary pdfDictionary = item.getMerged(0);
        Object object3 = pdfDictionary.getAsName(PdfName.FT);
        if (!PdfName.CH.equals(object3)) {
            return false;
        }
        object3 = this.getListOptionExport((String)object);
        PdfArray pdfArray = new PdfArray();
        int n3 = ((String[])object2).length;
        block0 : for (n = 0; n < n3; ++n) {
            String string2 = object2[n];
            for (int i = 0; i < ((String[])object3).length; ++i) {
                if (!object3[i].equals(string2)) continue;
                pdfArray.add(new PdfNumber(i));
                continue block0;
            }
        }
        item.writeToAll(PdfName.I, pdfArray, 5);
        object3 = new PdfArray();
        for (n = n2; n < ((String[])object2).length; ++n) {
            object3.add(new PdfString(object2[n]));
        }
        item.writeToAll(PdfName.V, (PdfObject)object3, 5);
        object = this.getAppearance(pdfDictionary, (String[])object2, (String)object);
        object2 = new PdfDictionary();
        object2.put(PdfName.N, object.getIndirectReference());
        item.writeToAll(PdfName.AP, (PdfObject)object2, 3);
        this.writer.releaseTemplate((PdfTemplate)object);
        item.markUsed(this, 6);
        return true;
    }

    public void setSubstitutionFonts(ArrayList<BaseFont> arrayList) {
        this.substitutionFonts = arrayList;
    }

    public boolean signatureCoversWholeDocument(String string2) {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        boolean bl = this.sigNames.containsKey(string2);
        boolean bl2 = false;
        if (!bl) {
            return false;
        }
        if ((long)this.sigNames.get(string2)[0] == this.reader.getFileLength()) {
            bl2 = true;
        }
        return bl2;
    }

    public PdfPKCS7 verifySignature(String string2) {
        return this.verifySignature(string2, null);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public PdfPKCS7 verifySignature(String object, String object2) {
        PdfDictionary pdfDictionary = this.getSignatureDictionary((String)object);
        if (pdfDictionary == null) {
            return null;
        }
        try {
            object = pdfDictionary.getAsName(PdfName.SUBFILTER);
            PdfString pdfString = pdfDictionary.getAsString(PdfName.CONTENTS);
            if (object.equals(PdfName.ADBE_X509_RSA_SHA1)) {
                PdfString pdfString2 = pdfDictionary.getAsString(PdfName.CERT);
                object = pdfString2;
                if (pdfString2 == null) {
                    object = pdfDictionary.getAsArray(PdfName.CERT).getAsString(0);
                }
                object = new PdfPKCS7(pdfString.getOriginalBytes(), object.getBytes(), (String)object2);
            } else {
                object = new PdfPKCS7(pdfString.getOriginalBytes(), (PdfName)object, (String)object2);
            }
            this.updateByteRange((PdfPKCS7)object, pdfDictionary);
            object2 = pdfDictionary.getAsString(PdfName.M);
            if (object2 != null) {
                object.setSignDate(PdfDate.decode(object2.toString()));
            }
            if ((object2 = PdfReader.getPdfObject(pdfDictionary.get(PdfName.NAME))) != null) {
                if (object2.isString()) {
                    object.setSignName(((PdfString)object2).toUnicodeString());
                } else if (object2.isName()) {
                    object.setSignName(PdfName.decodeName(object2.toString()));
                }
            }
            if ((object2 = pdfDictionary.getAsString(PdfName.REASON)) != null) {
                object.setReason(object2.toUnicodeString());
            }
            if ((object2 = pdfDictionary.getAsString(PdfName.LOCATION)) != null) {
                object.setLocation(object2.toUnicodeString());
            }
            return object;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public static class FieldPosition {
        public int page;
        public Rectangle position;
    }

    private static class InstHit {
        IntHashtable hits;

        public InstHit(int[] arrn) {
            if (arrn == null) {
                return;
            }
            this.hits = new IntHashtable();
            for (int i = 0; i < arrn.length; ++i) {
                this.hits.put(arrn[i], 1);
            }
        }

        public boolean isHit(int n) {
            if (this.hits == null) {
                return true;
            }
            return this.hits.containsKey(n);
        }
    }

    public static class Item {
        public static final int WRITE_MERGED = 1;
        public static final int WRITE_VALUE = 4;
        public static final int WRITE_WIDGET = 2;
        protected ArrayList<PdfDictionary> merged = new ArrayList();
        protected ArrayList<Integer> page = new ArrayList();
        protected ArrayList<Integer> tabOrder = new ArrayList();
        protected ArrayList<PdfDictionary> values = new ArrayList();
        protected ArrayList<PdfIndirectReference> widget_refs = new ArrayList();
        protected ArrayList<PdfDictionary> widgets = new ArrayList();

        void addMerged(PdfDictionary pdfDictionary) {
            this.merged.add(pdfDictionary);
        }

        void addPage(int n) {
            this.page.add(n);
        }

        void addTabOrder(int n) {
            this.tabOrder.add(n);
        }

        void addValue(PdfDictionary pdfDictionary) {
            this.values.add(pdfDictionary);
        }

        void addWidget(PdfDictionary pdfDictionary) {
            this.widgets.add(pdfDictionary);
        }

        void addWidgetRef(PdfIndirectReference pdfIndirectReference) {
            this.widget_refs.add(pdfIndirectReference);
        }

        void forcePage(int n, int n2) {
            this.page.set(n, n2);
        }

        public PdfDictionary getMerged(int n) {
            return this.merged.get(n);
        }

        public Integer getPage(int n) {
            return this.page.get(n);
        }

        public Integer getTabOrder(int n) {
            return this.tabOrder.get(n);
        }

        public PdfDictionary getValue(int n) {
            return this.values.get(n);
        }

        public PdfDictionary getWidget(int n) {
            return this.widgets.get(n);
        }

        public PdfIndirectReference getWidgetRef(int n) {
            return this.widget_refs.get(n);
        }

        public void markUsed(AcroFields acroFields, int n) {
            int n2 = 0;
            if ((n & 4) != 0) {
                for (int i = 0; i < this.size(); ++i) {
                    acroFields.markUsed(this.getValue(i));
                }
            }
            if ((n & 2) != 0) {
                for (n = n2; n < this.size(); ++n) {
                    acroFields.markUsed(this.getWidget(n));
                }
            }
        }

        void remove(int n) {
            this.values.remove(n);
            this.widgets.remove(n);
            this.widget_refs.remove(n);
            this.merged.remove(n);
            this.page.remove(n);
            this.tabOrder.remove(n);
        }

        public int size() {
            return this.values.size();
        }

        public void writeToAll(PdfName pdfName, PdfObject pdfObject, int n) {
            int n2;
            int n3 = 0;
            if ((n & 1) != 0) {
                for (n2 = 0; n2 < this.merged.size(); ++n2) {
                    this.getMerged(n2).put(pdfName, pdfObject);
                }
            }
            if ((n & 2) != 0) {
                for (n2 = 0; n2 < this.widgets.size(); ++n2) {
                    this.getWidget(n2).put(pdfName, pdfObject);
                }
            }
            if ((n & 4) != 0) {
                for (n = n3; n < this.values.size(); ++n) {
                    this.getValue(n).put(pdfName, pdfObject);
                }
            }
        }
    }

    private static class SorterComparator
    implements Comparator<Object[]> {
        private SorterComparator() {
        }

        @Override
        public int compare(Object[] arrobject, Object[] arrobject2) {
            return ((int[])arrobject[1])[0] - ((int[])arrobject2[1])[0];
        }
    }

}

