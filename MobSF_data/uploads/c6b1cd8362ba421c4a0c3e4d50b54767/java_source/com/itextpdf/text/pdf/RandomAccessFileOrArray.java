/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.Document;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.io.IndependentRandomAccessSource;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;

public class RandomAccessFileOrArray
implements DataInput {
    private byte back;
    private final RandomAccessSource byteSource;
    private long byteSourcePosition;
    private boolean isBack = false;

    public RandomAccessFileOrArray(RandomAccessSource randomAccessSource) {
        this.byteSource = randomAccessSource;
    }

    @Deprecated
    public RandomAccessFileOrArray(RandomAccessFileOrArray randomAccessFileOrArray) {
        this(new IndependentRandomAccessSource(randomAccessFileOrArray.byteSource));
    }

    @Deprecated
    public RandomAccessFileOrArray(InputStream inputStream) throws IOException {
        this(new RandomAccessSourceFactory().createSource(inputStream));
    }

    @Deprecated
    public RandomAccessFileOrArray(String string2) throws IOException {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2));
    }

    @Deprecated
    public RandomAccessFileOrArray(String string2, boolean bl, boolean bl2) throws IOException {
        this(new RandomAccessSourceFactory().setForceRead(bl).setUsePlainRandomAccess(bl2).createBestSource(string2));
    }

    @Deprecated
    public RandomAccessFileOrArray(URL uRL) throws IOException {
        this(new RandomAccessSourceFactory().createSource(uRL));
    }

    @Deprecated
    public RandomAccessFileOrArray(byte[] arrby) {
        this(new RandomAccessSourceFactory().createSource(arrby));
    }

    public void close() throws IOException {
        this.isBack = false;
        this.byteSource.close();
    }

    public RandomAccessSource createSourceView() {
        return new IndependentRandomAccessSource(this.byteSource);
    }

    public RandomAccessFileOrArray createView() {
        return new RandomAccessFileOrArray(new IndependentRandomAccessSource(this.byteSource));
    }

    @Deprecated
    protected RandomAccessSource getByteSource() {
        return this.byteSource;
    }

    public long getFilePointer() throws IOException {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.provideAs(TypeTransformer.java:780)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.e1expr(TypeTransformer.java:496)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:713)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:703)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.e1expr(TypeTransformer.java:539)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:713)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:703)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.e2expr(TypeTransformer.java:632)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:716)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:703)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.s1stmt(TypeTransformer.java:810)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.sxStmt(TypeTransformer.java:840)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:206)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    public long length() throws IOException {
        return this.byteSource.length();
    }

    public void pushBack(byte by) {
        this.back = by;
        this.isBack = true;
    }

    @Deprecated
    public void reOpen() throws IOException {
        this.seek(0L);
    }

    public int read() throws IOException {
        if (this.isBack) {
            this.isBack = false;
            return this.back & 255;
        }
        RandomAccessSource randomAccessSource = this.byteSource;
        long l = this.byteSourcePosition;
        this.byteSourcePosition = l + 1L;
        return randomAccessSource.get(l);
    }

    public int read(byte[] arrby) throws IOException {
        return this.read(arrby, 0, arrby.length);
    }

    public int read(byte[] arrby, int n, int n2) throws IOException {
        int n3;
        int n4;
        if (n2 == 0) {
            return 0;
        }
        if (this.isBack && n2 > 0) {
            this.isBack = false;
            arrby[n] = this.back;
            n4 = 1;
            --n2;
            n3 = n + 1;
            n = n4;
        } else {
            n3 = n;
            n = 0;
        }
        n4 = n;
        if (n2 > 0) {
            n2 = this.byteSource.get(this.byteSourcePosition, arrby, n3, n2);
            n4 = n;
            if (n2 > 0) {
                n4 = n + n2;
                this.byteSourcePosition += (long)n2;
            }
        }
        if (n4 == 0) {
            return -1;
        }
        return n4;
    }

    @Override
    public boolean readBoolean() throws IOException {
        int n = this.read();
        if (n < 0) {
            throw new EOFException();
        }
        if (n != 0) {
            return true;
        }
        return false;
    }

    @Override
    public byte readByte() throws IOException {
        int n = this.read();
        if (n < 0) {
            throw new EOFException();
        }
        return (byte)n;
    }

    @Override
    public char readChar() throws IOException {
        int n;
        int n2 = this.read();
        if ((n2 | (n = this.read())) < 0) {
            throw new EOFException();
        }
        return (char)((n2 << 8) + n);
    }

    public final char readCharLE() throws IOException {
        int n;
        int n2 = this.read();
        if ((n2 | (n = this.read())) < 0) {
            throw new EOFException();
        }
        return (char)((n << 8) + (n2 << 0));
    }

    @Override
    public double readDouble() throws IOException {
        return Double.longBitsToDouble(this.readLong());
    }

    public final double readDoubleLE() throws IOException {
        return Double.longBitsToDouble(this.readLongLE());
    }

    @Override
    public float readFloat() throws IOException {
        return Float.intBitsToFloat(this.readInt());
    }

    public final float readFloatLE() throws IOException {
        return Float.intBitsToFloat(this.readIntLE());
    }

    @Override
    public void readFully(byte[] arrby) throws IOException {
        this.readFully(arrby, 0, arrby.length);
    }

    @Override
    public void readFully(byte[] arrby, int n, int n2) throws IOException {
        int n3;
        int n4 = 0;
        do {
            if ((n3 = this.read(arrby, n + n4, n2 - n4)) < 0) {
                throw new EOFException();
            }
            n4 = n3 = n4 + n3;
        } while (n3 < n2);
    }

    @Override
    public int readInt() throws IOException {
        int n;
        int n2;
        int n3;
        int n4 = this.read();
        if ((n4 | (n3 = this.read()) | (n = this.read()) | (n2 = this.read())) < 0) {
            throw new EOFException();
        }
        return (n4 << 24) + (n3 << 16) + (n << 8) + n2;
    }

    public final int readIntLE() throws IOException {
        int n;
        int n2;
        int n3;
        int n4 = this.read();
        if ((n4 | (n3 = this.read()) | (n = this.read()) | (n2 = this.read())) < 0) {
            throw new EOFException();
        }
        return (n2 << 24) + (n << 16) + (n3 << 8) + (n4 << 0);
    }

    @Override
    public String readLine() throws IOException {
        StringBuilder stringBuilder = new StringBuilder();
        boolean bl = false;
        int n = -1;
        while (!bl) {
            n = this.read();
            if (n != -1 && n != 10) {
                if (n != 13) {
                    stringBuilder.append((char)n);
                    continue;
                }
                long l = this.getFilePointer();
                if (this.read() != 10) {
                    this.seek(l);
                }
            }
            bl = true;
        }
        if (n == -1 && stringBuilder.length() == 0) {
            return null;
        }
        return stringBuilder.toString();
    }

    @Override
    public long readLong() throws IOException {
        return ((long)this.readInt() << 32) + ((long)this.readInt() & 0xFFFFFFFFL);
    }

    public final long readLongLE() throws IOException {
        int n = this.readIntLE();
        return ((long)this.readIntLE() << 32) + ((long)n & 0xFFFFFFFFL);
    }

    @Override
    public short readShort() throws IOException {
        int n;
        int n2 = this.read();
        if ((n2 | (n = this.read())) < 0) {
            throw new EOFException();
        }
        return (short)((n2 << 8) + n);
    }

    public final short readShortLE() throws IOException {
        int n;
        int n2 = this.read();
        if ((n2 | (n = this.read())) < 0) {
            throw new EOFException();
        }
        return (short)((n << 8) + (n2 << 0));
    }

    public String readString(int n, String string2) throws IOException {
        byte[] arrby = new byte[n];
        this.readFully(arrby);
        try {
            string2 = new String(arrby, string2);
            return string2;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    @Override
    public String readUTF() throws IOException {
        return DataInputStream.readUTF(this);
    }

    @Override
    public int readUnsignedByte() throws IOException {
        int n = this.read();
        if (n < 0) {
            throw new EOFException();
        }
        return n;
    }

    public final long readUnsignedInt() throws IOException {
        long l;
        long l2;
        long l3;
        long l4 = this.read();
        if ((l4 | (l3 = (long)this.read()) | (l2 = (long)this.read()) | (l = (long)this.read())) < 0L) {
            throw new EOFException();
        }
        return (l4 << 24) + (l3 << 16) + (l2 << 8) + (l << 0);
    }

    public final long readUnsignedIntLE() throws IOException {
        long l;
        long l2;
        long l3;
        long l4 = this.read();
        if ((l4 | (l3 = (long)this.read()) | (l2 = (long)this.read()) | (l = (long)this.read())) < 0L) {
            throw new EOFException();
        }
        return (l << 24) + (l2 << 16) + (l3 << 8) + (l4 << 0);
    }

    @Override
    public int readUnsignedShort() throws IOException {
        int n;
        int n2 = this.read();
        if ((n2 | (n = this.read())) < 0) {
            throw new EOFException();
        }
        return (n2 << 8) + n;
    }

    public final int readUnsignedShortLE() throws IOException {
        int n;
        int n2 = this.read();
        if ((n2 | (n = this.read())) < 0) {
            throw new EOFException();
        }
        return (n << 8) + (n2 << 0);
    }

    public void seek(long l) throws IOException {
        this.byteSourcePosition = l;
        this.isBack = false;
    }

    public long skip(long l) throws IOException {
        long l2;
        if (l <= 0L) {
            return 0L;
        }
        boolean bl = this.isBack;
        int n = 0;
        long l3 = l;
        if (bl) {
            this.isBack = false;
            if (l == 1L) {
                return 1L;
            }
            n = 1;
            l3 = l - 1L;
        }
        if ((l3 = (l2 = this.getFilePointer()) + l3) <= (l = this.length())) {
            l = l3;
        }
        this.seek(l);
        return l - l2 + (long)n;
    }

    @Override
    public int skipBytes(int n) throws IOException {
        return (int)this.skip(n);
    }
}

