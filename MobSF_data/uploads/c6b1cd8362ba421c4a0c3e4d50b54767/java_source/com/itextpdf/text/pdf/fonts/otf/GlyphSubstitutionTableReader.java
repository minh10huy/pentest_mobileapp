/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.fonts.otf;

import com.itextpdf.text.log.Logger;
import com.itextpdf.text.pdf.Glyph;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.fonts.otf.FontReadingException;
import com.itextpdf.text.pdf.fonts.otf.OpenTypeFontTableReader;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class GlyphSubstitutionTableReader
extends OpenTypeFontTableReader {
    private final Map<Integer, Character> glyphToCharacterMap;
    private final int[] glyphWidthsByIndex;
    private Map<Integer, List<Integer>> rawLigatureSubstitutionMap;

    public GlyphSubstitutionTableReader(RandomAccessFileOrArray randomAccessFileOrArray, int n, Map<Integer, Character> map, int[] arrn) throws IOException {
        super(randomAccessFileOrArray, n);
        this.glyphWidthsByIndex = arrn;
        this.glyphToCharacterMap = map;
    }

    /*
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private String getTextFromGlyph(int n, Map<Integer, Character> object) throws FontReadingException {
        StringBuilder stringBuilder = new StringBuilder(1);
        List<Integer> list = (Character)object.get(n);
        if (list != null) {
            stringBuilder.append(list.charValue());
            return stringBuilder.toString();
        }
        list = this.rawLigatureSubstitutionMap.get(n);
        if (list != null && !list.isEmpty()) {
            list = list.iterator();
            while (list.hasNext()) {
                stringBuilder.append(this.getTextFromGlyph((Integer)list.next(), (Map<Integer, Character>)object));
            }
            return stringBuilder.toString();
        }
        object = new StringBuilder();
        object.append("No corresponding character or simple glyphs found for GlyphID=");
        object.append(n);
        throw new FontReadingException(object.toString());
    }

    private void readLigatureSetTable(int n, int n2) throws IOException {
        this.rf.seek(n);
        int n3 = this.rf.readShort();
        Iterator<Integer> iterator = LOG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("ligatureCount=");
        stringBuilder.append(n3);
        iterator.debug(stringBuilder.toString());
        iterator = new ArrayList(n3);
        for (int i = 0; i < n3; ++i) {
            iterator.add(Integer.valueOf(this.rf.readShort()));
        }
        iterator = iterator.iterator();
        while (iterator.hasNext()) {
            this.readLigatureTable((Integer)iterator.next() + n, n2);
        }
    }

    private void readLigatureSubstitutionSubtable(int n) throws IOException {
        this.rf.seek(n);
        int n2 = this.rf.readShort();
        Object object = LOG;
        Object object2 = new StringBuilder();
        object2.append("substFormat=");
        object2.append(n2);
        object.debug(object2.toString());
        if (n2 != 1) {
            throw new IllegalArgumentException("The expected SubstFormat is 1");
        }
        int n3 = this.rf.readShort();
        object = LOG;
        object2 = new StringBuilder();
        object2.append("coverage=");
        object2.append(n3);
        object.debug(object2.toString());
        int n4 = this.rf.readShort();
        object = new ArrayList(n4);
        int n5 = 0;
        for (n2 = 0; n2 < n4; ++n2) {
            object.add(Integer.valueOf(this.rf.readShort()));
        }
        object2 = this.readCoverageFormat(n3 + n);
        if (n4 != object2.size()) {
            throw new IllegalArgumentException("According to the OpenTypeFont specifications, the coverage count should be equal to the no. of LigatureSetTables");
        }
        for (n2 = n5; n2 < n4; ++n2) {
            n5 = (Integer)object2.get(n2);
            n3 = (Integer)object.get(n2);
            Logger logger = LOG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("ligatureOffset=");
            stringBuilder.append(n3);
            logger.debug(stringBuilder.toString());
            this.readLigatureSetTable(n3 + n, n5);
        }
    }

    private void readLigatureTable(int n, int n2) throws IOException {
        this.rf.seek(n);
        short s = this.rf.readShort();
        Object object = LOG;
        List<Integer> list = new StringBuilder();
        list.append("ligGlyph=");
        list.append((int)s);
        object.debug(list.toString());
        short s2 = this.rf.readShort();
        object = new ArrayList();
        object.add(n2);
        for (n = 0; n < s2 - 1; ++n) {
            object.add(Integer.valueOf(this.rf.readShort()));
        }
        list = LOG;
        Object object2 = new StringBuilder();
        object2.append("glyphIdList=");
        object2.append(object);
        list.debug(object2.toString());
        list = this.rawLigatureSubstitutionMap.put(Integer.valueOf(s), (List<Integer>)object);
        if (list != null) {
            object2 = LOG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("!!!!!!!!!!glyphId=");
            stringBuilder.append(s);
            stringBuilder.append(",\npreviousValue=");
            stringBuilder.append(list);
            stringBuilder.append(",\ncurrentVal=");
            stringBuilder.append(object);
            object2.warn(stringBuilder.toString());
        }
    }

    private void readSingleSubstitutionSubtable(int n) throws IOException {
        Object object;
        int n2;
        block6 : {
            block5 : {
                Object object2;
                block4 : {
                    this.rf.seek(n);
                    n2 = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("substFormat=");
                    object2.append(n2);
                    object.debug(object2.toString());
                    if (n2 != 1) break block4;
                    short s = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("coverage=");
                    object2.append(s);
                    object.debug(object2.toString());
                    n2 = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("deltaGlyphID=");
                    object2.append(n2);
                    object.debug(object2.toString());
                    object = this.readCoverageFormat(n + s).iterator();
                    while (object.hasNext()) {
                        n = (Integer)object.next();
                        this.rawLigatureSubstitutionMap.put(n + n2, Arrays.asList(n));
                    }
                    break block5;
                }
                if (n2 == 2) {
                    short s = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("coverage=");
                    object2.append(s);
                    object.debug(object2.toString());
                    int n3 = this.rf.readUnsignedShort();
                    object = new int[n3];
                    for (n2 = 0; n2 < n3; ++n2) {
                        object[n2] = this.rf.readUnsignedShort();
                    }
                    object2 = this.readCoverageFormat(n + s);
                    for (n = 0; n < n3; ++n) {
                        this.rawLigatureSubstitutionMap.put((int)object[n], Arrays.asList((Integer)object2.get(n)));
                    }
                }
                break block6;
            }
            return;
        }
        object = new StringBuilder();
        object.append("Bad substFormat: ");
        object.append(n2);
        throw new IllegalArgumentException(object.toString());
    }

    public Map<String, Glyph> getGlyphSubstitutionMap() throws FontReadingException {
        LinkedHashMap<String, Glyph> linkedHashMap = new LinkedHashMap<String, Glyph>();
        for (Integer n : this.rawLigatureSubstitutionMap.keySet()) {
            Object object = this.rawLigatureSubstitutionMap.get(n);
            StringBuilder stringBuilder = new StringBuilder(object.size());
            object = object.iterator();
            while (object.hasNext()) {
                stringBuilder.append(this.getTextFromGlyph((Integer)object.next(), this.glyphToCharacterMap));
            }
            Glyph object2 = new Glyph(n, this.glyphWidthsByIndex[n], stringBuilder.toString());
            linkedHashMap.put(object2.chars, object2);
        }
        return Collections.unmodifiableMap(linkedHashMap);
    }

    public void read() throws FontReadingException {
        this.rawLigatureSubstitutionMap = new LinkedHashMap<Integer, List<Integer>>();
        this.startReadingTable();
    }

    @Override
    protected void readSubTable(int n, int n2) throws IOException {
        if (n == 1) {
            this.readSingleSubstitutionSubtable(n2);
            return;
        }
        if (n == 4) {
            this.readLigatureSubstitutionSubtable(n2);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("LookupType ");
        stringBuilder.append(n);
        stringBuilder.append(" is not yet handled for ");
        stringBuilder.append(GlyphSubstitutionTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }
}

