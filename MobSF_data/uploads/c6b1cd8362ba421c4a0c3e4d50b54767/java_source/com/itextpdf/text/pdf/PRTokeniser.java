/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.InvalidPdfException;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import java.io.IOException;

public class PRTokeniser {
    static final String EMPTY = "";
    public static final boolean[] delims = new boolean[]{true, true, false, false, false, false, false, false, false, false, true, true, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, false, true, true, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false};
    private final RandomAccessFileOrArray file;
    protected int generation;
    protected boolean hexString;
    private final StringBuilder outBuf = new StringBuilder();
    protected int reference;
    protected String stringValue;
    protected TokenType type;

    public PRTokeniser(RandomAccessFileOrArray randomAccessFileOrArray) {
        this.file = randomAccessFileOrArray;
    }

    public static long[] checkObjectStart(byte[] object) {
        block5 : {
            block7 : {
                int n;
                int n2;
                block10 : {
                    block9 : {
                        block8 : {
                            block6 : {
                                try {
                                    object = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource((byte[])object)));
                                    if (!object.nextToken()) break block5;
                                    if (object.getTokenType() == TokenType.NUMBER) break block6;
                                    return null;
                                }
                                catch (Exception exception) {
                                    return null;
                                }
                            }
                            n = object.intValue();
                            if (!object.nextToken()) break block7;
                            if (object.getTokenType() == TokenType.NUMBER) break block8;
                            return null;
                        }
                        n2 = object.intValue();
                        if (object.nextToken()) break block9;
                        return null;
                    }
                    if (object.getStringValue().equals("obj")) break block10;
                    return null;
                }
                long l = n;
                long l2 = n2;
                return new long[]{l, l2};
            }
            return null;
        }
        return null;
    }

    public static int getHex(int n) {
        if (n >= 48 && n <= 57) {
            return n - 48;
        }
        if (n >= 65 && n <= 70) {
            return n - 65 + 10;
        }
        if (n >= 97 && n <= 102) {
            return n - 97 + 10;
        }
        return -1;
    }

    public static final boolean isDelimiter(int n) {
        if (n != 40 && n != 41 && n != 60 && n != 62 && n != 91 && n != 93 && n != 47 && n != 37) {
            return false;
        }
        return true;
    }

    public static final boolean isDelimiterWhitespace(int n) {
        return delims[n + 1];
    }

    public static final boolean isWhitespace(int n) {
        return PRTokeniser.isWhitespace(n, true);
    }

    public static final boolean isWhitespace(int n, boolean bl) {
        if (!(bl && n == 0 || n == 9 || n == 10 || n == 12 || n == 13 || n == 32)) {
            return false;
        }
        return true;
    }

    public void backOnePosition(int n) {
        if (n != -1) {
            this.file.pushBack((byte)n);
        }
    }

    public void checkFdfHeader() throws IOException {
        this.file.seek(0L);
        if (this.readString(1024).indexOf("%FDF-") != 0) {
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("fdf.header.not.found", new Object[0]));
        }
    }

    public char checkPdfHeader() throws IOException {
        this.file.seek(0L);
        String string2 = this.readString(1024);
        if (string2.indexOf("%PDF-") != 0) {
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("pdf.header.not.found", new Object[0]));
        }
        return string2.charAt(7);
    }

    public void close() throws IOException {
        this.file.close();
    }

    public RandomAccessFileOrArray getFile() {
        return this.file;
    }

    public long getFilePointer() throws IOException {
        return this.file.getFilePointer();
    }

    public int getGeneration() {
        return this.generation;
    }

    public int getHeaderOffset() throws IOException {
        int n;
        String string2 = this.readString(1024);
        int n2 = n = string2.indexOf("%PDF-");
        if (n < 0) {
            n2 = n = string2.indexOf("%FDF-");
            if (n < 0) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("pdf.header.not.found", new Object[0]));
            }
        }
        return n2;
    }

    public int getReference() {
        return this.reference;
    }

    public RandomAccessFileOrArray getSafeFile() {
        return new RandomAccessFileOrArray(this.file);
    }

    public long getStartxref() throws IOException {
        long l = this.file.length();
        long l2 = 1024;
        long l3 = 1L;
        if ((l -= l2) < 1L) {
            l = l3;
        }
        while (l > 0L) {
            this.file.seek(l);
            int n = this.readString(1024).lastIndexOf("startxref");
            if (n >= 0) {
                return l + (long)n;
            }
            l = l - l2 + 9L;
        }
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("pdf.startxref.not.found", new Object[0]));
    }

    public String getStringValue() {
        return this.stringValue;
    }

    public TokenType getTokenType() {
        return this.type;
    }

    public int intValue() {
        return Integer.parseInt(this.stringValue);
    }

    public boolean isHexString() {
        return this.hexString;
    }

    public long length() throws IOException {
        return this.file.length();
    }

    public long longValue() {
        return Long.parseLong(this.stringValue);
    }

    /*
     * Exception decompiling
     */
    public boolean nextToken() throws IOException {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Extractable last case doesn't follow previous
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:486)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public void nextValidToken() throws IOException {
        String string2 = null;
        int n = 0;
        long l = 0L;
        String string3 = null;
        block4 : while (this.nextToken()) {
            block8 : {
                if (this.type == TokenType.COMMENT) continue;
                switch (n) {
                    default: {
                        if (this.type == TokenType.OTHER && this.stringValue.equals("R")) break;
                        break block8;
                    }
                    case 1: {
                        if (this.type != TokenType.NUMBER) {
                            this.file.seek(l);
                            this.type = TokenType.NUMBER;
                            this.stringValue = string2;
                            return;
                        }
                        string3 = this.stringValue;
                        ++n;
                        continue block4;
                    }
                    case 0: {
                        if (this.type != TokenType.NUMBER) {
                            return;
                        }
                        l = this.file.getFilePointer();
                        string2 = this.stringValue;
                        ++n;
                        continue block4;
                    }
                }
                this.type = TokenType.REF;
                this.reference = Integer.parseInt(string2);
                this.generation = Integer.parseInt(string3);
                return;
            }
            this.file.seek(l);
            this.type = TokenType.NUMBER;
            this.stringValue = string2;
            return;
        }
        if (n == 1) {
            this.type = TokenType.NUMBER;
        }
    }

    public int read() throws IOException {
        return this.file.read();
    }

    public boolean readLineSegment(byte[] arrby) throws IOException {
        return this.readLineSegment(arrby, true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public boolean readLineSegment(byte[] var1_1, boolean var2_2) throws IOException {
        var7_3 = var1_1.length;
        if (var7_3 > 0) {
            while (PRTokeniser.isWhitespace(var3_4 = this.read(), var2_2)) {
            }
            var5_5 = 0;
            var4_6 = 0;
        } else {
            var5_5 = 0;
            var4_6 = 0;
            var3_4 = -1;
        }
        do {
            var6_7 = var4_6;
            if (var5_5 != 0) break;
            var6_7 = var4_6;
            if (var4_6 >= var7_3) break;
            if (var3_4 == -1 || var3_4 == 10) ** GOTO lbl24
            if (var3_4 != 13) {
                var1_1[var4_6] = (byte)var3_4;
                ++var4_6;
            } else {
                var8_8 = this.getFilePointer();
                if (this.read() != 10) {
                    this.seek(var8_8);
                }
lbl24: // 4 sources:
                var5_5 = 1;
            }
            var6_7 = var4_6;
            if (var5_5 != 0) break;
            if (var7_3 <= var4_6) {
                var6_7 = var4_6;
                break;
            }
            var3_4 = this.read();
        } while (true);
        var5_5 = var3_4;
        if (var6_7 >= var7_3) {
            var4_6 = 0;
            do {
                var5_5 = var3_4;
                if (var4_6 != 0) break;
                var3_4 = this.read();
                if (var3_4 != -1 && var3_4 != 10) {
                    if (var3_4 != 13) continue;
                    var8_8 = this.getFilePointer();
                    if (this.read() != 10) {
                        this.seek(var8_8);
                    }
                }
                var4_6 = 1;
            } while (true);
        }
        if (var5_5 == -1 && var6_7 == 0) {
            return false;
        }
        if (var6_7 + 2 > var7_3) return true;
        var1_1[var6_7] = 32;
        var1_1[var6_7 + 1] = 88;
        return true;
    }

    public String readString(int n) throws IOException {
        int n2;
        StringBuilder stringBuilder = new StringBuilder();
        while (n > 0 && (n2 = this.read()) != -1) {
            stringBuilder.append((char)n2);
            --n;
        }
        return stringBuilder.toString();
    }

    public void seek(long l) throws IOException {
        this.file.seek(l);
    }

    public void throwError(String string2) throws IOException {
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("1.at.file.pointer.2", string2, String.valueOf(this.file.getFilePointer())));
    }

    public static enum TokenType {
        NUMBER,
        STRING,
        NAME,
        COMMENT,
        START_ARRAY,
        END_ARRAY,
        START_DIC,
        END_DIC,
        REF,
        OTHER,
        ENDOFFILE;
        

        private TokenType() {
        }
    }

}

