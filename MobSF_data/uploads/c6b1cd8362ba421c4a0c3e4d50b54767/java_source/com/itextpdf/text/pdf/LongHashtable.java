/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class LongHashtable
implements Cloneable {
    private transient int count;
    private float loadFactor;
    private transient Entry[] table;
    private int threshold;

    public LongHashtable() {
        this(150, 0.75f);
    }

    public LongHashtable(int n) {
        this(n, 0.75f);
    }

    public LongHashtable(int n, float f) {
        if (n < 0) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("illegal.capacity.1", n));
        }
        if (f <= 0.0f) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("illegal.load.1", String.valueOf(f)));
        }
        int n2 = n;
        if (n == 0) {
            n2 = 1;
        }
        this.loadFactor = f;
        this.table = new Entry[n2];
        this.threshold = (int)((float)n2 * f);
    }

    public void clear() {
        Entry[] arrentry = this.table;
        int n = arrentry.length;
        while (--n >= 0) {
            arrentry[n] = null;
        }
        this.count = 0;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public Object clone() {
        try {
            var4_1 = (LongHashtable)super.clone();
            var4_1.table = new Entry[this.table.length];
            var1_2 = this.table.length;
        }
        catch (CloneNotSupportedException var3_5) {
            throw new InternalError();
        }
        do lbl-1000: // 2 sources:
        {
            var2_3 = var1_2 - 1;
            if (var1_2 <= 0) return var4_1;
            var5_6 = var4_1.table;
            var3_4 = this.table[var2_3] != null ? (Entry)this.table[var2_3].clone() : null;
            break;
        } while (true);
        {
            var5_6[var2_3] = var3_4;
            var1_2 = var2_3;
            ** while (true)
        }
    }

    public boolean contains(long l) {
        Entry[] arrentry = this.table;
        int n = arrentry.length;
        do {
            int n2 = n - 1;
            if (n <= 0) break;
            Entry entry = arrentry[n2];
            while (entry != null) {
                if (entry.value == l) {
                    return true;
                }
                entry = entry.next;
            }
            n = n2;
        } while (true);
        return false;
    }

    public boolean containsKey(long l) {
        Object object = this.table;
        int n = (int)(l ^ l >>> 32);
        object = object[(Integer.MAX_VALUE & n) % ((Entry[])object).length];
        while (object != null) {
            if (object.hash == n && object.key == l) {
                return true;
            }
            object = object.next;
        }
        return false;
    }

    public boolean containsValue(long l) {
        return this.contains(l);
    }

    public long get(long l) {
        Object object = this.table;
        int n = (int)(l ^ l >>> 32);
        object = object[(Integer.MAX_VALUE & n) % ((Entry[])object).length];
        while (object != null) {
            if (object.hash == n && object.key == l) {
                return object.value;
            }
            object = object.next;
        }
        return 0L;
    }

    public Iterator<Entry> getEntryIterator() {
        return new LongHashtableIterator(this.table);
    }

    public long[] getKeys() {
        long[] arrl = new long[this.count];
        int n = this.table.length;
        int n2 = 0;
        Entry entry = null;
        do {
            int n3 = n;
            Entry entry2 = entry;
            if (entry == null) {
                do {
                    n3 = n - 1;
                    if (n <= 0) break;
                    entry = entry2 = this.table[n3];
                    if (entry2 != null) break;
                    n = n3;
                    entry = entry2;
                } while (true);
                entry2 = entry;
            }
            if (entry2 == null) {
                return arrl;
            }
            entry = entry2.next;
            arrl[n2] = entry2.key;
            ++n2;
            n = n3;
        } while (true);
    }

    public long getOneKey() {
        Entry entry;
        if (this.count == 0) {
            return 0L;
        }
        int n = this.table.length;
        Entry entry2 = null;
        do {
            int n2 = n - 1;
            entry = entry2;
            if (n <= 0) break;
            entry = entry2 = this.table[n2];
            if (entry2 != null) break;
            n = n2;
        } while (true);
        if (entry == null) {
            return 0L;
        }
        return entry.key;
    }

    public boolean isEmpty() {
        if (this.count == 0) {
            return true;
        }
        return false;
    }

    public long put(long l, long l2) {
        Entry[] arrentry = this.table;
        int n = (int)(l ^ l >>> 32);
        int n2 = Integer.MAX_VALUE & n;
        int n3 = n2 % arrentry.length;
        Object object = arrentry[n3];
        while (object != null) {
            if (object.hash == n && object.key == l) {
                l = object.value;
                object.value = l2;
                return l;
            }
            object = object.next;
        }
        object = arrentry;
        if (this.count >= this.threshold) {
            this.rehash();
            object = this.table;
            n3 = n2 % ((Entry[])object).length;
        }
        object[n3] = new Entry(n, l, l2, object[n3]);
        ++this.count;
        return 0L;
    }

    protected void rehash() {
        int n = this.table.length;
        Entry[] arrentry = this.table;
        int n2 = n * 2 + 1;
        Entry[] arrentry2 = new Entry[n2];
        this.threshold = (int)((float)n2 * this.loadFactor);
        this.table = arrentry2;
        do {
            int n3 = n - 1;
            if (n <= 0) break;
            Entry entry = arrentry[n3];
            while (entry != null) {
                Entry entry2 = entry.next;
                n = (entry.hash & Integer.MAX_VALUE) % n2;
                entry.next = arrentry2[n];
                arrentry2[n] = entry;
                entry = entry2;
            }
            n = n3;
        } while (true);
    }

    public long remove(long l) {
        Entry[] arrentry = this.table;
        int n = (int)(l ^ l >>> 32);
        int n2 = (Integer.MAX_VALUE & n) % arrentry.length;
        Entry entry = arrentry[n2];
        Entry entry2 = null;
        do {
            Entry entry3 = entry2;
            entry2 = entry;
            if (entry2 == null) break;
            if (entry2.hash == n && entry2.key == l) {
                if (entry3 != null) {
                    entry3.next = entry2.next;
                } else {
                    arrentry[n2] = entry2.next;
                }
                --this.count;
                l = entry2.value;
                entry2.value = 0L;
                return l;
            }
            entry = entry2.next;
        } while (true);
        return 0L;
    }

    public int size() {
        return this.count;
    }

    public long[] toOrderedKeys() {
        long[] arrl = this.getKeys();
        Arrays.sort(arrl);
        return arrl;
    }

    static class Entry {
        int hash;
        long key;
        Entry next;
        long value;

        protected Entry(int n, long l, long l2, Entry entry) {
            this.hash = n;
            this.key = l;
            this.value = l2;
            this.next = entry;
        }

        protected Object clone() {
            Entry entry;
            long l;
            int n;
            long l2;
            n = this.hash;
            l2 = this.key;
            l = this.value;
            entry = this.next != null ? (Entry)this.next.clone() : null;
            return new Entry(n, l2, l, entry);
        }

        public long getKey() {
            return this.key;
        }

        public long getValue() {
            return this.value;
        }
    }

    static class LongHashtableIterator
    implements Iterator<Entry> {
        Entry entry;
        int index;
        Entry[] table;

        LongHashtableIterator(Entry[] arrentry) {
            this.table = arrentry;
            this.index = arrentry.length;
        }

        @Override
        public boolean hasNext() {
            block2 : {
                Entry entry;
                if (this.entry != null) {
                    return true;
                }
                do {
                    int n = this.index;
                    this.index = n - 1;
                    if (n <= 0) break block2;
                    this.entry = entry = this.table[this.index];
                } while (entry == null);
                return true;
            }
            return false;
        }

        @Override
        public Entry next() {
            Entry entry;
            if (this.entry == null) {
                do {
                    int n = this.index;
                    this.index = n - 1;
                    if (n <= 0) break;
                    this.entry = entry = this.table[this.index];
                } while (entry == null);
            }
            if (this.entry != null) {
                entry = this.entry;
                this.entry = entry.next;
                return entry;
            }
            throw new NoSuchElementException(MessageLocalization.getComposedMessage("inthashtableiterator", new Object[0]));
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException(MessageLocalization.getComposedMessage("remove.not.supported", new Object[0]));
        }
    }

}

