/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.codec;

import com.itextpdf.text.BadElementException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Image;
import com.itextpdf.text.ImgRaw;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfString;
import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.HashMap;

public class BmpImage {
    private static final int BI_BITFIELDS = 3;
    private static final int BI_RGB = 0;
    private static final int BI_RLE4 = 2;
    private static final int BI_RLE8 = 1;
    private static final int LCS_CALIBRATED_RGB = 0;
    private static final int LCS_CMYK = 2;
    private static final int LCS_sRGB = 1;
    private static final int VERSION_2_1_BIT = 0;
    private static final int VERSION_2_24_BIT = 3;
    private static final int VERSION_2_4_BIT = 1;
    private static final int VERSION_2_8_BIT = 2;
    private static final int VERSION_3_1_BIT = 4;
    private static final int VERSION_3_24_BIT = 7;
    private static final int VERSION_3_4_BIT = 5;
    private static final int VERSION_3_8_BIT = 6;
    private static final int VERSION_3_NT_16_BIT = 8;
    private static final int VERSION_3_NT_32_BIT = 9;
    private static final int VERSION_4_16_BIT = 13;
    private static final int VERSION_4_1_BIT = 10;
    private static final int VERSION_4_24_BIT = 14;
    private static final int VERSION_4_32_BIT = 15;
    private static final int VERSION_4_4_BIT = 11;
    private static final int VERSION_4_8_BIT = 12;
    private int alphaMask;
    private long bitmapFileSize;
    private long bitmapOffset;
    private int bitsPerPixel;
    private int blueMask;
    private long compression;
    private int greenMask;
    int height;
    private long imageSize;
    private int imageType;
    private InputStream inputStream;
    private boolean isBottomUp;
    private int numBands;
    private byte[] palette;
    public HashMap<String, Object> properties = new HashMap();
    private int redMask;
    int width;
    private long xPelsPerMeter;
    private long yPelsPerMeter;

    BmpImage(InputStream inputStream, boolean bl, int n) throws IOException {
        this.bitmapFileSize = n;
        this.bitmapOffset = 0L;
        this.process(inputStream, bl);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private byte[] decodeRLE(boolean var1_1, byte[] var2_2) {
        var13_4 = new byte[this.width * this.height];
        var6_5 = 0;
        var5_6 = 0;
        var4_7 = 0;
        var3_8 = 0;
        do {
            block25 : {
                block26 : {
                    block24 : {
                        block22 : {
                            block23 : {
                                if (var6_5 >= this.height) return var13_4;
                                if (var5_6 >= var2_2.length) return var13_4;
                                var9_11 = var5_6 + 1;
                                var8_10 = var2_2[var5_6] & 255;
                                if (var8_10 == 0) break block23;
                                var10_12 = var2_2[var9_11] & 255;
                                if (!var1_1) ** GOTO lbl54
                                for (var5_6 = var8_10; var5_6 != 0; --var5_6, ++var3_8) {
                                    var13_4[var3_8] = (byte)var10_12;
                                }
                                var5_6 = var3_8;
                                ** GOTO lbl63
                            }
                            var5_6 = var9_11 + 1;
                            var11_13 = var2_2[var9_11] & 255;
                            if (var11_13 == 1) {
                                return var13_4;
                            }
                            if (var11_13 == 0) ** GOTO lbl48
                            if (var11_13 != 2) {
                                if (var1_1) {
                                    var9_11 = var11_13;
                                    do {
                                        var7_9 = var3_8++;
                                        var8_10 = var5_6;
                                        if (var9_11 != 0) {
                                            var13_4[var3_8] = (byte)(var2_2[var5_6] & 255);
                                            --var9_11;
                                            ++var5_6;
                                            continue;
                                        }
                                        break block22;
                                        break;
                                    } while (true);
                                }
                            } else {
                                var3_8 = var5_6 + 1;
                                var4_7 += var2_2[var5_6] & 255;
                                var5_6 = var3_8 + 1;
                                var6_5 += var2_2[var3_8] & 255;
                                try {
                                    var3_8 = this.width * var6_5 + var4_7;
                                }
                                catch (RuntimeException var2_3) {
                                    return var13_4;
                                }
lbl48: // 1 sources:
                                ++var6_5;
                                var3_8 = this.width;
                                var3_8 *= var6_5;
                                var4_7 = 0;
lbl54: // 1 sources:
                                var7_9 = 0;
                                do {
                                    var5_6 = var3_8;
                                    if (var7_9 >= var8_10) break;
                                    var5_6 = (var7_9 & 1) == 1 ? var10_12 & 15 : var10_12 >>> 4 & 15;
                                    var13_4[var3_8] = (byte)var5_6;
                                    ++var7_9;
                                    ++var3_8;
                                } while (true);
lbl63: // 2 sources:
                                var4_7 += var8_10;
                                var7_9 = var9_11 + 1;
                                var3_8 = var5_6;
                                var5_6 = var7_9;
                                continue;
                            }
                            var9_11 = 0;
                            var10_12 = 0;
                            do {
                                var7_9 = var3_8;
                                var8_10 = var5_6;
                                if (var9_11 >= var11_13) break;
                                var12_14 = var9_11 & 1;
                                var7_9 = var5_6;
                                var8_10 = var10_12;
                                if (var12_14 == 0) {
                                    var8_10 = var2_2[var5_6] & 255;
                                    var7_9 = var5_6 + 1;
                                }
                                var5_6 = var12_14 == 1 ? var8_10 & 15 : var8_10 >>> 4 & 15;
                                var13_4[var3_8] = (byte)var5_6;
                                ++var9_11;
                                ++var3_8;
                                var5_6 = var7_9;
                                var10_12 = var8_10;
                            } while (true);
                        }
                        var4_7 += var11_13;
                        if (!var1_1) break block24;
                        var3_8 = var8_10;
                        if ((var11_13 & 1) == 1) {
                            var3_8 = var8_10 + 1;
                        }
                        break block25;
                    }
                    var5_6 = var11_13 & 3;
                    if (var5_6 == 1) break block26;
                    var3_8 = var8_10;
                    if (var5_6 != 2) break block25;
                }
                var3_8 = var8_10 + 1;
            }
            var5_6 = var3_8;
            var3_8 = var7_9;
        } while (true);
    }

    private int findMask(int n) {
        int n2 = 0;
        int n3 = n;
        for (n = n2; n < 32; ++n) {
            if ((n3 & 1) == 1) {
                return n3;
            }
            n3 >>>= 1;
        }
        return n3;
    }

    private int findShift(int n) {
        int n2 = 0;
        int n3 = n;
        for (n = n2; n < 32; ++n) {
            if ((n3 & 1) == 1) {
                return n;
            }
            n3 >>>= 1;
        }
        return n;
    }

    private Image getImage() throws IOException, BadElementException {
        switch (this.imageType) {
            default: {
                return null;
            }
            case 15: {
                return this.read1632Bit(true);
            }
            case 14: {
                byte[] arrby = new byte[this.width * this.height * 3];
                this.read24Bit(arrby);
                return new ImgRaw(this.width, this.height, 3, 8, arrby);
            }
            case 13: {
                return this.read1632Bit(false);
            }
            case 12: {
                switch ((int)this.compression) {
                    default: {
                        throw new RuntimeException("Invalid compression specified for BMP file.");
                    }
                    case 1: {
                        return this.readRLE8();
                    }
                    case 0: 
                }
                return this.read8Bit(4);
            }
            case 11: {
                int n = (int)this.compression;
                if (n != 0) {
                    if (n != 2) {
                        throw new RuntimeException("Invalid compression specified for BMP file.");
                    }
                    return this.readRLE4();
                }
                return this.read4Bit(4);
            }
            case 10: {
                return this.read1Bit(4);
            }
            case 9: {
                return this.read1632Bit(true);
            }
            case 8: {
                return this.read1632Bit(false);
            }
            case 7: {
                byte[] arrby = new byte[this.width * this.height * 3];
                this.read24Bit(arrby);
                return new ImgRaw(this.width, this.height, 3, 8, arrby);
            }
            case 6: {
                switch ((int)this.compression) {
                    default: {
                        throw new RuntimeException("Invalid compression specified for BMP file.");
                    }
                    case 1: {
                        return this.readRLE8();
                    }
                    case 0: 
                }
                return this.read8Bit(4);
            }
            case 5: {
                int n = (int)this.compression;
                if (n != 0) {
                    if (n != 2) {
                        throw new RuntimeException("Invalid compression specified for BMP file.");
                    }
                    return this.readRLE4();
                }
                return this.read4Bit(4);
            }
            case 4: {
                return this.read1Bit(4);
            }
            case 3: {
                byte[] arrby = new byte[this.width * this.height * 3];
                this.read24Bit(arrby);
                return new ImgRaw(this.width, this.height, 3, 8, arrby);
            }
            case 2: {
                return this.read8Bit(3);
            }
            case 1: {
                return this.read4Bit(3);
            }
            case 0: 
        }
        return this.read1Bit(3);
    }

    public static Image getImage(InputStream inputStream) throws IOException {
        return BmpImage.getImage(inputStream, false, 0);
    }

    public static Image getImage(InputStream object, boolean bl, int n) throws IOException {
        object = new BmpImage((InputStream)object, bl, n);
        try {
            Image image = BmpImage.super.getImage();
            image.setDpi((int)((double)object.xPelsPerMeter * 0.0254 + 0.5), (int)((double)object.yPelsPerMeter * 0.0254 + 0.5));
            image.setOriginalType(4);
            return image;
        }
        catch (BadElementException badElementException) {
            throw new ExceptionConverter(badElementException);
        }
    }

    public static Image getImage(String string2) throws IOException {
        return BmpImage.getImage(Utilities.toURL(string2));
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public static Image getImage(URL object) throws IOException {
        Object object2;
        block4 : {
            Image image;
            object2 = object.openStream();
            try {
                image = BmpImage.getImage((InputStream)object2);
                image.setUrl((URL)object);
                if (object2 == null) return image;
            }
            catch (Throwable throwable) {
                object = object2;
                object2 = throwable;
            }
            object2.close();
            return image;
            break block4;
            catch (Throwable throwable) {
                object = null;
            }
        }
        if (object == null) throw object2;
        object.close();
        throw object2;
    }

    public static Image getImage(byte[] arrby) throws IOException {
        Image image = BmpImage.getImage(new ByteArrayInputStream(arrby));
        image.setOriginalData(arrby);
        return image;
    }

    private byte[] getPalette(int n) {
        if (this.palette == null) {
            return null;
        }
        byte[] arrby = new byte[this.palette.length / n * 3];
        int n2 = this.palette.length / n;
        for (int i = 0; i < n2; ++i) {
            int n3 = i * n;
            int n4 = i * 3;
            byte[] arrby2 = this.palette;
            int n5 = n3 + 1;
            arrby[n4 + 2] = arrby2[n3];
            arrby[n4 + 1] = this.palette[n5];
            arrby[n4] = this.palette[n5 + 1];
        }
        return arrby;
    }

    private Image indexedModel(byte[] object, int n, int n2) throws BadElementException {
        object = new ImgRaw(this.width, this.height, 1, n, (byte[])object);
        PdfArray pdfArray = new PdfArray();
        pdfArray.add(PdfName.INDEXED);
        pdfArray.add(PdfName.DEVICERGB);
        Object object2 = this.getPalette(n2);
        pdfArray.add(new PdfNumber(((byte[])object2).length / 3 - 1));
        pdfArray.add(new PdfString((byte[])object2));
        object2 = new PdfDictionary();
        object2.put(PdfName.COLORSPACE, pdfArray);
        object.setAdditional((PdfDictionary)object2);
        return object;
    }

    private Image read1632Bit(boolean bl) throws IOException, BadElementException {
        byte[] arrby;
        int n;
        int n2 = this.findMask(this.redMask);
        int n3 = this.findShift(this.redMask);
        int n4 = n2 + 1;
        int n5 = this.findMask(this.greenMask);
        int n6 = this.findShift(this.greenMask);
        int n7 = n5 + 1;
        int n8 = this.findMask(this.blueMask);
        int n9 = this.findShift(this.blueMask);
        int n10 = n8 + 1;
        arrby = new byte[this.width * this.height * 3];
        n = !bl && (n = this.width * 16) % 32 != 0 ? (int)Math.ceil((double)((n / 32 + 1) * 32 - n) / 8.0) : 0;
        if ((int)this.imageSize == 0) {
            long l = this.bitmapFileSize;
            l = this.bitmapOffset;
        }
        if (this.isBottomUp) {
            int n11 = n;
            n = n6;
            int n12 = n3;
            for (int i = this.height - 1; i >= 0; --i) {
                int n13;
                n3 = this.width * 3 * i;
                for (n13 = 0; n13 < this.width; ++n13) {
                    n6 = bl ? (int)this.readDWord(this.inputStream) : this.readWord(this.inputStream);
                    int n14 = n3 + 1;
                    arrby[n3] = (byte)((n6 >>> n12 & n2) * 256 / n4);
                    int n15 = n14 + 1;
                    arrby[n14] = (byte)((n6 >>> n & n5) * 256 / n7);
                    n3 = n15 + 1;
                    arrby[n15] = (byte)((n6 >>> n9 & n8) * 256 / n10);
                }
                for (n13 = 0; n13 < n11; ++n13) {
                    this.inputStream.read();
                }
            }
        } else {
            int n16 = 0;
            for (int i = 0; i < this.height; ++i) {
                int n17;
                for (n17 = 0; n17 < this.width; ++n17) {
                    int n18 = bl ? (int)this.readDWord(this.inputStream) : this.readWord(this.inputStream);
                    int n19 = n16 + 1;
                    arrby[n16] = (byte)((n18 >>> n3 & n2) * 256 / n4);
                    int n20 = n19 + 1;
                    arrby[n19] = (byte)((n18 >>> n6 & n5) * 256 / n7);
                    n16 = n20 + 1;
                    arrby[n20] = (byte)((n18 >>> n9 & n8) * 256 / n10);
                }
                for (n17 = 0; n17 < n; ++n17) {
                    this.inputStream.read();
                }
            }
        }
        return new ImgRaw(this.width, this.height, 3, 8, arrby);
    }

    private Image read1Bit(int n) throws IOException, BadElementException {
        byte[] arrby;
        arrby = new byte[(this.width + 7) / 8 * this.height];
        int n2 = (int)Math.ceil((double)this.width / 8.0);
        int n3 = n2 % 4;
        int n4 = 0;
        int n5 = 0;
        n3 = n3 != 0 ? 4 - n3 : 0;
        int n6 = n3 + n2;
        int n7 = this.height * n6;
        byte[] arrby2 = new byte[n7];
        for (n3 = 0; n3 < n7; n3 += this.inputStream.read((byte[])arrby2, (int)n3, (int)(n7 - n3))) {
        }
        if (this.isBottomUp) {
            n3 = n5;
            while (n3 < this.height) {
                n5 = n3 + 1;
                System.arraycopy(arrby2, n7 - n5 * n6, arrby, n3 * n2, n2);
                n3 = n5;
            }
        } else {
            for (n3 = n4; n3 < this.height; ++n3) {
                System.arraycopy(arrby2, n3 * n6, arrby, n3 * n2, n2);
            }
        }
        return this.indexedModel(arrby, 1, n);
    }

    private void read24Bit(byte[] arrby) {
        int n;
        int n2 = this.width * 24;
        int n3 = n2 % 32 != 0 ? (int)Math.ceil((double)((n2 / 32 + 1) * 32 - n2) / 8.0) : 0;
        int n4 = (this.width * 3 + 3) / 4 * 4 * this.height;
        byte[] arrby2 = new byte[n4];
        for (n2 = 0; n2 < n4; n2 += n) {
            try {
                n = this.inputStream.read(arrby2, n2, n4 - n2);
                if (n < 0) break;
                continue;
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
        }
        if (this.isBottomUp) {
            int n5 = this.width;
            int n6 = this.height;
            n2 = - n3;
            n4 = 0;
            while (n4 < this.height) {
                int n7 = n4 + 1;
                n = n5 * n6 * 3 - 1 - this.width * n7 * 3 + 1;
                n2 += n3;
                for (n4 = 0; n4 < this.width; ++n4) {
                    int n8 = n2 + 1;
                    arrby[n + 2] = arrby2[n2];
                    int n9 = n8 + 1;
                    arrby[n + 1] = arrby2[n8];
                    n2 = n9 + 1;
                    arrby[n] = arrby2[n9];
                    n += 3;
                }
                n4 = n7;
            }
        } else {
            n2 = - n3;
            n = 0;
            for (n4 = 0; n4 < this.height; ++n4) {
                n2 += n3;
                for (int i = 0; i < this.width; ++i) {
                    int n10 = n2 + 1;
                    arrby[n + 2] = arrby2[n2];
                    int n11 = n10 + 1;
                    arrby[n + 1] = arrby2[n10];
                    n2 = n11 + 1;
                    arrby[n] = arrby2[n11];
                    n += 3;
                }
            }
        }
    }

    private Image read4Bit(int n) throws IOException, BadElementException {
        byte[] arrby;
        arrby = new byte[(this.width + 1) / 2 * this.height];
        int n2 = (int)Math.ceil((double)this.width / 2.0);
        int n3 = n2 % 4;
        int n4 = 0;
        int n5 = 0;
        n3 = n3 != 0 ? 4 - n3 : 0;
        int n6 = n3 + n2;
        int n7 = this.height * n6;
        byte[] arrby2 = new byte[n7];
        for (n3 = 0; n3 < n7; n3 += this.inputStream.read((byte[])arrby2, (int)n3, (int)(n7 - n3))) {
        }
        if (this.isBottomUp) {
            n3 = n5;
            while (n3 < this.height) {
                n5 = n3 + 1;
                System.arraycopy(arrby2, n7 - n5 * n6, arrby, n3 * n2, n2);
                n3 = n5;
            }
        } else {
            for (n3 = n4; n3 < this.height; ++n3) {
                System.arraycopy(arrby2, n3 * n6, arrby, n3 * n2, n2);
            }
        }
        return this.indexedModel(arrby, 4, n);
    }

    private Image read8Bit(int n) throws IOException, BadElementException {
        byte[] arrby;
        int n2;
        arrby = new byte[this.width * this.height];
        int n3 = this.width * 8;
        int n4 = 0;
        int n5 = 0;
        n3 = n3 % 32 != 0 ? (int)Math.ceil((double)((n3 / 32 + 1) * 32 - n3) / 8.0) : 0;
        int n6 = (this.width + n3) * this.height;
        byte[] arrby2 = new byte[n6];
        for (n2 = 0; n2 < n6; n2 += this.inputStream.read((byte[])arrby2, (int)n2, (int)(n6 - n2))) {
        }
        if (this.isBottomUp) {
            n2 = n5;
            while (n2 < this.height) {
                n5 = n2 + 1;
                System.arraycopy(arrby2, n6 - (this.width + n3) * n5, arrby, n2 * this.width, this.width);
                n2 = n5;
            }
        } else {
            for (n2 = n4; n2 < this.height; ++n2) {
                System.arraycopy(arrby2, (this.width + n3) * n2, arrby, this.width * n2, this.width);
            }
        }
        return this.indexedModel(arrby, 8, n);
    }

    private long readDWord(InputStream inputStream) throws IOException {
        return this.readUnsignedInt(inputStream);
    }

    private int readInt(InputStream inputStream) throws IOException {
        int n = this.readUnsignedByte(inputStream);
        int n2 = this.readUnsignedByte(inputStream);
        int n3 = this.readUnsignedByte(inputStream);
        return this.readUnsignedByte(inputStream) << 24 | n3 << 16 | n2 << 8 | n;
    }

    private int readLong(InputStream inputStream) throws IOException {
        return this.readInt(inputStream);
    }

    private void readPalette(int n) throws IOException {
        int n2;
        if (n == 0) {
            return;
        }
        this.palette = new byte[n];
        for (int i = 0; i < n; i += n2) {
            n2 = this.inputStream.read(this.palette, i, n - i);
            if (n2 >= 0) continue;
            throw new RuntimeException(MessageLocalization.getComposedMessage("incomplete.palette", new Object[0]));
        }
        this.properties.put("palette", this.palette);
    }

    private Image readRLE4() throws IOException, BadElementException {
        int n;
        int n2;
        int n3;
        int n4;
        int n5 = n2 = (int)this.imageSize;
        if (n2 == 0) {
            n5 = (int)(this.bitmapFileSize - this.bitmapOffset);
        }
        byte[] arrby = new byte[n5];
        for (n2 = 0; n2 < n5; n2 += this.inputStream.read((byte[])arrby, (int)n2, (int)(n5 - n2))) {
        }
        byte[] arrby2 = this.decodeRLE(false, arrby);
        arrby = arrby2;
        if (this.isBottomUp) {
            arrby = new byte[this.width * this.height];
            n2 = this.height - 1;
            n5 = 0;
            do {
                n = n5;
                if (n2 < 0) break;
                n4 = this.width * n2;
                n3 = this.width;
                n5 = n;
                while (n5 != n3 + n) {
                    arrby[n5] = arrby2[n4];
                    ++n5;
                    ++n4;
                }
                --n2;
            } while (true);
        }
        n3 = (this.width + 1) / 2;
        arrby2 = new byte[this.height * n3];
        n5 = 0;
        n = 0;
        for (n2 = 0; n2 < this.height; ++n2) {
            for (n4 = 0; n4 < this.width; ++n4) {
                if ((n4 & 1) == 0) {
                    arrby2[n4 / 2 + n] = (byte)(arrby[n5] << 4);
                    ++n5;
                    continue;
                }
                int n6 = n4 / 2 + n;
                byte by = arrby2[n6];
                arrby2[n6] = (byte)((byte)(arrby[n5] & 15) | by);
                ++n5;
            }
            n += n3;
        }
        return this.indexedModel(arrby2, 4, 4);
    }

    private Image readRLE8() throws IOException, BadElementException {
        int n;
        int n2 = n = (int)this.imageSize;
        if (n == 0) {
            n2 = (int)(this.bitmapFileSize - this.bitmapOffset);
        }
        byte[] arrby = new byte[n2];
        int n3 = 0;
        for (n = 0; n < n2; n += this.inputStream.read((byte[])arrby, (int)n, (int)(n2 - n))) {
        }
        byte[] arrby2 = this.decodeRLE(true, arrby);
        int n4 = this.width;
        int n5 = this.height;
        arrby = arrby2;
        if (this.isBottomUp) {
            arrby = new byte[arrby2.length];
            int n6 = this.width;
            n2 = n3;
            while (n2 < this.height) {
                n = n2 + 1;
                System.arraycopy(arrby2, n4 * n5 - n * n6, arrby, n2 * n6, n6);
                n2 = n;
            }
        }
        return this.indexedModel(arrby, 8, 4);
    }

    private int readShort(InputStream inputStream) throws IOException {
        int n = this.readUnsignedByte(inputStream);
        return this.readUnsignedByte(inputStream) << 8 | n;
    }

    private int readUnsignedByte(InputStream inputStream) throws IOException {
        return inputStream.read() & 255;
    }

    private long readUnsignedInt(InputStream inputStream) throws IOException {
        int n = this.readUnsignedByte(inputStream);
        int n2 = this.readUnsignedByte(inputStream);
        int n3 = this.readUnsignedByte(inputStream);
        return (long)(this.readUnsignedByte(inputStream) << 24 | n3 << 16 | n2 << 8 | n) & -1L;
    }

    private int readUnsignedShort(InputStream inputStream) throws IOException {
        int n = this.readUnsignedByte(inputStream);
        return (this.readUnsignedByte(inputStream) << 8 | n) & 65535;
    }

    private int readWord(InputStream inputStream) throws IOException {
        return this.readUnsignedShort(inputStream);
    }

    protected void process(InputStream arrby, boolean bl) throws IOException {
        int n;
        int n2;
        int n3;
        block97 : {
            long l;
            long l2;
            long l3;
            block98 : {
                block99 : {
                    block96 : {
                        this.inputStream = !bl && !(arrby instanceof BufferedInputStream) ? new BufferedInputStream((InputStream)arrby) : arrby;
                        if (!bl) {
                            if (this.readUnsignedByte(this.inputStream) == 66 && this.readUnsignedByte(this.inputStream) == 77) {
                                this.bitmapFileSize = this.readDWord(this.inputStream);
                                this.readWord(this.inputStream);
                                this.readWord(this.inputStream);
                                this.bitmapOffset = this.readDWord(this.inputStream);
                            } else {
                                throw new RuntimeException(MessageLocalization.getComposedMessage("invalid.magic.value.for.bmp.file", new Object[0]));
                            }
                        }
                        if ((l = this.readDWord(this.inputStream)) == 12L) {
                            this.width = this.readWord(this.inputStream);
                            this.height = this.readWord(this.inputStream);
                        } else {
                            this.width = this.readLong(this.inputStream);
                            this.height = this.readLong(this.inputStream);
                        }
                        n3 = this.readWord(this.inputStream);
                        this.bitsPerPixel = this.readWord(this.inputStream);
                        this.properties.put("color_planes", n3);
                        this.properties.put("bits_per_pixel", this.bitsPerPixel);
                        this.numBands = 3;
                        if (this.bitmapOffset == 0L) {
                            this.bitmapOffset = l;
                        }
                        if (l != 12L) break block96;
                        this.properties.put("bmp_version", "BMP v. 2.x");
                        if (this.bitsPerPixel == 1) {
                            this.imageType = 0;
                        } else if (this.bitsPerPixel == 4) {
                            this.imageType = 1;
                        } else if (this.bitsPerPixel == 8) {
                            this.imageType = 2;
                        } else if (this.bitsPerPixel == 24) {
                            this.imageType = 3;
                        }
                        n = n3 = (int)((this.bitmapOffset - 14L - l) / 3L) * 3;
                        if (this.bitmapOffset == l) {
                            switch (this.imageType) {
                                default: {
                                    break;
                                }
                                case 3: {
                                    n3 = 0;
                                    break;
                                }
                                case 2: {
                                    n3 = 768;
                                    break;
                                }
                                case 1: {
                                    n3 = 48;
                                    break;
                                }
                                case 0: {
                                    n3 = 6;
                                }
                            }
                            this.bitmapOffset = l + (long)n3;
                            n = n3;
                        }
                        this.readPalette(n);
                        break block97;
                    }
                    this.compression = this.readDWord(this.inputStream);
                    this.imageSize = this.readDWord(this.inputStream);
                    this.xPelsPerMeter = this.readLong(this.inputStream);
                    this.yPelsPerMeter = this.readLong(this.inputStream);
                    l3 = this.readDWord(this.inputStream);
                    l2 = this.readDWord(this.inputStream);
                    switch ((int)this.compression) {
                        default: {
                            break;
                        }
                        case 3: {
                            this.properties.put("compression", "BI_BITFIELDS");
                            break;
                        }
                        case 2: {
                            this.properties.put("compression", "BI_RLE4");
                            break;
                        }
                        case 1: {
                            this.properties.put("compression", "BI_RLE8");
                            break;
                        }
                        case 0: {
                            this.properties.put("compression", "BI_RGB");
                        }
                    }
                    this.properties.put("x_pixels_per_meter", this.xPelsPerMeter);
                    this.properties.put("y_pixels_per_meter", this.yPelsPerMeter);
                    this.properties.put("colors_used", l3);
                    this.properties.put("colors_important", l2);
                    if (l == 40L || l == 52L || l == 56L) break block98;
                    if (l != 108L) break block99;
                    this.properties.put("bmp_version", "BMP v. 4.x");
                    this.redMask = (int)this.readDWord(this.inputStream);
                    this.greenMask = (int)this.readDWord(this.inputStream);
                    this.blueMask = (int)this.readDWord(this.inputStream);
                    this.alphaMask = (int)this.readDWord(this.inputStream);
                    long l4 = this.readDWord(this.inputStream);
                    n = this.readLong(this.inputStream);
                    n2 = this.readLong(this.inputStream);
                    int n4 = this.readLong(this.inputStream);
                    int n5 = this.readLong(this.inputStream);
                    int n6 = this.readLong(this.inputStream);
                    int n7 = this.readLong(this.inputStream);
                    int n8 = this.readLong(this.inputStream);
                    int n9 = this.readLong(this.inputStream);
                    int n10 = this.readLong(this.inputStream);
                    long l5 = this.readDWord(this.inputStream);
                    long l6 = this.readDWord(this.inputStream);
                    long l7 = this.readDWord(this.inputStream);
                    if (this.bitsPerPixel == 1) {
                        this.imageType = 10;
                    } else if (this.bitsPerPixel == 4) {
                        this.imageType = 11;
                    } else if (this.bitsPerPixel == 8) {
                        this.imageType = 12;
                    } else if (this.bitsPerPixel == 16) {
                        this.imageType = 13;
                        if ((int)this.compression == 0) {
                            this.redMask = 31744;
                            this.greenMask = 992;
                            this.blueMask = 31;
                        }
                    } else if (this.bitsPerPixel == 24) {
                        this.imageType = 14;
                    } else if (this.bitsPerPixel == 32) {
                        this.imageType = 15;
                        if ((int)this.compression == 0) {
                            this.redMask = 16711680;
                            this.greenMask = 65280;
                            this.blueMask = 255;
                        }
                    }
                    this.properties.put("red_mask", this.redMask);
                    this.properties.put("green_mask", this.greenMask);
                    this.properties.put("blue_mask", this.blueMask);
                    this.properties.put("alpha_mask", this.alphaMask);
                    n3 = (int)((this.bitmapOffset - 14L - l) / 4L) * 4;
                    if (this.bitmapOffset == l) {
                        switch (this.imageType) {
                            default: {
                                n3 = 0;
                                break;
                            }
                            case 12: {
                                l2 = l3;
                                if (l3 == 0L) {
                                    l2 = 256L;
                                }
                                n3 = (int)l2 * 4;
                                break;
                            }
                            case 11: {
                                l2 = l3;
                                if (l3 == 0L) {
                                    l2 = 16L;
                                }
                                n3 = (int)l2 * 4;
                                break;
                            }
                            case 10: {
                                l2 = l3;
                                if (l3 == 0L) {
                                    l2 = 2L;
                                }
                                n3 = (int)l2 * 4;
                            }
                        }
                        this.bitmapOffset = l + (long)n3;
                    }
                    this.readPalette(n3);
                    switch ((int)l4) {
                        default: {
                            break block97;
                        }
                        case 2: {
                            this.properties.put("color_space", "LCS_CMYK");
                            throw new RuntimeException("Not implemented yet.");
                        }
                        case 1: {
                            this.properties.put("color_space", "LCS_sRGB");
                            break block97;
                        }
                        case 0: {
                            this.properties.put("color_space", "LCS_CALIBRATED_RGB");
                            this.properties.put("redX", n);
                            this.properties.put("redY", n2);
                            this.properties.put("redZ", n4);
                            this.properties.put("greenX", n5);
                            this.properties.put("greenY", n6);
                            this.properties.put("greenZ", n7);
                            this.properties.put("blueX", n8);
                            this.properties.put("blueY", n9);
                            this.properties.put("blueZ", n10);
                            this.properties.put("gamma_red", l5);
                            this.properties.put("gamma_green", l6);
                            this.properties.put("gamma_blue", l7);
                            throw new RuntimeException("Not implemented yet.");
                        }
                    }
                }
                this.properties.put("bmp_version", "BMP v. 5.x");
                throw new RuntimeException("BMP version 5 not implemented yet.");
            }
            switch ((int)this.compression) {
                default: {
                    throw new RuntimeException("Invalid compression specified in BMP file.");
                }
                case 3: {
                    if (this.bitsPerPixel == 16) {
                        this.imageType = 8;
                    } else if (this.bitsPerPixel == 32) {
                        this.imageType = 9;
                    }
                    this.redMask = (int)this.readDWord(this.inputStream);
                    this.greenMask = (int)this.readDWord(this.inputStream);
                    this.blueMask = (int)this.readDWord(this.inputStream);
                    if (l == 56L) {
                        this.alphaMask = (int)this.readDWord(this.inputStream);
                        this.properties.put("alpha_mask", this.alphaMask);
                    }
                    this.properties.put("red_mask", this.redMask);
                    this.properties.put("green_mask", this.greenMask);
                    this.properties.put("blue_mask", this.blueMask);
                    if (l3 != 0L) {
                        this.readPalette((int)l3 * 4);
                    }
                    this.properties.put("bmp_version", "BMP v. 3.x NT");
                    break;
                }
                case 0: 
                case 1: 
                case 2: {
                    if (this.bitsPerPixel == 1) {
                        this.imageType = 4;
                    } else if (this.bitsPerPixel == 4) {
                        this.imageType = 5;
                    } else if (this.bitsPerPixel == 8) {
                        this.imageType = 6;
                    } else if (this.bitsPerPixel == 24) {
                        this.imageType = 7;
                    } else if (this.bitsPerPixel == 16) {
                        this.imageType = 8;
                        this.redMask = 31744;
                        this.greenMask = 992;
                        this.blueMask = 31;
                        this.properties.put("red_mask", this.redMask);
                        this.properties.put("green_mask", this.greenMask);
                        this.properties.put("blue_mask", this.blueMask);
                    } else if (this.bitsPerPixel == 32) {
                        this.imageType = 9;
                        this.redMask = 16711680;
                        this.greenMask = 65280;
                        this.blueMask = 255;
                        this.properties.put("red_mask", this.redMask);
                        this.properties.put("green_mask", this.greenMask);
                        this.properties.put("blue_mask", this.blueMask);
                    }
                    if (l >= 52L) {
                        this.redMask = (int)this.readDWord(this.inputStream);
                        this.greenMask = (int)this.readDWord(this.inputStream);
                        this.blueMask = (int)this.readDWord(this.inputStream);
                        this.properties.put("red_mask", this.redMask);
                        this.properties.put("green_mask", this.greenMask);
                        this.properties.put("blue_mask", this.blueMask);
                    }
                    if (l == 56L) {
                        this.alphaMask = (int)this.readDWord(this.inputStream);
                        this.properties.put("alpha_mask", this.alphaMask);
                    }
                    n3 = (int)((this.bitmapOffset - 14L - l) / 4L) * 4;
                    if (this.bitmapOffset == l) {
                        switch (this.imageType) {
                            default: {
                                n3 = 0;
                                break;
                            }
                            case 6: {
                                l2 = l3;
                                if (l3 == 0L) {
                                    l2 = 256L;
                                }
                                n3 = (int)l2 * 4;
                                break;
                            }
                            case 5: {
                                l2 = l3;
                                if (l3 == 0L) {
                                    l2 = 16L;
                                }
                                n3 = (int)l2 * 4;
                                break;
                            }
                            case 4: {
                                l2 = l3;
                                if (l3 == 0L) {
                                    l2 = 2L;
                                }
                                n3 = (int)l2 * 4;
                            }
                        }
                        this.bitmapOffset = l + (long)n3;
                    }
                    this.readPalette(n3);
                    this.properties.put("bmp_version", "BMP v. 3.x");
                }
            }
        }
        if (this.height > 0) {
            this.isBottomUp = true;
        } else {
            this.isBottomUp = false;
            this.height = Math.abs(this.height);
        }
        n2 = 0;
        n = 0;
        if (this.bitsPerPixel != 1 && this.bitsPerPixel != 4 && this.bitsPerPixel != 8) {
            if (this.bitsPerPixel == 16) {
                this.numBands = 3;
                return;
            }
            n3 = 3;
            if (this.bitsPerPixel == 32) {
                if (this.alphaMask != 0) {
                    n3 = 4;
                }
                this.numBands = n3;
                return;
            }
            this.numBands = 3;
            return;
        }
        this.numBands = 1;
        if (this.imageType != 0 && this.imageType != 1 && this.imageType != 2) {
            n3 = n2 = this.palette.length / 4;
            if (n2 > 256) {
                n3 = 256;
            }
            arrby = new byte[n3];
            byte[] arrby2 = new byte[n3];
            byte[] arrby3 = new byte[n3];
            while (n < n3) {
                n2 = n * 4;
                arrby3[n] = this.palette[n2];
                arrby2[n] = this.palette[n2 + 1];
                arrby[n] = this.palette[n2 + 2];
                ++n;
            }
        } else {
            n3 = n = this.palette.length / 3;
            if (n > 256) {
                n3 = 256;
            }
            arrby = new byte[n3];
            byte[] arrby4 = new byte[n3];
            byte[] arrby5 = new byte[n3];
            for (n = n2; n < n3; ++n) {
                n2 = n * 3;
                arrby5[n] = this.palette[n2];
                arrby4[n] = this.palette[n2 + 1];
                arrby[n] = this.palette[n2 + 2];
            }
        }
    }
}

