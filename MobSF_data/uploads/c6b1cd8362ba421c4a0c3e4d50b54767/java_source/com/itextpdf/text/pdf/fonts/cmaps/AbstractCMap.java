/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.fonts.cmaps;

import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfString;

public abstract class AbstractCMap {
    private String cmapName;
    private String ordering;
    private String registry;
    private int supplement;

    private static int byteArrayToInt(byte[] arrby) {
        int n = 0;
        for (int i = 0; i < arrby.length; ++i) {
            n = n << 8 | arrby[i] & 255;
        }
        return n;
    }

    public static byte[] decodeStringToByte(PdfString arrby) {
        arrby = arrby.getBytes();
        byte[] arrby2 = new byte[arrby.length];
        System.arraycopy(arrby, 0, arrby2, 0, arrby.length);
        return arrby2;
    }

    private static void intToByteArray(int n, byte[] arrby) {
        int n2 = arrby.length - 1;
        int n3 = n;
        for (n = n2; n >= 0; --n) {
            arrby[n] = (byte)n3;
            n3 >>>= 8;
        }
    }

    abstract void addChar(PdfString var1, PdfObject var2);

    void addRange(PdfString arrby, PdfString object, PdfObject pdfObject) {
        byte[] arrby2 = AbstractCMap.decodeStringToByte((PdfString)arrby);
        if (arrby2.length == ((byte[])(object = AbstractCMap.decodeStringToByte((PdfString)object))).length && arrby2.length != 0) {
            arrby = null;
            boolean bl = pdfObject instanceof PdfString;
            if (bl) {
                arrby = AbstractCMap.decodeStringToByte((PdfString)pdfObject);
            }
            int n = AbstractCMap.byteArrayToInt(arrby2);
            int n2 = AbstractCMap.byteArrayToInt((byte[])object);
            for (int i = n; i <= n2; ++i) {
                AbstractCMap.intToByteArray(i, arrby2);
                object = new PdfString(arrby2);
                object.setHexWriting(true);
                if (pdfObject instanceof PdfArray) {
                    this.addChar((PdfString)object, ((PdfArray)pdfObject).getPdfObject(i - n));
                    continue;
                }
                if (pdfObject instanceof PdfNumber) {
                    this.addChar((PdfString)object, new PdfNumber(((PdfNumber)pdfObject).intValue() + i - n));
                    continue;
                }
                if (!bl) continue;
                PdfString pdfString = new PdfString(arrby);
                pdfString.setHexWriting(true);
                int n3 = arrby.length - 1;
                arrby[n3] = (byte)(arrby[n3] + 1);
                this.addChar((PdfString)object, pdfString);
            }
            return;
        }
        throw new IllegalArgumentException("Invalid map.");
    }

    public String decodeStringToUnicode(PdfString pdfString) {
        if (pdfString.isHexWriting()) {
            return PdfEncodings.convertToString(pdfString.getBytes(), "UnicodeBigUnmarked");
        }
        return pdfString.toUnicodeString();
    }

    public String getName() {
        return this.cmapName;
    }

    public String getOrdering() {
        return this.ordering;
    }

    public String getRegistry() {
        return this.registry;
    }

    public int getSupplement() {
        return this.supplement;
    }

    void setName(String string2) {
        this.cmapName = string2;
    }

    void setOrdering(String string2) {
        this.ordering = string2;
    }

    void setRegistry(String string2) {
        this.registry = string2;
    }

    void setSupplement(int n) {
        this.supplement = n;
    }
}

