/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BadPdfFormatException;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfCopy;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNull;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfStructureTreeRoot;
import com.itextpdf.text.pdf.RefKey;
import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class PdfStructTreeController {
    private PdfIndirectReference nullReference = null;
    private PdfDictionary parentTree;
    protected PdfReader reader;
    private PdfDictionary roleMap = null;
    private PdfDictionary sourceClassMap = null;
    private PdfDictionary sourceRoleMap = null;
    private PdfDictionary structTreeRoot;
    private PdfStructureTreeRoot structureTreeRoot;
    private PdfCopy writer;

    protected PdfStructTreeController(PdfReader pdfReader, PdfCopy pdfCopy) throws BadPdfFormatException {
        if (!pdfCopy.isTagged()) {
            throw new BadPdfFormatException(MessageLocalization.getComposedMessage("no.structtreeroot.found", new Object[0]));
        }
        this.writer = pdfCopy;
        this.structureTreeRoot = pdfCopy.getStructureTreeRoot();
        this.structureTreeRoot.put(PdfName.PARENTTREE, new PdfDictionary(PdfName.STRUCTELEM));
        this.setReader(pdfReader);
    }

    private void addKid(PdfObject pdfObject) throws IOException, BadPdfFormatException {
        if (!pdfObject.isIndirect()) {
            return;
        }
        RefKey refKey = new RefKey((PRIndirectReference)(pdfObject = (PRIndirectReference)pdfObject));
        if (!this.writer.indirects.containsKey(refKey)) {
            this.writer.copyIndirect((PRIndirectReference)pdfObject, true, false);
        }
        pdfObject = this.writer.indirects.get(refKey).getRef();
        if (this.writer.updateRootKids) {
            this.addKid(this.structureTreeRoot, pdfObject);
            this.writer.structureTreeRootKidsForReaderImported(this.reader);
        }
    }

    public static boolean checkTagged(PdfReader object) {
        if ((object = PdfStructTreeController.getDirectObject(object.getCatalog().get(PdfName.STRUCTTREEROOT))) != null) {
            if (!object.isDictionary()) {
                return false;
            }
            if ((object = PdfStructTreeController.getDirectObject(((PdfDictionary)object).get(PdfName.PARENTTREE))) != null) {
                if (!object.isDictionary()) {
                    return false;
                }
                return true;
            }
            return false;
        }
        return false;
    }

    public static boolean compareObjects(PdfObject pdfObject, PdfObject pdfObject2) {
        block24 : {
            block25 : {
                boolean bl;
                block27 : {
                    block26 : {
                        pdfObject2 = PdfStructTreeController.getDirectObject(pdfObject2);
                        boolean bl2 = false;
                        boolean bl3 = false;
                        bl = false;
                        if (pdfObject2 == null) {
                            return false;
                        }
                        if (pdfObject.type() != pdfObject2.type()) {
                            return false;
                        }
                        if (pdfObject.isBoolean()) {
                            if (pdfObject == pdfObject2) {
                                return true;
                            }
                            if (pdfObject2 instanceof PdfBoolean) {
                                if (((PdfBoolean)pdfObject).booleanValue() == ((PdfBoolean)pdfObject2).booleanValue()) {
                                    bl = true;
                                }
                                return bl;
                            }
                            return false;
                        }
                        if (pdfObject.isName()) {
                            return pdfObject.equals(pdfObject2);
                        }
                        if (pdfObject.isNumber()) {
                            if (pdfObject == pdfObject2) {
                                return true;
                            }
                            if (pdfObject2 instanceof PdfNumber) {
                                bl = bl2;
                                if (((PdfNumber)pdfObject).doubleValue() == ((PdfNumber)pdfObject2).doubleValue()) {
                                    bl = true;
                                }
                                return bl;
                            }
                            return false;
                        }
                        if (pdfObject.isNull()) {
                            if (pdfObject == pdfObject2) {
                                return true;
                            }
                            if (pdfObject2 instanceof PdfNull) {
                                return true;
                            }
                            return false;
                        }
                        if (!pdfObject.isString()) break block24;
                        if (pdfObject == pdfObject2) {
                            return true;
                        }
                        if (!(pdfObject2 instanceof PdfString)) break block25;
                        pdfObject2 = (PdfString)pdfObject2;
                        if (pdfObject2.value == null && ((PdfString)pdfObject).value == null) break block26;
                        pdfObject = (PdfString)pdfObject;
                        bl = bl3;
                        if (pdfObject.value == null) break block27;
                        bl = bl3;
                        if (!pdfObject.value.equals(pdfObject2.value)) break block27;
                    }
                    bl = true;
                }
                return bl;
            }
            return false;
        }
        if (pdfObject.isArray()) {
            pdfObject = (PdfArray)pdfObject;
            pdfObject2 = (PdfArray)pdfObject2;
            if (pdfObject.size() != pdfObject2.size()) {
                return false;
            }
            for (int i = 0; i < pdfObject.size(); ++i) {
                if (PdfStructTreeController.compareObjects(pdfObject.getPdfObject(i), pdfObject2.getPdfObject(i))) continue;
                return false;
            }
            return true;
        }
        if (pdfObject.isDictionary()) {
            pdfObject = (PdfDictionary)pdfObject;
            pdfObject2 = (PdfDictionary)pdfObject2;
            if (pdfObject.size() != pdfObject2.size()) {
                return false;
            }
            for (PdfName pdfName : pdfObject.hashMap.keySet()) {
                if (PdfStructTreeController.compareObjects(pdfObject.get(pdfName), pdfObject2.get(pdfName))) continue;
                return false;
            }
            return true;
        }
        return false;
    }

    private returnType copyPageMarks(PdfDictionary pdfObject, PdfNumber pdfNumber, int n) throws BadPdfFormatException, IOException {
        PdfObject pdfObject2 = (PdfArray)PdfStructTreeController.getDirectObject(pdfObject.get(PdfName.NUMS));
        if (pdfObject2 == null) {
            if ((pdfObject = (PdfArray)PdfStructTreeController.getDirectObject(pdfObject.get(PdfName.KIDS))) == null) {
                return returnType.NOTFOUND;
            }
            int n2 = pdfObject.size() / 2;
            int n3 = 0;
            block5 : do {
                int n4 = n2 + n3;
                pdfObject2 = (PdfDictionary)PdfStructTreeController.getDirectObject(pdfObject.getPdfObject(n4));
                switch (.$SwitchMap$com$itextpdf$text$pdf$PdfStructTreeController$returnType[this.copyPageMarks((PdfDictionary)pdfObject2, pdfNumber, n).ordinal()]) {
                    default: {
                        return returnType.NOTFOUND;
                    }
                    case 3: {
                        if (n4 == 0) {
                            return returnType.BELOW;
                        }
                        if (n2 == 0) {
                            return returnType.NOTFOUND;
                        }
                        n2 /= 2;
                        continue block5;
                    }
                    case 2: {
                        n2 = n3 = n2 / 2;
                        if (n3 == 0) {
                            n2 = 1;
                        }
                        if (n2 + n4 == pdfObject.size()) {
                            return returnType.ABOVE;
                        }
                        n3 = n4;
                        continue block5;
                    }
                    case 1: 
                }
                break;
            } while (true);
            return returnType.FOUND;
        }
        if (pdfObject2.size() == 0) {
            return returnType.NOTFOUND;
        }
        return this.findAndCopyMarks((PdfArray)pdfObject2, pdfNumber.intValue(), n);
    }

    private returnType findAndCopyMarks(PdfArray pdfObject, int n, int n2) throws BadPdfFormatException, IOException {
        if (pdfObject.getAsNumber(0).intValue() > n) {
            return returnType.BELOW;
        }
        if (pdfObject.getAsNumber(pdfObject.size() - 2).intValue() < n) {
            return returnType.ABOVE;
        }
        int n3 = pdfObject.size() / 4;
        int n4 = 0;
        do {
            int n5;
            int n6;
            int n7;
            block18 : {
                block21 : {
                    block20 : {
                        PdfObject pdfObject2;
                        block19 : {
                            if ((n6 = pdfObject.getAsNumber(n5 = (n7 = n4 + n3) * 2).intValue()) != n) break block18;
                            pdfObject = pdfObject2 = pdfObject.getPdfObject(n5 + 1);
                            while (pdfObject.isIndirect()) {
                                pdfObject = PdfReader.getPdfObjectRelease(pdfObject);
                            }
                            if (!pdfObject.isArray()) break block19;
                            pdfObject2 = null;
                            Iterator<PdfObject> iterator = ((PdfArray)pdfObject).iterator();
                            pdfObject = pdfObject2;
                            while (iterator.hasNext()) {
                                pdfObject2 = iterator.next();
                                if (pdfObject2.isNull()) {
                                    if (this.nullReference == null) {
                                        this.nullReference = this.writer.addToBody(new PdfNull()).getIndirectReference();
                                    }
                                    this.structureTreeRoot.setPageMark(n2, this.nullReference);
                                    continue;
                                }
                                PdfObject pdfObject3 = this.writer.copyObject(pdfObject2, true, false);
                                pdfObject2 = pdfObject;
                                if (pdfObject == null) {
                                    pdfObject2 = pdfObject3;
                                }
                                this.structureTreeRoot.setPageMark(n2, (PdfIndirectReference)pdfObject3);
                                pdfObject = pdfObject2;
                            }
                            this.attachStructTreeRootKids(pdfObject);
                            break block20;
                        }
                        if (!pdfObject.isDictionary()) break block21;
                        if (PdfStructTreeController.getKDict((PdfDictionary)pdfObject) == null) {
                            return returnType.NOTFOUND;
                        }
                        pdfObject = this.writer.copyObject(pdfObject2, true, false);
                        this.structureTreeRoot.setAnnotationMark(n2, (PdfIndirectReference)pdfObject);
                    }
                    return returnType.FOUND;
                }
                return returnType.NOTFOUND;
            }
            if (n6 < n) {
                if (n3 == 0) {
                    return returnType.NOTFOUND;
                }
                n5 = n3;
                if (n3 != 1) {
                    n5 = n3 / 2;
                }
                if (n5 + n7 == pdfObject.size()) {
                    return returnType.NOTFOUND;
                }
                n4 = n7;
                n3 = n5;
                continue;
            }
            if (n7 == 0) {
                return returnType.BELOW;
            }
            if (n3 == 0) {
                return returnType.NOTFOUND;
            }
            n3 /= 2;
        } while (true);
    }

    private static PdfArray getDirectArray(PdfArray pdfArray) {
        PdfArray pdfArray2 = new PdfArray();
        for (int i = 0; i < pdfArray.size(); ++i) {
            PdfObject pdfObject = PdfStructTreeController.getDirectObject(pdfArray.getPdfObject(i));
            if (pdfObject == null) continue;
            if (pdfObject.isArray()) {
                pdfArray2.add(PdfStructTreeController.getDirectArray((PdfArray)pdfObject));
                continue;
            }
            if (pdfObject.isDictionary()) {
                pdfArray2.add(PdfStructTreeController.getDirectDict((PdfDictionary)pdfObject));
                continue;
            }
            pdfArray2.add(pdfObject);
        }
        return pdfArray2;
    }

    private static PdfDictionary getDirectDict(PdfDictionary object) {
        PdfDictionary pdfDictionary = new PdfDictionary();
        for (Map.Entry<PdfName, PdfObject> entry : object.hashMap.entrySet()) {
            PdfObject pdfObject = PdfStructTreeController.getDirectObject(entry.getValue());
            if (pdfObject == null) continue;
            if (pdfObject.isArray()) {
                pdfDictionary.put(entry.getKey(), PdfStructTreeController.getDirectArray((PdfArray)pdfObject));
                continue;
            }
            if (pdfObject.isDictionary()) {
                pdfDictionary.put(entry.getKey(), PdfStructTreeController.getDirectDict((PdfDictionary)pdfObject));
                continue;
            }
            pdfDictionary.put(entry.getKey(), pdfObject);
        }
        return pdfDictionary;
    }

    public static PdfObject getDirectObject(PdfObject pdfObject) {
        PdfObject pdfObject2 = pdfObject;
        if (pdfObject == null) {
            return null;
        }
        while (pdfObject2.isIndirect()) {
            pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject2);
        }
        return pdfObject2;
    }

    static PdfDictionary getKDict(PdfDictionary pdfObject) {
        PdfDictionary pdfDictionary = pdfObject.getAsDict(PdfName.K);
        if (pdfDictionary != null) {
            if (PdfName.OBJR.equals(pdfDictionary.getAsName(PdfName.TYPE))) {
                return pdfDictionary;
            }
        } else {
            if ((pdfObject = pdfObject.getAsArray(PdfName.K)) == null) {
                return null;
            }
            for (int i = 0; i < pdfObject.size(); ++i) {
                pdfDictionary = pdfObject.getAsDict(i);
                if (pdfDictionary == null || !PdfName.OBJR.equals(pdfDictionary.getAsName(PdfName.TYPE))) continue;
                return pdfDictionary;
            }
        }
        return null;
    }

    protected void addClass(PdfObject pdfObject) throws BadPdfFormatException {
        pdfObject = PdfStructTreeController.getDirectObject(pdfObject);
        boolean bl = pdfObject.isDictionary();
        if (bl) {
            if ((pdfObject = ((PdfDictionary)pdfObject).get(PdfName.C)) == null) {
                return;
            }
            if (pdfObject.isArray()) {
                pdfObject = (PdfArray)pdfObject;
                for (int i = 0; i < pdfObject.size(); ++i) {
                    this.addClass(pdfObject.getPdfObject(i));
                }
            } else if (pdfObject.isName()) {
                this.addClass(pdfObject);
                return;
            }
        } else if (pdfObject.isName()) {
            PdfObject pdfObject2;
            pdfObject = (PdfName)pdfObject;
            if (this.sourceClassMap == null) {
                pdfObject2 = PdfStructTreeController.getDirectObject(this.structTreeRoot.get(PdfName.CLASSMAP));
                if (pdfObject2 != null) {
                    if (!pdfObject2.isDictionary()) {
                        return;
                    }
                    this.sourceClassMap = (PdfDictionary)pdfObject2;
                } else {
                    return;
                }
            }
            if ((pdfObject2 = PdfStructTreeController.getDirectObject(this.sourceClassMap.get((PdfName)pdfObject))) == null) {
                return;
            }
            PdfObject pdfObject3 = this.structureTreeRoot.getMappedClass((PdfName)pdfObject);
            if (pdfObject3 != null) {
                if (!PdfStructTreeController.compareObjects(pdfObject3, pdfObject2)) {
                    throw new BadPdfFormatException(MessageLocalization.getComposedMessage("conflict.in.classmap", pdfObject));
                }
            } else {
                if (pdfObject2.isDictionary()) {
                    this.structureTreeRoot.mapClass((PdfName)pdfObject, PdfStructTreeController.getDirectDict((PdfDictionary)pdfObject2));
                    return;
                }
                if (pdfObject2.isArray()) {
                    this.structureTreeRoot.mapClass((PdfName)pdfObject, PdfStructTreeController.getDirectArray((PdfArray)pdfObject2));
                }
            }
        }
    }

    protected void addKid(PdfDictionary pdfDictionary, PdfObject pdfObject) {
        PdfArray pdfArray;
        PdfObject pdfObject2 = pdfDictionary.get(PdfName.K);
        if (pdfObject2 instanceof PdfArray) {
            pdfArray = (PdfArray)pdfObject2;
        } else {
            pdfArray = new PdfArray();
            if (pdfObject2 != null) {
                pdfArray.add(pdfObject2);
            }
        }
        pdfArray.add(pdfObject);
        pdfDictionary.put(PdfName.K, pdfArray);
    }

    protected void addRole(PdfName pdfName) throws BadPdfFormatException {
        if (pdfName == null) {
            return;
        }
        Object object = this.writer.getStandardStructElems().iterator();
        while (object.hasNext()) {
            if (!object.next().equals(pdfName)) continue;
            return;
        }
        if (this.sourceRoleMap == null) {
            object = PdfStructTreeController.getDirectObject(this.structTreeRoot.get(PdfName.ROLEMAP));
            if (object != null) {
                if (!object.isDictionary()) {
                    return;
                }
                this.sourceRoleMap = (PdfDictionary)object;
            } else {
                return;
            }
        }
        if ((object = this.sourceRoleMap.get(pdfName)) != null) {
            if (!object.isName()) {
                return;
            }
            if (this.roleMap == null) {
                this.roleMap = new PdfDictionary();
                this.structureTreeRoot.put(PdfName.ROLEMAP, this.roleMap);
                this.roleMap.put(pdfName, (PdfObject)object);
                return;
            }
            PdfObject pdfObject = this.roleMap.get(pdfName);
            if (pdfObject != null) {
                if (!pdfObject.equals(object)) {
                    throw new BadPdfFormatException(MessageLocalization.getComposedMessage("conflict.in.rolemap", pdfName));
                }
            } else {
                this.roleMap.put(pdfName, (PdfObject)object);
            }
            return;
        }
    }

    protected void attachStructTreeRootKids(PdfObject object) throws IOException, BadPdfFormatException {
        PdfObject pdfObject = this.structTreeRoot.get(PdfName.K);
        if (pdfObject != null && (pdfObject.isArray() || pdfObject.isIndirect())) {
            if (pdfObject.isIndirect()) {
                this.addKid(pdfObject);
                return;
            }
            object = ((PdfArray)pdfObject).iterator();
            while (object.hasNext()) {
                this.addKid((PdfObject)object.next());
            }
        } else {
            this.addKid(this.structureTreeRoot, (PdfObject)object);
        }
    }

    public void copyStructTreeForPage(PdfNumber pdfNumber, int n) throws BadPdfFormatException, IOException {
        if (this.copyPageMarks(this.parentTree, pdfNumber, n) == returnType.NOTFOUND) {
            throw new BadPdfFormatException(MessageLocalization.getComposedMessage("invalid.structparent", new Object[0]));
        }
    }

    protected void setReader(PdfReader object) throws BadPdfFormatException {
        this.reader = object;
        if ((object = PdfStructTreeController.getDirectObject(object.getCatalog().get(PdfName.STRUCTTREEROOT))) != null && object.isDictionary()) {
            this.structTreeRoot = (PdfDictionary)object;
            object = PdfStructTreeController.getDirectObject(this.structTreeRoot.get(PdfName.PARENTTREE));
            if (object != null && object.isDictionary()) {
                this.parentTree = (PdfDictionary)object;
                this.sourceRoleMap = null;
                this.sourceClassMap = null;
                this.nullReference = null;
                return;
            }
            throw new BadPdfFormatException(MessageLocalization.getComposedMessage("the.document.does.not.contain.parenttree", new Object[0]));
        }
        throw new BadPdfFormatException(MessageLocalization.getComposedMessage("no.structtreeroot.found", new Object[0]));
    }

    public static enum returnType {
        BELOW,
        FOUND,
        ABOVE,
        NOTFOUND;
        

        private returnType() {
        }
    }

}

