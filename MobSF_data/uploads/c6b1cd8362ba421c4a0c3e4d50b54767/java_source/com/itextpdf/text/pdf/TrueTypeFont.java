/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.GlyphList;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfRectangle;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.TrueTypeFontSubSet;
import java.io.File;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

class TrueTypeFont
extends BaseFont {
    static final String[] codePages = new String[]{"1252 Latin 1", "1250 Latin 2: Eastern Europe", "1251 Cyrillic", "1253 Greek", "1254 Turkish", "1255 Hebrew", "1256 Arabic", "1257 Windows Baltic", "1258 Vietnamese", null, null, null, null, null, null, null, "874 Thai", "932 JIS/Japan", "936 Chinese: Simplified chars--PRC and Singapore", "949 Korean Wansung", "950 Chinese: Traditional chars--Taiwan and Hong Kong", "1361 Korean Johab", null, null, null, null, null, null, null, "Macintosh Character Set (US Roman)", "OEM Character Set", "Symbol Character Set", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "869 IBM Greek", "866 MS-DOS Russian", "865 MS-DOS Nordic", "864 Arabic", "863 MS-DOS Canadian French", "862 Hebrew", "861 MS-DOS Icelandic", "860 MS-DOS Portuguese", "857 IBM Turkish", "855 IBM Cyrillic; primarily Russian", "852 Latin 2", "775 MS-DOS Baltic", "737 Greek; former 437 G", "708 Arabic; ASMO 708", "850 WE/Latin 1", "437 US"};
    protected String[][] allNameEntries;
    protected int[][] bboxes;
    protected boolean cff = false;
    protected int cffLength;
    protected int cffOffset;
    protected HashMap<Integer, int[]> cmap10;
    protected HashMap<Integer, int[]> cmap31;
    protected HashMap<Integer, int[]> cmapExt;
    protected int directoryOffset;
    protected String[][] familyName;
    protected String fileName;
    protected String fontName;
    protected String[][] fullName;
    protected int[] glyphIdToChar;
    protected int[] glyphWidthsByIndex;
    protected FontHeader head = new FontHeader();
    protected HorizontalHeader hhea = new HorizontalHeader();
    protected boolean isFixedPitch = false;
    protected double italicAngle;
    protected boolean justNames = false;
    protected IntHashtable kerning = new IntHashtable();
    protected int maxGlyphId;
    protected WindowsMetrics os_2 = new WindowsMetrics();
    protected RandomAccessFileOrArray rf;
    protected String style = "";
    protected String[][] subFamily;
    protected HashMap<String, int[]> tables;
    protected String ttcIndex;
    protected int underlinePosition;
    protected int underlineThickness;

    protected TrueTypeFont() {
    }

    TrueTypeFont(String charSequence, String string2, boolean bl, byte[] arrby, boolean bl2, boolean bl3) throws DocumentException, IOException {
        this.justNames = bl2;
        String string3 = TrueTypeFont.getBaseName((String)charSequence);
        String string4 = TrueTypeFont.getTTCName(string3);
        if (string3.length() < charSequence.length()) {
            this.style = charSequence.substring(string3.length());
        }
        this.encoding = string2;
        this.embedded = bl;
        this.fileName = string4;
        this.fontType = 1;
        this.ttcIndex = "";
        if (string4.length() < string3.length()) {
            this.ttcIndex = string3.substring(string4.length() + 1);
        }
        if (!(this.fileName.toLowerCase().endsWith(".ttf") || this.fileName.toLowerCase().endsWith(".otf") || this.fileName.toLowerCase().endsWith(".ttc"))) {
            charSequence = new StringBuilder();
            charSequence.append(this.fileName);
            charSequence.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.ttf.otf.or.ttc.font.file", charSequence.toString()));
        }
        this.process(arrby, bl3);
        if (!bl2 && this.embedded && this.os_2.fsType == 2) {
            charSequence = new StringBuilder();
            charSequence.append(this.fileName);
            charSequence.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("1.cannot.be.embedded.due.to.licensing.restrictions", charSequence.toString()));
        }
        if (!this.encoding.startsWith("#")) {
            PdfEncodings.convertToBytes(" ", string2);
        }
        this.createEncoding();
    }

    protected static int[] compactRanges(ArrayList<int[]> arrn) {
        int[] arrn2;
        int n;
        int n2;
        int n3;
        int n4;
        ArrayList<int[]> arrayList = new ArrayList<int[]>();
        for (n2 = 0; n2 < arrn.size(); ++n2) {
            arrn2 = arrn.get(n2);
            for (n4 = 0; n4 < arrn2.length; n4 += 2) {
                n = arrn2[n4];
                n3 = n4 + 1;
                arrayList.add(new int[]{Math.max(0, Math.min(n, arrn2[n3])), Math.min(65535, Math.max(arrn2[n4], arrn2[n3]))});
            }
        }
        n4 = 0;
        while (n4 < arrayList.size() - 1) {
            n2 = n = n4 + 1;
            while (n2 < arrayList.size()) {
                block8 : {
                    block7 : {
                        arrn = (int[])arrayList.get(n4);
                        if (arrn[0] >= (arrn2 = (int[])arrayList.get(n2))[0] && arrn[0] <= arrn2[1]) break block7;
                        n3 = n2;
                        if (arrn[1] < arrn2[0]) break block8;
                        n3 = n2;
                        if (arrn[0] > arrn2[1]) break block8;
                    }
                    arrn[0] = Math.min(arrn[0], arrn2[0]);
                    arrn[1] = Math.max(arrn[1], arrn2[1]);
                    arrayList.remove(n2);
                    n3 = n2 - 1;
                }
                n2 = n3 + 1;
            }
            n4 = n;
        }
        arrn = new int[arrayList.size() * 2];
        for (n2 = 0; n2 < arrayList.size(); ++n2) {
            arrn2 = (int[])arrayList.get(n2);
            n4 = n2 * 2;
            arrn[n4] = arrn2[0];
            arrn[n4 + 1] = arrn2[1];
        }
        return arrn;
    }

    protected static String getTTCName(String string2) {
        int n = string2.toLowerCase().indexOf(".ttc,");
        if (n < 0) {
            return string2;
        }
        return string2.substring(0, n + 4);
    }

    private void readBbox() throws DocumentException, IOException {
        int[] arrn;
        Object object;
        Object object2 = this.tables.get("head");
        if (object2 == null) {
            object2 = new StringBuilder();
            object2.append(this.fileName);
            object2.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "head", object2.toString()));
        }
        this.rf.seek(object2[0] + 51);
        Object object3 = this.rf.readUnsignedShort() == 0 ? 1 : 0;
        object2 = this.tables.get("loca");
        if (object2 == null) {
            return;
        }
        this.rf.seek((long)object2[0]);
        if (object3 != 0) {
            object = object2[1] / 2;
            arrn = new int[object];
            object3 = 0;
            do {
                object2 = arrn;
                if (object3 < object) {
                    arrn[object3] = this.rf.readUnsignedShort() * 2;
                    ++object3;
                    continue;
                }
                break;
            } while (true);
        } else {
            object = object2[1] / 4;
            arrn = new int[object];
            object3 = 0;
            do {
                object2 = arrn;
                if (object3 >= object) break;
                arrn[object3] = this.rf.readInt();
                ++object3;
            } while (true);
        }
        if ((arrn = this.tables.get("glyf")) == null) {
            object2 = new StringBuilder();
            object2.append(this.fileName);
            object2.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "glyf", object2.toString()));
        }
        int n = arrn[0];
        this.bboxes = new int[((Object)object2).length - 1][];
        object3 = 0;
        while (object3 < ((Object)object2).length - 1) {
            Object object4 = object2[object3];
            object = object3 + 1;
            if (object4 != object2[object]) {
                this.rf.seek((long)(object4 + n + 2));
                this.bboxes[object3] = new int[]{this.rf.readShort() * 1000 / this.head.unitsPerEm, this.rf.readShort() * 1000 / this.head.unitsPerEm, this.rf.readShort() * 1000 / this.head.unitsPerEm, this.rf.readShort() * 1000 / this.head.unitsPerEm};
            }
            object3 = object;
        }
    }

    protected void addRangeUni(HashMap<Integer, int[]> hashMap, boolean bl, boolean bl2) {
        if (!(bl2 || this.subsetRanges == null && this.directoryOffset <= 0)) {
            void var6_9;
            int[] arrn;
            if (this.subsetRanges == null && this.directoryOffset > 0) {
                int[] arrn2 = arrn = new int[2];
                arrn2[0] = 0;
                arrn2[1] = 65535;
            } else {
                arrn = TrueTypeFont.compactRanges(this.subsetRanges);
            }
            if (!this.fontSpecific && this.cmap31 != null) {
                HashMap<Integer, int[]> object2 = this.cmap31;
            } else if (this.fontSpecific && this.cmap10 != null) {
                HashMap<Integer, int[]> hashMap2 = this.cmap10;
            } else if (this.cmap31 != null) {
                HashMap<Integer, int[]> hashMap3 = this.cmap31;
            } else {
                HashMap<Integer, int[]> hashMap4 = this.cmap10;
            }
            for (Map.Entry entry : var6_9.entrySet()) {
                void var6_14;
                Integer n;
                int n2;
                int n3;
                int[] arrn3;
                block13 : {
                    arrn3 = (int[])entry.getValue();
                    n = arrn3[0];
                    if (hashMap.containsKey(n)) continue;
                    n3 = (Integer)entry.getKey();
                    for (n2 = 0; n2 < arrn.length; n2 += 2) {
                        if (n3 < arrn[n2] || n3 > arrn[n2 + 1]) continue;
                        n2 = 0;
                        break block13;
                    }
                    n2 = 1;
                }
                if (n2 != 0) continue;
                if (bl) {
                    int[] arrn4 = new int[]{arrn3[0], arrn3[1], n3};
                } else {
                    Object var6_13 = null;
                }
                hashMap.put(n, (int[])var6_14);
            }
        }
    }

    protected void addRangeUni(HashSet<Integer> hashSet, boolean bl) {
        if (!(bl || this.subsetRanges == null && this.directoryOffset <= 0)) {
            int[] arrn;
            if (this.subsetRanges == null && this.directoryOffset > 0) {
                int[] arrn2 = arrn = new int[2];
                arrn2[0] = 0;
                arrn2[1] = 65535;
            } else {
                arrn = TrueTypeFont.compactRanges(this.subsetRanges);
            }
            HashMap<Integer, int[]> hashMap = !this.fontSpecific && this.cmap31 != null ? this.cmap31 : (this.fontSpecific && this.cmap10 != null ? this.cmap10 : (this.cmap31 != null ? this.cmap31 : this.cmap10));
            for (Map.Entry entry : hashMap.entrySet()) {
                int n;
                Object object;
                block5 : {
                    object = (int[])entry.getValue();
                    int n2 = 0;
                    if (hashSet.contains(object = Integer.valueOf(object[0]))) continue;
                    int n3 = (Integer)entry.getKey();
                    for (n = 0; n < arrn.length; n += 2) {
                        if (n3 < arrn[n] || n3 > arrn[n + 1]) continue;
                        n = n2;
                        break block5;
                    }
                    n = 1;
                }
                if (n != 0) continue;
                hashSet.add((Integer)object);
            }
        }
    }

    void checkCff() {
        int[] arrn = this.tables.get("CFF ");
        if (arrn != null) {
            this.cff = true;
            this.cffOffset = arrn[0];
            this.cffLength = arrn[1];
        }
    }

    void fillTables() throws DocumentException, IOException {
        int n;
        Object object = this.tables.get("head");
        boolean bl = true;
        if (object == null) {
            object = new StringBuilder();
            object.append(this.fileName);
            object.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "head", object.toString()));
        }
        this.rf.seek(object[0] + 16);
        this.head.flags = this.rf.readUnsignedShort();
        this.head.unitsPerEm = this.rf.readUnsignedShort();
        this.rf.skipBytes(16);
        this.head.xMin = this.rf.readShort();
        this.head.yMin = this.rf.readShort();
        this.head.xMax = this.rf.readShort();
        this.head.yMax = this.rf.readShort();
        this.head.macStyle = this.rf.readUnsignedShort();
        object = this.tables.get("hhea");
        if (object == null) {
            object = new StringBuilder();
            object.append(this.fileName);
            object.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "hhea", object.toString()));
        }
        this.rf.seek((long)(object[0] + 4));
        this.hhea.Ascender = this.rf.readShort();
        this.hhea.Descender = this.rf.readShort();
        this.hhea.LineGap = this.rf.readShort();
        this.hhea.advanceWidthMax = this.rf.readUnsignedShort();
        this.hhea.minLeftSideBearing = this.rf.readShort();
        this.hhea.minRightSideBearing = this.rf.readShort();
        this.hhea.xMaxExtent = this.rf.readShort();
        this.hhea.caretSlopeRise = this.rf.readShort();
        this.hhea.caretSlopeRun = this.rf.readShort();
        this.rf.skipBytes(12);
        this.hhea.numberOfHMetrics = this.rf.readUnsignedShort();
        object = this.tables.get("OS/2");
        if (object != null) {
            this.rf.seek((long)object[0]);
            n = this.rf.readUnsignedShort();
            this.os_2.xAvgCharWidth = this.rf.readShort();
            this.os_2.usWeightClass = this.rf.readUnsignedShort();
            this.os_2.usWidthClass = this.rf.readUnsignedShort();
            this.os_2.fsType = this.rf.readShort();
            this.os_2.ySubscriptXSize = this.rf.readShort();
            this.os_2.ySubscriptYSize = this.rf.readShort();
            this.os_2.ySubscriptXOffset = this.rf.readShort();
            this.os_2.ySubscriptYOffset = this.rf.readShort();
            this.os_2.ySuperscriptXSize = this.rf.readShort();
            this.os_2.ySuperscriptYSize = this.rf.readShort();
            this.os_2.ySuperscriptXOffset = this.rf.readShort();
            this.os_2.ySuperscriptYOffset = this.rf.readShort();
            this.os_2.yStrikeoutSize = this.rf.readShort();
            this.os_2.yStrikeoutPosition = this.rf.readShort();
            this.os_2.sFamilyClass = this.rf.readShort();
            this.rf.readFully(this.os_2.panose);
            this.rf.skipBytes(16);
            this.rf.readFully(this.os_2.achVendID);
            this.os_2.fsSelection = this.rf.readUnsignedShort();
            this.os_2.usFirstCharIndex = this.rf.readUnsignedShort();
            this.os_2.usLastCharIndex = this.rf.readUnsignedShort();
            this.os_2.sTypoAscender = this.rf.readShort();
            this.os_2.sTypoDescender = this.rf.readShort();
            if (this.os_2.sTypoDescender > 0) {
                this.os_2.sTypoDescender = - this.os_2.sTypoDescender;
            }
            this.os_2.sTypoLineGap = this.rf.readShort();
            this.os_2.usWinAscent = this.rf.readUnsignedShort();
            this.os_2.usWinDescent = this.rf.readUnsignedShort();
            this.os_2.ulCodePageRange1 = 0;
            this.os_2.ulCodePageRange2 = 0;
            if (n > 0) {
                this.os_2.ulCodePageRange1 = this.rf.readInt();
                this.os_2.ulCodePageRange2 = this.rf.readInt();
            }
            if (n > 1) {
                this.rf.skipBytes(2);
                this.os_2.sCapHeight = this.rf.readShort();
            } else {
                this.os_2.sCapHeight = (int)((double)this.head.unitsPerEm * 0.7);
            }
        } else if (this.tables.get("hhea") != null && this.tables.get("head") != null) {
            if (this.head.macStyle == 0) {
                this.os_2.usWeightClass = 700;
                this.os_2.usWidthClass = 5;
            } else if (this.head.macStyle == 5) {
                this.os_2.usWeightClass = 400;
                this.os_2.usWidthClass = 3;
            } else if (this.head.macStyle == 6) {
                this.os_2.usWeightClass = 400;
                this.os_2.usWidthClass = 7;
            } else {
                this.os_2.usWeightClass = 400;
                this.os_2.usWidthClass = 5;
            }
            this.os_2.fsType = 0;
            this.os_2.ySubscriptYSize = 0;
            this.os_2.ySubscriptYOffset = 0;
            this.os_2.ySuperscriptYSize = 0;
            this.os_2.ySuperscriptYOffset = 0;
            this.os_2.yStrikeoutSize = 0;
            this.os_2.yStrikeoutPosition = 0;
            this.os_2.sTypoAscender = (short)((double)this.hhea.Ascender - (double)this.hhea.Ascender * 0.21);
            this.os_2.sTypoDescender = (short)(- (double)Math.abs(this.hhea.Descender) - (double)Math.abs(this.hhea.Descender) * 0.07);
            this.os_2.sTypoLineGap = (short)(this.hhea.LineGap * 2);
            this.os_2.usWinAscent = this.hhea.Ascender;
            this.os_2.usWinDescent = this.hhea.Descender;
            this.os_2.ulCodePageRange1 = 0;
            this.os_2.ulCodePageRange2 = 0;
            this.os_2.sCapHeight = (int)((double)this.head.unitsPerEm * 0.7);
        }
        object = this.tables.get("post");
        if (object == null) {
            this.italicAngle = (- Math.atan2(this.hhea.caretSlopeRun, this.hhea.caretSlopeRise)) * 180.0 / 3.141592653589793;
        } else {
            this.rf.seek((long)(object[0] + 4));
            n = this.rf.readShort();
            int n2 = this.rf.readUnsignedShort();
            this.italicAngle = (double)n + (double)n2 / 16384.0;
            this.underlinePosition = this.rf.readShort();
            this.underlineThickness = this.rf.readShort();
            if (this.rf.readInt() == 0) {
                bl = false;
            }
            this.isFixedPitch = bl;
        }
        object = this.tables.get("maxp");
        if (object == null) {
            this.maxGlyphId = 65536;
            return;
        }
        this.rf.seek((long)(object[0] + 4));
        this.maxGlyphId = this.rf.readUnsignedShort();
    }

    @Override
    public String[][] getAllNameEntries() {
        return this.allNameEntries;
    }

    String[][] getAllNames() throws DocumentException, IOException {
        int n;
        Object object;
        int[] arrn = this.tables.get("name");
        int n2 = 0;
        if (arrn == null) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(this.fileName);
            stringBuilder.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "name", stringBuilder.toString()));
        }
        this.rf.seek(arrn[0] + 2);
        int n3 = this.rf.readUnsignedShort();
        int n4 = this.rf.readUnsignedShort();
        ArrayList<String[]> arrayList = new ArrayList<String[]>();
        for (n = 0; n < n3; ++n) {
            int n5 = this.rf.readUnsignedShort();
            int n6 = this.rf.readUnsignedShort();
            int n7 = this.rf.readUnsignedShort();
            int n8 = this.rf.readUnsignedShort();
            int n9 = this.rf.readUnsignedShort();
            int n10 = this.rf.readUnsignedShort();
            int n11 = (int)this.rf.getFilePointer();
            this.rf.seek(arrn[0] + n4 + n10);
            object = n5 != 0 && n5 != 3 && (n5 != 2 || n6 != 1) ? this.readStandardString(n9) : this.readUnicodeString(n9);
            arrayList.add(new String[]{String.valueOf(n8), String.valueOf(n5), String.valueOf(n6), String.valueOf(n7), object});
            this.rf.seek(n11);
        }
        object = new String[arrayList.size()][];
        for (n = n2; n < arrayList.size(); ++n) {
            object[n] = (String[])arrayList.get(n);
        }
        return object;
    }

    String getBaseFont() throws DocumentException, IOException {
        Object object = this.tables.get("name");
        if (object == null) {
            object = new StringBuilder();
            object.append(this.fileName);
            object.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "name", object.toString()));
        }
        this.rf.seek(object[0] + 2);
        int n = this.rf.readUnsignedShort();
        int n2 = this.rf.readUnsignedShort();
        for (int i = 0; i < n; ++i) {
            int n3 = this.rf.readUnsignedShort();
            this.rf.readUnsignedShort();
            this.rf.readUnsignedShort();
            int n4 = this.rf.readUnsignedShort();
            int n5 = this.rf.readUnsignedShort();
            int n6 = this.rf.readUnsignedShort();
            if (n4 != 6) continue;
            this.rf.seek((long)(object[0] + n2 + n6));
            if (n3 != 0 && n3 != 3) {
                return this.readStandardString(n5);
            }
            return this.readUnicodeString(n5);
        }
        return new File(this.fileName).getName().replace(' ', '-');
    }

    @Override
    public String[] getCodePagesSupported() {
        int n;
        int n2;
        long l = ((long)this.os_2.ulCodePageRange2 << 32) + ((long)this.os_2.ulCodePageRange1 & 0xFFFFFFFFL);
        long l2 = 1L;
        int n3 = 0;
        long l3 = 1L;
        int n4 = 0;
        for (n = 0; n < 64; ++n) {
            n2 = n4;
            if ((l & l3) != 0L) {
                n2 = n4;
                if (codePages[n] != null) {
                    n2 = n4 + 1;
                }
            }
            l3 <<= 1;
            n4 = n2;
        }
        String[] arrstring = new String[n4];
        n4 = 0;
        l3 = l2;
        for (n = n3; n < 64; ++n) {
            n2 = n4;
            if ((l & l3) != 0L) {
                n2 = n4;
                if (codePages[n] != null) {
                    arrstring[n4] = codePages[n];
                    n2 = n4 + 1;
                }
            }
            l3 <<= 1;
            n4 = n2;
        }
        return arrstring;
    }

    @Override
    public String[][] getFamilyFontName() {
        return this.familyName;
    }

    protected PdfDictionary getFontBaseType(PdfIndirectReference pdfIndirectReference, String object, int n, int n2, byte[] arrby) {
        Serializable serializable;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        if (this.cff) {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.TYPE1);
            object = PdfName.BASEFONT;
            serializable = new StringBuilder();
            serializable.append(this.fontName);
            serializable.append(this.style);
            pdfDictionary.put((PdfName)object, new PdfName(serializable.toString()));
        } else {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.TRUETYPE);
            serializable = PdfName.BASEFONT;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append((String)object);
            stringBuilder.append(this.fontName);
            stringBuilder.append(this.style);
            pdfDictionary.put((PdfName)serializable, new PdfName(stringBuilder.toString()));
        }
        int n3 = n;
        if (!this.fontSpecific) {
            int n4 = n;
            do {
                n3 = n;
                if (n4 > n2) break;
                if (!this.differences[n4].equals(".notdef")) {
                    n3 = n4;
                    break;
                }
                ++n4;
            } while (true);
            if (!this.encoding.equals("Cp1252") && !this.encoding.equals("MacRoman")) {
                object = new PdfDictionary(PdfName.ENCODING);
                serializable = new PdfArray();
                n = 1;
                for (int i = n3; i <= n2; ++i) {
                    if (arrby[i] != 0) {
                        n4 = n;
                        if (n != 0) {
                            serializable.add(new PdfNumber(i));
                            n4 = 0;
                        }
                        serializable.add(new PdfName(this.differences[i]));
                        n = n4;
                        continue;
                    }
                    n = 1;
                }
                object.put(PdfName.DIFFERENCES, (PdfObject)serializable);
                pdfDictionary.put(PdfName.ENCODING, (PdfObject)object);
            } else {
                serializable = PdfName.ENCODING;
                object = this.encoding.equals("Cp1252") ? PdfName.WIN_ANSI_ENCODING : PdfName.MAC_ROMAN_ENCODING;
                pdfDictionary.put((PdfName)serializable, (PdfObject)object);
            }
        }
        pdfDictionary.put(PdfName.FIRSTCHAR, new PdfNumber(n3));
        pdfDictionary.put(PdfName.LASTCHAR, new PdfNumber(n2));
        object = new PdfArray();
        while (n3 <= n2) {
            if (arrby[n3] == 0) {
                object.add(new PdfNumber(0));
            } else {
                object.add(new PdfNumber(this.widths[n3]));
            }
            ++n3;
        }
        pdfDictionary.put(PdfName.WIDTHS, (PdfObject)object);
        if (pdfIndirectReference != null) {
            pdfDictionary.put(PdfName.FONTDESCRIPTOR, pdfIndirectReference);
        }
        return pdfDictionary;
    }

    @Override
    public float getFontDescriptor(int n, float f) {
        switch (n) {
            default: {
                return 0.0f;
            }
            case 22: {
                return this.os_2.usWidthClass;
            }
            case 21: {
                return this.os_2.usWeightClass;
            }
            case 20: {
                return (float)this.os_2.ySuperscriptYOffset * f / (float)this.head.unitsPerEm;
            }
            case 19: {
                return (float)this.os_2.ySuperscriptYSize * f / (float)this.head.unitsPerEm;
            }
            case 18: {
                return (float)(- this.os_2.ySubscriptYOffset) * f / (float)this.head.unitsPerEm;
            }
            case 17: {
                return (float)this.os_2.ySubscriptYSize * f / (float)this.head.unitsPerEm;
            }
            case 16: {
                return (float)this.os_2.yStrikeoutSize * f / (float)this.head.unitsPerEm;
            }
            case 15: {
                return (float)this.os_2.yStrikeoutPosition * f / (float)this.head.unitsPerEm;
            }
            case 14: {
                return (float)this.underlineThickness * f / (float)this.head.unitsPerEm;
            }
            case 13: {
                return (float)(this.underlinePosition - this.underlineThickness / 2) * f / (float)this.head.unitsPerEm;
            }
            case 12: {
                return f * (float)this.hhea.advanceWidthMax / (float)this.head.unitsPerEm;
            }
            case 11: {
                return f * (float)this.hhea.LineGap / (float)this.head.unitsPerEm;
            }
            case 10: {
                return f * (float)this.hhea.Descender / (float)this.head.unitsPerEm;
            }
            case 9: {
                return f * (float)this.hhea.Ascender / (float)this.head.unitsPerEm;
            }
            case 8: {
                return f * (float)this.head.yMax / (float)this.head.unitsPerEm;
            }
            case 7: {
                return f * (float)this.head.xMax / (float)this.head.unitsPerEm;
            }
            case 6: {
                return f * (float)this.head.yMin / (float)this.head.unitsPerEm;
            }
            case 5: {
                return f * (float)this.head.xMin / (float)this.head.unitsPerEm;
            }
            case 4: {
                return (float)this.italicAngle;
            }
            case 3: {
                return (float)this.os_2.sTypoDescender * f / (float)this.head.unitsPerEm;
            }
            case 2: {
                return (float)this.os_2.sCapHeight * f / (float)this.head.unitsPerEm;
            }
            case 1: 
        }
        return (float)this.os_2.sTypoAscender * f / (float)this.head.unitsPerEm;
    }

    protected PdfDictionary getFontDescriptor(PdfIndirectReference pdfIndirectReference, String string2, PdfIndirectReference pdfObject) {
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONTDESCRIPTOR);
        pdfDictionary.put(PdfName.ASCENT, new PdfNumber(this.os_2.sTypoAscender * 1000 / this.head.unitsPerEm));
        pdfDictionary.put(PdfName.CAPHEIGHT, new PdfNumber(this.os_2.sCapHeight * 1000 / this.head.unitsPerEm));
        pdfDictionary.put(PdfName.DESCENT, new PdfNumber(this.os_2.sTypoDescender * 1000 / this.head.unitsPerEm));
        pdfDictionary.put(PdfName.FONTBBOX, new PdfRectangle(this.head.xMin * 1000 / this.head.unitsPerEm, this.head.yMin * 1000 / this.head.unitsPerEm, this.head.xMax * 1000 / this.head.unitsPerEm, this.head.yMax * 1000 / this.head.unitsPerEm));
        if (pdfObject != null) {
            pdfDictionary.put(PdfName.CIDSET, pdfObject);
        }
        if (this.cff) {
            if (this.encoding.startsWith("Identity-")) {
                pdfObject = PdfName.FONTNAME;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append(this.fontName);
                stringBuilder.append("-");
                stringBuilder.append(this.encoding);
                pdfDictionary.put((PdfName)pdfObject, new PdfName(stringBuilder.toString()));
            } else {
                pdfObject = PdfName.FONTNAME;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append(this.fontName);
                stringBuilder.append(this.style);
                pdfDictionary.put((PdfName)pdfObject, new PdfName(stringBuilder.toString()));
            }
        } else {
            pdfObject = PdfName.FONTNAME;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(string2);
            stringBuilder.append(this.fontName);
            stringBuilder.append(this.style);
            pdfDictionary.put((PdfName)pdfObject, new PdfName(stringBuilder.toString()));
        }
        pdfDictionary.put(PdfName.ITALICANGLE, new PdfNumber(this.italicAngle));
        pdfDictionary.put(PdfName.STEMV, new PdfNumber(80));
        if (pdfIndirectReference != null) {
            if (this.cff) {
                pdfDictionary.put(PdfName.FONTFILE3, pdfIndirectReference);
            } else {
                pdfDictionary.put(PdfName.FONTFILE2, pdfIndirectReference);
            }
        }
        int n = 0;
        if (this.isFixedPitch) {
            n = 1;
        }
        int n2 = this.fontSpecific ? 4 : 32;
        n = n2 = n | n2;
        if ((this.head.macStyle & 2) != 0) {
            n = n2 | 64;
        }
        n2 = n;
        if ((this.head.macStyle & 1) != 0) {
            n2 = n | 262144;
        }
        pdfDictionary.put(PdfName.FLAGS, new PdfNumber(n2));
        return pdfDictionary;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected byte[] getFullFont() throws IOException {
        void var1_7;
        RandomAccessFileOrArray randomAccessFileOrArray;
        block8 : {
            byte[] arrby;
            randomAccessFileOrArray = new RandomAccessFileOrArray(this.rf);
            try {
                randomAccessFileOrArray.reOpen();
                arrby = new byte[(int)randomAccessFileOrArray.length()];
                randomAccessFileOrArray.readFully(arrby);
                if (randomAccessFileOrArray == null) return arrby;
            }
            catch (Throwable throwable) {}
            try {
                randomAccessFileOrArray.close();
                return arrby;
            }
            catch (Exception exception) {
                return arrby;
            }
            break block8;
            catch (Throwable throwable) {
                randomAccessFileOrArray = null;
            }
        }
        if (randomAccessFileOrArray == null) throw var1_7;
        try {
            randomAccessFileOrArray.close();
        }
        catch (Exception exception) {
            throw var1_7;
        }
        throw var1_7;
    }

    @Override
    public String[][] getFullFontName() {
        return this.fullName;
    }

    @Override
    public PdfStream getFullFontStream() throws IOException, DocumentException {
        if (this.cff) {
            return new BaseFont.StreamFont(this.readCffFont(), "Type1C", this.compressionLevel);
        }
        byte[] arrby = this.getFullFont();
        int n = arrby.length;
        int n2 = this.compressionLevel;
        return new BaseFont.StreamFont(arrby, new int[]{n}, n2);
    }

    protected int getGlyphWidth(int n) {
        int n2 = n;
        if (n >= this.glyphWidthsByIndex.length) {
            n2 = this.glyphWidthsByIndex.length - 1;
        }
        return this.glyphWidthsByIndex[n2];
    }

    @Override
    public int getKerning(int n, int n2) {
        int[] arrn = this.getMetricsTT(n);
        if (arrn == null) {
            return 0;
        }
        n = arrn[0];
        arrn = this.getMetricsTT(n2);
        if (arrn == null) {
            return 0;
        }
        n2 = arrn[0];
        return this.kerning.get((n << 16) + n2);
    }

    public int[] getMetricsTT(int n) {
        if (this.cmapExt != null) {
            return this.cmapExt.get(n);
        }
        if (!this.fontSpecific && this.cmap31 != null) {
            return this.cmap31.get(n);
        }
        if (this.fontSpecific && this.cmap10 != null) {
            return this.cmap10.get(n);
        }
        if (this.cmap31 != null) {
            return this.cmap31.get(n);
        }
        if (this.cmap10 != null) {
            return this.cmap10.get(n);
        }
        return null;
    }

    String[][] getNames(int n) throws DocumentException, IOException {
        Object object;
        int[] arrn = this.tables.get("name");
        if (arrn == null) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(this.fileName);
            stringBuilder.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "name", stringBuilder.toString()));
        }
        this.rf.seek(arrn[0] + 2);
        int n2 = this.rf.readUnsignedShort();
        int n3 = this.rf.readUnsignedShort();
        ArrayList<String[]> arrayList = new ArrayList<String[]>();
        for (int i = 0; i < n2; ++i) {
            int n4 = this.rf.readUnsignedShort();
            int n5 = this.rf.readUnsignedShort();
            int n6 = this.rf.readUnsignedShort();
            int n7 = this.rf.readUnsignedShort();
            int n8 = this.rf.readUnsignedShort();
            int n9 = this.rf.readUnsignedShort();
            if (n7 != n) continue;
            n7 = (int)this.rf.getFilePointer();
            this.rf.seek(arrn[0] + n3 + n9);
            object = n4 != 0 && n4 != 3 && (n4 != 2 || n5 != 1) ? this.readStandardString(n8) : this.readUnicodeString(n8);
            arrayList.add(new String[]{String.valueOf(n4), String.valueOf(n5), String.valueOf(n6), object});
            this.rf.seek(n7);
        }
        object = new String[arrayList.size()][];
        for (n = 0; n < arrayList.size(); ++n) {
            object[n] = (String[])arrayList.get(n);
        }
        return object;
    }

    @Override
    public String getPostscriptFontName() {
        return this.fontName;
    }

    @Override
    protected int[] getRawCharBBox(int n, String object) {
        object = object != null && this.cmap31 != null ? this.cmap31 : this.cmap10;
        if (object == null) {
            return null;
        }
        if ((object = object.get(n)) != null) {
            if (this.bboxes == null) {
                return null;
            }
            return this.bboxes[object[0]];
        }
        return null;
    }

    @Override
    int getRawWidth(int n, String arrn) {
        arrn = this.getMetricsTT(n);
        if (arrn == null) {
            return 0;
        }
        return arrn[1];
    }

    protected byte[] getSubSet(HashSet arrby, boolean bl) throws IOException, DocumentException {
        synchronized (this) {
            arrby = new TrueTypeFontSubSet(this.fileName, new RandomAccessFileOrArray(this.rf), (HashSet<Integer>)arrby, this.directoryOffset, true, bl ^ true).process();
            return arrby;
        }
    }

    @Override
    public String getSubfamily() {
        if (this.subFamily != null && this.subFamily.length > 0) {
            return this.subFamily[0][3];
        }
        return super.getSubfamily();
    }

    @Override
    public boolean hasKernPairs() {
        if (this.kerning.size() > 0) {
            return true;
        }
        return false;
    }

    /*
     * Enabled aggressive exception aggregation
     */
    void process(byte[] object, boolean bl) throws DocumentException, IOException {
        int n;
        void var2_6;
        int n2;
        this.tables = new HashMap();
        this.rf = object == null ? new RandomAccessFileOrArray(this.fileName, (boolean)var2_6, Document.plainRandomAccess) : new RandomAccessFileOrArray((byte[])object);
        if (this.ttcIndex.length() > 0) {
            n2 = Integer.parseInt(this.ttcIndex);
            if (n2 < 0) {
                throw new DocumentException(MessageLocalization.getComposedMessage("the.font.index.for.1.must.be.positive", this.fileName));
            }
            if (!this.readStandardString(4).equals("ttcf")) {
                throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.valid.ttc.file", this.fileName));
            }
            this.rf.skipBytes(4);
            n = this.rf.readInt();
            if (n2 >= n) {
                throw new DocumentException(MessageLocalization.getComposedMessage("the.font.index.for.1.must.be.between.0.and.2.it.was.3", this.fileName, String.valueOf(n - 1), String.valueOf(n2)));
            }
            this.rf.skipBytes(n2 * 4);
            this.directoryOffset = this.rf.readInt();
        }
        this.rf.seek(this.directoryOffset);
        n2 = this.rf.readInt();
        if (n2 != 65536 && n2 != 1330926671) {
            throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.valid.ttf.or.otf.file", this.fileName));
        }
        n = this.rf.readUnsignedShort();
        this.rf.skipBytes(6);
        for (n2 = 0; n2 < n; ++n2) {
            String string2 = this.readStandardString(4);
            this.rf.skipBytes(4);
            int n3 = this.rf.readInt();
            int n4 = this.rf.readInt();
            this.tables.put(string2, new int[]{n3, n4});
        }
        {
            continue;
        }
        try {
            this.checkCff();
            this.fontName = this.getBaseFont();
            this.fullName = this.getNames(4);
            String[][] arrstring = this.getNames(16);
            this.familyName = arrstring.length > 0 ? arrstring : this.getNames(1);
            String[][] arrstring2 = this.getNames(17);
            this.subFamily = arrstring.length > 0 ? arrstring2 : this.getNames(2);
            this.allNameEntries = this.getAllNames();
            if (!this.justNames) {
                this.fillTables();
                this.readGlyphWidths();
                this.readCMaps();
                this.readKerning();
                this.readBbox();
            }
            return;
        }
        finally {
            if (!this.embedded) {
                this.rf.close();
                this.rf = null;
            }
        }
    }

    void readCMaps() throws DocumentException, IOException {
        int n;
        Object object = this.tables.get("cmap");
        if (object == null) {
            object = new StringBuilder();
            object.append(this.fileName);
            object.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "cmap", object.toString()));
        }
        this.rf.seek(object[0]);
        this.rf.skipBytes(2);
        int n2 = this.rf.readUnsignedShort();
        this.fontSpecific = false;
        int n3 = 0;
        int n4 = 0;
        int n5 = 0;
        int n6 = 0;
        for (int i = 0; i < n2; ++i) {
            int n7;
            int n8;
            int n9;
            int n10 = this.rf.readUnsignedShort();
            int n11 = this.rf.readUnsignedShort();
            n = this.rf.readInt();
            if (n10 == 3 && n11 == 0) {
                this.fontSpecific = true;
                n9 = n;
                n7 = n4;
                n8 = n6;
            } else if (n10 == 3 && n11 == 1) {
                n7 = n;
                n9 = n5;
                n8 = n6;
            } else {
                n7 = n4;
                n9 = n5;
                n8 = n6;
                if (n10 == 3) {
                    n7 = n4;
                    n9 = n5;
                    n8 = n6;
                    if (n11 == 10) {
                        n8 = n;
                        n9 = n5;
                        n7 = n4;
                    }
                }
            }
            n6 = n3;
            if (n10 == 1) {
                n6 = n3;
                if (n11 == 0) {
                    n6 = n;
                }
            }
            n3 = n6;
            n4 = n7;
            n5 = n9;
            n6 = n8;
        }
        if (n3 > 0) {
            this.rf.seek((long)(object[0] + n3));
            n = this.rf.readUnsignedShort();
            if (n != 0) {
                if (n != 4) {
                    if (n == 6) {
                        this.cmap10 = this.readFormat6();
                    }
                } else {
                    this.cmap10 = this.readFormat4();
                }
            } else {
                this.cmap10 = this.readFormat0();
            }
        }
        if (n4 > 0) {
            this.rf.seek((long)(object[0] + n4));
            if (this.rf.readUnsignedShort() == 4) {
                this.cmap31 = this.readFormat4();
            }
        }
        if (n5 > 0) {
            this.rf.seek((long)(object[0] + n5));
            if (this.rf.readUnsignedShort() == 4) {
                this.cmap10 = this.readFormat4();
            }
        }
        if (n6 > 0) {
            this.rf.seek((long)(object[0] + n6));
            n = this.rf.readUnsignedShort();
            if (n != 0) {
                if (n != 4) {
                    if (n != 6) {
                        if (n != 12) {
                            return;
                        }
                        this.cmapExt = this.readFormat12();
                        return;
                    }
                    this.cmapExt = this.readFormat6();
                    return;
                }
                this.cmapExt = this.readFormat4();
                return;
            }
            this.cmapExt = this.readFormat0();
        }
    }

    protected byte[] readCffFont() throws IOException {
        RandomAccessFileOrArray randomAccessFileOrArray = new RandomAccessFileOrArray(this.rf);
        byte[] arrby = new byte[this.cffLength];
        try {
            randomAccessFileOrArray.reOpen();
            randomAccessFileOrArray.seek(this.cffOffset);
            randomAccessFileOrArray.readFully(arrby);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    HashMap<Integer, int[]> readFormat0() throws IOException {
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        this.rf.skipBytes(4);
        for (int i = 0; i < 256; ++i) {
            int[] arrn;
            arrn = new int[]{this.rf.readUnsignedByte(), this.getGlyphWidth(arrn[0])};
            hashMap.put(i, arrn);
        }
        return hashMap;
    }

    HashMap<Integer, int[]> readFormat12() throws IOException {
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        this.rf.skipBytes(2);
        this.rf.readInt();
        this.rf.skipBytes(4);
        int n = this.rf.readInt();
        for (int i = 0; i < n; ++i) {
            int n2 = this.rf.readInt();
            int n3 = this.rf.readInt();
            for (int j = this.rf.readInt(); j <= n2; ++j) {
                int[] arrn;
                arrn = new int[]{n3++, this.getGlyphWidth(arrn[0])};
                hashMap.put(j, arrn);
            }
        }
        return hashMap;
    }

    HashMap<Integer, int[]> readFormat4() throws IOException {
        int n;
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        int n2 = this.rf.readUnsignedShort();
        this.rf.skipBytes(2);
        int n3 = this.rf.readUnsignedShort() / 2;
        this.rf.skipBytes(6);
        int[] arrn = new int[n3];
        for (n = 0; n < n3; ++n) {
            arrn[n] = this.rf.readUnsignedShort();
        }
        this.rf.skipBytes(2);
        int[] arrn2 = new int[n3];
        for (n = 0; n < n3; ++n) {
            arrn2[n] = this.rf.readUnsignedShort();
        }
        int[] arrn3 = new int[n3];
        for (n = 0; n < n3; ++n) {
            arrn3[n] = this.rf.readUnsignedShort();
        }
        int[] arrn4 = new int[n3];
        for (n = 0; n < n3; ++n) {
            arrn4[n] = this.rf.readUnsignedShort();
        }
        int[] arrn5 = new int[n2 / 2 - 8 - n3 * 4];
        for (n = 0; n < arrn5.length; ++n) {
            arrn5[n] = this.rf.readUnsignedShort();
        }
        for (n2 = 0; n2 < n3; ++n2) {
            for (n = arrn2[n2]; n <= arrn[n2] && n != 65535; ++n) {
                int n4;
                int[] arrn6;
                if (arrn4[n2] == 0) {
                    n4 = 65535 & arrn3[n2] + n;
                } else {
                    n4 = arrn4[n2] / 2 + n2 - n3 + n - arrn2[n2];
                    if (n4 >= arrn5.length) continue;
                    n4 = 65535 & arrn5[n4] + arrn3[n2];
                }
                arrn6 = new int[]{n4, this.getGlyphWidth(arrn6[0])};
                n4 = this.fontSpecific && (65280 & n) == 61440 ? n & 255 : n;
                hashMap.put(n4, arrn6);
            }
        }
        return hashMap;
    }

    HashMap<Integer, int[]> readFormat6() throws IOException {
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        this.rf.skipBytes(4);
        int n = this.rf.readUnsignedShort();
        int n2 = this.rf.readUnsignedShort();
        for (int i = 0; i < n2; ++i) {
            int[] arrn;
            arrn = new int[]{this.rf.readUnsignedShort(), this.getGlyphWidth(arrn[0])};
            hashMap.put(i + n, arrn);
        }
        return hashMap;
    }

    protected void readGlyphWidths() throws DocumentException, IOException {
        Object object = this.tables.get("hmtx");
        if (object == null) {
            object = new StringBuilder();
            object.append(this.fileName);
            object.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "hmtx", object.toString()));
        }
        this.rf.seek(object[0]);
        this.glyphWidthsByIndex = new int[this.hhea.numberOfHMetrics];
        for (int i = 0; i < this.hhea.numberOfHMetrics; ++i) {
            this.glyphWidthsByIndex[i] = this.rf.readUnsignedShort() * 1000 / this.head.unitsPerEm;
            int n = this.rf.readShort() * 1000 / this.head.unitsPerEm;
        }
    }

    void readKerning() throws IOException {
        int[] arrn = this.tables.get("kern");
        if (arrn == null) {
            return;
        }
        this.rf.seek(arrn[0] + 2);
        int n = this.rf.readUnsignedShort();
        int n2 = arrn[0] + 4;
        int n3 = 0;
        for (int i = 0; i < n; ++i) {
            int n4 = n2 + n3;
            this.rf.seek(n4);
            this.rf.skipBytes(2);
            n3 = this.rf.readUnsignedShort();
            if ((this.rf.readUnsignedShort() & 65527) == 1) {
                int n5 = this.rf.readUnsignedShort();
                this.rf.skipBytes(6);
                for (n2 = 0; n2 < n5; ++n2) {
                    int n6 = this.rf.readInt();
                    int n7 = this.rf.readShort() * 1000 / this.head.unitsPerEm;
                    this.kerning.put(n6, n7);
                }
            }
            n2 = n4;
        }
    }

    protected String readStandardString(int n) throws IOException {
        return this.rf.readString(n, "Cp1252");
    }

    protected String readUnicodeString(int n) throws IOException {
        StringBuffer stringBuffer = new StringBuffer();
        int n2 = n / 2;
        for (n = 0; n < n2; ++n) {
            stringBuffer.append(this.rf.readChar());
        }
        return stringBuffer.toString();
    }

    @Override
    public boolean setKerning(int n, int n2, int n3) {
        int[] arrn = this.getMetricsTT(n);
        if (arrn == null) {
            return false;
        }
        n = arrn[0];
        arrn = this.getMetricsTT(n2);
        if (arrn == null) {
            return false;
        }
        n2 = arrn[0];
        this.kerning.put((n << 16) + n2, n3);
        return true;
    }

    @Override
    public void setPostscriptFontName(String string2) {
        this.fontName = string2;
    }

    @Override
    void writeFont(PdfWriter pdfWriter, PdfIndirectReference pdfIndirectReference, Object[] object) throws DocumentException, IOException {
        HashSet<Integer> hashSet;
        int n = (Integer)object[0];
        int n2 = (Integer)object[1];
        byte[] arrby = (byte[])object[2];
        boolean bl = (Boolean)object[3] != false && this.subset;
        if (!bl) {
            n2 = arrby.length;
            for (n = 0; n < arrby.length; ++n) {
                arrby[n] = 1;
            }
            --n2;
            n = 0;
        }
        String string2 = "";
        if (this.embedded) {
            if (this.cff) {
                object = pdfWriter.addToBody(new BaseFont.StreamFont(this.readCffFont(), "Type1C", this.compressionLevel)).getIndirectReference();
            } else {
                int n3;
                if (bl) {
                    string2 = TrueTypeFont.createSubsetPrefix();
                }
                hashSet = new HashSet();
                for (n3 = n; n3 <= n2; ++n3) {
                    if (arrby[n3] == 0) continue;
                    object = this.specialMap != null ? ((object = GlyphList.nameToUnicode(this.differences[n3])) != null ? this.getMetricsTT((int)object[0]) : null) : (this.fontSpecific ? this.getMetricsTT(n3) : this.getMetricsTT(this.unicodeDifferences[n3]));
                    if (object == null) continue;
                    hashSet.add((int)object[0]);
                }
                this.addRangeUni(hashSet, bl);
                object = !bl && this.directoryOffset == 0 && this.subsetRanges == null ? this.getFullFont() : this.getSubSet(new HashSet<Integer>(hashSet), bl);
                n3 = ((Object[])object).length;
                int n4 = this.compressionLevel;
                object = pdfWriter.addToBody(new BaseFont.StreamFont((byte[])object, new int[]{n3}, n4)).getIndirectReference();
            }
        } else {
            string2 = "";
            object = null;
        }
        hashSet = this.getFontDescriptor((PdfIndirectReference)object, string2, null);
        if (hashSet != null) {
            object = pdfWriter.addToBody((PdfObject)((Object)hashSet)).getIndirectReference();
        }
        pdfWriter.addToBody((PdfObject)this.getFontBaseType((PdfIndirectReference)object, string2, n, n2, arrby), pdfIndirectReference);
    }

    protected static class FontHeader {
        int flags;
        int macStyle;
        int unitsPerEm;
        short xMax;
        short xMin;
        short yMax;
        short yMin;

        protected FontHeader() {
        }
    }

    protected static class HorizontalHeader {
        short Ascender;
        short Descender;
        short LineGap;
        int advanceWidthMax;
        short caretSlopeRise;
        short caretSlopeRun;
        short minLeftSideBearing;
        short minRightSideBearing;
        int numberOfHMetrics;
        short xMaxExtent;

        protected HorizontalHeader() {
        }
    }

    protected static class WindowsMetrics {
        byte[] achVendID = new byte[4];
        int fsSelection;
        short fsType;
        byte[] panose = new byte[10];
        int sCapHeight;
        short sFamilyClass;
        short sTypoAscender;
        short sTypoDescender;
        short sTypoLineGap;
        int ulCodePageRange1;
        int ulCodePageRange2;
        int usFirstCharIndex;
        int usLastCharIndex;
        int usWeightClass;
        int usWidthClass;
        int usWinAscent;
        int usWinDescent;
        short xAvgCharWidth;
        short yStrikeoutPosition;
        short yStrikeoutSize;
        short ySubscriptXOffset;
        short ySubscriptXSize;
        short ySubscriptYOffset;
        short ySubscriptYSize;
        short ySuperscriptXOffset;
        short ySuperscriptXSize;
        short ySuperscriptYOffset;
        short ySuperscriptYSize;

        protected WindowsMetrics() {
        }
    }

}

