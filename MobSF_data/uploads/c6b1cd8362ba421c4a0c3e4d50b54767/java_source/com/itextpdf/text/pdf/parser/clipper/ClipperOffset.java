/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Clipper;
import com.itextpdf.text.pdf.parser.clipper.DefaultClipper;
import com.itextpdf.text.pdf.parser.clipper.LongRect;
import com.itextpdf.text.pdf.parser.clipper.Path;
import com.itextpdf.text.pdf.parser.clipper.Paths;
import com.itextpdf.text.pdf.parser.clipper.Point;
import com.itextpdf.text.pdf.parser.clipper.PolyNode;
import com.itextpdf.text.pdf.parser.clipper.PolyTree;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

public class ClipperOffset {
    private static final double DEFAULT_ARC_TOLERANCE = 0.25;
    private static final double TOLERANCE = 1.0E-20;
    private static final double TWO_PI = 6.283185307179586;
    private final double arcTolerance;
    private double cos;
    private double delta;
    private Path destPoly;
    private Paths destPolys;
    private double inA;
    private Point.LongPoint lowest;
    private double miterLim;
    private final double miterLimit;
    private final List<Point.DoublePoint> normals;
    private final PolyNode polyNodes;
    private double sin;
    private Path srcPoly;
    private double stepsPerRad;

    public ClipperOffset() {
        this(2.0, 0.25);
    }

    public ClipperOffset(double d) {
        this(d, 0.25);
    }

    public ClipperOffset(double d, double d2) {
        this.miterLimit = d;
        this.arcTolerance = d2;
        this.lowest = new Point.LongPoint();
        this.lowest.setX(-1L);
        this.polyNodes = new PolyNode();
        this.normals = new ArrayList<Point.DoublePoint>();
    }

    private void doMiter(int n, int n2, double d) {
        d = this.delta / d;
        this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getX() + (this.normals.get(n2).getX() + this.normals.get(n).getX()) * d), Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getY() + (this.normals.get(n2).getY() + this.normals.get(n).getY()) * d)));
    }

    /*
     * Enabled aggressive block sorting
     */
    private void doOffset(double d) {
        this.destPolys = new Paths();
        this.delta = d;
        boolean bl = ClipperOffset.nearZero(d);
        int n = 0;
        if (bl) {
            do {
                if (n >= this.polyNodes.getChildCount()) {
                    return;
                }
                PolyNode polyNode = this.polyNodes.getChilds().get(n);
                if (polyNode.getEndType() == Clipper.EndType.CLOSED_POLYGON) {
                    this.destPolys.add(polyNode.getPolygon());
                }
                ++n;
            } while (true);
        }
        this.miterLim = this.miterLimit > 2.0 ? 2.0 / (this.miterLimit * this.miterLimit) : 0.5;
        double d2 = this.arcTolerance;
        double d3 = 0.0;
        double d4 = 0.25;
        if (d2 > 0.0) {
            d4 = this.arcTolerance > Math.abs(d) * 0.25 ? 0.25 * Math.abs(d) : this.arcTolerance;
        }
        d4 = 3.141592653589793 / Math.acos(1.0 - d4 / Math.abs(d));
        d2 = 6.283185307179586 / d4;
        this.sin = Math.sin(d2);
        this.cos = Math.cos(d2);
        this.stepsPerRad = d4 / 6.283185307179586;
        if (d < 0.0) {
            this.sin = - this.sin;
        }
        int n2 = 0;
        while (n2 < this.polyNodes.getChildCount()) {
            block40 : {
                block38 : {
                    block33 : {
                        double d5;
                        block36 : {
                            block34 : {
                                List<Point.LongPoint> list;
                                Object object;
                                int n3;
                                int n4;
                                Object object2;
                                block39 : {
                                    block37 : {
                                        block35 : {
                                            object2 = this.polyNodes.getChilds().get(n2);
                                            this.srcPoly = object2.getPolygon();
                                            n4 = this.srcPoly.size();
                                            if (n4 == 0 || d <= d3 && (n4 < 3 || object2.getEndType() != Clipper.EndType.CLOSED_POLYGON)) break block34;
                                            this.destPoly = new Path();
                                            n = 1;
                                            if (n4 != 1) break block35;
                                            if (object2.getJoinType() == Clipper.JoinType.ROUND) {
                                                d5 = 1.0;
                                                d2 = d3;
                                                d3 = d5;
                                                do {
                                                    d5 = d3;
                                                    if ((double)n <= d4) {
                                                        this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() + d5 * d), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() + d2 * d)));
                                                        d3 = d5 * this.cos - this.sin * d2;
                                                        double d6 = this.sin;
                                                        d2 = d2 * this.cos + d6 * d5;
                                                        ++n;
                                                        continue;
                                                    }
                                                    break block33;
                                                    break;
                                                } while (true);
                                            }
                                            break block36;
                                        }
                                        d3 = d4;
                                        this.normals.clear();
                                        n3 = 0;
                                        while (n3 < (n = n4 - 1)) {
                                            List<Point.DoublePoint> list2 = this.normals;
                                            object = (Point.LongPoint)this.srcPoly.get(n3);
                                            list = this.srcPoly;
                                            list2.add(Point.getUnitNormal((Point.LongPoint)object, (Point.LongPoint)list.get(++n3)));
                                        }
                                        if (object2.getEndType() != Clipper.EndType.CLOSED_LINE && object2.getEndType() != Clipper.EndType.CLOSED_POLYGON) {
                                            this.normals.add(new Point.DoublePoint(this.normals.get(n4 - 2)));
                                        } else {
                                            this.normals.add(Point.getUnitNormal((Point.LongPoint)this.srcPoly.get(n), (Point.LongPoint)this.srcPoly.get(0)));
                                        }
                                        if (object2.getEndType() != Clipper.EndType.CLOSED_POLYGON) break block37;
                                        for (n3 = 0; n3 < n4; ++n3) {
                                            Clipper.JoinType joinType = object2.getJoinType();
                                            this.offsetPoint(n3, new int[]{n}, joinType);
                                        }
                                        this.destPolys.add(this.destPoly);
                                        break block38;
                                    }
                                    if (object2.getEndType() != Clipper.EndType.CLOSED_LINE) break block39;
                                    int[] arrn = new int[]{n};
                                    for (n3 = 0; n3 < n4; ++n3) {
                                        this.offsetPoint(n3, arrn, object2.getJoinType());
                                    }
                                    this.destPolys.add(this.destPoly);
                                    this.destPoly = new Path();
                                    object = this.normals.get(n);
                                    for (n3 = n; n3 > 0; --n3) {
                                        list = this.normals;
                                        List<Point.DoublePoint> list3 = this.normals;
                                        n4 = n3 - 1;
                                        list.set(n3, (Point.LongPoint)((Object)new Point.DoublePoint(- list3.get(n4).getX(), - this.normals.get(n4).getY())));
                                    }
                                    this.normals.set(0, new Point.DoublePoint(- object.getX(), - object.getY(), 0.0));
                                    arrn[0] = 0;
                                    while (n >= 0) {
                                        this.offsetPoint(n, arrn, object2.getJoinType());
                                        --n;
                                    }
                                    this.destPolys.add(this.destPoly);
                                    break block38;
                                }
                                int[] arrn = new int[1];
                                for (n3 = 1; n3 < n; ++n3) {
                                    this.offsetPoint(n3, arrn, object2.getJoinType());
                                }
                                if (object2.getEndType() == Clipper.EndType.OPEN_BUTT) {
                                    object = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getX() + this.normals.get(n).getX() * d), Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getY() + this.normals.get(n).getY() * d), 0L);
                                    this.destPoly.add(object);
                                    object = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getX() - this.normals.get(n).getX() * d), Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getY() - this.normals.get(n).getY() * d), 0L);
                                    this.destPoly.add(object);
                                } else {
                                    arrn[0] = n4 - 2;
                                    this.inA = 0.0;
                                    this.normals.set(n, new Point.DoublePoint(- this.normals.get(n).getX(), - this.normals.get(n).getY()));
                                    if (object2.getEndType() == Clipper.EndType.OPEN_SQUARE) {
                                        this.doSquare(n, arrn[0], true);
                                    } else {
                                        this.doRound(n, arrn[0]);
                                    }
                                }
                                for (n3 = n; n3 > 0; --n3) {
                                    object = this.normals;
                                    list = this.normals;
                                    n4 = n3 - 1;
                                    object.set(n3, new Point.DoublePoint(- ((Point.DoublePoint)((Object)list.get(n4))).getX(), - this.normals.get(n4).getY()));
                                }
                                this.normals.set(0, new Point.DoublePoint(- this.normals.get(1).getX(), - this.normals.get(1).getY()));
                                arrn[0] = n;
                                for (n = arrn[0] - 1; n > 0; --n) {
                                    this.offsetPoint(n, arrn, object2.getJoinType());
                                }
                                if (object2.getEndType() == Clipper.EndType.OPEN_BUTT) {
                                    object2 = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() - this.normals.get(0).getX() * d), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() - this.normals.get(0).getY() * d));
                                    this.destPoly.add(object2);
                                    object2 = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() + this.normals.get(0).getX() * d), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() + this.normals.get(0).getY() * d));
                                    this.destPoly.add(object2);
                                } else {
                                    arrn[0] = 1;
                                    this.inA = 0.0;
                                    if (object2.getEndType() == Clipper.EndType.OPEN_SQUARE) {
                                        this.doSquare(0, 1, true);
                                    } else {
                                        this.doRound(0, 1);
                                    }
                                }
                                d4 = 0.0;
                                this.destPolys.add(this.destPoly);
                                break block40;
                            }
                            d2 = d3;
                            d3 = d4;
                            d4 = d2;
                            break block40;
                        }
                        d3 = d4;
                        n = 0;
                        d5 = -1.0;
                        d2 = -1.0;
                        do {
                            d4 = d3;
                            if (n >= 4) break;
                            this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() + d5 * d), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() + d2 * d)));
                            if (d5 < 0.0) {
                                d4 = 1.0;
                            } else if (d2 < 0.0) {
                                d2 = 1.0;
                                d4 = d5;
                            } else {
                                d4 = -1.0;
                            }
                            ++n;
                            d5 = d4;
                        } while (true);
                    }
                    this.destPolys.add(this.destPoly);
                    d3 = d4;
                }
                d4 = 0.0;
            }
            ++n2;
            d2 = d3;
            d3 = d4;
            d4 = d2;
        }
    }

    private void doRound(int n, int n2) {
        double d = Math.atan2(this.inA, this.normals.get(n2).getX() * this.normals.get(n).getX() + this.normals.get(n2).getY() * this.normals.get(n).getY());
        int n3 = Math.max((int)Math.round(this.stepsPerRad * Math.abs(d)), 1);
        double d2 = this.normals.get(n2).getX();
        d = this.normals.get(n2).getY();
        for (n2 = 0; n2 < n3; ++n2) {
            this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getX() + this.delta * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getY() + this.delta * d)));
            double d3 = this.cos;
            double d4 = this.sin;
            double d5 = this.sin;
            d5 = d * this.cos + d2 * d5;
            d2 = d3 * d2 - d4 * d;
            d = d5;
        }
        this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getX() + this.normals.get(n).getX() * this.delta), Math.round((double)((Point.LongPoint)this.srcPoly.get(n)).getY() + this.normals.get(n).getY() * this.delta)));
    }

    private void doSquare(int n, int n2, boolean bl) {
        double d = this.normals.get(n2).getX();
        double d2 = this.normals.get(n2).getY();
        double d3 = this.normals.get(n).getX();
        double d4 = this.normals.get(n).getY();
        double d5 = ((Point.LongPoint)this.srcPoly.get(n)).getX();
        double d6 = ((Point.LongPoint)this.srcPoly.get(n)).getY();
        double d7 = Math.tan(Math.atan2(this.inA, d * d3 + d2 * d4) / 4.0);
        Path path = this.destPoly;
        double d8 = this.delta;
        double d9 = 0.0;
        double d10 = bl ? d2 * d7 : 0.0;
        long l = Math.round(d8 * (d - d10) + d5);
        d8 = this.delta;
        d10 = bl ? d * d7 : 0.0;
        path.add(new Point.LongPoint(l, Math.round(d8 * (d2 + d10) + d6), 0L));
        path = this.destPoly;
        d2 = this.delta;
        d10 = bl ? d4 * d7 : 0.0;
        l = Math.round(d5 + d2 * (d3 + d10));
        d5 = this.delta;
        d10 = d9;
        if (bl) {
            d10 = d3 * d7;
        }
        path.add(new Point.LongPoint(l, Math.round(d6 + d5 * (d4 - d10)), 0L));
    }

    /*
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void fixOrientations() {
        long l = this.lowest.getX();
        int n = 0;
        int n2 = 0;
        int n3 = n;
        if (l >= 0L) {
            n3 = n;
            if (!this.polyNodes.childs.get((int)this.lowest.getX()).getPolygon().orientation()) {
                n3 = n2;
                while (n3 < this.polyNodes.getChildCount()) {
                    PolyNode polyNode = this.polyNodes.childs.get(n3);
                    if (polyNode.getEndType() == Clipper.EndType.CLOSED_POLYGON || polyNode.getEndType() == Clipper.EndType.CLOSED_LINE && polyNode.getPolygon().orientation()) {
                        Collections.reverse(polyNode.getPolygon());
                    }
                    ++n3;
                }
                return;
            }
        }
        while (n3 < this.polyNodes.getChildCount()) {
            PolyNode polyNode = this.polyNodes.childs.get(n3);
            if (polyNode.getEndType() == Clipper.EndType.CLOSED_LINE && !polyNode.getPolygon().orientation()) {
                Collections.reverse(polyNode.getPolygon());
            }
            ++n3;
        }
    }

    private static boolean nearZero(double d) {
        if (d > -1.0E-20 && d < 1.0E-20) {
            return true;
        }
        return false;
    }

    private void offsetPoint(int n, int[] arrn, Clipper.JoinType object) {
        int n2 = arrn[0];
        double d = this.normals.get(n2).getX();
        double d2 = this.normals.get(n2).getY();
        double d3 = this.normals.get(n).getY();
        double d4 = this.normals.get(n).getX();
        long l = ((Point.LongPoint)this.srcPoly.get(n)).getX();
        long l2 = ((Point.LongPoint)this.srcPoly.get(n)).getY();
        this.inA = d * d3 - d4 * d2;
        if (Math.abs(this.inA * this.delta) < 1.0) {
            if (d * d4 + d3 * d2 > 0.0) {
                this.destPoly.add(new Point.LongPoint(Math.round((double)l + d * this.delta), Math.round((double)l2 + d2 * this.delta), 0L));
                return;
            }
        } else if (this.inA > 1.0) {
            this.inA = 1.0;
        } else if (this.inA < -1.0) {
            this.inA = -1.0;
        }
        if (this.inA * this.delta < 0.0) {
            object = this.destPoly;
            double d5 = l;
            l = Math.round(d * this.delta + d5);
            d = l2;
            object.add(new Point.LongPoint(l, Math.round(d2 * this.delta + d)));
            this.destPoly.add(this.srcPoly.get(n));
            this.destPoly.add(new Point.LongPoint(Math.round(d5 + d4 * this.delta), Math.round(d + this.delta * d3)));
        } else {
            int n3 = n;
            switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$JoinType[object.ordinal()]) {
                default: {
                    break;
                }
                case 3: {
                    this.doRound(n3, n2);
                    break;
                }
                case 2: {
                    this.doSquare(n3, n2, false);
                    break;
                }
                case 1: {
                    d2 = d4 * d + 1.0 + d3 * d2;
                    if (d2 >= this.miterLim) {
                        this.doMiter(n3, n2, d2);
                        break;
                    }
                    this.doSquare(n3, n2, false);
                }
            }
        }
        arrn[0] = n;
    }

    public void addPath(Path object, Clipper.JoinType enum_, Clipper.EndType endType) {
        int n;
        int n2;
        int n3;
        int n4;
        PolyNode polyNode;
        block14 : {
            block13 : {
                n3 = object.size() - 1;
                if (n3 < 0) {
                    return;
                }
                polyNode = new PolyNode();
                polyNode.setJoinType((Clipper.JoinType)enum_);
                polyNode.setEndType(endType);
                enum_ = Clipper.EndType.CLOSED_LINE;
                n2 = 0;
                n = n3;
                if (endType == enum_) break block13;
                n4 = n3;
                if (endType != Clipper.EndType.CLOSED_POLYGON) break block14;
                n = n3;
            }
            do {
                n4 = n;
                if (n <= 0) break;
                n4 = n;
                if (object.get(0) != object.get(n)) break;
                --n;
            } while (true);
        }
        polyNode.getPolygon().add(object.get(0));
        n3 = 0;
        for (n = 1; n <= n4; ++n) {
            int n5;
            int n6;
            block15 : {
                block16 : {
                    n5 = n2;
                    n6 = n3;
                    if (polyNode.getPolygon().get(n2) == object.get(n)) break block15;
                    ++n2;
                    polyNode.getPolygon().add(object.get(n));
                    if (((Point.LongPoint)object.get(n)).getY() > ((Point.LongPoint)polyNode.getPolygon().get(n3)).getY()) break block16;
                    n5 = n2;
                    n6 = n3;
                    if (((Point.LongPoint)object.get(n)).getY() != ((Point.LongPoint)polyNode.getPolygon().get(n3)).getY()) break block15;
                    n5 = n2;
                    n6 = n3;
                    if (((Point.LongPoint)object.get(n)).getX() >= ((Point.LongPoint)polyNode.getPolygon().get(n3)).getX()) break block15;
                }
                n6 = n2;
                n5 = n2;
            }
            n2 = n5;
            n3 = n6;
        }
        if (endType == Clipper.EndType.CLOSED_POLYGON && n2 < 2) {
            return;
        }
        this.polyNodes.addChild(polyNode);
        if (endType != Clipper.EndType.CLOSED_POLYGON) {
            return;
        }
        if (this.lowest.getX() < 0L) {
            this.lowest = new Point.LongPoint(this.polyNodes.getChildCount() - 1, n3);
            return;
        }
        object = (Point.LongPoint)this.polyNodes.getChilds().get((int)this.lowest.getX()).getPolygon().get((int)this.lowest.getY());
        if (((Point.LongPoint)polyNode.getPolygon().get(n3)).getY() > object.getY() || ((Point.LongPoint)polyNode.getPolygon().get(n3)).getY() == object.getY() && ((Point.LongPoint)polyNode.getPolygon().get(n3)).getX() < object.getX()) {
            this.lowest = new Point.LongPoint(this.polyNodes.getChildCount() - 1, n3);
        }
    }

    public void addPaths(Paths object, Clipper.JoinType joinType, Clipper.EndType endType) {
        object = object.iterator();
        while (object.hasNext()) {
            this.addPath((Path)object.next(), joinType, endType);
        }
    }

    public void clear() {
        this.polyNodes.getChilds().clear();
        this.lowest.setX(-1L);
    }

    public void execute(Paths paths, double d) {
        paths.clear();
        this.fixOrientations();
        this.doOffset(d);
        DefaultClipper defaultClipper = new DefaultClipper(1);
        defaultClipper.addPaths(this.destPolys, Clipper.PolyType.SUBJECT, true);
        if (d > 0.0) {
            defaultClipper.execute(Clipper.ClipType.UNION, paths, Clipper.PolyFillType.POSITIVE, Clipper.PolyFillType.POSITIVE);
            return;
        }
        LongRect longRect = this.destPolys.getBounds();
        Path path = new Path(4);
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.top - 10L, 0L));
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.top - 10L, 0L));
        defaultClipper.addPath(path, Clipper.PolyType.SUBJECT, true);
        defaultClipper.execute(Clipper.ClipType.UNION, paths, Clipper.PolyFillType.NEGATIVE, Clipper.PolyFillType.NEGATIVE);
        if (paths.size() > 0) {
            paths.remove(0);
        }
    }

    public void execute(PolyTree polyTree, double d) {
        polyTree.Clear();
        this.fixOrientations();
        this.doOffset(d);
        Object object = new DefaultClipper(1);
        object.addPaths(this.destPolys, Clipper.PolyType.SUBJECT, true);
        if (d > 0.0) {
            object.execute(Clipper.ClipType.UNION, polyTree, Clipper.PolyFillType.POSITIVE, Clipper.PolyFillType.POSITIVE);
            return;
        }
        LongRect longRect = this.destPolys.getBounds();
        Path path = new Path(4);
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.top - 10L, 0L));
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.top - 10L, 0L));
        object.addPath(path, Clipper.PolyType.SUBJECT, true);
        object.execute(Clipper.ClipType.UNION, polyTree, Clipper.PolyFillType.NEGATIVE, Clipper.PolyFillType.NEGATIVE);
        if (polyTree.getChildCount() == 1 && polyTree.getChilds().get(0).getChildCount() > 0) {
            object = polyTree.getChilds().get(0);
            polyTree.getChilds().set(0, object.getChilds().get(0));
            polyTree.getChilds().get(0).setParent(polyTree);
            for (int i = 1; i < object.getChildCount(); ++i) {
                polyTree.addChild(object.getChilds().get(i));
            }
        } else {
            polyTree.Clear();
        }
    }

}

