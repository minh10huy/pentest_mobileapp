/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.Font;
import com.itextpdf.text.Image;
import com.itextpdf.text.SplitCharacter;
import com.itextpdf.text.TabSettings;
import com.itextpdf.text.TabStop;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.DefaultSplitCharacter;
import com.itextpdf.text.pdf.HyphenationEvent;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfFont;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import java.io.Serializable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class PdfChunk {
    private static final float ITALIC_ANGLE = 0.21256f;
    private static final String TABSTOP = "TABSTOP";
    public static final float UNDERLINE_OFFSET = -0.33333334f;
    public static final float UNDERLINE_THICKNESS = 0.06666667f;
    private static final HashSet<String> keysAttributes;
    private static final HashSet<String> keysNoStroke;
    private static final char[] singleSpace;
    protected IAccessibleElement accessibleElement = null;
    protected HashMap<String, Object> attributes = new HashMap();
    protected BaseFont baseFont;
    protected boolean changeLeading = false;
    protected String encoding = "Cp1252";
    protected PdfFont font;
    protected Image image;
    protected float imageScalePercentage = 1.0f;
    protected float leading = 0.0f;
    protected boolean newlineSplit;
    protected HashMap<String, Object> noStroke = new HashMap();
    protected float offsetX;
    protected float offsetY;
    protected SplitCharacter splitCharacter;
    protected String value = "";

    static {
        singleSpace = new char[]{' '};
        keysAttributes = new HashSet();
        keysNoStroke = new HashSet();
        keysAttributes.add("ACTION");
        keysAttributes.add("UNDERLINE");
        keysAttributes.add("REMOTEGOTO");
        keysAttributes.add("LOCALGOTO");
        keysAttributes.add("LOCALDESTINATION");
        keysAttributes.add("GENERICTAG");
        keysAttributes.add("NEWPAGE");
        keysAttributes.add("IMAGE");
        keysAttributes.add("BACKGROUND");
        keysAttributes.add("PDFANNOTATION");
        keysAttributes.add("SKEW");
        keysAttributes.add("HSCALE");
        keysAttributes.add("SEPARATOR");
        keysAttributes.add("TAB");
        keysAttributes.add("TABSETTINGS");
        keysAttributes.add("CHAR_SPACING");
        keysAttributes.add("WORD_SPACING");
        keysAttributes.add("LINEHEIGHT");
        keysNoStroke.add("SUBSUPSCRIPT");
        keysNoStroke.add("SPLITCHARACTER");
        keysNoStroke.add("HYPHENATION");
        keysNoStroke.add("TEXTRENDERMODE");
    }

    PdfChunk(Chunk chunk, PdfAction serializable) {
        float f;
        int n;
        this.value = chunk.getContent();
        Font font = chunk.getFont();
        float f2 = f = font.getSize();
        if (f == -1.0f) {
            f2 = 12.0f;
        }
        this.baseFont = font.getBaseFont();
        int n2 = n = font.getStyle();
        if (n == -1) {
            n2 = 0;
        }
        if (this.baseFont == null) {
            this.baseFont = font.getCalculatedBaseFont(false);
        } else {
            if ((n2 & 1) != 0) {
                this.attributes.put("TEXTRENDERMODE", new Object[]{2, new Float(f2 / 30.0f), null});
            }
            if ((n2 & 2) != 0) {
                this.attributes.put("SKEW", new float[]{0.0f, 0.21256f});
            }
        }
        this.font = new PdfFont(this.baseFont, f2);
        float[] arrf = chunk.getAttributes();
        if (arrf != null) {
            for (Map.Entry<String, Object> entry : arrf.entrySet()) {
                String string2 = entry.getKey();
                if (keysAttributes.contains(string2)) {
                    this.attributes.put(string2, entry.getValue());
                    continue;
                }
                if (!keysNoStroke.contains(string2)) continue;
                this.noStroke.put(string2, entry.getValue());
            }
            if ("".equals(arrf.get("GENERICTAG"))) {
                this.attributes.put("GENERICTAG", chunk.getContent());
            }
        }
        if (font.isUnderlined()) {
            arrf = new float[]{0.0f, 0.06666667f, 0.0f, -0.33333334f, 0.0f};
            arrf = Utilities.addToArray((Object[][])this.attributes.get("UNDERLINE"), new Object[]{null, arrf});
            this.attributes.put("UNDERLINE", arrf);
        }
        if (font.isStrikethru()) {
            arrf = new float[]{0.0f, 0.06666667f, 0.0f, 0.33333334f, 0.0f};
            arrf = Utilities.addToArray((Object[][])this.attributes.get("UNDERLINE"), new Object[]{null, arrf});
            this.attributes.put("UNDERLINE", arrf);
        }
        if (serializable != null) {
            this.attributes.put("ACTION", serializable);
        }
        this.noStroke.put("COLOR", font.getColor());
        this.noStroke.put("ENCODING", this.font.getFont().getEncoding());
        serializable = (Float)this.attributes.get("LINEHEIGHT");
        if (serializable != null) {
            this.changeLeading = true;
            this.leading = serializable.floatValue();
        }
        if ((serializable = (Object[])this.attributes.get("IMAGE")) == null) {
            this.image = null;
        } else {
            this.attributes.remove("HSCALE");
            this.image = (Image)((Object)serializable[0]);
            this.offsetX = ((Float)serializable[1]).floatValue();
            this.offsetY = ((Float)serializable[2]).floatValue();
            this.changeLeading = (Boolean)serializable[3];
        }
        serializable = (Float)this.attributes.get("HSCALE");
        if (serializable != null) {
            this.font.setHorizontalScaling(serializable.floatValue());
        }
        this.encoding = this.font.getFont().getEncoding();
        this.splitCharacter = (SplitCharacter)this.noStroke.get("SPLITCHARACTER");
        if (this.splitCharacter == null) {
            this.splitCharacter = DefaultSplitCharacter.DEFAULT;
        }
        this.accessibleElement = chunk;
    }

    PdfChunk(Chunk chunk, PdfAction pdfAction, TabSettings tabSettings) {
        this(chunk, pdfAction);
        if (tabSettings != null && this.attributes.get("TABSETTINGS") == null) {
            this.attributes.put("TABSETTINGS", tabSettings);
        }
    }

    PdfChunk(String arrobject, PdfChunk pdfChunk) {
        this.value = arrobject;
        this.font = pdfChunk.font;
        this.attributes = pdfChunk.attributes;
        this.noStroke = pdfChunk.noStroke;
        this.baseFont = pdfChunk.baseFont;
        this.changeLeading = pdfChunk.changeLeading;
        this.leading = pdfChunk.leading;
        arrobject = (Object[])this.attributes.get("IMAGE");
        if (arrobject == null) {
            this.image = null;
        } else {
            this.image = (Image)arrobject[0];
            this.offsetX = ((Float)arrobject[1]).floatValue();
            this.offsetY = ((Float)arrobject[2]).floatValue();
            this.changeLeading = (Boolean)arrobject[3];
        }
        this.encoding = this.font.getFont().getEncoding();
        this.splitCharacter = (SplitCharacter)this.noStroke.get("SPLITCHARACTER");
        if (this.splitCharacter == null) {
            this.splitCharacter = DefaultSplitCharacter.DEFAULT;
        }
        this.accessibleElement = pdfChunk.accessibleElement;
    }

    static TabStop getTabStop(PdfChunk pdfChunk, float f) {
        Object object = (Object[])pdfChunk.attributes.get("TAB");
        if (object != null) {
            if (Float.isNaN((object = (Float)object[0]).floatValue())) {
                return TabSettings.getTabStopNewInstance(f, (TabSettings)pdfChunk.attributes.get("TABSETTINGS"));
            }
            return TabStop.newInstance(f, object.floatValue());
        }
        return null;
    }

    public static boolean noPrint(int n) {
        if (n >= 8203 && n <= 8207 || n >= 8234 && n <= 8238 || n == 173) {
            return true;
        }
        return false;
    }

    @Deprecated
    void adjustLeft(float f) {
        Object[] arrobject = (Object[])this.attributes.get("TAB");
        if (arrobject != null) {
            this.attributes.put("TAB", new Object[]{arrobject[0], arrobject[1], arrobject[2], new Float(f)});
        }
    }

    public boolean changeLeading() {
        return this.changeLeading;
    }

    BaseColor color() {
        return (BaseColor)this.noStroke.get("COLOR");
    }

    PdfFont font() {
        return this.font;
    }

    Object getAttribute(String string2) {
        if (this.attributes.containsKey(string2)) {
            return this.attributes.get(string2);
        }
        return this.noStroke.get(string2);
    }

    float getCharWidth(int n) {
        if (PdfChunk.noPrint(n)) {
            return 0.0f;
        }
        if (this.isAttribute("CHAR_SPACING")) {
            Float f = (Float)this.getAttribute("CHAR_SPACING");
            return this.font.width(n) + f.floatValue() * this.font.getHorizontalScaling();
        }
        if (this.isImage()) {
            return this.getImageWidth();
        }
        return this.font.width(n);
    }

    String getEncoding() {
        return this.encoding;
    }

    Image getImage() {
        return this.image;
    }

    float getImageHeight() {
        return this.image.getScaledHeight() * this.imageScalePercentage;
    }

    float getImageOffsetX() {
        return this.offsetX;
    }

    float getImageOffsetY() {
        return this.offsetY;
    }

    public float getImageScalePercentage() {
        return this.imageScalePercentage;
    }

    float getImageWidth() {
        return this.image.getScaledWidth() * this.imageScalePercentage;
    }

    public float getLeading() {
        return this.leading;
    }

    TabStop getTabStop() {
        return (TabStop)this.attributes.get(TABSTOP);
    }

    public float getTextRise() {
        Float f = (Float)this.getAttribute("SUBSUPSCRIPT");
        if (f != null) {
            return f.floatValue();
        }
        return 0.0f;
    }

    public int getUnicodeEquivalent(int n) {
        return this.baseFont.getUnicodeEquivalent(n);
    }

    public float getWidthCorrected(float f, float f2) {
        if (this.image != null) {
            return this.image.getScaledWidth() + f;
        }
        int n = 0;
        int n2 = -1;
        while ((n2 = this.value.indexOf(32, n2 + 1)) >= 0) {
            ++n;
        }
        return this.font.width(this.value) + (float)this.value.length() * f + (float)n * f2;
    }

    protected int getWord(String string2, int n) {
        int n2 = string2.length();
        while (n < n2) {
            if (!Character.isLetter(string2.charAt(n))) {
                return n;
            }
            ++n;
        }
        return n;
    }

    float height() {
        if (this.isImage()) {
            return this.getImageHeight();
        }
        return this.font.size();
    }

    boolean isAttribute(String string2) {
        if (this.attributes.containsKey(string2)) {
            return true;
        }
        return this.noStroke.containsKey(string2);
    }

    boolean isExtSplitCharacter(int n, int n2, int n3, char[] arrc, PdfChunk[] arrpdfChunk) {
        return this.splitCharacter.isSplitCharacter(n, n2, n3, arrc, arrpdfChunk);
    }

    boolean isHorizontalSeparator() {
        if (this.isAttribute("SEPARATOR")) {
            return (Boolean)((Object[])this.getAttribute("SEPARATOR"))[1] ^ true;
        }
        return false;
    }

    boolean isImage() {
        if (this.image != null) {
            return true;
        }
        return false;
    }

    public boolean isNewlineSplit() {
        return this.newlineSplit;
    }

    boolean isSeparator() {
        return this.isAttribute("SEPARATOR");
    }

    boolean isSpecialEncoding() {
        if (!this.encoding.equals("UnicodeBigUnmarked") && !this.encoding.equals("Identity-H")) {
            return false;
        }
        return true;
    }

    boolean isStroked() {
        return this.attributes.isEmpty() ^ true;
    }

    boolean isTab() {
        return this.isAttribute("TAB");
    }

    int length() {
        return this.value.length();
    }

    int lengthUtf32() {
        if (!"Identity-H".equals(this.encoding)) {
            return this.value.length();
        }
        int n = this.value.length();
        int n2 = 0;
        int n3 = 0;
        while (n2 < n) {
            int n4 = n2;
            if (Utilities.isSurrogateHigh(this.value.charAt(n2))) {
                n4 = n2 + 1;
            }
            ++n3;
            n2 = n4 + 1;
        }
        return n3;
    }

    void setImageOffsetX(float f) {
        this.offsetX = f;
    }

    void setImageOffsetY(float f) {
        this.offsetY = f;
    }

    public void setImageScalePercentage(float f) {
        this.imageScalePercentage = f;
    }

    void setTabStop(TabStop tabStop) {
        this.attributes.put(TABSTOP, tabStop);
    }

    void setValue(String string2) {
        this.value = string2;
    }

    PdfChunk split(float f) {
        int n;
        Object object;
        float f2;
        int n2;
        Object object2;
        int n3;
        int n4;
        Object object3;
        int n5;
        block24 : {
            block23 : {
                int n6;
                float f3;
                int n7;
                block22 : {
                    this.newlineSplit = false;
                    if (this.image != null) {
                        if (this.image.getScaledWidth() > f) {
                            PdfChunk pdfChunk = new PdfChunk("\ufffc", this);
                            this.value = "";
                            this.attributes = new HashMap();
                            this.image = null;
                            this.font = PdfFont.getDefaultFont();
                            return pdfChunk;
                        }
                        return null;
                    }
                    object = (HyphenationEvent)this.noStroke.get("HYPHENATION");
                    n4 = this.value.length();
                    object2 = this.value.toCharArray();
                    object3 = this.font.getFont();
                    n3 = object3.getFontType();
                    n7 = 2;
                    f3 = 0.0f;
                    float f4 = 0.0f;
                    n2 = -1;
                    if (n3 == 2 && object3.getUnicodeEquivalent(32) != 32) {
                        f2 = 0.0f;
                        n3 = 0;
                        n = -1;
                        do {
                            f3 = f2;
                            n5 = n2;
                            n7 = n3;
                            n6 = n;
                            if (n3 >= n4) break block22;
                            n5 = object2[n3];
                            n7 = (char)object3.getUnicodeEquivalent(n5);
                            if (n7 == 10) {
                                this.newlineSplit = true;
                                object2 = this.value.substring(n3 + 1);
                                this.value = this.value.substring(0, n3);
                                if (this.value.length() < 1) {
                                    this.value = "\u0001";
                                }
                                return new PdfChunk((String)object2, this);
                            }
                            f3 = f4 + this.getCharWidth(n5);
                            if (n7 == 32) {
                                n2 = n3 + 1;
                                f2 = f3;
                            }
                            if (f3 > f) {
                                n5 = n2;
                                break block23;
                            }
                            if (this.splitCharacter.isSplitCharacter(0, n3, n4, (char[])object2, new PdfChunk[]{this})) {
                                n = n3 + 1;
                            }
                            ++n3;
                            f4 = f3;
                        } while (true);
                    }
                    n3 = 0;
                    f2 = 0.0f;
                    n = -1;
                    while (n3 < n4) {
                        n5 = object2[n3];
                        if (n5 != 13 && n5 != 10) {
                            boolean bl = Utilities.isSurrogatePair((char[])object2, n3);
                            f3 = bl ? (f3 += this.getCharWidth(Utilities.convertToUtf32(object2[n3], object2[n3 + 1]))) : (f3 += this.getCharWidth(n5));
                            if (n5 == 32) {
                                n2 = n3 + 1;
                                f2 = f3;
                            }
                            n5 = n3;
                            if (bl) {
                                n5 = n3 + 1;
                            }
                            if (f3 > f) {
                                n3 = n2;
                                n2 = n5;
                                break block24;
                            }
                            if (this.splitCharacter.isSplitCharacter(0, n5, n4, (char[])object2, null)) {
                                n = n5 + 1;
                            }
                            n3 = n5 + 1;
                            continue;
                        }
                        this.newlineSplit = true;
                        n = n5 == 13 && (n = n3 + 1) < n4 && object2[n] == '\n' ? n7 : 1;
                        object2 = this.value.substring(n + n3);
                        this.value = this.value.substring(0, n3);
                        if (this.value.length() < 1) {
                            this.value = " ";
                        }
                        return new PdfChunk((String)object2, this);
                    }
                    n6 = n;
                    n7 = n3;
                    n5 = n2;
                    f3 = f2;
                }
                f2 = f3;
                n = n6;
                n3 = n7;
            }
            n2 = n3;
            n3 = n5;
        }
        if (n2 == n4) {
            return null;
        }
        if (n < 0) {
            object2 = this.value;
            this.value = "";
            return new PdfChunk((String)object2, this);
        }
        n5 = n;
        if (n3 > n) {
            n5 = n;
            if (this.splitCharacter.isSplitCharacter(0, 0, 1, singleSpace, null)) {
                n5 = n3;
            }
        }
        if (object != null && n3 >= 0 && n3 < n2 && (n = this.getWord(this.value, n3)) > n3) {
            object2 = object.getHyphenatedWordPre(this.value.substring(n3, n), this.font.getFont(), this.font.size(), f - f2);
            object = object.getHyphenatedWordPost();
            if (object2.length() > 0) {
                object3 = new StringBuilder();
                object3.append((String)object);
                object3.append(this.value.substring(n));
                object = object3.toString();
                object3 = new StringBuilder();
                object3.append(this.value.substring(0, n3));
                object3.append((String)object2);
                this.value = this.trim(object3.toString());
                return new PdfChunk((String)object, this);
            }
        }
        object2 = this.value.substring(n5);
        this.value = this.trim(this.value.substring(0, n5));
        return new PdfChunk((String)object2, this);
    }

    public String toString() {
        return this.value;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    String trim(String string2) {
        Object object = this.font.getFont();
        String string3 = string2;
        if (object.getFontType() == 2) {
            string3 = string2;
            if (object.getUnicodeEquivalent(32) != 32) {
                do {
                    object = string2;
                    if (!string2.endsWith("\u0001")) return object;
                    string2 = string2.substring(0, string2.length() - 1);
                } while (true);
            }
        }
        do {
            if (!string3.endsWith(" ")) {
                object = string3;
                if (!string3.endsWith("\t")) {
                    return object;
                }
            }
            string3 = string3.substring(0, string3.length() - 1);
        } while (true);
    }

    public float trimFirstSpace() {
        BaseFont baseFont = this.font.getFont();
        if (baseFont.getFontType() == 2 && baseFont.getUnicodeEquivalent(32) != 32) {
            if (this.value.length() > 1 && this.value.startsWith("\u0001")) {
                this.value = this.value.substring(1);
                return this.font.width(1);
            }
        } else if (this.value.length() > 1 && this.value.startsWith(" ")) {
            this.value = this.value.substring(1);
            return this.font.width(32);
        }
        return 0.0f;
    }

    public float trimLastSpace() {
        BaseFont baseFont = this.font.getFont();
        if (baseFont.getFontType() == 2 && baseFont.getUnicodeEquivalent(32) != 32) {
            if (this.value.length() > 1 && this.value.endsWith("\u0001")) {
                this.value = this.value.substring(0, this.value.length() - 1);
                return this.font.width(1);
            }
        } else if (this.value.length() > 1 && this.value.endsWith(" ")) {
            this.value = this.value.substring(0, this.value.length() - 1);
            return this.font.width(32);
        }
        return 0.0f;
    }

    PdfChunk truncate(float f) {
        if (this.image != null) {
            if (this.image.getScaledWidth() > f) {
                if (this.image.isScaleToFitLineWhenOverflow()) {
                    this.setImageScalePercentage(f / this.image.getWidth());
                    return null;
                }
                PdfChunk pdfChunk = new PdfChunk("", this);
                this.value = "";
                this.attributes.remove("IMAGE");
                this.image = null;
                this.font = PdfFont.getDefaultFont();
                return pdfChunk;
            }
            return null;
        }
        float f2 = this.font.width();
        int n = 1;
        if (f < f2) {
            String string2 = this.value.substring(1);
            this.value = this.value.substring(0, 1);
            return new PdfChunk(string2, this);
        }
        int n2 = this.value.length();
        int n3 = 0;
        f2 = 0.0f;
        boolean bl = false;
        while (n3 < n2) {
            bl = Utilities.isSurrogatePair(this.value, n3);
            f2 = bl ? (f2 += this.getCharWidth(Utilities.convertToUtf32(this.value, n3))) : (f2 += this.getCharWidth(this.value.charAt(n3)));
            if (f2 > f) break;
            int n4 = n3;
            if (bl) {
                n4 = n3 + 1;
            }
            n3 = n4 + 1;
        }
        if (n3 == n2) {
            return null;
        }
        if (n3 == 0) {
            n3 = n;
            if (bl) {
                n3 = 2;
            }
        }
        String string3 = this.value.substring(n3);
        this.value = this.value.substring(0, n3);
        return new PdfChunk(string3, this);
    }

    float width() {
        return this.width(this.value);
    }

    float width(String object) {
        float f;
        if (this.isAttribute("SEPARATOR")) {
            return 0.0f;
        }
        if (this.isImage()) {
            return this.getImageWidth();
        }
        float f2 = f = this.font.width((String)object);
        if (this.isAttribute("CHAR_SPACING")) {
            Float f3 = (Float)this.getAttribute("CHAR_SPACING");
            f2 = f + (float)object.length() * f3.floatValue();
        }
        f = f2;
        if (this.isAttribute("WORD_SPACING")) {
            int n = 0;
            int n2 = -1;
            while ((n2 = object.indexOf(32, n2 + 1)) >= 0) {
                ++n;
            }
            object = (Float)this.getAttribute("WORD_SPACING");
            f = f2 + (float)n * object.floatValue();
        }
        return f;
    }
}

