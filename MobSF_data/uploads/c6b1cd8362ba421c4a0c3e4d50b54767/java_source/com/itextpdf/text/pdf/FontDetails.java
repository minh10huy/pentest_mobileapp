/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.pdf.ArrayBasedStringTokenizer;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.CJKFont;
import com.itextpdf.text.pdf.Glyph;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.TrueTypeFontUnicode;
import com.itextpdf.text.pdf.fonts.otf.Language;
import com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner;
import com.itextpdf.text.pdf.languages.GlyphRepositioner;
import com.itextpdf.text.pdf.languages.IndicCompositeCharacterComparator;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

class FontDetails {
    BaseFont baseFont;
    CJKFont cjkFont;
    IntHashtable cjkTag;
    PdfName fontName;
    int fontType;
    PdfIndirectReference indirectReference;
    HashMap<Integer, int[]> longTag;
    byte[] shortTag;
    protected boolean subset = true;
    boolean symbolic;
    TrueTypeFontUnicode ttu;

    FontDetails(PdfName pdfName, PdfIndirectReference pdfIndirectReference, BaseFont baseFont) {
        this.fontName = pdfName;
        this.indirectReference = pdfIndirectReference;
        this.baseFont = baseFont;
        this.fontType = baseFont.getFontType();
        switch (this.fontType) {
            default: {
                return;
            }
            case 3: {
                this.longTag = new HashMap();
                this.ttu = (TrueTypeFontUnicode)baseFont;
                this.symbolic = baseFont.isFontSpecific();
                return;
            }
            case 2: {
                this.cjkTag = new IntHashtable();
                this.cjkFont = (CJKFont)baseFont;
                return;
            }
            case 0: 
            case 1: 
        }
        this.shortTag = new byte[256];
    }

    private boolean canApplyGlyphSubstitution() {
        if (this.fontType == 3 && this.ttu.getGlyphSubstitutionMap() != null) {
            return true;
        }
        return false;
    }

    private byte[] convertToBytesAfterGlyphSubstitution(String object) throws UnsupportedEncodingException {
        int n;
        Object object2;
        if (!this.canApplyGlyphSubstitution()) {
            throw new IllegalArgumentException("Make sure the font type if TTF Unicode and a valid GlyphSubstitutionTable exists!");
        }
        Object object3 = this.ttu.getGlyphSubstitutionMap();
        Object object4 = new String[](new IndicCompositeCharacterComparator());
        object4.addAll(object3.keySet());
        object4 = new ArrayBasedStringTokenizer(object4.toArray(new String[0])).tokenize((String)object);
        object = new ArrayList(50);
        int n2 = ((String[])object4).length;
        for (n = 0; n < n2; ++n) {
            object2 = object4[n];
            int[] arrn = (int[])object3.get(object2);
            if (arrn != null) {
                object.add(arrn);
                continue;
            }
            for (char c : object2.toCharArray()) {
                arrn = this.ttu.getMetricsTT(c);
                object.add(new Glyph(arrn[0], arrn[1], String.valueOf(c)));
            }
        }
        object3 = this.getGlyphRepositioner();
        if (object3 != null) {
            object3.repositionGlyphs((List<Glyph>)object);
        }
        object3 = new char[object.size()];
        for (n = 0; n < object.size(); ++n) {
            object4 = (Glyph)object.get(n);
            object3[n] = (char)object4.code;
            object2 = object4.code;
            if (this.longTag.containsKey(object2)) continue;
            this.longTag.put((Integer)object2, new int[]{object4.code, object4.width, object4.chars.charAt(0)});
        }
        return new String((char[])object3).getBytes("UnicodeBigUnmarked");
    }

    private GlyphRepositioner getGlyphRepositioner() {
        Object object = this.ttu.getSupportedLanguage();
        if (object == null) {
            object = new StringBuilder();
            object.append("The supported language field cannot be null in ");
            object.append(this.ttu.getClass().getName());
            throw new IllegalArgumentException(object.toString());
        }
        if (.$SwitchMap$com$itextpdf$text$pdf$fonts$otf$Language[object.ordinal()] != 1) {
            return null;
        }
        return new BanglaGlyphRepositioner(Collections.unmodifiableMap(this.ttu.cmap31), this.ttu.getGlyphSubstitutionMap());
    }

    /*
     * Exception decompiling
     */
    byte[] convertToBytes(String var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.CannotPerformDecode: reachable test BLOCK was exited and re-entered.
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Misc.getFarthestReachableInRange(Misc.java:143)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:385)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    /*
     * Unable to fully structure code
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    Object[] convertToBytesGid(String var1_1) {
        if (this.fontType != 3) {
            throw new IllegalArgumentException("GID require TT Unicode");
        }
        var8_3 = new StringBuilder();
        var9_4 = var1_1.toCharArray();
        var4_5 = var9_4.length;
        var2_6 = 0;
        var3_7 = 0;
        do {
            block8 : {
                if (var2_6 >= var4_5) ** GOTO lbl25
                var5_8 = var9_4[var2_6];
                try {
                    var6_9 = this.ttu.getGlyphWidth(var5_8);
                }
                catch (Exception var1_2) {
                    throw new ExceptionConverter(var1_2);
                }
                var3_7 += var6_9;
                var7_10 = this.ttu.GetCharFromGlyphId(var5_8);
                if (var7_10 == 0) ** GOTO lbl22
                var8_3.append(Utilities.convertFromUtf32(var7_10));
lbl22: // 2 sources:
                if (!this.longTag.containsKey(var10_11 = Integer.valueOf(var5_8))) {
                    this.longTag.put(var10_11, new int[]{var5_8, var6_9, var7_10});
                }
                break block8;
lbl25: // 1 sources:
                var1_1 = var1_1.getBytes("UnicodeBigUnmarked");
                var8_3 = var8_3.toString();
                return new Object[]{var1_1, var8_3, var3_7};
            }
            ++var2_6;
        } while (true);
    }

    BaseFont getBaseFont() {
        return this.baseFont;
    }

    PdfName getFontName() {
        return this.fontName;
    }

    PdfIndirectReference getIndirectReference() {
        return this.indirectReference;
    }

    public boolean isSubset() {
        return this.subset;
    }

    public void setSubset(boolean bl) {
        this.subset = bl;
    }

    /*
     * Exception decompiling
     */
    public void writeFont(PdfWriter var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [4[CASE]], but top level block is 1[TRYBLOCK]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

}

