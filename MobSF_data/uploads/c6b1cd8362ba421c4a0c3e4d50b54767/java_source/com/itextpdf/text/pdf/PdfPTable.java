/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.AccessibleElementId;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.ElementListener;
import com.itextpdf.text.Image;
import com.itextpdf.text.LargeElement;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.api.Spaceable;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.PdfArtifact;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfPCell;
import com.itextpdf.text.pdf.PdfPHeaderCell;
import com.itextpdf.text.pdf.PdfPRow;
import com.itextpdf.text.pdf.PdfPTableBody;
import com.itextpdf.text.pdf.PdfPTableEvent;
import com.itextpdf.text.pdf.PdfPTableFooter;
import com.itextpdf.text.pdf.PdfPTableHeader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.events.PdfPTableEventForwarder;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class PdfPTable
implements LargeElement,
Spaceable,
IAccessibleElement {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    public static final int BACKGROUNDCANVAS = 1;
    public static final int BASECANVAS = 0;
    public static final int LINECANVAS = 2;
    public static final int TEXTCANVAS = 3;
    private final Logger LOGGER = LoggerFactory.getLogger(PdfPTable.class);
    protected float[] absoluteWidths;
    protected HashMap<PdfName, PdfObject> accessibleAttributes;
    private PdfPTableBody body;
    protected boolean complete;
    protected int currentColIdx;
    protected PdfPCell[] currentRow;
    protected PdfPCell defaultCell;
    private boolean[] extendLastRow;
    private PdfPTableFooter footer;
    private int footerRows;
    private PdfPTableHeader header;
    protected int headerRows;
    private boolean headersInEvent;
    private int horizontalAlignment;
    protected AccessibleElementId id;
    protected boolean isColspan;
    private boolean keepTogether;
    private boolean lockedWidth;
    protected boolean loopCheck;
    private int numberOfWrittenRows;
    protected float paddingTop;
    protected float[] relativeWidths;
    protected PdfName role;
    protected boolean rowCompleted;
    protected ArrayList<PdfPRow> rows = new ArrayList();
    protected boolean rowsNotChecked;
    protected int runDirection;
    private boolean skipFirstHeader;
    private boolean skipLastFooter;
    protected float spacingAfter;
    protected float spacingBefore;
    private boolean splitLate;
    private boolean splitRows;
    protected PdfPTableEvent tableEvent;
    protected float totalHeight = 0.0f;
    protected float totalWidth;
    protected float widthPercentage;

    protected PdfPTable() {
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
    }

    public PdfPTable(int n) {
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
        if (n <= 0) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.number.of.columns.in.pdfptable.constructor.must.be.greater.than.zero", new Object[0]));
        }
        this.relativeWidths = new float[n];
        for (int i = 0; i < n; ++i) {
            this.relativeWidths[i] = 1.0f;
        }
        this.absoluteWidths = new float[this.relativeWidths.length];
        this.calculateWidths();
        this.currentRow = new PdfPCell[this.absoluteWidths.length];
        this.keepTogether = false;
    }

    public PdfPTable(PdfPTable pdfPTable) {
        int n;
        int n2 = 0;
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
        this.copyFormat(pdfPTable);
        int n3 = 0;
        do {
            n = n2;
            if (n3 >= this.currentRow.length) break;
            if (pdfPTable.currentRow[n3] == null) {
                n = n2;
                break;
            }
            this.currentRow[n3] = new PdfPCell(pdfPTable.currentRow[n3]);
            ++n3;
        } while (true);
        while (n < pdfPTable.rows.size()) {
            PdfPRow pdfPRow;
            PdfPRow pdfPRow2 = pdfPRow = pdfPTable.rows.get(n);
            if (pdfPRow != null) {
                pdfPRow2 = new PdfPRow(pdfPRow);
            }
            this.rows.add(pdfPRow2);
            ++n;
        }
    }

    public PdfPTable(float[] arrf) {
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
        if (arrf == null) {
            throw new NullPointerException(MessageLocalization.getComposedMessage("the.widths.array.in.pdfptable.constructor.can.not.be.null", new Object[0]));
        }
        if (arrf.length == 0) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.widths.array.in.pdfptable.constructor.can.not.have.zero.length", new Object[0]));
        }
        this.relativeWidths = new float[arrf.length];
        System.arraycopy(arrf, 0, this.relativeWidths, 0, arrf.length);
        this.absoluteWidths = new float[arrf.length];
        this.calculateWidths();
        this.currentRow = new PdfPCell[this.absoluteWidths.length];
        this.keepTogether = false;
    }

    public static PdfContentByte[] beginWritingRows(PdfContentByte pdfContentByte) {
        return new PdfContentByte[]{pdfContentByte, pdfContentByte.getDuplicate(), pdfContentByte.getDuplicate(), pdfContentByte.getDuplicate()};
    }

    private PdfPTableBody closeTableBlock(PdfPTableBody pdfPTableBody, PdfContentByte pdfContentByte) {
        if (pdfContentByte.writer.getStandardStructElems().contains(pdfPTableBody.getRole())) {
            pdfContentByte.closeMCBlock(pdfPTableBody);
        }
        return null;
    }

    public static void endWritingRows(PdfContentByte[] arrpdfContentByte) {
        PdfContentByte pdfContentByte = arrpdfContentByte[0];
        PdfArtifact pdfArtifact = new PdfArtifact();
        pdfContentByte.openMCBlock(pdfArtifact);
        pdfContentByte.saveState();
        pdfContentByte.add(arrpdfContentByte[1]);
        pdfContentByte.restoreState();
        pdfContentByte.saveState();
        pdfContentByte.setLineCap(2);
        pdfContentByte.resetRGBColorStroke();
        pdfContentByte.add(arrpdfContentByte[2]);
        pdfContentByte.restoreState();
        pdfContentByte.closeMCBlock(pdfArtifact);
        pdfContentByte.add(arrpdfContentByte[3]);
    }

    private PdfPTableBody openTableBlock(PdfPTableBody pdfPTableBody, PdfContentByte pdfContentByte) {
        if (pdfContentByte.writer.getStandardStructElems().contains(pdfPTableBody.getRole())) {
            pdfContentByte.openMCBlock(pdfPTableBody);
            return pdfPTableBody;
        }
        return null;
    }

    public static PdfPTable shallowCopy(PdfPTable pdfPTable) {
        PdfPTable pdfPTable2 = new PdfPTable();
        pdfPTable2.copyFormat(pdfPTable);
        return pdfPTable2;
    }

    private void skipColsWithRowspanAbove() {
        int n = this.runDirection == 3 ? -1 : 1;
        while (this.rowSpanAbove(this.rows.size(), this.currentColIdx)) {
            this.currentColIdx += n;
        }
    }

    public PdfPCell addCell(PdfPCell pdfPCell) {
        boolean bl;
        this.rowCompleted = false;
        pdfPCell = pdfPCell instanceof PdfPHeaderCell ? new PdfPHeaderCell((PdfPHeaderCell)pdfPCell) : new PdfPCell(pdfPCell);
        int n = Math.min(Math.max(pdfPCell.getColspan(), 1), this.currentRow.length - this.currentColIdx);
        pdfPCell.setColspan(n);
        if (n != 1) {
            this.isColspan = true;
        }
        if (pdfPCell.getRunDirection() == 1) {
            pdfPCell.setRunDirection(this.runDirection);
        }
        this.skipColsWithRowspanAbove();
        if (this.currentColIdx < this.currentRow.length) {
            this.currentRow[this.currentColIdx] = pdfPCell;
            this.currentColIdx += n;
            bl = true;
        } else {
            bl = false;
        }
        this.skipColsWithRowspanAbove();
        while (this.currentColIdx >= this.currentRow.length) {
            Object object;
            int n2 = this.getNumberOfColumns();
            if (this.runDirection == 3) {
                object = new PdfPCell[n2];
                int n3 = this.currentRow.length;
                int n4 = 0;
                while (n4 < this.currentRow.length) {
                    PdfPCell pdfPCell2 = this.currentRow[n4];
                    int n5 = pdfPCell2.getColspan();
                    object[n3 -= n5] = pdfPCell2;
                    n4 = n4 + (n5 - 1) + 1;
                }
                this.currentRow = object;
            }
            object = new PdfPRow(this.currentRow);
            if (this.totalWidth > 0.0f) {
                object.setWidths(this.absoluteWidths);
                this.totalHeight += object.getMaxHeights();
            }
            this.rows.add((PdfPRow)object);
            this.currentRow = new PdfPCell[n2];
            this.currentColIdx = 0;
            this.skipColsWithRowspanAbove();
            this.rowCompleted = true;
        }
        if (!bl) {
            this.currentRow[this.currentColIdx] = pdfPCell;
            this.currentColIdx += n;
        }
        return pdfPCell;
    }

    public void addCell(Image image) {
        this.defaultCell.setImage(image);
        this.addCell((PdfPCell)this.defaultCell).id = new AccessibleElementId();
        this.defaultCell.setImage(null);
    }

    public void addCell(Phrase phrase) {
        this.defaultCell.setPhrase(phrase);
        this.addCell((PdfPCell)this.defaultCell).id = new AccessibleElementId();
        this.defaultCell.setPhrase(null);
    }

    public void addCell(PdfPTable pdfPTable) {
        this.defaultCell.setTable(pdfPTable);
        this.addCell((PdfPCell)this.defaultCell).id = new AccessibleElementId();
        this.defaultCell.setTable(null);
    }

    public void addCell(String string2) {
        this.addCell(new Phrase(string2));
    }

    void addNumberOfRowsWritten(int n) {
        this.numberOfWrittenRows += n;
    }

    protected PdfPRow adjustCellsInRow(int n, int n2) {
        PdfPRow pdfPRow = this.getRow(n);
        if (pdfPRow.isAdjusted()) {
            return pdfPRow;
        }
        pdfPRow = new PdfPRow(pdfPRow);
        PdfPCell[] arrpdfPCell = pdfPRow.getCells();
        for (int i = 0; i < arrpdfPCell.length; ++i) {
            PdfPCell pdfPCell = arrpdfPCell[i];
            if (pdfPCell == null || pdfPCell.getRowspan() == 1) continue;
            int n3 = Math.min(n2, pdfPCell.getRowspan() + n);
            float f = 0.0f;
            for (int j = 1 + n; j < n3; ++j) {
                f += this.getRow(j).getMaxHeights();
            }
            pdfPRow.setExtraHeight(i, f);
        }
        pdfPRow.setAdjusted(true);
        return pdfPRow;
    }

    public float calculateHeights() {
        if (this.totalWidth <= 0.0f) {
            return 0.0f;
        }
        this.totalHeight = 0.0f;
        for (int i = 0; i < this.rows.size(); ++i) {
            this.totalHeight += this.getRowHeight(i, true);
        }
        return this.totalHeight;
    }

    protected void calculateWidths() {
        if (this.totalWidth <= 0.0f) {
            return;
        }
        int n = this.getNumberOfColumns();
        int n2 = 0;
        int n3 = 0;
        float f = 0.0f;
        do {
            if (n3 >= n) break;
            f += this.relativeWidths[n3];
            ++n3;
        } while (true);
        for (int i = n2; i < n; ++i) {
            this.absoluteWidths[i] = this.totalWidth * this.relativeWidths[i] / f;
        }
    }

    PdfPCell cellAt(int n, int n2) {
        PdfPCell[] arrpdfPCell = this.rows.get(n).getCells();
        for (n = 0; n < arrpdfPCell.length; ++n) {
            if (arrpdfPCell[n] == null || n2 < n || n2 >= arrpdfPCell[n].getColspan() + n) continue;
            return arrpdfPCell[n];
        }
        return null;
    }

    public void completeRow() {
        while (!this.rowCompleted) {
            this.addCell(this.defaultCell);
        }
    }

    protected void copyFormat(PdfPTable pdfPTable) {
        this.rowsNotChecked = pdfPTable.rowsNotChecked;
        this.relativeWidths = new float[pdfPTable.getNumberOfColumns()];
        this.absoluteWidths = new float[pdfPTable.getNumberOfColumns()];
        System.arraycopy(pdfPTable.relativeWidths, 0, this.relativeWidths, 0, this.getNumberOfColumns());
        System.arraycopy(pdfPTable.absoluteWidths, 0, this.absoluteWidths, 0, this.getNumberOfColumns());
        this.totalWidth = pdfPTable.totalWidth;
        this.totalHeight = pdfPTable.totalHeight;
        this.currentColIdx = 0;
        this.tableEvent = pdfPTable.tableEvent;
        this.runDirection = pdfPTable.runDirection;
        this.defaultCell = pdfPTable.defaultCell instanceof PdfPHeaderCell ? new PdfPHeaderCell((PdfPHeaderCell)pdfPTable.defaultCell) : new PdfPCell(pdfPTable.defaultCell);
        this.currentRow = new PdfPCell[pdfPTable.currentRow.length];
        this.isColspan = pdfPTable.isColspan;
        this.splitRows = pdfPTable.splitRows;
        this.spacingAfter = pdfPTable.spacingAfter;
        this.spacingBefore = pdfPTable.spacingBefore;
        this.headerRows = pdfPTable.headerRows;
        this.footerRows = pdfPTable.footerRows;
        this.lockedWidth = pdfPTable.lockedWidth;
        this.extendLastRow = pdfPTable.extendLastRow;
        this.headersInEvent = pdfPTable.headersInEvent;
        this.widthPercentage = pdfPTable.widthPercentage;
        this.splitLate = pdfPTable.splitLate;
        this.skipFirstHeader = pdfPTable.skipFirstHeader;
        this.skipLastFooter = pdfPTable.skipLastFooter;
        this.horizontalAlignment = pdfPTable.horizontalAlignment;
        this.keepTogether = pdfPTable.keepTogether;
        this.complete = pdfPTable.complete;
        this.loopCheck = pdfPTable.loopCheck;
        this.id = pdfPTable.id;
        this.role = pdfPTable.role;
        if (pdfPTable.accessibleAttributes != null) {
            this.accessibleAttributes = new HashMap<PdfName, PdfObject>(pdfPTable.accessibleAttributes);
        }
        this.header = pdfPTable.getHeader();
        this.body = pdfPTable.getBody();
        this.footer = pdfPTable.getFooter();
    }

    public void deleteBodyRows() {
        ArrayList<PdfPRow> arrayList = new ArrayList<PdfPRow>();
        for (int i = 0; i < this.headerRows; ++i) {
            arrayList.add(this.rows.get(i));
        }
        this.rows = arrayList;
        this.totalHeight = 0.0f;
        if (this.totalWidth > 0.0f) {
            this.totalHeight = this.getHeaderHeight();
        }
    }

    public boolean deleteLastRow() {
        return this.deleteRow(this.rows.size() - 1);
    }

    public boolean deleteRow(int n) {
        if (n >= 0 && n < this.rows.size()) {
            PdfPRow pdfPRow;
            if (this.totalWidth > 0.0f && (pdfPRow = this.rows.get(n)) != null) {
                this.totalHeight -= pdfPRow.getMaxHeights();
            }
            this.rows.remove(n);
            if (n < this.headerRows) {
                --this.headerRows;
                if (n >= this.headerRows - this.footerRows) {
                    --this.footerRows;
                }
            }
            return true;
        }
        return false;
    }

    @Override
    public void flushContent() {
        this.deleteBodyRows();
        if (this.numberOfWrittenRows > 0) {
            this.setSkipFirstHeader(true);
        }
    }

    public float[] getAbsoluteWidths() {
        return this.absoluteWidths;
    }

    @Override
    public PdfObject getAccessibleAttribute(PdfName pdfName) {
        if (this.accessibleAttributes != null) {
            return this.accessibleAttributes.get(pdfName);
        }
        return null;
    }

    @Override
    public HashMap<PdfName, PdfObject> getAccessibleAttributes() {
        return this.accessibleAttributes;
    }

    public PdfPTableBody getBody() {
        if (this.body == null) {
            this.body = new PdfPTableBody();
        }
        return this.body;
    }

    public int getCellStartRowIndex(int n, int n2) {
        while (this.getRow(n).getCells()[n2] == null && n > 0) {
            --n;
        }
        return n;
    }

    @Override
    public List<Chunk> getChunks() {
        return new ArrayList<Chunk>();
    }

    public PdfPCell getDefaultCell() {
        return this.defaultCell;
    }

    float[][] getEventWidths(float f, int n, int n2, boolean bl) {
        float[][] arrarrf;
        int n3 = n;
        int n4 = n2;
        if (bl) {
            n3 = Math.max(n, this.headerRows);
            n4 = Math.max(n2, this.headerRows);
        }
        int n5 = 0;
        n2 = 0;
        n = bl ? this.headerRows : 0;
        arrarrf = new float[n + n4 - n3][];
        if (this.isColspan) {
            PdfPRow pdfPRow;
            int n6;
            if (bl) {
                n = 0;
                n5 = n2;
                do {
                    n6 = n3;
                    n2 = n++;
                    if (n5 < this.headerRows) {
                        pdfPRow = this.rows.get(n5);
                        if (pdfPRow != null) {
                            arrarrf[n] = pdfPRow.getEventWidth(f, this.absoluteWidths);
                            ++n;
                        }
                        ++n5;
                        continue;
                    }
                    break;
                } while (true);
            } else {
                n2 = 0;
                n6 = n3;
            }
            while (n6 < n4) {
                pdfPRow = this.rows.get(n6);
                if (pdfPRow == null) {
                    ++n2;
                } else {
                    arrarrf[n2] = pdfPRow.getEventWidth(f, this.absoluteWidths);
                    ++n2;
                }
                ++n6;
            }
        } else {
            n3 = this.getNumberOfColumns();
            float[] arrf = new float[n3 + 1];
            arrf[0] = f;
            n = 0;
            do {
                if (n >= n3) break;
                n2 = n + 1;
                arrf[n2] = arrf[n] + this.absoluteWidths[n];
                n = n2;
            } while (true);
            for (n2 = n5; n2 < arrarrf.length; ++n2) {
                arrarrf[n2] = arrf;
            }
        }
        return arrarrf;
    }

    public FittingRows getFittingRows(float f, int n) {
        int n2;
        int n3;
        this.LOGGER.info(String.format("getFittingRows(%s, %s)", Float.valueOf(f), n));
        if (n > 0) {
            this.rows.size();
        }
        int n4 = this.getNumberOfColumns();
        ColumnMeasurementState[] arrcolumnMeasurementState = new ColumnMeasurementState[n4];
        for (n3 = 0; n3 < n4; ++n3) {
            arrcolumnMeasurementState[n3] = new ColumnMeasurementState();
        }
        HashMap<Integer, Float> hashMap = new HashMap<Integer, Float>();
        float f2 = 0.0f;
        float f3 = 0.0f;
        n3 = n4;
        for (n2 = n; n2 < this.size(); ++n2) {
            int n5;
            Object object;
            float f4;
            PdfPRow pdfPRow = this.getRow(n2);
            float f5 = pdfPRow.getMaxRowHeightsWithoutCalculating();
            float f6 = 0.0f;
            for (n4 = 0; n4 < n3; n4 += columnMeasurementState.colspan) {
                object = pdfPRow.getCells()[n4];
                ColumnMeasurementState columnMeasurementState = arrcolumnMeasurementState[n4];
                if (object == null) {
                    columnMeasurementState.consumeRowspan(f2, f5);
                } else {
                    columnMeasurementState.beginCell((PdfPCell)object, f2, f5);
                    this.LOGGER.info(String.format("Height after beginCell: %s (cell: %s)", Float.valueOf(columnMeasurementState.height), Float.valueOf(object.getCachedMaxHeight())));
                }
                f4 = f6;
                if (columnMeasurementState.cellEnds()) {
                    f4 = f6;
                    if (columnMeasurementState.height > f6) {
                        f4 = columnMeasurementState.height;
                    }
                }
                for (n5 = 1; n5 < columnMeasurementState.colspan; ++n5) {
                    arrcolumnMeasurementState[n4 + n5].height = columnMeasurementState.height;
                }
                f6 = f4;
            }
            n5 = arrcolumnMeasurementState.length;
            f5 = 0.0f;
            for (n4 = 0; n4 < n5; ++n4) {
                object = arrcolumnMeasurementState[n4];
                f4 = f5;
                if (object.height > f5) {
                    f4 = object.height;
                }
                f5 = f4;
            }
            pdfPRow.setFinalMaxHeights(f6 - f2);
            f4 = this.isSplitLate() ? f5 : f6;
            if (f - f4 < 0.0f) break;
            hashMap.put(n2, Float.valueOf(f5 - f2));
            f2 = f6;
            f3 = f5;
        }
        this.rowsNotChecked = false;
        return new FittingRows(n, n2 - 1, f3, f2, hashMap);
    }

    public PdfPTableFooter getFooter() {
        if (this.footer == null) {
            this.footer = new PdfPTableFooter();
        }
        return this.footer;
    }

    public float getFooterHeight() {
        int n = Math.min(this.rows.size(), this.headerRows);
        float f = 0.0f;
        for (int i = Math.max((int)0, (int)(this.headerRows - this.footerRows)); i < n; ++i) {
            PdfPRow pdfPRow = this.rows.get(i);
            float f2 = f;
            if (pdfPRow != null) {
                f2 = f + pdfPRow.getMaxHeights();
            }
            f = f2;
        }
        return f;
    }

    public int getFooterRows() {
        return this.footerRows;
    }

    public PdfPTableHeader getHeader() {
        if (this.header == null) {
            this.header = new PdfPTableHeader();
        }
        return this.header;
    }

    public float getHeaderHeight() {
        int n = Math.min(this.rows.size(), this.headerRows);
        float f = 0.0f;
        for (int i = 0; i < n; ++i) {
            PdfPRow pdfPRow = this.rows.get(i);
            float f2 = f;
            if (pdfPRow != null) {
                f2 = f + pdfPRow.getMaxHeights();
            }
            f = f2;
        }
        return f;
    }

    public int getHeaderRows() {
        return this.headerRows;
    }

    public int getHorizontalAlignment() {
        return this.horizontalAlignment;
    }

    @Override
    public AccessibleElementId getId() {
        return this.id;
    }

    public boolean getKeepTogether() {
        return this.keepTogether;
    }

    public int getLastCompletedRowIndex() {
        return this.rows.size() - 1;
    }

    public int getNumberOfColumns() {
        return this.relativeWidths.length;
    }

    @Override
    public float getPaddingTop() {
        return this.paddingTop;
    }

    @Override
    public PdfName getRole() {
        return this.role;
    }

    public PdfPRow getRow(int n) {
        return this.rows.get(n);
    }

    public float getRowHeight(int n) {
        return this.getRowHeight(n, false);
    }

    protected float getRowHeight(int n, boolean bl) {
        if (this.totalWidth > 0.0f && n >= 0) {
            if (n >= this.rows.size()) {
                return 0.0f;
            }
            PdfPRow pdfPRow = this.rows.get(n);
            if (pdfPRow == null) {
                return 0.0f;
            }
            if (bl) {
                pdfPRow.setWidths(this.absoluteWidths);
            }
            float f = pdfPRow.getMaxHeights();
            for (int i = 0; i < this.relativeWidths.length; ++i) {
                float f2;
                if (!this.rowSpanAbove(n, i)) {
                    f2 = f;
                } else {
                    float f3;
                    int n2;
                    int n3 = 1;
                    while (this.rowSpanAbove(n2 = n - n3, i)) {
                        ++n3;
                    }
                    PdfPCell pdfPCell = this.rows.get(n2).getCells()[i];
                    if (pdfPCell != null && pdfPCell.getRowspan() == n3 + 1) {
                        f2 = pdfPCell.getMaxHeight();
                        do {
                            f3 = f2;
                            if (n3 > 0) {
                                f2 -= this.getRowHeight(n - n3);
                                --n3;
                                continue;
                            }
                            break;
                        } while (true);
                    } else {
                        f3 = 0.0f;
                    }
                    f2 = f;
                    if (f3 > f) {
                        f2 = f3;
                    }
                }
                f = f2;
            }
            pdfPRow.setMaxHeights(f);
            return f;
        }
        return 0.0f;
    }

    public ArrayList<PdfPRow> getRows() {
        return this.rows;
    }

    public ArrayList<PdfPRow> getRows(int n, int n2) {
        ArrayList<PdfPRow> arrayList = new ArrayList<PdfPRow>();
        if (n >= 0) {
            if (n2 > this.size()) {
                return arrayList;
            }
            while (n < n2) {
                arrayList.add(this.adjustCellsInRow(n, n2));
                ++n;
            }
            return arrayList;
        }
        return arrayList;
    }

    public float getRowspanHeight(int n, int n2) {
        float f = this.totalWidth;
        float f2 = 0.0f;
        if (f > 0.0f && n >= 0) {
            if (n >= this.rows.size()) {
                return 0.0f;
            }
            IAccessibleElement iAccessibleElement = this.rows.get(n);
            if (iAccessibleElement != null) {
                if (n2 >= iAccessibleElement.getCells().length) {
                    return 0.0f;
                }
                if ((iAccessibleElement = iAccessibleElement.getCells()[n2]) == null) {
                    return 0.0f;
                }
                for (n2 = 0; n2 < iAccessibleElement.getRowspan(); ++n2) {
                    f2 += this.getRowHeight(n + n2);
                }
                return f2;
            }
            return 0.0f;
        }
        return 0.0f;
    }

    public int getRunDirection() {
        return this.runDirection;
    }

    @Override
    public float getSpacingAfter() {
        return this.spacingAfter;
    }

    @Override
    public float getSpacingBefore() {
        return this.spacingBefore;
    }

    public String getSummary() {
        return this.getAccessibleAttribute(PdfName.SUMMARY).toString();
    }

    public PdfPTableEvent getTableEvent() {
        return this.tableEvent;
    }

    public float getTotalHeight() {
        return this.totalHeight;
    }

    public float getTotalWidth() {
        return this.totalWidth;
    }

    public float getWidthPercentage() {
        return this.widthPercentage;
    }

    public boolean hasRowspan(int n) {
        if (n < this.rows.size() && this.getRow(n).hasRowspan()) {
            return true;
        }
        PdfPRow pdfPRow = n > 0 ? this.getRow(n - 1) : null;
        if (pdfPRow != null && pdfPRow.hasRowspan()) {
            return true;
        }
        for (int i = 0; i < this.getNumberOfColumns(); ++i) {
            if (!this.rowSpanAbove(n - 1, i)) continue;
            return true;
        }
        return false;
    }

    public void init() {
        this.LOGGER.info("Initialize row and cell heights");
        for (PdfPRow pdfPRow : this.getRows()) {
            if (pdfPRow == null) continue;
            pdfPRow.calculated = false;
            for (PdfPCell pdfPCell : pdfPRow.getCells()) {
                if (pdfPCell == null) continue;
                pdfPCell.setCalculatedHeight(0.0f);
            }
        }
    }

    @Override
    public boolean isComplete() {
        return this.complete;
    }

    @Override
    public boolean isContent() {
        return true;
    }

    public boolean isExtendLastRow() {
        return this.extendLastRow[0];
    }

    public boolean isExtendLastRow(boolean bl) {
        if (bl) {
            return this.extendLastRow[0];
        }
        return this.extendLastRow[1];
    }

    public boolean isHeadersInEvent() {
        return this.headersInEvent;
    }

    @Override
    public boolean isInline() {
        return false;
    }

    public boolean isLockedWidth() {
        return this.lockedWidth;
    }

    public boolean isLoopCheck() {
        return this.loopCheck;
    }

    @Override
    public boolean isNestable() {
        return true;
    }

    public boolean isSkipFirstHeader() {
        return this.skipFirstHeader;
    }

    public boolean isSkipLastFooter() {
        return this.skipLastFooter;
    }

    public boolean isSplitLate() {
        return this.splitLate;
    }

    public boolean isSplitRows() {
        return this.splitRows;
    }

    public void keepRowsTogether(int n) {
        this.keepRowsTogether(n, this.rows.size());
    }

    public void keepRowsTogether(int n, int n2) {
        if (n < n2) {
            while (n < n2) {
                this.getRow(n).setMayNotBreak(true);
                ++n;
            }
        }
    }

    public void keepRowsTogether(int[] arrn) {
        for (int i = 0; i < arrn.length; ++i) {
            this.getRow(arrn[i]).setMayNotBreak(true);
        }
    }

    public void normalizeHeadersFooters() {
        if (this.footerRows > this.headerRows) {
            this.footerRows = this.headerRows;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public boolean process(ElementListener elementListener) {
        try {
            return elementListener.add(this);
        }
        catch (DocumentException documentException) {
            return false;
        }
    }

    public void resetColumnCount(int n) {
        if (n <= 0) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.number.of.columns.in.pdfptable.constructor.must.be.greater.than.zero", new Object[0]));
        }
        this.relativeWidths = new float[n];
        for (int i = 0; i < n; ++i) {
            this.relativeWidths[i] = 1.0f;
        }
        this.absoluteWidths = new float[this.relativeWidths.length];
        this.calculateWidths();
        this.currentRow = new PdfPCell[this.absoluteWidths.length];
        this.totalHeight = 0.0f;
    }

    boolean rowSpanAbove(int n, int n2) {
        if (n2 < this.getNumberOfColumns() && n2 >= 0) {
            if (n < 1) {
                return false;
            }
            int n3 = n - 1;
            if (this.rows.get(n3) == null) {
                return false;
            }
            Object object = this.cellAt(n3, n2);
            while (object == null && n3 > 0) {
                object = this.rows;
                if ((PdfPRow)object.get(--n3) == null) {
                    return false;
                }
                object = this.cellAt(n3, n2);
            }
            int n4 = n - n3;
            PdfPCell[] arrpdfPCell = object;
            n = n4;
            if (object.getRowspan() == 1) {
                arrpdfPCell = object;
                n = n4;
                if (n4 > 1) {
                    PdfPRow pdfPRow = this.rows.get(n3 + 1);
                    n3 = n4 - 1;
                    object = pdfPRow.getCells()[--n2];
                    do {
                        arrpdfPCell = object;
                        n = n3;
                        if (object != null) break;
                        arrpdfPCell = object;
                        n = n3;
                        if (n2 <= 0) break;
                        object = pdfPRow.getCells();
                        object = object[--n2];
                    } while (true);
                }
            }
            if (arrpdfPCell != null && arrpdfPCell.getRowspan() > n) {
                return true;
            }
            return false;
        }
        return false;
    }

    @Override
    public void setAccessibleAttribute(PdfName pdfName, PdfObject pdfObject) {
        if (this.accessibleAttributes == null) {
            this.accessibleAttributes = new HashMap();
        }
        this.accessibleAttributes.put(pdfName, pdfObject);
    }

    public /* varargs */ void setBreakPoints(int ... arrn) {
        this.keepRowsTogether(0, this.rows.size());
        for (int i = 0; i < arrn.length; ++i) {
            this.getRow(arrn[i]).setMayNotBreak(false);
        }
    }

    @Override
    public void setComplete(boolean bl) {
        this.complete = bl;
    }

    public void setExtendLastRow(boolean bl) {
        this.extendLastRow[0] = bl;
        this.extendLastRow[1] = bl;
    }

    public void setExtendLastRow(boolean bl, boolean bl2) {
        this.extendLastRow[0] = bl;
        this.extendLastRow[1] = bl2;
    }

    public void setFooterRows(int n) {
        int n2 = n;
        if (n < 0) {
            n2 = 0;
        }
        this.footerRows = n2;
    }

    public void setHeaderRows(int n) {
        int n2 = n;
        if (n < 0) {
            n2 = 0;
        }
        this.headerRows = n2;
    }

    public void setHeadersInEvent(boolean bl) {
        this.headersInEvent = bl;
    }

    public void setHorizontalAlignment(int n) {
        this.horizontalAlignment = n;
    }

    @Override
    public void setId(AccessibleElementId accessibleElementId) {
        this.id = accessibleElementId;
    }

    public void setKeepTogether(boolean bl) {
        this.keepTogether = bl;
    }

    public void setLockedWidth(boolean bl) {
        this.lockedWidth = bl;
    }

    public void setLoopCheck(boolean bl) {
        this.loopCheck = bl;
    }

    @Override
    public void setPaddingTop(float f) {
        this.paddingTop = f;
    }

    @Override
    public void setRole(PdfName pdfName) {
        this.role = pdfName;
    }

    public void setRunDirection(int n) {
        switch (n) {
            default: {
                throw new RuntimeException(MessageLocalization.getComposedMessage("invalid.run.direction.1", n));
            }
            case 0: 
            case 1: 
            case 2: 
            case 3: 
        }
        this.runDirection = n;
    }

    public void setSkipFirstHeader(boolean bl) {
        this.skipFirstHeader = bl;
    }

    public void setSkipLastFooter(boolean bl) {
        this.skipLastFooter = bl;
    }

    @Override
    public void setSpacingAfter(float f) {
        this.spacingAfter = f;
    }

    @Override
    public void setSpacingBefore(float f) {
        this.spacingBefore = f;
    }

    public void setSplitLate(boolean bl) {
        this.splitLate = bl;
    }

    public void setSplitRows(boolean bl) {
        this.splitRows = bl;
    }

    public void setSummary(String string2) {
        this.setAccessibleAttribute(PdfName.SUMMARY, new PdfString(string2));
    }

    public void setTableEvent(PdfPTableEvent pdfPTableEvent) {
        if (pdfPTableEvent == null) {
            this.tableEvent = null;
            return;
        }
        if (this.tableEvent == null) {
            this.tableEvent = pdfPTableEvent;
            return;
        }
        if (this.tableEvent instanceof PdfPTableEventForwarder) {
            ((PdfPTableEventForwarder)this.tableEvent).addTableEvent(pdfPTableEvent);
            return;
        }
        PdfPTableEventForwarder pdfPTableEventForwarder = new PdfPTableEventForwarder();
        pdfPTableEventForwarder.addTableEvent(this.tableEvent);
        pdfPTableEventForwarder.addTableEvent(pdfPTableEvent);
        this.tableEvent = pdfPTableEventForwarder;
    }

    public void setTotalWidth(float f) {
        if (this.totalWidth == f) {
            return;
        }
        this.totalWidth = f;
        this.totalHeight = 0.0f;
        this.calculateWidths();
        this.calculateHeights();
    }

    public void setTotalWidth(float[] arrf) throws DocumentException {
        int n = arrf.length;
        int n2 = this.getNumberOfColumns();
        if (n != n2) {
            throw new DocumentException(MessageLocalization.getComposedMessage("wrong.number.of.columns", new Object[0]));
        }
        this.totalWidth = 0.0f;
        for (int i = 0; i < arrf.length; ++i) {
            this.totalWidth += arrf[i];
        }
        this.setWidths(arrf);
    }

    public void setWidthPercentage(float f) {
        this.widthPercentage = f;
    }

    public void setWidthPercentage(float[] arrf, Rectangle rectangle) throws DocumentException {
        if (arrf.length != this.getNumberOfColumns()) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("wrong.number.of.columns", new Object[0]));
        }
        this.setTotalWidth(arrf);
        this.widthPercentage = this.totalWidth / (rectangle.getRight() - rectangle.getLeft()) * 100.0f;
    }

    public void setWidths(float[] arrf) throws DocumentException {
        if (arrf.length != this.getNumberOfColumns()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("wrong.number.of.columns", new Object[0]));
        }
        this.relativeWidths = new float[arrf.length];
        System.arraycopy(arrf, 0, this.relativeWidths, 0, arrf.length);
        this.absoluteWidths = new float[arrf.length];
        this.totalHeight = 0.0f;
        this.calculateWidths();
        this.calculateHeights();
    }

    public void setWidths(int[] arrn) throws DocumentException {
        float[] arrf = new float[arrn.length];
        for (int i = 0; i < arrn.length; ++i) {
            arrf[i] = arrn[i];
        }
        this.setWidths(arrf);
    }

    public int size() {
        return this.rows.size();
    }

    public float spacingAfter() {
        return this.spacingAfter;
    }

    public float spacingBefore() {
        return this.spacingBefore;
    }

    @Override
    public int type() {
        return 23;
    }

    public float writeSelectedRows(int n, int n2, float f, float f2, PdfContentByte pdfContentByte) {
        return this.writeSelectedRows(0, -1, n, n2, f, f2, pdfContentByte);
    }

    public float writeSelectedRows(int n, int n2, float f, float f2, PdfContentByte[] arrpdfContentByte) {
        return this.writeSelectedRows(0, -1, n, n2, f, f2, arrpdfContentByte);
    }

    public float writeSelectedRows(int n, int n2, int n3, int n4, float f, float f2, PdfContentByte pdfContentByte) {
        return this.writeSelectedRows(n, n2, n3, n4, f, f2, pdfContentByte, true);
    }

    public float writeSelectedRows(int n, int n2, int n3, int n4, float f, float f2, PdfContentByte pdfContentByte, boolean bl) {
        int n5 = this.getNumberOfColumns();
        boolean bl2 = false;
        n = n < 0 ? 0 : Math.min(n, n5);
        n2 = n2 < 0 ? n5 : Math.min(n2, n5);
        if (n != 0 || n2 != n5) {
            bl2 = true;
        }
        if (bl2) {
            float f3 = 0.0f;
            for (int i = n; i < n2; ++i) {
                f3 += this.absoluteWidths[i];
            }
            pdfContentByte.saveState();
            float f4 = 10000.0f;
            float f5 = n == 0 ? 10000.0f : 0.0f;
            if (n2 != n5) {
                f4 = 0.0f;
            }
            pdfContentByte.rectangle(f - f5, -10000.0f, f3 + f5 + f4, 20000.0f);
            pdfContentByte.clip();
            pdfContentByte.newPath();
        }
        PdfContentByte[] arrpdfContentByte = PdfPTable.beginWritingRows(pdfContentByte);
        f = this.writeSelectedRows(n, n2, n3, n4, f, f2, arrpdfContentByte, bl);
        PdfPTable.endWritingRows(arrpdfContentByte);
        if (bl2) {
            pdfContentByte.restoreState();
        }
        return f;
    }

    public float writeSelectedRows(int n, int n2, int n3, int n4, float f, float f2, PdfContentByte[] arrpdfContentByte) {
        return this.writeSelectedRows(n, n2, n3, n4, f, f2, arrpdfContentByte, true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public float writeSelectedRows(int var1_1, int var2_2, int var3_3, int var4_4, float var5_5, float var6_6, PdfContentByte[] var7_7, boolean var8_8) {
        if (this.totalWidth <= 0.0f) {
            throw new RuntimeException(MessageLocalization.getComposedMessage("the.table.width.must.be.greater.than.zero", new Object[0]));
        }
        var10_9 = this.rows.size();
        if (var3_3 < 0) {
            var3_3 = 0;
        }
        var4_4 = var4_4 < 0 ? var10_9 : Math.min(var4_4, var10_9);
        if (var3_3 >= var4_4) {
            return var6_6;
        }
        var11_10 = this.getNumberOfColumns();
        var10_9 = var1_1 < 0 ? 0 : Math.min(var1_1, var11_10);
        var2_2 = var2_2 < 0 ? var11_10 : Math.min(var2_2, var11_10);
        this.LOGGER.info(String.format("Writing row %s to %s; column %s to %s", new Object[]{var3_3, var4_4, var10_9, var2_2}));
        var14_11 = null;
        if (this.rowsNotChecked) {
            this.getFittingRows(Float.MAX_VALUE, var3_3);
        }
        var13_12 = this.getRows(var3_3, var4_4);
        var15_13 = var13_12.iterator();
        var9_14 = var6_6;
        var1_1 = var3_3;
        while (var15_13.hasNext()) {
            block17 : {
                block16 : {
                    var16_28 = var15_13.next();
                    if (this.getHeader().rows != null && this.getHeader().rows.contains(var16_28) && var14_11 == null) {
                        var12_16 = this.openTableBlock(this.getHeader(), var7_7[3]);
                    } else if (this.getBody().rows != null && this.getBody().rows.contains(var16_28) && var14_11 == null) {
                        var12_17 = this.openTableBlock(this.getBody(), var7_7[3]);
                    } else {
                        var12_18 = var14_11;
                        if (this.getFooter().rows != null) {
                            var12_19 = var14_11;
                            if (this.getFooter().rows.contains(var16_28)) {
                                var12_20 = var14_11;
                                if (var14_11 == null) {
                                    var12_21 = this.openTableBlock(this.getFooter(), var7_7[3]);
                                }
                            }
                        }
                    }
                    if (var16_28 != null) {
                        var16_28.writeCells(var10_9, var2_2, var5_5, var9_14, var7_7, var8_8);
                        var9_14 -= var16_28.getMaxHeights();
                    }
                    if (this.getHeader().rows == null || !this.getHeader().rows.contains(var16_28) || var1_1 != var4_4 - 1 && this.getHeader().rows.contains(var13_12.get(var1_1 + 1))) break block16;
                    var12_23 = this.closeTableBlock(this.getHeader(), var7_7[3]);
                    ** GOTO lbl48
                }
                if (this.getBody().rows == null || !this.getBody().rows.contains(var16_28) || var1_1 != var4_4 - 1 && this.getBody().rows.contains(var13_12.get(var1_1 + 1))) break block17;
                var12_25 = this.closeTableBlock(this.getBody(), var7_7[3]);
                ** GOTO lbl48
            }
            if (this.getFooter().rows != null && this.getFooter().rows.contains(var16_28) && (var1_1 == var4_4 - 1 || !this.getFooter().rows.contains(var13_12.get(var1_1 + 1)))) {
                var12_26 = this.closeTableBlock(this.getFooter(), var7_7[3]);
lbl48: // 3 sources:
                var14_11 = var12_24;
            } else {
                var14_11 = var12_22;
            }
            ++var1_1;
        }
        if (this.tableEvent == null) return var9_14;
        if (var10_9 != 0) return var9_14;
        if (var2_2 != var11_10) return var9_14;
        var12_27 = new float[var4_4 - var3_3 + 1];
        var12_27[0] = var6_6;
        for (var1_1 = var3_3; var1_1 < var4_4; ++var1_1) {
            var14_11 = var13_12.get(var1_1);
            var6_6 = var14_11 != null ? var14_11.getMaxHeights() : 0.0f;
            var2_2 = var1_1 - var3_3;
            var12_27[var2_2 + 1] = var12_27[var2_2] - var6_6;
        }
        var13_12 = this.tableEvent;
        var14_11 = this.getEventWidths(var5_5, var3_3, var4_4, this.headersInEvent);
        var1_1 = this.headersInEvent != false ? this.headerRows : 0;
        var13_12.tableLayout(this, var14_11, var12_27, var1_1, var3_3, var7_7);
        return var9_14;
    }

    public static class ColumnMeasurementState {
        public int colspan = 1;
        public float height = 0.0f;
        public int rowspan = 1;

        public void beginCell(PdfPCell pdfPCell, float f, float f2) {
            this.rowspan = pdfPCell.getRowspan();
            this.colspan = pdfPCell.getColspan();
            float f3 = pdfPCell.hasCachedMaxHeight() ? pdfPCell.getCachedMaxHeight() : pdfPCell.getMaxHeight();
            this.height = f + Math.max(f3, f2);
        }

        public boolean cellEnds() {
            if (this.rowspan == 1) {
                return true;
            }
            return false;
        }

        public void consumeRowspan(float f, float f2) {
            --this.rowspan;
        }
    }

    public static class FittingRows {
        public final float completedRowsHeight;
        private final Map<Integer, Float> correctedHeightsForLastRow;
        public final int firstRow;
        public final float height;
        public final int lastRow;

        public FittingRows(int n, int n2, float f, float f2, Map<Integer, Float> map) {
            this.firstRow = n;
            this.lastRow = n2;
            this.height = f;
            this.completedRowsHeight = f2;
            this.correctedHeightsForLastRow = map;
        }

        public void correctLastRowChosen(PdfPTable iAccessibleElement, int n) {
            iAccessibleElement = iAccessibleElement.getRow(n);
            Float f = this.correctedHeightsForLastRow.get(n);
            if (f != null) {
                iAccessibleElement.setFinalMaxHeights(f.floatValue());
            }
        }
    }

}

