/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.spongycastle.cert.ocsp.BasicOCSPResp
 *  org.spongycastle.cert.ocsp.OCSPException
 *  org.spongycastle.cert.ocsp.OCSPResp
 */
package com.itextpdf.text.pdf.security;

import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.security.CRLVerifier;
import com.itextpdf.text.pdf.security.CertificateVerifier;
import com.itextpdf.text.pdf.security.LtvVerification;
import com.itextpdf.text.pdf.security.OCSPVerifier;
import com.itextpdf.text.pdf.security.PdfPKCS7;
import com.itextpdf.text.pdf.security.RootStoreVerifier;
import com.itextpdf.text.pdf.security.VerificationException;
import com.itextpdf.text.pdf.security.VerificationOK;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.GeneralSecurityException;
import java.security.KeyStore;
import java.security.Principal;
import java.security.PublicKey;
import java.security.cert.CRL;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import org.spongycastle.cert.ocsp.BasicOCSPResp;
import org.spongycastle.cert.ocsp.OCSPException;
import org.spongycastle.cert.ocsp.OCSPResp;

public class LtvVerifier
extends RootStoreVerifier {
    protected static final Logger LOGGER = LoggerFactory.getLogger(LtvVerifier.class);
    protected PdfDictionary dss;
    protected AcroFields fields;
    protected boolean latestRevision = true;
    protected LtvVerification.CertificateOption option = LtvVerification.CertificateOption.SIGNING_CERTIFICATE;
    protected PdfPKCS7 pkcs7;
    protected PdfReader reader;
    protected Date signDate;
    protected String signatureName;
    protected boolean verifyRootCertificate = true;

    public LtvVerifier(PdfReader object) throws GeneralSecurityException {
        super(null);
        this.reader = object;
        this.fields = object.getAcroFields();
        object = this.fields.getSignatureNames();
        this.signatureName = (String)object.get(object.size() - 1);
        this.signDate = new Date();
        this.pkcs7 = this.coversWholeDocument();
        Logger logger = LOGGER;
        object = this.pkcs7.isTsp() ? "document-level timestamp " : "";
        logger.info(String.format("Checking %ssignature %s", object, this.signatureName));
    }

    protected PdfPKCS7 coversWholeDocument() throws GeneralSecurityException {
        PdfPKCS7 pdfPKCS7 = this.fields.verifySignature(this.signatureName);
        if (this.fields.signatureCoversWholeDocument(this.signatureName)) {
            LOGGER.info("The timestamp covers whole document.");
            if (pdfPKCS7.verify()) {
                LOGGER.info("The signed document has not been modified.");
                return pdfPKCS7;
            }
            throw new VerificationException(null, "The document was altered after the final signature was applied.");
        }
        throw new VerificationException(null, "Signature doesn't cover whole document.");
    }

    public List<X509CRL> getCRLsFromDSS() throws GeneralSecurityException, IOException {
        ArrayList<X509CRL> arrayList = new ArrayList<X509CRL>();
        if (this.dss == null) {
            return arrayList;
        }
        PdfArray pdfArray = this.dss.getAsArray(PdfName.CRLS);
        if (pdfArray == null) {
            return arrayList;
        }
        CertificateFactory certificateFactory = CertificateFactory.getInstance("X.509");
        for (int i = 0; i < pdfArray.size(); ++i) {
            arrayList.add((X509CRL)certificateFactory.generateCRL(new ByteArrayInputStream(PdfReader.getStreamBytes((PRStream)pdfArray.getAsStream(i)))));
        }
        return arrayList;
    }

    public List<BasicOCSPResp> getOCSPResponsesFromDSS() throws IOException, GeneralSecurityException {
        ArrayList<BasicOCSPResp> arrayList = new ArrayList<BasicOCSPResp>();
        if (this.dss == null) {
            return arrayList;
        }
        PdfArray pdfArray = this.dss.getAsArray(PdfName.OCSPS);
        if (pdfArray == null) {
            return arrayList;
        }
        for (int i = 0; i < pdfArray.size(); ++i) {
            OCSPResp oCSPResp = new OCSPResp(PdfReader.getStreamBytes((PRStream)pdfArray.getAsStream(i)));
            if (oCSPResp.getStatus() != 0) continue;
            try {
                arrayList.add((BasicOCSPResp)oCSPResp.getResponseObject());
                continue;
            }
            catch (OCSPException oCSPException) {
                throw new GeneralSecurityException((Throwable)oCSPException);
            }
        }
        return arrayList;
    }

    public void setCertificateOption(LtvVerification.CertificateOption certificateOption) {
        this.option = certificateOption;
    }

    public void setVerifier(CertificateVerifier certificateVerifier) {
        this.verifier = certificateVerifier;
    }

    public void setVerifyRootCertificate(boolean bl) {
        this.verifyRootCertificate = bl;
    }

    public void switchToPreviousRevision() throws IOException, GeneralSecurityException {
        Object object;
        LOGGER.info("Switching to previous revision.");
        this.latestRevision = false;
        this.dss = this.reader.getCatalog().getAsDict(PdfName.DSS);
        ArrayList<String> arrayList = object = this.pkcs7.getTimeStampDate();
        if (object == null) {
            arrayList = this.pkcs7.getSignDate();
        }
        this.signDate = arrayList.getTime();
        arrayList = this.fields.getSignatureNames();
        if (arrayList.size() > 1) {
            this.signatureName = (String)arrayList.get(arrayList.size() - 2);
            this.reader = new PdfReader(this.fields.extractRevision(this.signatureName));
            this.fields = this.reader.getAcroFields();
            arrayList = this.fields.getSignatureNames();
            this.signatureName = (String)arrayList.get(arrayList.size() - 1);
            this.pkcs7 = this.coversWholeDocument();
            object = LOGGER;
            arrayList = this.pkcs7.isTsp() ? "document-level timestamp " : "";
            object.info(String.format("Checking %ssignature %s", arrayList, this.signatureName));
            return;
        }
        LOGGER.info("No signatures in revision");
        this.pkcs7 = null;
    }

    @Override
    public List<VerificationOK> verify(X509Certificate x509Certificate, X509Certificate x509Certificate2, Date date) throws GeneralSecurityException, IOException {
        RootStoreVerifier rootStoreVerifier = new RootStoreVerifier(this.verifier);
        rootStoreVerifier.setRootStore(this.rootStore);
        rootStoreVerifier = new CRLVerifier(rootStoreVerifier, this.getCRLsFromDSS());
        rootStoreVerifier.setRootStore(this.rootStore);
        boolean bl = this.latestRevision;
        boolean bl2 = true;
        bl = bl || this.onlineCheckingAllowed;
        rootStoreVerifier.setOnlineCheckingAllowed(bl);
        rootStoreVerifier = new OCSPVerifier(rootStoreVerifier, this.getOCSPResponsesFromDSS());
        rootStoreVerifier.setRootStore(this.rootStore);
        bl = bl2;
        if (!this.latestRevision) {
            bl = this.onlineCheckingAllowed ? bl2 : false;
        }
        rootStoreVerifier.setOnlineCheckingAllowed(bl);
        return rootStoreVerifier.verify(x509Certificate, x509Certificate2, date);
    }

    public List<VerificationOK> verify(List<VerificationOK> list) throws IOException, GeneralSecurityException {
        List<VerificationOK> list2 = list;
        if (list == null) {
            list2 = new ArrayList<VerificationOK>();
        }
        while (this.pkcs7 != null) {
            list2.addAll(this.verifySignature());
        }
        return list2;
    }

    public void verifyChain(Certificate[] object) throws GeneralSecurityException {
        for (int i = 0; i < ((Certificate[])object).length; ++i) {
            ((X509Certificate)object[i]).checkValidity(this.signDate);
            if (i <= 0) continue;
            object[i - 1].verify(object[i].getPublicKey());
        }
        object = LOGGER;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("All certificates are valid on ");
        stringBuilder.append(this.signDate.toString());
        object.info(stringBuilder.toString());
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public List<VerificationOK> verifySignature() throws GeneralSecurityException, IOException {
        X509Certificate x509Certificate;
        LOGGER.info("Verifying signature.");
        ArrayList<VerificationOK> arrayList = new ArrayList<VerificationOK>();
        Certificate[] arrcertificate = this.pkcs7.getSignCertificateChain();
        this.verifyChain(arrcertificate);
        int n = LtvVerification.CertificateOption.WHOLE_CHAIN.equals((Object)this.option) ? arrcertificate.length : 1;
        int n2 = 0;
        do {
            int n3;
            Object object;
            block8 : {
                if (n2 >= n) {
                    this.switchToPreviousRevision();
                    return arrayList;
                }
                n3 = n2 + 1;
                x509Certificate = (X509Certificate)arrcertificate[n2];
                object = null;
                if (n3 < arrcertificate.length) {
                    object = (X509Certificate)arrcertificate[n3];
                }
                LOGGER.info(x509Certificate.getSubjectDN().getName());
                object = this.verify(x509Certificate, (X509Certificate)object, this.signDate);
                if (object.size() == 0) {
                    x509Certificate.verify(x509Certificate.getPublicKey());
                    if (this.latestRevision && arrcertificate.length > 1) {
                        object.add(new VerificationOK(x509Certificate, this.getClass(), "Root certificate in final revision"));
                    }
                    if (object.size() == 0 && this.verifyRootCertificate) {
                        throw new GeneralSecurityException();
                    }
                    if (arrcertificate.length <= 1) break block8;
                    object.add(new VerificationOK(x509Certificate, this.getClass(), "Root certificate passed without checking"));
                }
            }
            arrayList.addAll((Collection<VerificationOK>)object);
            n2 = n3;
        } while (true);
        catch (GeneralSecurityException generalSecurityException) {
            throw new VerificationException(x509Certificate, "Couldn't verify with CRL or OCSP or trusted anchor");
        }
    }
}

