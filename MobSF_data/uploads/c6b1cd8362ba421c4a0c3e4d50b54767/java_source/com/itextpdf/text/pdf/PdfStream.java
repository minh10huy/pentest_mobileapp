/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocWriter;
import com.itextpdf.text.Document;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.OutputStreamCounter;
import com.itextpdf.text.pdf.OutputStreamEncryption;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncryption;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfWriter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;

public class PdfStream
extends PdfDictionary {
    public static final int BEST_COMPRESSION = 9;
    public static final int BEST_SPEED = 1;
    public static final int DEFAULT_COMPRESSION = -1;
    static final byte[] ENDSTREAM;
    public static final int NO_COMPRESSION = 0;
    static final int SIZESTREAM;
    static final byte[] STARTSTREAM;
    protected boolean compressed = false;
    protected int compressionLevel = 0;
    protected InputStream inputStream;
    protected int inputStreamLength = -1;
    protected int rawLength;
    protected PdfIndirectReference ref;
    protected ByteArrayOutputStream streamBytes = null;
    protected PdfWriter writer;

    static {
        STARTSTREAM = DocWriter.getISOBytes("stream\n");
        ENDSTREAM = DocWriter.getISOBytes("\nendstream");
        SIZESTREAM = STARTSTREAM.length + ENDSTREAM.length;
    }

    protected PdfStream() {
        this.type = 7;
    }

    public PdfStream(InputStream inputStream, PdfWriter pdfWriter) {
        this.type = 7;
        this.inputStream = inputStream;
        this.writer = pdfWriter;
        this.ref = pdfWriter.getPdfIndirectReference();
        this.put(PdfName.LENGTH, this.ref);
    }

    public PdfStream(byte[] arrby) {
        this.type = 7;
        this.bytes = arrby;
        this.rawLength = arrby.length;
        this.put(PdfName.LENGTH, new PdfNumber(arrby.length));
    }

    public void flateCompress() {
        this.flateCompress(-1);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void flateCompress(int n) {
        if (!Document.compress) {
            return;
        }
        if (this.compressed) {
            return;
        }
        this.compressionLevel = n;
        if (this.inputStream != null) {
            this.compressed = true;
            return;
        }
        PdfObject pdfObject = PdfReader.getPdfObject(this.get(PdfName.FILTER));
        if (pdfObject != null) {
            if (pdfObject.isName()) {
                if (PdfName.FLATEDECODE.equals(pdfObject)) {
                    return;
                }
            } else {
                if (!pdfObject.isArray()) {
                    throw new RuntimeException(MessageLocalization.getComposedMessage("stream.could.not.be.compressed.filter.is.not.a.name.or.array", new Object[0]));
                }
                if (((PdfArray)pdfObject).contains(PdfName.FLATEDECODE)) {
                    return;
                }
            }
        }
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            Deflater deflater = new Deflater(n);
            DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream((OutputStream)byteArrayOutputStream, deflater);
            if (this.streamBytes != null) {
                this.streamBytes.writeTo(deflaterOutputStream);
            } else {
                deflaterOutputStream.write(this.bytes);
            }
            deflaterOutputStream.close();
            deflater.end();
            this.streamBytes = byteArrayOutputStream;
            this.bytes = null;
            this.put(PdfName.LENGTH, new PdfNumber(this.streamBytes.size()));
            if (pdfObject == null) {
                this.put(PdfName.FILTER, PdfName.FLATEDECODE);
            } else {
                pdfObject = new PdfArray(pdfObject);
                pdfObject.add(0, PdfName.FLATEDECODE);
                this.put(PdfName.FILTER, pdfObject);
            }
            this.compressed = true;
            return;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public int getRawLength() {
        return this.rawLength;
    }

    protected void superToPdf(PdfWriter pdfWriter, OutputStream outputStream) throws IOException {
        super.toPdf(pdfWriter, outputStream);
    }

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public void toPdf(PdfWriter object, OutputStream outputStream) throws IOException {
        Object object2;
        byte[] arrby;
        Object object3;
        Object object4;
        int n;
        block21 : {
            block22 : {
                if (this.inputStream != null && this.compressed) {
                    this.put(PdfName.FILTER, PdfName.FLATEDECODE);
                }
                arrby = null;
                object2 = object != null ? object.getEncryption() : null;
                object4 = object2;
                if (object2 == null) break block21;
                object3 = this.get(PdfName.FILTER);
                object4 = object2;
                if (object3 == null) break block21;
                if (PdfName.CRYPT.equals(object3)) break block22;
                object4 = object2;
                if (!object3.isArray()) break block21;
                object3 = (PdfArray)object3;
                object4 = object2;
                if (object3.isEmpty()) break block21;
                object4 = object2;
                if (!PdfName.CRYPT.equals(object3.getPdfObject(0))) break block21;
            }
            object4 = null;
        }
        object2 = this.get(PdfName.LENGTH);
        if (object4 != null && object2 != null && object2.isNumber()) {
            n = ((PdfNumber)object2).intValue();
            this.put(PdfName.LENGTH, new PdfNumber(object4.calculateStreamSize(n)));
            this.superToPdf((PdfWriter)object, outputStream);
            this.put(PdfName.LENGTH, (PdfObject)object2);
        } else {
            this.superToPdf((PdfWriter)object, outputStream);
        }
        PdfWriter.checkPdfIsoConformance((PdfWriter)object, 9, this);
        outputStream.write(STARTSTREAM);
        if (this.inputStream == null) {
            if (object4 != null && !object4.isEmbeddedFilesOnly()) {
                object = this.streamBytes != null ? object4.encryptByteArray(this.streamBytes.toByteArray()) : object4.encryptByteArray(this.bytes);
                outputStream.write((byte[])object);
            } else if (this.streamBytes != null) {
                this.streamBytes.writeTo(outputStream);
            } else {
                outputStream.write(this.bytes);
            }
        } else {
            this.rawLength = 0;
            OutputStreamCounter outputStreamCounter = new OutputStreamCounter(outputStream);
            if (object4 != null && !object4.isEmbeddedFilesOnly()) {
                object2 = object = object4.getEncryptionStream(outputStreamCounter);
            } else {
                object = outputStreamCounter;
                object2 = null;
            }
            if (this.compressed) {
                object3 = new Deflater(this.compressionLevel);
                object = object4 = new DeflaterOutputStream((OutputStream)object, (Deflater)object3, 32768);
            } else {
                object3 = null;
                object4 = object;
                object = arrby;
            }
            arrby = new byte[4192];
            do {
                if ((n = this.inputStream.read(arrby)) <= 0) {
                    if (object != null) {
                        object.finish();
                        object3.end();
                    }
                    if (object2 != null) {
                        object2.finish();
                    }
                    this.inputStreamLength = (int)outputStreamCounter.getCounter();
                    break;
                }
                object4.write(arrby, 0, n);
                this.rawLength += n;
            } while (true);
        }
        outputStream.write(ENDSTREAM);
    }

    @Override
    public String toString() {
        if (this.get(PdfName.TYPE) == null) {
            return "Stream";
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Stream of type: ");
        stringBuilder.append(this.get(PdfName.TYPE));
        return stringBuilder.toString();
    }

    public void writeContent(OutputStream outputStream) throws IOException {
        if (this.streamBytes != null) {
            this.streamBytes.writeTo(outputStream);
            return;
        }
        if (this.bytes != null) {
            outputStream.write(this.bytes);
        }
    }

    public void writeLength() throws IOException {
        if (this.inputStream == null) {
            throw new UnsupportedOperationException(MessageLocalization.getComposedMessage("writelength.can.only.be.called.in.a.contructed.pdfstream.inputstream.pdfwriter", new Object[0]));
        }
        if (this.inputStreamLength == -1) {
            throw new IOException(MessageLocalization.getComposedMessage("writelength.can.only.be.called.after.output.of.the.stream.body", new Object[0]));
        }
        this.writer.addToBody((PdfObject)new PdfNumber(this.inputStreamLength), this.ref, false);
    }
}

