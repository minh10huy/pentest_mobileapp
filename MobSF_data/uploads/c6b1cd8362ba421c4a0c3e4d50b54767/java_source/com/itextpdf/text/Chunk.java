/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text;

import com.itextpdf.text.AccessibleElementId;
import com.itextpdf.text.BaseColor;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.ElementListener;
import com.itextpdf.text.Font;
import com.itextpdf.text.Image;
import com.itextpdf.text.SplitCharacter;
import com.itextpdf.text.TabSplitCharacter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.HyphenationEvent;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.draw.DrawInterface;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import java.net.URL;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Chunk
implements Element,
IAccessibleElement {
    public static final String ACTION = "ACTION";
    public static final String BACKGROUND = "BACKGROUND";
    public static final String CHAR_SPACING = "CHAR_SPACING";
    public static final String COLOR = "COLOR";
    public static final String ENCODING = "ENCODING";
    public static final String GENERICTAG = "GENERICTAG";
    public static final String HSCALE = "HSCALE";
    public static final String HYPHENATION = "HYPHENATION";
    public static final String IMAGE = "IMAGE";
    public static final String LINEHEIGHT = "LINEHEIGHT";
    public static final String LOCALDESTINATION = "LOCALDESTINATION";
    public static final String LOCALGOTO = "LOCALGOTO";
    public static final Chunk NEWLINE = new Chunk("\n");
    public static final String NEWPAGE = "NEWPAGE";
    public static final Chunk NEXTPAGE;
    public static final String OBJECT_REPLACEMENT_CHARACTER = "\ufffc";
    public static final String PDFANNOTATION = "PDFANNOTATION";
    public static final String REMOTEGOTO = "REMOTEGOTO";
    public static final String SEPARATOR = "SEPARATOR";
    public static final String SKEW = "SKEW";
    public static final Chunk SPACETABBING;
    public static final String SPLITCHARACTER = "SPLITCHARACTER";
    public static final String SUBSUPSCRIPT = "SUBSUPSCRIPT";
    public static final String TAB = "TAB";
    public static final Chunk TABBING;
    public static final String TABSETTINGS = "TABSETTINGS";
    public static final String TEXTRENDERMODE = "TEXTRENDERMODE";
    public static final String UNDERLINE = "UNDERLINE";
    public static final String WHITESPACE = "WHITESPACE";
    public static final String WORD_SPACING = "WORD_SPACING";
    protected HashMap<PdfName, PdfObject> accessibleAttributes = null;
    protected HashMap<String, Object> attributes = null;
    protected StringBuffer content = null;
    private String contentWithNoTabs = null;
    protected Font font = null;
    private AccessibleElementId id = null;
    protected PdfName role = null;

    static {
        NEWLINE.setRole(PdfName.P);
        NEXTPAGE = new Chunk("");
        NEXTPAGE.setNewPage();
        TABBING = new Chunk(Float.valueOf(Float.NaN), false);
        SPACETABBING = new Chunk(Float.valueOf(Float.NaN), true);
    }

    public Chunk() {
        this.content = new StringBuffer();
        this.font = new Font();
        this.role = PdfName.SPAN;
    }

    public Chunk(char c) {
        this(c, new Font());
    }

    public Chunk(char c, Font font) {
        this.content = new StringBuffer();
        this.content.append(c);
        this.font = font;
        this.role = PdfName.SPAN;
    }

    public Chunk(Chunk chunk) {
        if (chunk.content != null) {
            this.content = new StringBuffer(chunk.content.toString());
        }
        if (chunk.font != null) {
            this.font = new Font(chunk.font);
        }
        if (chunk.attributes != null) {
            this.attributes = new HashMap<String, Object>(chunk.attributes);
        }
        this.role = chunk.role;
        if (chunk.accessibleAttributes != null) {
            this.accessibleAttributes = new HashMap<PdfName, PdfObject>(chunk.accessibleAttributes);
        }
        this.id = chunk.getId();
    }

    public Chunk(Image image, float f, float f2) {
        this(OBJECT_REPLACEMENT_CHARACTER, new Font());
        image = Image.getInstance(image);
        image.setAbsolutePosition(Float.NaN, Float.NaN);
        this.setAttribute(IMAGE, new Object[]{image, new Float(f), new Float(f2), Boolean.FALSE});
        this.role = null;
    }

    public Chunk(Image image, float f, float f2, boolean bl) {
        this(OBJECT_REPLACEMENT_CHARACTER, new Font());
        this.setAttribute(IMAGE, new Object[]{image, new Float(f), new Float(f2), bl});
        this.role = PdfName.ARTIFACT;
    }

    public Chunk(DrawInterface drawInterface) {
        this(drawInterface, false);
    }

    @Deprecated
    public Chunk(DrawInterface drawInterface, float f) {
        this(drawInterface, f, false);
    }

    @Deprecated
    public Chunk(DrawInterface drawInterface, float f, boolean bl) {
        this(OBJECT_REPLACEMENT_CHARACTER, new Font());
        if (f < 0.0f) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("a.tab.position.may.not.be.lower.than.0.yours.is.1", String.valueOf(f)));
        }
        this.setAttribute(TAB, new Object[]{drawInterface, new Float(f), bl, new Float(0.0f)});
        this.role = PdfName.ARTIFACT;
    }

    public Chunk(DrawInterface drawInterface, boolean bl) {
        this(OBJECT_REPLACEMENT_CHARACTER, new Font());
        this.setAttribute(SEPARATOR, new Object[]{drawInterface, bl});
        this.role = null;
    }

    private Chunk(Float f, boolean bl) {
        this(OBJECT_REPLACEMENT_CHARACTER, new Font());
        if (f.floatValue() < 0.0f) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("a.tab.position.may.not.be.lower.than.0.yours.is.1", String.valueOf(f)));
        }
        this.setAttribute(TAB, new Object[]{f, bl});
        this.setAttribute(SPLITCHARACTER, TabSplitCharacter.TAB);
        this.setAttribute(TABSETTINGS, null);
        this.role = PdfName.ARTIFACT;
    }

    public Chunk(String string2) {
        this(string2, new Font());
    }

    public Chunk(String string2, Font font) {
        this.content = new StringBuffer(string2);
        this.font = font;
        this.role = PdfName.SPAN;
    }

    @Deprecated
    public static Chunk createTabspace() {
        return Chunk.createTabspace(60.0f);
    }

    @Deprecated
    public static Chunk createTabspace(float f) {
        return new Chunk(Float.valueOf(f), true);
    }

    public static Chunk createWhitespace(String string2) {
        return Chunk.createWhitespace(string2, false);
    }

    public static Chunk createWhitespace(String string2, boolean bl) {
        if (!bl) {
            Chunk chunk = new Chunk(' ');
            chunk.setAttribute(WHITESPACE, string2);
            return chunk;
        }
        return new Chunk(string2);
    }

    private Chunk setAttribute(String string2, Object object) {
        if (this.attributes == null) {
            this.attributes = new HashMap();
        }
        this.attributes.put(string2, object);
        return this;
    }

    public StringBuffer append(String string2) {
        this.contentWithNoTabs = null;
        StringBuffer stringBuffer = this.content;
        stringBuffer.append(string2);
        return stringBuffer;
    }

    @Override
    public PdfObject getAccessibleAttribute(PdfName pdfName) {
        if (this.getImage() != null) {
            return this.getImage().getAccessibleAttribute(pdfName);
        }
        if (this.accessibleAttributes != null) {
            return this.accessibleAttributes.get(pdfName);
        }
        return null;
    }

    @Override
    public HashMap<PdfName, PdfObject> getAccessibleAttributes() {
        if (this.getImage() != null) {
            return this.getImage().getAccessibleAttributes();
        }
        return this.accessibleAttributes;
    }

    public HashMap<String, Object> getAttributes() {
        return this.attributes;
    }

    public float getCharacterSpacing() {
        if (this.attributes != null && this.attributes.containsKey(CHAR_SPACING)) {
            return ((Float)this.attributes.get(CHAR_SPACING)).floatValue();
        }
        return 0.0f;
    }

    @Override
    public List<Chunk> getChunks() {
        ArrayList<Chunk> arrayList = new ArrayList<Chunk>();
        arrayList.add(this);
        return arrayList;
    }

    public String getContent() {
        if (this.contentWithNoTabs == null) {
            this.contentWithNoTabs = this.content.toString().replaceAll("\t", "");
        }
        return this.contentWithNoTabs;
    }

    public Font getFont() {
        return this.font;
    }

    public float getHorizontalScaling() {
        if (this.attributes == null) {
            return 1.0f;
        }
        Float f = (Float)this.attributes.get(HSCALE);
        if (f == null) {
            return 1.0f;
        }
        return f.floatValue();
    }

    public HyphenationEvent getHyphenation() {
        if (this.attributes == null) {
            return null;
        }
        return (HyphenationEvent)this.attributes.get(HYPHENATION);
    }

    @Override
    public AccessibleElementId getId() {
        if (this.id == null) {
            this.id = new AccessibleElementId();
        }
        return this.id;
    }

    public Image getImage() {
        if (this.attributes == null) {
            return null;
        }
        Object[] arrobject = (Object[])this.attributes.get(IMAGE);
        if (arrobject == null) {
            return null;
        }
        return (Image)arrobject[0];
    }

    @Override
    public PdfName getRole() {
        if (this.getImage() != null) {
            return this.getImage().getRole();
        }
        return this.role;
    }

    public String getTextExpansion() {
        PdfObject pdfObject = this.getAccessibleAttribute(PdfName.E);
        if (pdfObject instanceof PdfString) {
            return ((PdfString)pdfObject).toUnicodeString();
        }
        return null;
    }

    public float getTextRise() {
        if (this.attributes != null && this.attributes.containsKey(SUBSUPSCRIPT)) {
            return ((Float)this.attributes.get(SUBSUPSCRIPT)).floatValue();
        }
        return 0.0f;
    }

    public float getWidthPoint() {
        if (this.getImage() != null) {
            return this.getImage().getScaledWidth();
        }
        return this.font.getCalculatedBaseFont(true).getWidthPoint(this.getContent(), this.font.getCalculatedSize()) * this.getHorizontalScaling();
    }

    public float getWordSpacing() {
        if (this.attributes != null && this.attributes.containsKey(WORD_SPACING)) {
            return ((Float)this.attributes.get(WORD_SPACING)).floatValue();
        }
        return 0.0f;
    }

    public boolean hasAccessibleAttributes() {
        if (this.accessibleAttributes != null && !this.accessibleAttributes.isEmpty()) {
            return true;
        }
        return false;
    }

    public boolean hasAttributes() {
        if (this.attributes != null && !this.attributes.isEmpty()) {
            return true;
        }
        return false;
    }

    @Override
    public boolean isContent() {
        return true;
    }

    public boolean isEmpty() {
        if (this.content.toString().trim().length() == 0 && this.content.toString().indexOf("\n") == -1 && this.attributes == null) {
            return true;
        }
        return false;
    }

    @Override
    public boolean isInline() {
        return true;
    }

    @Override
    public boolean isNestable() {
        return true;
    }

    @Deprecated
    public boolean isTabspace() {
        if (this.attributes != null && this.attributes.containsKey(TAB)) {
            return true;
        }
        return false;
    }

    public boolean isWhitespace() {
        if (this.attributes != null && this.attributes.containsKey(WHITESPACE)) {
            return true;
        }
        return false;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public boolean process(ElementListener elementListener) {
        try {
            return elementListener.add(this);
        }
        catch (DocumentException documentException) {
            return false;
        }
    }

    @Override
    public void setAccessibleAttribute(PdfName pdfName, PdfObject pdfObject) {
        if (this.getImage() != null) {
            this.getImage().setAccessibleAttribute(pdfName, pdfObject);
            return;
        }
        if (this.accessibleAttributes == null) {
            this.accessibleAttributes = new HashMap();
        }
        this.accessibleAttributes.put(pdfName, pdfObject);
    }

    public Chunk setAction(PdfAction pdfAction) {
        this.setRole(PdfName.LINK);
        return this.setAttribute(ACTION, pdfAction);
    }

    public Chunk setAnchor(String string2) {
        this.setRole(PdfName.LINK);
        this.setAccessibleAttribute(PdfName.ALT, new PdfString(string2));
        return this.setAttribute(ACTION, new PdfAction(string2));
    }

    public Chunk setAnchor(URL object) {
        this.setRole(PdfName.LINK);
        object = object.toExternalForm();
        this.setAccessibleAttribute(PdfName.ALT, new PdfString((String)object));
        return this.setAttribute(ACTION, new PdfAction((String)object));
    }

    public Chunk setAnnotation(PdfAnnotation pdfAnnotation) {
        return this.setAttribute(PDFANNOTATION, pdfAnnotation);
    }

    public void setAttributes(HashMap<String, Object> hashMap) {
        this.attributes = hashMap;
    }

    public Chunk setBackground(BaseColor baseColor) {
        return this.setBackground(baseColor, 0.0f, 0.0f, 0.0f, 0.0f);
    }

    public Chunk setBackground(BaseColor baseColor, float f, float f2, float f3, float f4) {
        return this.setAttribute(BACKGROUND, new Object[]{baseColor, new float[]{f, f2, f3, f4}});
    }

    public Chunk setCharacterSpacing(float f) {
        return this.setAttribute(CHAR_SPACING, new Float(f));
    }

    public void setFont(Font font) {
        this.font = font;
    }

    public Chunk setGenericTag(String string2) {
        return this.setAttribute(GENERICTAG, string2);
    }

    public Chunk setHorizontalScaling(float f) {
        return this.setAttribute(HSCALE, new Float(f));
    }

    public Chunk setHyphenation(HyphenationEvent hyphenationEvent) {
        return this.setAttribute(HYPHENATION, hyphenationEvent);
    }

    @Override
    public void setId(AccessibleElementId accessibleElementId) {
        this.id = accessibleElementId;
    }

    public Chunk setLineHeight(float f) {
        return this.setAttribute(LINEHEIGHT, Float.valueOf(f));
    }

    public Chunk setLocalDestination(String string2) {
        return this.setAttribute(LOCALDESTINATION, string2);
    }

    public Chunk setLocalGoto(String string2) {
        return this.setAttribute(LOCALGOTO, string2);
    }

    public Chunk setNewPage() {
        return this.setAttribute(NEWPAGE, null);
    }

    public Chunk setRemoteGoto(String string2, int n) {
        return this.setAttribute(REMOTEGOTO, new Object[]{string2, n});
    }

    public Chunk setRemoteGoto(String string2, String string3) {
        return this.setAttribute(REMOTEGOTO, new Object[]{string2, string3});
    }

    @Override
    public void setRole(PdfName pdfName) {
        if (this.getImage() != null) {
            this.getImage().setRole(pdfName);
            return;
        }
        this.role = pdfName;
    }

    public Chunk setSkew(float f, float f2) {
        return this.setAttribute(SKEW, new float[]{(float)Math.tan((double)f * 3.141592653589793 / 180.0), (float)Math.tan((double)f2 * 3.141592653589793 / 180.0)});
    }

    public Chunk setSplitCharacter(SplitCharacter splitCharacter) {
        return this.setAttribute(SPLITCHARACTER, splitCharacter);
    }

    public void setTextExpansion(String string2) {
        this.setAccessibleAttribute(PdfName.E, new PdfString(string2));
    }

    public Chunk setTextRenderMode(int n, float f, BaseColor baseColor) {
        return this.setAttribute(TEXTRENDERMODE, new Object[]{n, new Float(f), baseColor});
    }

    public Chunk setTextRise(float f) {
        return this.setAttribute(SUBSUPSCRIPT, new Float(f));
    }

    public Chunk setUnderline(float f, float f2) {
        return this.setUnderline(null, f, 0.0f, f2, 0.0f, 0);
    }

    public Chunk setUnderline(BaseColor baseColor, float f, float f2, float f3, float f4, int n) {
        if (this.attributes == null) {
            this.attributes = new HashMap();
        }
        float[] arrf = new float[]{f, f2, f3, f4, n};
        return this.setAttribute(UNDERLINE, Utilities.addToArray((Object[][])this.attributes.get(UNDERLINE), new Object[]{baseColor, arrf}));
    }

    public Chunk setWordSpacing(float f) {
        return this.setAttribute(WORD_SPACING, new Float(f));
    }

    @Override
    public String toString() {
        return this.getContent();
    }

    @Override
    public int type() {
        return 10;
    }
}

