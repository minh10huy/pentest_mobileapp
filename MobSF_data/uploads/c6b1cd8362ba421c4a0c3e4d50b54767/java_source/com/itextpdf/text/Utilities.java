/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text;

import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfEncodings;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URL;
import java.util.Collections;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Set;

public class Utilities {
    public static Object[][] addToArray(Object[][] arrobject, Object[] arrobject2) {
        if (arrobject == null) {
            return new Object[][]{arrobject2};
        }
        Object[][] arrobject3 = new Object[arrobject.length + 1][];
        System.arraycopy(arrobject, 0, arrobject3, 0, arrobject.length);
        arrobject3[arrobject.length] = arrobject2;
        return arrobject3;
    }

    public static boolean checkTrueOrFalse(Properties properties, String string2) {
        return "true".equalsIgnoreCase(properties.getProperty(string2));
    }

    public static String convertFromUtf32(int n) {
        if (n < 65536) {
            return Character.toString((char)n);
        }
        return new String(new char[]{(char)((n -= 65536) / 1024 + 55296), (char)(n % 1024 + 56320)});
    }

    public static String convertToHex(byte[] arrby) {
        ByteBuffer byteBuffer = new ByteBuffer();
        int n = arrby.length;
        for (int i = 0; i < n; ++i) {
            byteBuffer.appendHex(arrby[i]);
        }
        return PdfEncodings.convertToString(byteBuffer.toByteArray(), null).toUpperCase();
    }

    public static int convertToUtf32(char c, char c2) {
        return (c - 55296) * 1024 + c2 - 56320 + 65536;
    }

    public static int convertToUtf32(String string2, int n) {
        return (string2.charAt(n) - 55296) * 1024 + string2.charAt(n + 1) - 56320 + 65536;
    }

    public static int convertToUtf32(char[] arrc, int n) {
        return (arrc[n] - 55296) * 1024 + arrc[n + 1] - 56320 + 65536;
    }

    public static char[] copyOfRange(char[] object, int n, int n2) {
        int n3 = n2 - n;
        if (n3 < 0) {
            object = new StringBuilder();
            object.append(n);
            object.append(" > ");
            object.append(n2);
            throw new IllegalArgumentException(object.toString());
        }
        char[] arrc = new char[n3];
        System.arraycopy(object, n, arrc, 0, Math.min(((Object)object).length - n, n3));
        return arrc;
    }

    @Deprecated
    public static <K, V> Set<K> getKeySet(Hashtable<K, V> hashtable) {
        if (hashtable == null) {
            return Collections.emptySet();
        }
        return hashtable.keySet();
    }

    public static final float inchesToMillimeters(float f) {
        return f * 25.4f;
    }

    public static final float inchesToPoints(float f) {
        return f * 72.0f;
    }

    public static boolean isSurrogateHigh(char c) {
        if (c >= '\ud800' && c <= '\udbff') {
            return true;
        }
        return false;
    }

    public static boolean isSurrogateLow(char c) {
        if (c >= '\udc00' && c <= '\udfff') {
            return true;
        }
        return false;
    }

    public static boolean isSurrogatePair(String string2, int n) {
        boolean bl = false;
        if (n >= 0) {
            if (n > string2.length() - 2) {
                return false;
            }
            boolean bl2 = bl;
            if (Utilities.isSurrogateHigh(string2.charAt(n))) {
                bl2 = bl;
                if (Utilities.isSurrogateLow(string2.charAt(n + 1))) {
                    bl2 = true;
                }
            }
            return bl2;
        }
        return false;
    }

    public static boolean isSurrogatePair(char[] arrc, int n) {
        boolean bl = false;
        if (n >= 0) {
            if (n > arrc.length - 2) {
                return false;
            }
            boolean bl2 = bl;
            if (Utilities.isSurrogateHigh(arrc[n])) {
                bl2 = bl;
                if (Utilities.isSurrogateLow(arrc[n + 1])) {
                    bl2 = true;
                }
            }
            return bl2;
        }
        return false;
    }

    public static final float millimetersToInches(float f) {
        return f / 25.4f;
    }

    public static final float millimetersToPoints(float f) {
        return Utilities.inchesToPoints(Utilities.millimetersToInches(f));
    }

    public static final float pointsToInches(float f) {
        return f / 72.0f;
    }

    public static final float pointsToMillimeters(float f) {
        return Utilities.inchesToMillimeters(Utilities.pointsToInches(f));
    }

    public static String readFileToString(File file) throws IOException {
        byte[] arrby = new byte[(int)file.length()];
        new FileInputStream(file).read(arrby);
        return new String(arrby);
    }

    public static String readFileToString(String string2) throws IOException {
        return Utilities.readFileToString(new File(string2));
    }

    public static void skip(InputStream inputStream, int n) throws IOException {
        while (n > 0) {
            long l = n;
            long l2 = inputStream.skip(l);
            if (l2 <= 0L) {
                return;
            }
            n = (int)(l - l2);
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static URL toURL(String string2) throws MalformedURLException {
        try {
            return new URL(string2);
        }
        catch (Exception exception) {
            return new File(string2).toURI().toURL();
        }
    }

    public static String unEscapeURL(String arrc) {
        StringBuffer stringBuffer = new StringBuffer();
        arrc = arrc.toCharArray();
        for (int i = 0; i < arrc.length; ++i) {
            char c = arrc[i];
            if (c == '%') {
                int n = i + 2;
                if (n >= arrc.length) {
                    stringBuffer.append(c);
                    continue;
                }
                int n2 = PRTokeniser.getHex(arrc[i + 1]);
                int n3 = PRTokeniser.getHex(arrc[n]);
                if (n2 >= 0 && n3 >= 0) {
                    stringBuffer.append((char)(n2 * 16 + n3));
                    i = n;
                    continue;
                }
                stringBuffer.append(c);
                continue;
            }
            stringBuffer.append(c);
        }
        return stringBuffer.toString();
    }
}

