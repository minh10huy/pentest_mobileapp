/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.ElementListener;
import com.itextpdf.text.Font;
import com.itextpdf.text.SpecialSymbol;
import com.itextpdf.text.TabSettings;
import com.itextpdf.text.TextElementArray;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.HyphenationEvent;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

public class Phrase
extends ArrayList<Element>
implements TextElementArray {
    private static final long serialVersionUID = 2643594602455068231L;
    protected Font font;
    protected HyphenationEvent hyphenation = null;
    protected float leading = Float.NaN;
    protected float multipliedLeading = 0.0f;
    protected TabSettings tabSettings = null;

    public Phrase() {
        this(16.0f);
    }

    public Phrase(float f) {
        this.leading = f;
        this.font = new Font();
    }

    public Phrase(float f, Chunk chunk) {
        this.leading = f;
        super.add(chunk);
        this.font = chunk.getFont();
        this.setHyphenation(chunk.getHyphenation());
    }

    public Phrase(float f, String string2) {
        this(f, string2, new Font());
    }

    public Phrase(float f, String string2, Font font) {
        this.leading = f;
        this.font = font;
        if (string2 != null && string2.length() != 0) {
            super.add(new Chunk(string2, font));
        }
    }

    public Phrase(Chunk chunk) {
        super.add(chunk);
        this.font = chunk.getFont();
        this.setHyphenation(chunk.getHyphenation());
    }

    public Phrase(Phrase phrase) {
        this.addAll(phrase);
        this.setLeading(phrase.getLeading(), phrase.getMultipliedLeading());
        this.font = phrase.getFont();
        this.tabSettings = phrase.getTabSettings();
        this.setHyphenation(phrase.getHyphenation());
    }

    public Phrase(String string2) {
        this(Float.NaN, string2, new Font());
    }

    public Phrase(String string2, Font font) {
        this(Float.NaN, string2, font);
    }

    private Phrase(boolean bl) {
    }

    public static final Phrase getInstance(int n, String string2) {
        return Phrase.getInstance(n, string2, new Font());
    }

    public static final Phrase getInstance(int n, String string2, Font font) {
        Phrase phrase = new Phrase(true);
        phrase.setLeading(n);
        phrase.font = font;
        String string3 = string2;
        if (font.getFamily() != Font.FontFamily.SYMBOL) {
            string3 = string2;
            if (font.getFamily() != Font.FontFamily.ZAPFDINGBATS) {
                string3 = string2;
                if (font.getBaseFont() == null) {
                    do {
                        n = SpecialSymbol.index(string2);
                        string3 = string2;
                        if (n <= -1) break;
                        string3 = string2;
                        if (n > 0) {
                            phrase.add(new Chunk(string2.substring(0, n), font));
                            string3 = string2.substring(n);
                        }
                        Font font2 = new Font(Font.FontFamily.SYMBOL, font.getSize(), font.getStyle(), font.getColor());
                        StringBuffer stringBuffer = new StringBuffer();
                        stringBuffer.append(SpecialSymbol.getCorrespondingSymbol(string3.charAt(0)));
                        string2 = string3.substring(1);
                        while (SpecialSymbol.index(string2) == 0) {
                            stringBuffer.append(SpecialSymbol.getCorrespondingSymbol(string2.charAt(0)));
                            string2 = string2.substring(1);
                        }
                        phrase.add(new Chunk(stringBuffer.toString(), font2));
                    } while (true);
                }
            }
        }
        if (string3 != null && string3.length() != 0) {
            phrase.add(new Chunk(string3, font));
        }
        return phrase;
    }

    public static final Phrase getInstance(String string2) {
        return Phrase.getInstance(16, string2, new Font());
    }

    @Override
    public void add(int n, Element element) {
        if (element == null) {
            return;
        }
        int n2 = element.type();
        if (n2 != 14 && n2 != 17 && n2 != 23 && n2 != 29 && n2 != 37 && n2 != 50 && n2 != 55 && n2 != 666) {
            switch (n2) {
                default: {
                    throw new ClassCastException(MessageLocalization.getComposedMessage("insertion.of.illegal.element.1", element.getClass().getName()));
                }
                case 10: {
                    element = (Chunk)element;
                    if (!this.font.isStandardFont()) {
                        element.setFont(this.font.difference(element.getFont()));
                    }
                    if (this.hyphenation != null && element.getHyphenation() == null && !element.isEmpty()) {
                        element.setHyphenation(this.hyphenation);
                    }
                    super.add(n, element);
                    return;
                }
                case 11: 
                case 12: 
            }
        }
        super.add(n, element);
    }

    /*
     * Exception decompiling
     */
    @Override
    public boolean add(Element var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: First case is not immediately after switch.
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:366)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    @Override
    public boolean add(String string2) {
        if (string2 == null) {
            return false;
        }
        return super.add(new Chunk(string2, this.font));
    }

    @Override
    public boolean addAll(Collection<? extends Element> object) {
        object = object.iterator();
        while (object.hasNext()) {
            this.add((Element)object.next());
        }
        return true;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected boolean addChunk(Chunk chunk) {
        Object object;
        String string2;
        block9 : {
            Object object2 = chunk.getFont();
            string2 = chunk.getContent();
            object = object2;
            if (this.font != null) {
                object = object2;
                if (!this.font.isStandardFont()) {
                    object = this.font.difference(chunk.getFont());
                }
            }
            if (this.size() > 0 && !chunk.hasAttributes()) {
                boolean bl;
                block8 : {
                    block7 : {
                        try {
                            object2 = (Chunk)this.get(this.size() - 1);
                            PdfName pdfName = object2.getRole();
                            PdfName pdfName2 = chunk.getRole();
                            if (pdfName == null || pdfName2 == null) break block7;
                            bl = pdfName.equals(pdfName2);
                            break block8;
                        }
                        catch (ClassCastException classCastException) {
                            break block9;
                        }
                    }
                    bl = true;
                }
                if (!(!bl || object2.hasAttributes() || chunk.hasAccessibleAttributes() || object2.hasAccessibleAttributes() || object != null && object.compareTo(object2.getFont()) != 0 || "".equals(object2.getContent().trim()) || "".equals(string2.trim()))) {
                    object2.append(string2);
                    return true;
                }
            }
        }
        object = new Chunk(string2, (Font)object);
        object.setAttributes(chunk.getAttributes());
        object.role = chunk.getRole();
        object.accessibleAttributes = chunk.getAccessibleAttributes();
        if (this.hyphenation != null && object.getHyphenation() == null && !object.isEmpty()) {
            object.setHyphenation(this.hyphenation);
        }
        return super.add(object);
    }

    protected void addSpecial(Element element) {
        super.add(element);
    }

    @Override
    public List<Chunk> getChunks() {
        ArrayList<Chunk> arrayList = new ArrayList<Chunk>();
        Iterator iterator = this.iterator();
        while (iterator.hasNext()) {
            arrayList.addAll(((Element)iterator.next()).getChunks());
        }
        return arrayList;
    }

    public String getContent() {
        StringBuffer stringBuffer = new StringBuffer();
        Iterator<Chunk> iterator = this.getChunks().iterator();
        while (iterator.hasNext()) {
            stringBuffer.append(iterator.next().toString());
        }
        return stringBuffer.toString();
    }

    public Font getFont() {
        return this.font;
    }

    public HyphenationEvent getHyphenation() {
        return this.hyphenation;
    }

    public float getLeading() {
        if (Float.isNaN(this.leading) && this.font != null) {
            return this.font.getCalculatedLeading(1.5f);
        }
        return this.leading;
    }

    public float getMultipliedLeading() {
        return this.multipliedLeading;
    }

    public TabSettings getTabSettings() {
        return this.tabSettings;
    }

    public float getTotalLeading() {
        float f = this.font == null ? this.multipliedLeading * 12.0f : this.font.getCalculatedLeading(this.multipliedLeading);
        if (f > 0.0f && !this.hasLeading()) {
            return f;
        }
        return this.getLeading() + f;
    }

    public boolean hasLeading() {
        if (Float.isNaN(this.leading)) {
            return false;
        }
        return true;
    }

    @Override
    public boolean isContent() {
        return true;
    }

    @Override
    public boolean isEmpty() {
        switch (this.size()) {
            default: {
                return false;
            }
            case 1: {
                Element element = (Element)this.get(0);
                if (element.type() == 10 && ((Chunk)element).isEmpty()) {
                    return true;
                }
                return false;
            }
            case 0: 
        }
        return true;
    }

    @Override
    public boolean isNestable() {
        return true;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public boolean process(ElementListener elementListener) {
        try {
            Iterator iterator = this.iterator();
            while (iterator.hasNext()) {
                elementListener.add((Element)iterator.next());
            }
            return true;
        }
        catch (DocumentException documentException) {
            return false;
        }
    }

    public void setFont(Font font) {
        this.font = font;
    }

    public void setHyphenation(HyphenationEvent hyphenationEvent) {
        this.hyphenation = hyphenationEvent;
    }

    public void setLeading(float f) {
        this.leading = f;
        this.multipliedLeading = 0.0f;
    }

    public void setLeading(float f, float f2) {
        this.leading = f;
        this.multipliedLeading = f2;
    }

    public void setMultipliedLeading(float f) {
        this.leading = 0.0f;
        this.multipliedLeading = f;
    }

    public void setTabSettings(TabSettings tabSettings) {
        this.tabSettings = tabSettings;
    }

    public boolean trim() {
        boolean bl;
        Element element;
        do {
            int n = this.size();
            bl = false;
            if (n <= 0 || !((element = (Element)this.get(0)) instanceof Chunk) || !((Chunk)element).isWhitespace()) break;
            this.remove(element);
        } while (true);
        while (this.size() > 0 && (element = (Element)this.get(this.size() - 1)) instanceof Chunk && ((Chunk)element).isWhitespace()) {
            this.remove(element);
        }
        if (this.size() > 0) {
            bl = true;
        }
        return bl;
    }

    @Override
    public int type() {
        return 11;
    }
}

