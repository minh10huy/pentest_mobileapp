/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl;

import com.itextpdf.xmp.XMPConst;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.impl.ParameterAsserts;
import com.itextpdf.xmp.impl.Utils;
import com.itextpdf.xmp.impl.XMPMetaImpl;
import com.itextpdf.xmp.impl.XMPNode;
import com.itextpdf.xmp.impl.XMPNodeUtils;
import com.itextpdf.xmp.impl.xpath.XMPPath;
import com.itextpdf.xmp.impl.xpath.XMPPathParser;
import com.itextpdf.xmp.impl.xpath.XMPPathSegment;
import com.itextpdf.xmp.options.PropertyOptions;
import com.itextpdf.xmp.properties.XMPAliasInfo;
import java.util.Iterator;

public class XMPUtilsImpl
implements XMPConst {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    private static final String COMMAS = ",\uff0c\uff64\ufe50\ufe51\u3001\u060c\u055d";
    private static final String CONTROLS = "\u2028\u2029";
    private static final String QUOTES = "\"\u00ab\u00bb\u301d\u301e\u301f\u2015\u2039\u203a";
    private static final String SEMICOLA = ";\uff1b\ufe54\u061b\u037e";
    private static final String SPACES = " \u3000\u303f";
    private static final int UCK_COMMA = 2;
    private static final int UCK_CONTROL = 5;
    private static final int UCK_NORMAL = 0;
    private static final int UCK_QUOTE = 4;
    private static final int UCK_SEMICOLON = 3;
    private static final int UCK_SPACE = 1;

    private XMPUtilsImpl() {
    }

    public static void appendProperties(XMPMeta object, XMPMeta xMPMeta, boolean bl, boolean bl2, boolean bl3) throws XMPException {
        ParameterAsserts.assertImplementation((XMPMeta)object);
        ParameterAsserts.assertImplementation(xMPMeta);
        object = (XMPMetaImpl)object;
        xMPMeta = (XMPMetaImpl)xMPMeta;
        Iterator iterator = object.getRoot().iterateChildren();
        while (iterator.hasNext()) {
            XMPNode xMPNode = (XMPNode)iterator.next();
            object = XMPNodeUtils.findSchemaNode(xMPMeta.getRoot(), xMPNode.getName(), false);
            boolean bl4 = true;
            if (object == null) {
                object = new XMPNode(xMPNode.getName(), xMPNode.getValue(), new PropertyOptions().setSchemaNode(true));
                xMPMeta.getRoot().addChild((XMPNode)object);
            } else {
                bl4 = false;
            }
            Iterator iterator2 = xMPNode.iterateChildren();
            while (iterator2.hasNext()) {
                XMPNode xMPNode2 = (XMPNode)iterator2.next();
                if (!bl && Utils.isInternalProperty(xMPNode.getName(), xMPNode2.getName())) continue;
                XMPUtilsImpl.appendSubtree((XMPMetaImpl)xMPMeta, xMPNode2, (XMPNode)object, bl2, bl3);
            }
            if (object.hasChildren() || !bl4 && !bl3) continue;
            xMPMeta.getRoot().removeChild((XMPNode)object);
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    private static void appendSubtree(XMPMetaImpl object, XMPNode object2, XMPNode xMPNode, boolean bl, boolean bl2) throws XMPException {
        XMPNode xMPNode2 = XMPNodeUtils.findChildNode(xMPNode, object2.getName(), false);
        int n = bl2 && (object2.getOptions().isSimple() ? object2.getValue() == null || object2.getValue().length() == 0 : !object2.hasChildren()) ? 1 : 0;
        if (bl2 && n != 0) {
            if (xMPNode2 == null) return;
            {
                xMPNode.removeChild(xMPNode2);
                return;
            }
        }
        if (xMPNode2 == null) {
            xMPNode.addChild((XMPNode)object2.clone());
            return;
        }
        if (bl) {
            object.setNode(xMPNode2, object2.getValue(), object2.getOptions(), true);
            xMPNode.removeChild(xMPNode2);
            xMPNode.addChild((XMPNode)object2.clone());
            return;
        }
        Object object3 = object2.getOptions();
        if (object3 != xMPNode2.getOptions()) {
            return;
        }
        if (object3.isStruct()) {
            object2 = object2.iterateChildren();
            while (object2.hasNext()) {
                XMPUtilsImpl.appendSubtree((XMPMetaImpl)object, (XMPNode)object2.next(), xMPNode2, bl, bl2);
                if (!bl2 || xMPNode2.hasChildren()) continue;
                xMPNode.removeChild(xMPNode2);
            }
            return;
        }
        if (!object3.isArrayAltText()) {
            if (!object3.isArray()) return;
            object2 = object2.iterateChildren();
            object = xMPNode2;
        } else {
            object = object2.iterateChildren();
            while (object.hasNext()) {
                object2 = (XMPNode)object.next();
                if (!object2.hasQualifier() || !"xml:lang".equals(object2.getQualifier(1).getName())) continue;
                n = XMPNodeUtils.lookupLanguageItem(xMPNode2, object2.getQualifier(1).getValue());
                if (bl2 && (object2.getValue() == null || object2.getValue().length() == 0)) {
                    if (n == -1) continue;
                    xMPNode2.removeChild(n);
                    if (xMPNode2.hasChildren()) continue;
                    xMPNode.removeChild(xMPNode2);
                    continue;
                }
                if (n != -1) continue;
                if ("x-default".equals(object2.getQualifier(1).getValue()) && xMPNode2.hasChildren()) {
                    object3 = new XMPNode(object2.getName(), object2.getValue(), object2.getOptions());
                    object2.cloneSubtree((XMPNode)object3);
                    xMPNode2.addChild(1, (XMPNode)object3);
                    continue;
                }
                object2.cloneSubtree(xMPNode2);
            }
            return;
        }
        while (object2.hasNext()) {
            xMPNode2 = (XMPNode)object2.next();
            object3 = object.iterateChildren();
            n = 0;
            while (object3.hasNext()) {
                if (!XMPUtilsImpl.itemValuesMatch(xMPNode2, (XMPNode)object3.next())) continue;
                n = 1;
            }
            object = (XMPNode)xMPNode2.clone();
            xMPNode.addChild((XMPNode)object);
        }
    }

    private static String applyQuotes(String charSequence, char c, char c2, boolean bl) {
        int n;
        String string2 = charSequence;
        if (charSequence == null) {
            string2 = "";
        }
        int n2 = 0;
        for (n = 0; n < string2.length(); ++n) {
            int n3 = XMPUtilsImpl.classifyCharacter(string2.charAt(n));
            if (n == 0 && n3 == 4) break;
            if (n3 == 1) {
                if (n2 != 0) break;
                n2 = 1;
                continue;
            }
            if (n3 == 3 || n3 == 5 || n3 == 2 && !bl) break;
            n2 = 0;
        }
        charSequence = string2;
        if (n < string2.length()) {
            charSequence = new StringBuffer(string2.length() + 2);
            for (n2 = 0; n2 <= n && XMPUtilsImpl.classifyCharacter(string2.charAt(n)) != 4; ++n2) {
            }
            charSequence.append(c);
            charSequence.append(string2.substring(0, n2));
            while (n2 < string2.length()) {
                charSequence.append(string2.charAt(n2));
                if (XMPUtilsImpl.classifyCharacter(string2.charAt(n2)) == 4 && XMPUtilsImpl.isSurroundingQuote(string2.charAt(n2), c, c2)) {
                    charSequence.append(string2.charAt(n2));
                }
                ++n2;
            }
            charSequence.append(c2);
            charSequence = charSequence.toString();
        }
        return charSequence;
    }

    public static String catenateArrayItems(XMPMeta object, String object2, String object3, String string2, String string3, boolean bl) throws XMPException {
        String string4;
        block13 : {
            block12 : {
                block11 : {
                    block10 : {
                        ParameterAsserts.assertSchemaNS((String)object2);
                        ParameterAsserts.assertArrayName((String)object3);
                        ParameterAsserts.assertImplementation((XMPMeta)object);
                        if (string2 == null) break block10;
                        string4 = string2;
                        if (string2.length() != 0) break block11;
                    }
                    string4 = "; ";
                }
                if (string3 == null) break block12;
                string2 = string3;
                if (string3.length() != 0) break block13;
            }
            string2 = "\"";
        }
        object = (XMPMetaImpl)object;
        object2 = XMPPathParser.expandXPath((String)object2, (String)object3);
        object2 = XMPNodeUtils.findNode(object.getRoot(), (XMPPath)object2, false, null);
        if (object2 == null) {
            return "";
        }
        if (object2.getOptions().isArray() && !object2.getOptions().isArrayAlternate()) {
            XMPUtilsImpl.checkSeparator(string4);
            char c = string2.charAt(0);
            char c2 = XMPUtilsImpl.checkQuotes(string2, c);
            object = new StringBuffer();
            object2 = object2.iterateChildren();
            while (object2.hasNext()) {
                object3 = (XMPNode)object2.next();
                if (object3.getOptions().isCompositeProperty()) {
                    throw new XMPException("Array items must be simple", 4);
                }
                object.append(XMPUtilsImpl.applyQuotes(object3.getValue(), c, c2, bl));
                if (!object2.hasNext()) continue;
                object.append(string4);
            }
            return object.toString();
        }
        throw new XMPException("Named property must be non-alternate array", 4);
    }

    private static char checkQuotes(String string2, char c) throws XMPException {
        char c2;
        if (XMPUtilsImpl.classifyCharacter(c) != 4) {
            throw new XMPException("Invalid quoting character", 4);
        }
        if (string2.length() == 1) {
            c2 = c;
        } else {
            char c3;
            c2 = c3 = string2.charAt(1);
            if (XMPUtilsImpl.classifyCharacter(c3) != 4) {
                throw new XMPException("Invalid quoting character", 4);
            }
        }
        if (c2 != XMPUtilsImpl.getClosingQuote(c)) {
            throw new XMPException("Mismatched quote pair", 4);
        }
        return c2;
    }

    private static void checkSeparator(String string2) throws XMPException {
        boolean bl = false;
        for (int i = 0; i < string2.length(); ++i) {
            int n = XMPUtilsImpl.classifyCharacter(string2.charAt(i));
            if (n == 3) {
                if (bl) {
                    throw new XMPException("Separator can have only one semicolon", 4);
                }
                bl = true;
                continue;
            }
            if (n == 1) continue;
            throw new XMPException("Separator can have only spaces and one semicolon", 4);
        }
        if (!bl) {
            throw new XMPException("Separator must have one semicolon", 4);
        }
    }

    private static int classifyCharacter(char c) {
        if (SPACES.indexOf(c) < 0 && ('\u2000' > c || c > '\u200b')) {
            if (COMMAS.indexOf(c) >= 0) {
                return 2;
            }
            if (SEMICOLA.indexOf(c) >= 0) {
                return 3;
            }
            if (!(QUOTES.indexOf(c) >= 0 || '\u3008' <= c && c <= '\u300f' || '\u2018' <= c && c <= '\u201f')) {
                if (c >= ' ' && CONTROLS.indexOf(c) < 0) {
                    return 0;
                }
                return 5;
            }
            return 4;
        }
        return 1;
    }

    private static char getClosingQuote(char c) {
        switch (c) {
            default: {
                return '\u0000';
            }
            case '\u301d': {
                return '\u301f';
            }
            case '\u300e': {
                return '\u300f';
            }
            case '\u300c': {
                return '\u300d';
            }
            case '\u300a': {
                return '\u300b';
            }
            case '\u3008': {
                return '\u3009';
            }
            case '\u203a': {
                return '\u2039';
            }
            case '\u2039': {
                return '\u203a';
            }
            case '\u201e': {
                return '\u201f';
            }
            case '\u201c': {
                return '\u201d';
            }
            case '\u201a': {
                return '\u201b';
            }
            case '\u2018': {
                return '\u2019';
            }
            case '\u2015': {
                return '\u2015';
            }
            case '\u00bb': {
                return '\u00ab';
            }
            case '\u00ab': {
                return '\u00bb';
            }
            case '\"': 
        }
        return '\"';
    }

    private static boolean isClosingingQuote(char c, char c2, char c3) {
        if (c != c3 && (c2 != '\u301d' || c != '\u301e') && c != '\u301f') {
            return false;
        }
        return true;
    }

    private static boolean isSurroundingQuote(char c, char c2, char c3) {
        if (c != c2 && !XMPUtilsImpl.isClosingingQuote(c, c2, c3)) {
            return false;
        }
        return true;
    }

    private static boolean itemValuesMatch(XMPNode object, XMPNode xMPNode) throws XMPException {
        Object object2 = object.getOptions();
        if (object2.equals(xMPNode.getOptions())) {
            return false;
        }
        if (object2.getOptions() == 0) {
            if (!object.getValue().equals(xMPNode.getValue())) {
                return false;
            }
            if (object.getOptions().getHasLanguage() != xMPNode.getOptions().getHasLanguage()) {
                return false;
            }
            if (object.getOptions().getHasLanguage() && !object.getQualifier(1).getValue().equals(xMPNode.getQualifier(1).getValue())) {
                return false;
            }
        } else if (object2.isStruct()) {
            if (object.getChildrenLength() != xMPNode.getChildrenLength()) {
                return false;
            }
            object = object.iterateChildren();
            while (object.hasNext()) {
                object2 = (XMPNode)object.next();
                XMPNode xMPNode2 = XMPNodeUtils.findChildNode(xMPNode, object2.getName(), false);
                if (xMPNode2 != null && XMPUtilsImpl.itemValuesMatch((XMPNode)object2, xMPNode2)) continue;
                return false;
            }
        } else {
            object = object.iterateChildren();
            while (object.hasNext()) {
                boolean bl;
                block12 : {
                    object2 = (XMPNode)object.next();
                    Iterator iterator = xMPNode.iterateChildren();
                    while (iterator.hasNext()) {
                        if (!XMPUtilsImpl.itemValuesMatch((XMPNode)object2, (XMPNode)iterator.next())) continue;
                        bl = true;
                        break block12;
                    }
                    bl = false;
                }
                if (bl) continue;
                return false;
            }
        }
        return true;
    }

    public static void removeProperties(XMPMeta object, String object2, String object3, boolean bl, boolean bl2) throws XMPException {
        block7 : {
            block8 : {
                block5 : {
                    block6 : {
                        ParameterAsserts.assertImplementation((XMPMeta)object);
                        object = (XMPMetaImpl)object;
                        if (object3 == null || object3.length() <= 0) break block5;
                        if (object2 == null || object2.length() == 0) break block6;
                        object2 = XMPPathParser.expandXPath((String)object2, (String)object3);
                        if ((object = XMPNodeUtils.findNode(object.getRoot(), (XMPPath)object2, false, null)) != null && (bl || !Utils.isInternalProperty(object2.getSegment(0).getName(), object2.getSegment(1).getName()))) {
                            object2 = object.getParent();
                            object2.removeChild((XMPNode)object);
                            if (object2.getOptions().isSchemaNode() && !object2.hasChildren()) {
                                object2.getParent().removeChild((XMPNode)object2);
                                return;
                            }
                        }
                        break block7;
                    }
                    throw new XMPException("Property name requires schema namespace", 4);
                }
                if (object2 == null || object2.length() <= 0) break block8;
                object3 = XMPNodeUtils.findSchemaNode(object.getRoot(), (String)object2, false);
                if (object3 != null && XMPUtilsImpl.removeSchemaChildren((XMPNode)object3, bl)) {
                    object.getRoot().removeChild((XMPNode)object3);
                }
                if (!bl2) break block7;
                object2 = XMPMetaFactory.getSchemaRegistry().findAliases((String)object2);
                for (int i = 0; i < ((XMPAliasInfo[])object2).length; ++i) {
                    object3 = object2[i];
                    object3 = XMPPathParser.expandXPath(object3.getNamespace(), object3.getPropName());
                    object3 = XMPNodeUtils.findNode(object.getRoot(), (XMPPath)object3, false, null);
                    if (object3 == null) continue;
                    object3.getParent().removeChild((XMPNode)object3);
                }
                break block7;
            }
            object = object.getRoot().iterateChildren();
            while (object.hasNext()) {
                if (!XMPUtilsImpl.removeSchemaChildren((XMPNode)object.next(), bl)) continue;
                object.remove();
            }
        }
    }

    private static boolean removeSchemaChildren(XMPNode xMPNode, boolean bl) {
        Iterator iterator = xMPNode.iterateChildren();
        while (iterator.hasNext()) {
            XMPNode xMPNode2 = (XMPNode)iterator.next();
            if (!bl && Utils.isInternalProperty(xMPNode.getName(), xMPNode2.getName())) continue;
            iterator.remove();
        }
        return xMPNode.hasChildren() ^ true;
    }

    public static void separateArrayItems(XMPMeta object, String object2, String charSequence, String string2, PropertyOptions propertyOptions, boolean bl) throws XMPException {
        ParameterAsserts.assertSchemaNS((String)object2);
        ParameterAsserts.assertArrayName((String)charSequence);
        if (string2 == null) {
            throw new XMPException("Parameter must not be null", 4);
        }
        ParameterAsserts.assertImplementation((XMPMeta)object);
        object2 = XMPUtilsImpl.separateFindCreateArray((String)object2, (String)charSequence, propertyOptions, (XMPMetaImpl)object);
        int n = string2.length();
        int n2 = 0;
        int n3 = 0;
        char c = '\u0000';
        while (n2 < n) {
            int n4;
            int n5;
            int n6;
            char c2;
            block23 : {
                block22 : {
                    n4 = n3;
                    c2 = c;
                    for (n6 = n2; n6 < n; ++n6) {
                        c = string2.charAt(n6);
                        n2 = XMPUtilsImpl.classifyCharacter(c);
                        c2 = c;
                        n4 = n2;
                        if (n2 == 0) break;
                        if (n2 == 4) {
                            c2 = c;
                            n4 = n2;
                            break;
                        }
                        c2 = c;
                        n4 = n2;
                    }
                    if (n6 >= n) {
                        return;
                    }
                    n5 = 1;
                    if (n4 != 4) {
                        n2 = n4;
                        for (n4 = n6; n4 < n; ++n4) {
                            c = string2.charAt(n4);
                            n3 = XMPUtilsImpl.classifyCharacter(c);
                            c2 = c;
                            if (n3 != 0) {
                                c2 = c;
                                if (n3 != 4) {
                                    if (n3 == 2 && bl) {
                                        c2 = c;
                                    } else {
                                        if (n3 != 1) {
                                            n2 = n3;
                                            c2 = c;
                                            break;
                                        }
                                        int n7 = n4 + 1;
                                        n2 = n3;
                                        c2 = c;
                                        if (n7 >= n) break;
                                        c = string2.charAt(n7);
                                        n7 = XMPUtilsImpl.classifyCharacter(c);
                                        c2 = c;
                                        if (n7 != 0) {
                                            c2 = c;
                                            if (n7 != 4) {
                                                n2 = n3;
                                                c2 = c;
                                                if (n7 != 2) break;
                                                n2 = n3;
                                                c2 = c;
                                                if (!bl) break;
                                                c2 = c;
                                            }
                                        }
                                    }
                                }
                            }
                            n2 = n3;
                        }
                        object = string2.substring(n6, n4);
                        n6 = n2;
                    } else {
                        char c3 = XMPUtilsImpl.getClosingQuote(c2);
                        n2 = n6 + 1;
                        object = "";
                        c = c2;
                        n6 = n4;
                        for (n4 = n2; n4 < n; ++n4) {
                            c = string2.charAt(n4);
                            n6 = XMPUtilsImpl.classifyCharacter(c);
                            if (n6 == 4 && XMPUtilsImpl.isSurroundingQuote(c, c2, c3)) {
                                n2 = n4 + 1;
                                if (n2 < n) {
                                    char c4 = string2.charAt(n2);
                                    XMPUtilsImpl.classifyCharacter(c4);
                                    n3 = c4;
                                } else {
                                    n3 = 59;
                                }
                                if (c == n3) {
                                    charSequence = new StringBuilder();
                                    charSequence.append((String)object);
                                    charSequence.append(c);
                                    object = charSequence.toString();
                                    n4 = n2;
                                    continue;
                                }
                                if (!XMPUtilsImpl.isClosingingQuote(c, c2, c3)) {
                                    charSequence = new StringBuilder();
                                    charSequence.append((String)object);
                                    charSequence.append(c);
                                    object = charSequence.toString();
                                    continue;
                                }
                                c2 = c;
                                n4 = n2;
                                break block22;
                            }
                            charSequence = new StringBuilder();
                            charSequence.append((String)object);
                            charSequence.append(c);
                            object = charSequence.toString();
                        }
                        c2 = c;
                    }
                }
                for (n2 = n5; n2 <= object2.getChildrenLength(); ++n2) {
                    if (!object.equals(object2.getChild(n2).getValue())) continue;
                    n5 = n2;
                    break block23;
                }
                n5 = -1;
            }
            c = c2;
            n2 = n4;
            n3 = n6;
            if (n5 >= 0) continue;
            object2.addChild(new XMPNode("[]", (String)object, null));
            c = c2;
            n2 = n4;
            n3 = n6;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private static XMPNode separateFindCreateArray(String object, String object2, PropertyOptions propertyOptions, XMPMetaImpl xMPMetaImpl) throws XMPException {
        if (!(propertyOptions = XMPNodeUtils.verifySetOptions(propertyOptions, null)).isOnlyArrayOptions()) {
            throw new XMPException("Options can only provide array form", 103);
        }
        object2 = XMPPathParser.expandXPath((String)object, (String)object2);
        object = XMPNodeUtils.findNode(xMPMetaImpl.getRoot(), (XMPPath)object2, false, null);
        if (object != null) {
            object2 = object.getOptions();
            if (!object2.isArray() || object2.isArrayAlternate()) throw new XMPException("Named property must be non-alternate array", 102);
            if (!propertyOptions.equalArrayTypes((PropertyOptions)object2)) return object;
            throw new XMPException("Mismatch of specified and existing array form", 102);
        }
        object = object2 = XMPNodeUtils.findNode(xMPMetaImpl.getRoot(), (XMPPath)object2, true, propertyOptions.setArray(true));
        if (object2 != null) return object;
        throw new XMPException("Failed to create named array", 102);
    }
}

