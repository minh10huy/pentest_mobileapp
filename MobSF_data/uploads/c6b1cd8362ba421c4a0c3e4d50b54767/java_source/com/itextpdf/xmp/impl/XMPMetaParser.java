/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl;

import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.impl.ByteBuffer;
import com.itextpdf.xmp.impl.FixASCIIControlsReader;
import com.itextpdf.xmp.impl.Latin1Converter;
import com.itextpdf.xmp.impl.ParameterAsserts;
import com.itextpdf.xmp.impl.ParseRDF;
import com.itextpdf.xmp.impl.XMPMetaImpl;
import com.itextpdf.xmp.impl.XMPNormalizer;
import com.itextpdf.xmp.options.ParseOptions;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;
import java.io.UnsupportedEncodingException;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

public class XMPMetaParser {
    private static final Object XMP_RDF = new Object();
    private static DocumentBuilderFactory factory = XMPMetaParser.createDocumentBuilderFactory();

    private XMPMetaParser() {
    }

    private static DocumentBuilderFactory createDocumentBuilderFactory() {
        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
        documentBuilderFactory.setNamespaceAware(true);
        documentBuilderFactory.setIgnoringComments(true);
        try {
            documentBuilderFactory.setFeature("http://javax.xml.XMLConstants/feature/secure-processing", true);
            documentBuilderFactory.setFeature("http://xml.org/sax/features/external-general-entities", false);
            documentBuilderFactory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false);
            documentBuilderFactory.setXIncludeAware(false);
            documentBuilderFactory.setExpandEntityReferences(false);
            return documentBuilderFactory;
        }
        catch (Exception exception) {
            return documentBuilderFactory;
        }
    }

    private static Object[] findRootNode(Node object, boolean bl, Object[] arrobject) {
        object = object.getChildNodes();
        for (int i = 0; i < object.getLength(); ++i) {
            Object object2;
            Object[] arrobject2 = object.item(i);
            if (7 == arrobject2.getNodeType() && "xpacket".equals((object2 = (ProcessingInstruction)arrobject2).getTarget())) {
                if (arrobject == null) continue;
                arrobject[2] = object2.getData();
                continue;
            }
            if (3 == arrobject2.getNodeType() || 7 == arrobject2.getNodeType()) continue;
            object2 = arrobject2.getNamespaceURI();
            String string2 = arrobject2.getLocalName();
            if (("xmpmeta".equals(string2) || "xapmeta".equals(string2)) && "adobe:ns:meta/".equals(object2)) {
                return XMPMetaParser.findRootNode((Node)arrobject2, false, arrobject);
            }
            if (!bl && "RDF".equals(string2) && "http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(object2)) {
                if (arrobject != null) {
                    arrobject[0] = arrobject2;
                    arrobject[1] = XMP_RDF;
                }
                return arrobject;
            }
            if ((arrobject2 = XMPMetaParser.findRootNode((Node)arrobject2, bl, arrobject)) == null) continue;
            return arrobject2;
        }
        return null;
    }

    public static XMPMeta parse(Object arrobject, ParseOptions parseOptions) throws XMPException {
        ParameterAsserts.assertNotNull(arrobject);
        if (parseOptions == null) {
            parseOptions = new ParseOptions();
        }
        arrobject = XMPMetaParser.findRootNode(XMPMetaParser.parseXml(arrobject, parseOptions), parseOptions.getRequireXMPMeta(), new Object[3]);
        if (arrobject != null && arrobject[1] == XMP_RDF) {
            XMPMetaImpl xMPMetaImpl = ParseRDF.parse((Node)arrobject[0]);
            xMPMetaImpl.setPacketHeader((String)arrobject[2]);
            if (!parseOptions.getOmitNormalization()) {
                return XMPNormalizer.process(xMPMetaImpl, parseOptions);
            }
            return xMPMetaImpl;
        }
        return new XMPMetaImpl();
    }

    private static Document parseInputSource(InputSource object) throws XMPException {
        try {
            DocumentBuilder documentBuilder = factory.newDocumentBuilder();
            documentBuilder.setErrorHandler(null);
            object = documentBuilder.parse((InputSource)object);
            return object;
        }
        catch (IOException iOException) {
            throw new XMPException("Error reading the XML-file", 204, iOException);
        }
        catch (ParserConfigurationException parserConfigurationException) {
            throw new XMPException("XML Parser not correctly configured", 0, parserConfigurationException);
        }
        catch (SAXException sAXException) {
            throw new XMPException("XML parsing failure", 201, sAXException);
        }
    }

    private static Document parseXml(Object object, ParseOptions parseOptions) throws XMPException {
        if (object instanceof InputStream) {
            return XMPMetaParser.parseXmlFromInputStream((InputStream)object, parseOptions);
        }
        if (object instanceof byte[]) {
            return XMPMetaParser.parseXmlFromBytebuffer(new ByteBuffer((byte[])object), parseOptions);
        }
        return XMPMetaParser.parseXmlFromString((String)object, parseOptions);
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private static Document parseXmlFromBytebuffer(ByteBuffer object, ParseOptions parseOptions) throws XMPException {
        Object object2 = new InputSource(object.getByteStream());
        try {
            return XMPMetaParser.parseInputSource((InputSource)object2);
        }
        catch (XMPException xMPException) {
            if (xMPException.getErrorCode() != 201) {
                if (xMPException.getErrorCode() != 204) throw xMPException;
            }
            object2 = object;
            if (parseOptions.getAcceptLatin1()) {
                object2 = Latin1Converter.convert((ByteBuffer)object);
            }
            if (!parseOptions.getFixControlChars()) return XMPMetaParser.parseInputSource(new InputSource(object2.getByteStream()));
            try {
                object = object2.getEncoding();
                return XMPMetaParser.parseInputSource(new InputSource(new FixASCIIControlsReader(new InputStreamReader(object2.getByteStream(), (String)object))));
            }
            catch (UnsupportedEncodingException unsupportedEncodingException) {
                throw new XMPException("Unsupported Encoding", 9, xMPException);
            }
        }
    }

    private static Document parseXmlFromInputStream(InputStream object, ParseOptions parseOptions) throws XMPException {
        if (!parseOptions.getAcceptLatin1() && !parseOptions.getFixControlChars()) {
            return XMPMetaParser.parseInputSource(new InputSource((InputStream)object));
        }
        try {
            object = XMPMetaParser.parseXmlFromBytebuffer(new ByteBuffer((InputStream)object), parseOptions);
            return object;
        }
        catch (IOException iOException) {
            throw new XMPException("Error reading the XML-file", 204, iOException);
        }
    }

    private static Document parseXmlFromString(String string2, ParseOptions parseOptions) throws XMPException {
        Object object = new InputSource(new StringReader(string2));
        try {
            object = XMPMetaParser.parseInputSource((InputSource)object);
            return object;
        }
        catch (XMPException xMPException) {
            if (xMPException.getErrorCode() == 201 && parseOptions.getFixControlChars()) {
                return XMPMetaParser.parseInputSource(new InputSource(new FixASCIIControlsReader(new StringReader(string2))));
            }
            throw xMPException;
        }
    }
}

