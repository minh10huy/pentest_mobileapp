/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl;

import com.itextpdf.xmp.XMPConst;
import com.itextpdf.xmp.XMPError;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.XMPSchemaRegistry;
import com.itextpdf.xmp.impl.Utils;
import com.itextpdf.xmp.impl.XMPMetaImpl;
import com.itextpdf.xmp.impl.XMPNode;
import com.itextpdf.xmp.impl.XMPNodeUtils;
import com.itextpdf.xmp.options.PropertyOptions;
import com.itextpdf.xmp.properties.XMPAliasInfo;
import java.util.ArrayList;
import java.util.Iterator;
import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class ParseRDF
implements XMPError,
XMPConst {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    public static final String DEFAULT_PREFIX = "_dflt";
    public static final int RDFTERM_ABOUT = 3;
    public static final int RDFTERM_ABOUT_EACH = 10;
    public static final int RDFTERM_ABOUT_EACH_PREFIX = 11;
    public static final int RDFTERM_BAG_ID = 12;
    public static final int RDFTERM_DATATYPE = 7;
    public static final int RDFTERM_DESCRIPTION = 8;
    public static final int RDFTERM_FIRST_CORE = 1;
    public static final int RDFTERM_FIRST_OLD = 10;
    public static final int RDFTERM_FIRST_SYNTAX = 1;
    public static final int RDFTERM_ID = 2;
    public static final int RDFTERM_LAST_CORE = 7;
    public static final int RDFTERM_LAST_OLD = 12;
    public static final int RDFTERM_LAST_SYNTAX = 9;
    public static final int RDFTERM_LI = 9;
    public static final int RDFTERM_NODE_ID = 6;
    public static final int RDFTERM_OTHER = 0;
    public static final int RDFTERM_PARSE_TYPE = 4;
    public static final int RDFTERM_RDF = 1;
    public static final int RDFTERM_RESOURCE = 5;

    private static XMPNode addChildNode(XMPMetaImpl object, XMPNode object2, Node object3, String string2, boolean bl) throws XMPException {
        XMPSchemaRegistry xMPSchemaRegistry = XMPMetaFactory.getSchemaRegistry();
        String string3 = object3.getNamespaceURI();
        if (string3 != null) {
            boolean bl2;
            String string4 = string3;
            if ("http://purl.org/dc/1.1/".equals(string3)) {
                string4 = "http://purl.org/dc/elements/1.1/";
            }
            Object object4 = xMPSchemaRegistry.getNamespacePrefix(string4);
            string3 = object4;
            if (object4 == null) {
                string3 = object3.getPrefix() != null ? object3.getPrefix() : DEFAULT_PREFIX;
                string3 = xMPSchemaRegistry.registerNamespace(string4, string3);
            }
            object4 = new StringBuilder();
            object4.append(string3);
            object4.append(object3.getLocalName());
            string3 = object4.toString();
            object4 = new PropertyOptions();
            boolean bl3 = bl2 = false;
            if (bl) {
                object3 = XMPNodeUtils.findSchemaNode(object.getRoot(), string4, DEFAULT_PREFIX, true);
                object3.setImplicit(false);
                bl3 = bl2;
                object2 = object3;
                if (xMPSchemaRegistry.findAlias(string3) != null) {
                    object.getRoot().setHasAliases(true);
                    object3.setHasAliases(true);
                    bl3 = true;
                    object2 = object3;
                }
            }
            bl2 = "rdf:li".equals(string3);
            boolean bl4 = "rdf:value".equals(string3);
            object = new XMPNode(string3, string2, (PropertyOptions)object4);
            object.setAlias(bl3);
            if (!bl4) {
                object2.addChild((XMPNode)object);
            } else {
                object2.addChild(1, (XMPNode)object);
            }
            if (bl4) {
                if (!bl && object2.getOptions().isStruct()) {
                    object2.setHasValueChild(true);
                } else {
                    throw new XMPException("Misplaced rdf:value element", 202);
                }
            }
            if (bl2) {
                if (!object2.getOptions().isArray()) {
                    throw new XMPException("Misplaced rdf:li element", 202);
                }
                object.setName("[]");
            }
            return object;
        }
        throw new XMPException("XML namespace required for all elements and attributes", 202);
    }

    private static XMPNode addQualifierNode(XMPNode xMPNode, String object, String string2) throws XMPException {
        String string3 = string2;
        if ("xml:lang".equals(object)) {
            string3 = Utils.normalizeLangValue(string2);
        }
        object = new XMPNode((String)object, string3, null);
        xMPNode.addQualifier((XMPNode)object);
        return object;
    }

    private static void fixupQualifiedNode(XMPNode xMPNode) throws XMPException {
        int n = 1;
        Object object = xMPNode.getChild(1);
        int n2 = n;
        if (object.getOptions().getHasLanguage()) {
            if (xMPNode.getOptions().getHasLanguage()) {
                throw new XMPException("Redundant xml:lang for rdf:value element", 203);
            }
            XMPNode xMPNode2 = object.getQualifier(1);
            object.removeQualifier(xMPNode2);
            xMPNode.addQualifier(xMPNode2);
            n2 = n;
        }
        while (n2 <= object.getQualifierLength()) {
            xMPNode.addQualifier(object.getQualifier(n2));
            ++n2;
        }
        for (n2 = 2; n2 <= xMPNode.getChildrenLength(); ++n2) {
            xMPNode.addQualifier(xMPNode.getChild(n2));
        }
        xMPNode.setHasValueChild(false);
        xMPNode.getOptions().setStruct(false);
        xMPNode.getOptions().mergeWith(object.getOptions());
        xMPNode.setValue(object.getValue());
        xMPNode.removeChildren();
        object = object.iterateChildren();
        while (object.hasNext()) {
            xMPNode.addChild((XMPNode)object.next());
        }
    }

    private static int getRDFTermKind(Node node) {
        String string2;
        String string3;
        block18 : {
            String string4;
            block19 : {
                string3 = node.getLocalName();
                string2 = string4 = node.getNamespaceURI();
                if (string4 != null) break block18;
                if ("about".equals(string3)) break block19;
                string2 = string4;
                if (!"ID".equals(string3)) break block18;
            }
            string2 = string4;
            if (node instanceof Attr) {
                string2 = string4;
                if ("http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(((Attr)node).getOwnerElement().getNamespaceURI())) {
                    string2 = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
                }
            }
        }
        if ("http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(string2)) {
            if ("li".equals(string3)) {
                return 9;
            }
            if ("parseType".equals(string3)) {
                return 4;
            }
            if ("Description".equals(string3)) {
                return 8;
            }
            if ("about".equals(string3)) {
                return 3;
            }
            if ("resource".equals(string3)) {
                return 5;
            }
            if ("RDF".equals(string3)) {
                return 1;
            }
            if ("ID".equals(string3)) {
                return 2;
            }
            if ("nodeID".equals(string3)) {
                return 6;
            }
            if ("datatype".equals(string3)) {
                return 7;
            }
            if ("aboutEach".equals(string3)) {
                return 10;
            }
            if ("aboutEachPrefix".equals(string3)) {
                return 11;
            }
            if ("bagID".equals(string3)) {
                return 12;
            }
        }
        return 0;
    }

    private static boolean isCoreSyntaxTerm(int n) {
        if (1 <= n && n <= 7) {
            return true;
        }
        return false;
    }

    private static boolean isOldTerm(int n) {
        if (10 <= n && n <= 12) {
            return true;
        }
        return false;
    }

    private static boolean isPropertyElementName(int n) {
        if (n != 8 && !ParseRDF.isOldTerm(n)) {
            return ParseRDF.isCoreSyntaxTerm(n) ^ true;
        }
        return false;
    }

    private static boolean isWhitespaceNode(Node object) {
        if (object.getNodeType() != 3) {
            return false;
        }
        object = object.getNodeValue();
        for (int i = 0; i < object.length(); ++i) {
            if (Character.isWhitespace(object.charAt(i))) continue;
            return false;
        }
        return true;
    }

    static XMPMetaImpl parse(Node node) throws XMPException {
        XMPMetaImpl xMPMetaImpl = new XMPMetaImpl();
        ParseRDF.rdf_RDF(xMPMetaImpl, node);
        return xMPMetaImpl;
    }

    /*
     * Exception decompiling
     */
    private static void rdf_EmptyPropertyElement(XMPMetaImpl var0, XMPNode var1_1, Node var2_2, boolean var3_3) throws XMPException {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Extractable last case doesn't follow previous
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:486)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    private static void rdf_LiteralPropertyElement(XMPMetaImpl object, XMPNode xMPNode, Node node, boolean bl) throws XMPException {
        CharSequence charSequence;
        Object object2;
        int n;
        xMPNode = ParseRDF.addChildNode((XMPMetaImpl)object, xMPNode, node, null, bl);
        int n2 = 0;
        for (n = 0; n < node.getAttributes().getLength(); ++n) {
            object = node.getAttributes().item(n);
            if ("xmlns".equals(object.getPrefix()) || object.getPrefix() == null && "xmlns".equals(object.getNodeName())) continue;
            object2 = object.getNamespaceURI();
            charSequence = object.getLocalName();
            if ("xml:lang".equals(object.getNodeName())) {
                ParseRDF.addQualifierNode(xMPNode, "xml:lang", object.getNodeValue());
                continue;
            }
            if ("http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(object2) && ("ID".equals(charSequence) || "datatype".equals(charSequence))) continue;
            throw new XMPException("Invalid attribute for literal property element", 202);
        }
        object = "";
        for (n = n2; n < node.getChildNodes().getLength(); ++n) {
            object2 = node.getChildNodes().item(n);
            if (object2.getNodeType() == 3) {
                charSequence = new StringBuilder();
                charSequence.append((String)object);
                charSequence.append(object2.getNodeValue());
                object = charSequence.toString();
                continue;
            }
            throw new XMPException("Invalid child of literal property element", 202);
        }
        xMPNode.setValue((String)object);
    }

    private static void rdf_NodeElement(XMPMetaImpl xMPMetaImpl, XMPNode xMPNode, Node node, boolean bl) throws XMPException {
        int n = ParseRDF.getRDFTermKind(node);
        if (n != 8 && n != 0) {
            throw new XMPException("Node element must be rdf:Description or typed node", 202);
        }
        if (bl && n == 0) {
            throw new XMPException("Top level typed node not allowed", 203);
        }
        ParseRDF.rdf_NodeElementAttrs(xMPMetaImpl, xMPNode, node, bl);
        ParseRDF.rdf_PropertyElementList(xMPMetaImpl, xMPNode, node, bl);
    }

    private static void rdf_NodeElementAttrs(XMPMetaImpl xMPMetaImpl, XMPNode xMPNode, Node node, boolean bl) throws XMPException {
        int n = 0;
        for (int i = 0; i < node.getAttributes().getLength(); ++i) {
            Node node2 = node.getAttributes().item(i);
            int n2 = n;
            if (!"xmlns".equals(node2.getPrefix())) {
                if (node2.getPrefix() == null && "xmlns".equals(node2.getNodeName())) {
                    n2 = n;
                } else {
                    int n3 = ParseRDF.getRDFTermKind(node2);
                    if (n3 != 0) {
                        if (n3 != 6) {
                            switch (n3) {
                                default: {
                                    throw new XMPException("Invalid nodeElement attribute", 202);
                                }
                                case 2: 
                                case 3: 
                            }
                        }
                        if (n > 0) {
                            throw new XMPException("Mutally exclusive about, ID, nodeID attributes", 202);
                        }
                        n2 = ++n;
                        if (bl) {
                            n2 = n;
                            if (n3 == 3) {
                                if (xMPNode.getName() != null && xMPNode.getName().length() > 0) {
                                    n2 = n;
                                    if (!xMPNode.getName().equals(node2.getNodeValue())) {
                                        throw new XMPException("Mismatched top level rdf:about values", 203);
                                    }
                                } else {
                                    xMPNode.setName(node2.getNodeValue());
                                    n2 = n;
                                }
                            }
                        }
                    } else {
                        ParseRDF.addChildNode(xMPMetaImpl, xMPNode, node2, node2.getNodeValue(), bl);
                        n2 = n;
                    }
                }
            }
            n = n2;
        }
    }

    private static void rdf_NodeElementList(XMPMetaImpl xMPMetaImpl, XMPNode xMPNode, Node node) throws XMPException {
        for (int i = 0; i < node.getChildNodes().getLength(); ++i) {
            Node node2 = node.getChildNodes().item(i);
            if (ParseRDF.isWhitespaceNode(node2)) continue;
            ParseRDF.rdf_NodeElement(xMPMetaImpl, xMPNode, node2, true);
        }
    }

    private static void rdf_ParseTypeCollectionPropertyElement() throws XMPException {
        throw new XMPException("ParseTypeCollection property element not allowed", 203);
    }

    private static void rdf_ParseTypeLiteralPropertyElement() throws XMPException {
        throw new XMPException("ParseTypeLiteral property element not allowed", 203);
    }

    private static void rdf_ParseTypeOtherPropertyElement() throws XMPException {
        throw new XMPException("ParseTypeOther property element not allowed", 203);
    }

    private static void rdf_ParseTypeResourcePropertyElement(XMPMetaImpl xMPMetaImpl, XMPNode xMPNode, Node node, boolean bl) throws XMPException {
        xMPNode = ParseRDF.addChildNode(xMPMetaImpl, xMPNode, node, "", bl);
        xMPNode.getOptions().setStruct(true);
        for (int i = 0; i < node.getAttributes().getLength(); ++i) {
            Node node2 = node.getAttributes().item(i);
            if ("xmlns".equals(node2.getPrefix()) || node2.getPrefix() == null && "xmlns".equals(node2.getNodeName())) continue;
            String string2 = node2.getLocalName();
            String string3 = node2.getNamespaceURI();
            if ("xml:lang".equals(node2.getNodeName())) {
                ParseRDF.addQualifierNode(xMPNode, "xml:lang", node2.getNodeValue());
                continue;
            }
            if ("http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(string3) && ("ID".equals(string2) || "parseType".equals(string2))) continue;
            throw new XMPException("Invalid attribute for ParseTypeResource property element", 202);
        }
        ParseRDF.rdf_PropertyElementList(xMPMetaImpl, xMPNode, node, false);
        if (xMPNode.getHasValueChild()) {
            ParseRDF.fixupQualifiedNode(xMPNode);
        }
    }

    private static void rdf_PropertyElement(XMPMetaImpl xMPMetaImpl, XMPNode xMPNode, Node node, boolean bl) throws XMPException {
        int n;
        Object object;
        Object object2;
        if (!ParseRDF.isPropertyElementName(ParseRDF.getRDFTermKind(node))) {
            throw new XMPException("Invalid property element name", 202);
        }
        NamedNodeMap namedNodeMap = node.getAttributes();
        int n2 = 0;
        ArrayList<String> arrayList = null;
        for (n = 0; n < namedNodeMap.getLength(); ++n) {
            block19 : {
                block18 : {
                    object = namedNodeMap.item(n);
                    if ("xmlns".equals(object.getPrefix())) break block18;
                    object2 = arrayList;
                    if (object.getPrefix() != null) break block19;
                    object2 = arrayList;
                    if (!"xmlns".equals(object.getNodeName())) break block19;
                }
                object2 = arrayList;
                if (arrayList == null) {
                    object2 = new ArrayList<String>();
                }
                object2.add(object.getNodeName());
            }
            arrayList = object2;
        }
        if (arrayList != null) {
            arrayList = arrayList.iterator();
            while (arrayList.hasNext()) {
                namedNodeMap.removeNamedItem((String)arrayList.next());
            }
        }
        if (namedNodeMap.getLength() > 3) {
            ParseRDF.rdf_EmptyPropertyElement(xMPMetaImpl, xMPNode, node, bl);
            return;
        }
        for (n = 0; n < namedNodeMap.getLength(); ++n) {
            arrayList = namedNodeMap.item(n);
            object2 = arrayList.getLocalName();
            object = arrayList.getNamespaceURI();
            String string2 = arrayList.getNodeValue();
            if (!(!"xml:lang".equals(arrayList.getNodeName()) || "ID".equals(object2) && "http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(object))) {
                continue;
            }
            if ("datatype".equals(object2) && "http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(object)) {
                ParseRDF.rdf_LiteralPropertyElement(xMPMetaImpl, xMPNode, node, bl);
                return;
            }
            if ("parseType".equals(object2) && "http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(object)) {
                if ("Literal".equals(string2)) {
                    ParseRDF.rdf_ParseTypeLiteralPropertyElement();
                    return;
                }
                if ("Resource".equals(string2)) {
                    ParseRDF.rdf_ParseTypeResourcePropertyElement(xMPMetaImpl, xMPNode, node, bl);
                    return;
                }
                if ("Collection".equals(string2)) {
                    ParseRDF.rdf_ParseTypeCollectionPropertyElement();
                    return;
                }
                ParseRDF.rdf_ParseTypeOtherPropertyElement();
                return;
            }
            ParseRDF.rdf_EmptyPropertyElement(xMPMetaImpl, xMPNode, node, bl);
            return;
        }
        if (node.hasChildNodes()) {
            for (n = n2; n < node.getChildNodes().getLength(); ++n) {
                if (node.getChildNodes().item(n).getNodeType() == 3) continue;
                ParseRDF.rdf_ResourcePropertyElement(xMPMetaImpl, xMPNode, node, bl);
                return;
            }
            ParseRDF.rdf_LiteralPropertyElement(xMPMetaImpl, xMPNode, node, bl);
            return;
        }
        ParseRDF.rdf_EmptyPropertyElement(xMPMetaImpl, xMPNode, node, bl);
    }

    private static void rdf_PropertyElementList(XMPMetaImpl xMPMetaImpl, XMPNode xMPNode, Node node, boolean bl) throws XMPException {
        for (int i = 0; i < node.getChildNodes().getLength(); ++i) {
            Node node2 = node.getChildNodes().item(i);
            if (ParseRDF.isWhitespaceNode(node2)) continue;
            if (node2.getNodeType() != 1) {
                throw new XMPException("Expected property element node not found", 202);
            }
            ParseRDF.rdf_PropertyElement(xMPMetaImpl, xMPNode, node2, bl);
        }
    }

    static void rdf_RDF(XMPMetaImpl xMPMetaImpl, Node node) throws XMPException {
        if (node.hasAttributes()) {
            ParseRDF.rdf_NodeElementList(xMPMetaImpl, xMPMetaImpl.getRoot(), node);
            return;
        }
        throw new XMPException("Invalid attributes of rdf:RDF element", 202);
    }

    private static void rdf_ResourcePropertyElement(XMPMetaImpl xMPMetaImpl, XMPNode xMPNode, Node node, boolean bl) throws XMPException {
        String string2;
        Node node2;
        int n;
        String string3;
        if (bl && "iX:changes".equals(node.getNodeName())) {
            return;
        }
        xMPNode = ParseRDF.addChildNode(xMPMetaImpl, xMPNode, node, "", bl);
        for (n = 0; n < node.getAttributes().getLength(); ++n) {
            node2 = node.getAttributes().item(n);
            if ("xmlns".equals(node2.getPrefix()) || node2.getPrefix() == null && "xmlns".equals(node2.getNodeName())) continue;
            string3 = node2.getLocalName();
            string2 = node2.getNamespaceURI();
            if ("xml:lang".equals(node2.getNodeName())) {
                ParseRDF.addQualifierNode(xMPNode, "xml:lang", node2.getNodeValue());
                continue;
            }
            if ("ID".equals(string3) && "http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(string2)) continue;
            throw new XMPException("Invalid attribute for resource property element", 202);
        }
        boolean bl2 = false;
        for (n = 0; n < node.getChildNodes().getLength(); ++n) {
            node2 = node.getChildNodes().item(n);
            boolean bl3 = bl2;
            if (!ParseRDF.isWhitespaceNode(node2)) {
                if (node2.getNodeType() == 1 && !bl2) {
                    bl = "http://www.w3.org/1999/02/22-rdf-syntax-ns#".equals(node2.getNamespaceURI());
                    string3 = node2.getLocalName();
                    if (bl && "Bag".equals(string3)) {
                        xMPNode.getOptions().setArray(true);
                    } else if (bl && "Seq".equals(string3)) {
                        xMPNode.getOptions().setArray(true).setArrayOrdered(true);
                    } else if (bl && "Alt".equals(string3)) {
                        xMPNode.getOptions().setArray(true).setArrayOrdered(true).setArrayAlternate(true);
                    } else {
                        xMPNode.getOptions().setStruct(true);
                        if (!bl && !"Description".equals(string3)) {
                            string2 = node2.getNamespaceURI();
                            if (string2 == null) {
                                throw new XMPException("All XML elements must be in a namespace", 203);
                            }
                            StringBuilder stringBuilder = new StringBuilder();
                            stringBuilder.append(string2);
                            stringBuilder.append(':');
                            stringBuilder.append(string3);
                            ParseRDF.addQualifierNode(xMPNode, "rdf:type", stringBuilder.toString());
                        }
                    }
                    ParseRDF.rdf_NodeElement(xMPMetaImpl, xMPNode, node2, false);
                    if (xMPNode.getHasValueChild()) {
                        ParseRDF.fixupQualifiedNode(xMPNode);
                    } else if (xMPNode.getOptions().isArrayAlternate()) {
                        XMPNodeUtils.detectAltText(xMPNode);
                    }
                    bl3 = true;
                } else {
                    if (bl2) {
                        throw new XMPException("Invalid child of resource property element", 202);
                    }
                    throw new XMPException("Children of resource property element must be XML elements", 202);
                }
            }
            bl2 = bl3;
        }
        if (!bl2) {
            throw new XMPException("Missing child of resource property element", 202);
        }
    }
}

