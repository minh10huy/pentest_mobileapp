/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.annotation.TargetApi
 *  android.graphics.ImageFormat
 *  android.graphics.PointF
 *  android.graphics.Rect
 *  android.graphics.SurfaceTexture
 *  android.graphics.YuvImage
 *  android.hardware.Camera
 *  android.hardware.Camera$Area
 *  android.hardware.Camera$AutoFocusCallback
 *  android.hardware.Camera$CameraInfo
 *  android.hardware.Camera$ErrorCallback
 *  android.hardware.Camera$Parameters
 *  android.hardware.Camera$PictureCallback
 *  android.hardware.Camera$PreviewCallback
 *  android.hardware.Camera$ShutterCallback
 *  android.hardware.Camera$Size
 *  android.location.Location
 *  android.media.CamcorderProfile
 *  android.media.MediaRecorder
 *  android.media.MediaRecorder$OnInfoListener
 *  android.os.Build
 *  android.os.Build$VERSION
 *  android.os.Handler
 *  android.view.SurfaceHolder
 */
package com.otaliastudios.cameraview;

import android.annotation.TargetApi;
import android.graphics.ImageFormat;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.SurfaceTexture;
import android.graphics.YuvImage;
import android.hardware.Camera;
import android.location.Location;
import android.media.CamcorderProfile;
import android.media.MediaRecorder;
import android.os.Build;
import android.os.Handler;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.WorkerThread;
import android.view.SurfaceHolder;
import com.otaliastudios.cameraview.Audio;
import com.otaliastudios.cameraview.CameraController;
import com.otaliastudios.cameraview.CameraException;
import com.otaliastudios.cameraview.CameraLogger;
import com.otaliastudios.cameraview.CameraOptions;
import com.otaliastudios.cameraview.CameraPreview;
import com.otaliastudios.cameraview.CameraView;
import com.otaliastudios.cameraview.Control;
import com.otaliastudios.cameraview.ExtraProperties;
import com.otaliastudios.cameraview.Facing;
import com.otaliastudios.cameraview.Flash;
import com.otaliastudios.cameraview.Frame;
import com.otaliastudios.cameraview.FrameManager;
import com.otaliastudios.cameraview.Gesture;
import com.otaliastudios.cameraview.Hdr;
import com.otaliastudios.cameraview.Mapper;
import com.otaliastudios.cameraview.RotationHelper;
import com.otaliastudios.cameraview.SessionType;
import com.otaliastudios.cameraview.Size;
import com.otaliastudios.cameraview.Task;
import com.otaliastudios.cameraview.VideoCodec;
import com.otaliastudios.cameraview.VideoQuality;
import com.otaliastudios.cameraview.WhiteBalance;
import com.otaliastudios.cameraview.WorkerHandler;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

class Camera1
extends CameraController
implements Camera.PreviewCallback,
Camera.ErrorCallback {
    private static final CameraLogger LOG = CameraLogger.create(TAG);
    private static final String TAG = "Camera1";
    private Camera mCamera;
    private boolean mIsBound = false;
    private final int mPostFocusResetDelay = 3000;
    private Runnable mPostFocusResetRunnable = new Runnable(){

        @Override
        public void run() {
            if (!Camera1.this.isCameraAvailable()) {
                return;
            }
            Camera1.this.mCamera.cancelAutoFocus();
            Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
            int n = parameters.getMaxNumFocusAreas();
            int n2 = parameters.getMaxNumMeteringAreas();
            if (n > 0) {
                parameters.setFocusAreas(null);
            }
            if (n2 > 0) {
                parameters.setMeteringAreas(null);
            }
            Camera1.this.applyDefaultFocus(parameters);
            Camera1.this.mCamera.setParameters(parameters);
        }
    };

    Camera1(CameraView.CameraCallbacks cameraCallbacks) {
        super(cameraCallbacks);
        this.mMapper = new Mapper.Mapper1();
    }

    private void applyDefaultFocus(Camera.Parameters parameters) {
        List list = parameters.getSupportedFocusModes();
        if (this.mSessionType == SessionType.VIDEO && list.contains("continuous-video")) {
            parameters.setFocusMode("continuous-video");
            return;
        }
        if (list.contains("continuous-picture")) {
            parameters.setFocusMode("continuous-picture");
            return;
        }
        if (list.contains("infinity")) {
            parameters.setFocusMode("infinity");
            return;
        }
        if (list.contains("fixed")) {
            parameters.setFocusMode("fixed");
            return;
        }
    }

    private void applySizesAndStartPreview(String string2) {
        LOG.i(string2, "Dispatching onCameraPreviewSizeChanged.");
        this.mCameraCallbacks.onCameraPreviewSizeChanged();
        boolean bl = this.shouldFlipSizes();
        CameraPreview cameraPreview = this.mPreview;
        int n = bl ? this.mPreviewSize.getHeight() : this.mPreviewSize.getWidth();
        int n2 = bl ? this.mPreviewSize.getWidth() : this.mPreviewSize.getHeight();
        cameraPreview.setDesiredSize(n, n2);
        cameraPreview = this.mCamera.getParameters();
        this.mPreviewFormat = cameraPreview.getPreviewFormat();
        cameraPreview.setPreviewSize(this.mPreviewSize.getWidth(), this.mPreviewSize.getHeight());
        cameraPreview.setPictureSize(this.mPictureSize.getWidth(), this.mPictureSize.getHeight());
        this.mCamera.setParameters((Camera.Parameters)cameraPreview);
        this.mCamera.setPreviewCallbackWithBuffer(null);
        this.mCamera.setPreviewCallbackWithBuffer((Camera.PreviewCallback)this);
        this.mFrameManager.allocate(ImageFormat.getBitsPerPixel((int)this.mPreviewFormat), this.mPreviewSize);
        LOG.i(string2, "Starting preview with startPreview().");
        this.mCamera.startPreview();
        LOG.i(string2, "Started preview.");
    }

    @WorkerThread
    private void bindToSurface() {
        block3 : {
            LOG.i("bindToSurface:", "Started");
            Object Output2 = this.mPreview.getOutput();
            try {
                if (this.mPreview.getOutputClass() == SurfaceHolder.class) {
                    this.mCamera.setPreviewDisplay((SurfaceHolder)Output2);
                    break block3;
                }
                this.mCamera.setPreviewTexture((SurfaceTexture)Output2);
            }
            catch (IOException iOException) {
                throw new CameraException(iOException);
            }
        }
        this.mPictureSize = this.computePictureSize();
        this.mPreviewSize = this.computePreviewSize(this.sizesFromList(this.mCamera.getParameters().getSupportedPreviewSizes()));
        this.applySizesAndStartPreview("bindToSurface:");
        this.mIsBound = true;
    }

    private boolean collectCameraId() {
        int n = (Integer)this.mMapper.map(this.mFacing);
        Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
        int n2 = Camera.getNumberOfCameras();
        for (int i = 0; i < n2; ++i) {
            Camera.getCameraInfo((int)i, (Camera.CameraInfo)cameraInfo);
            if (cameraInfo.facing != n) continue;
            this.mSensorOffset = cameraInfo.orientation;
            this.mCameraId = i;
            return true;
        }
        return false;
    }

    private static Rect computeMeteringArea(double d, double d2, double d3) {
        int n = (int)Math.max(d2 - (d3 /= 2.0), -1000.0);
        int n2 = (int)Math.min(d2 + d3, 1000.0);
        int n3 = (int)Math.max(d - d3, -1000.0);
        int n4 = (int)Math.min(d + d3, 1000.0);
        LOG.i("focus:", "computeMeteringArea:", "top:", n, "left:", n3, "bottom:", n2, "right:", n4);
        return new Rect(n3, n, n4, n2);
    }

    @WorkerThread
    private static List<Camera.Area> computeMeteringAreas(double d, double d2, int n, int n2, int n3) {
        n3 = - n3;
        d = d / (double)n * 2000.0 - 1000.0;
        d2 = d2 / (double)n2 * 2000.0 - 1000.0;
        double d3 = (double)n3 * 3.141592653589793 / 180.0;
        double d4 = Math.cos(d3) * d - Math.sin(d3) * d2;
        double d5 = Math.sin(d3);
        d3 = Math.cos(d3) * d2 + d5 * d;
        LOG.i("focus:", "viewClickX:", d, "viewClickY:", d2);
        LOG.i("focus:", "sensorClickX:", d4, "sensorClickY:", d3);
        Rect rect = Camera1.computeMeteringArea(d4, d3, 150.0);
        Rect rect2 = Camera1.computeMeteringArea(d4, d3, 300.0);
        ArrayList<Camera.Area> arrayList = new ArrayList<Camera.Area>(2);
        arrayList.add(new Camera.Area(rect, 1000));
        arrayList.add(new Camera.Area(rect2, 100));
        return arrayList;
    }

    @WorkerThread
    private void endVideoImmediately() {
        LOG.i("endVideoImmediately:", "is capturing:", this.mIsCapturingVideo);
        this.mIsCapturingVideo = false;
        if (this.mMediaRecorder != null) {
            try {
                this.mMediaRecorder.stop();
            }
            catch (Exception exception) {
                LOG.w("endVideoImmediately:", "Error while closing media recorder. Swallowing", exception);
            }
            this.mMediaRecorder.release();
            this.mMediaRecorder = null;
        }
        if (this.mVideoFile != null) {
            this.mCameraCallbacks.dispatchOnVideoTaken(this.mVideoFile);
            this.mVideoFile = null;
        }
    }

    @WorkerThread
    private void initMediaRecorder() {
        this.mMediaRecorder = new MediaRecorder();
        this.mCamera.unlock();
        this.mMediaRecorder.setCamera(this.mCamera);
        this.mMediaRecorder.setVideoSource(1);
        if (this.mAudio == Audio.ON) {
            this.mMediaRecorder.setAudioSource(0);
        }
        CamcorderProfile camcorderProfile = this.getCamcorderProfile();
        this.mMediaRecorder.setOutputFormat(camcorderProfile.fileFormat);
        this.mMediaRecorder.setVideoFrameRate(camcorderProfile.videoFrameRate);
        this.mMediaRecorder.setVideoSize(camcorderProfile.videoFrameWidth, camcorderProfile.videoFrameHeight);
        this.mMediaRecorder.setVideoEncoder(this.mMapper.map(this.mVideoCodec));
        this.mMediaRecorder.setVideoEncodingBitRate(camcorderProfile.videoBitRate);
        if (this.mAudio == Audio.ON) {
            this.mMediaRecorder.setAudioChannels(camcorderProfile.audioChannels);
            this.mMediaRecorder.setAudioSamplingRate(camcorderProfile.audioSampleRate);
            this.mMediaRecorder.setAudioEncoder(camcorderProfile.audioCodec);
            this.mMediaRecorder.setAudioEncodingBitRate(camcorderProfile.audioBitRate);
        }
        if (this.mLocation != null) {
            this.mMediaRecorder.setLocation((float)this.mLocation.getLatitude(), (float)this.mLocation.getLongitude());
        }
        this.mMediaRecorder.setOutputFile(this.mVideoFile.getAbsolutePath());
        this.mMediaRecorder.setOrientationHint(this.computeSensorToOutputOffset());
        this.mMediaRecorder.setMaxFileSize(this.mVideoMaxSize);
        this.mMediaRecorder.setMaxDuration(this.mVideoMaxDuration);
        this.mMediaRecorder.setOnInfoListener(new MediaRecorder.OnInfoListener(){

            public void onInfo(MediaRecorder mediaRecorder, int n, int n2) {
                switch (n) {
                    default: {
                        return;
                    }
                    case 800: 
                    case 801: 
                }
                Camera1.this.endVideoImmediately();
            }
        });
    }

    private boolean isCameraAvailable() {
        switch (this.mState) {
            default: {
                return false;
            }
            case 2: {
                return true;
            }
            case 1: {
                if (this.mCamera != null) {
                    return true;
                }
                return false;
            }
            case 0: {
                return false;
            }
            case -1: 
        }
        return false;
    }

    private boolean mergeFlash(Camera.Parameters parameters, Flash flash) {
        if (this.mCameraOptions.supports(this.mFlash)) {
            parameters.setFlashMode((String)this.mMapper.map(this.mFlash));
            return true;
        }
        this.mFlash = flash;
        return false;
    }

    private boolean mergeHdr(Camera.Parameters parameters, Hdr hdr) {
        if (this.mCameraOptions.supports(this.mHdr)) {
            parameters.setSceneMode((String)this.mMapper.map(this.mHdr));
            return true;
        }
        this.mHdr = hdr;
        return false;
    }

    private boolean mergeLocation(Camera.Parameters parameters, Location location) {
        if (this.mLocation != null) {
            parameters.setGpsLatitude(this.mLocation.getLatitude());
            parameters.setGpsLongitude(this.mLocation.getLongitude());
            parameters.setGpsAltitude(this.mLocation.getAltitude());
            parameters.setGpsTimestamp(this.mLocation.getTime());
            parameters.setGpsProcessingMethod(this.mLocation.getProvider());
            if (this.mIsCapturingVideo && this.mMediaRecorder != null) {
                this.mMediaRecorder.setLocation((float)this.mLocation.getLatitude(), (float)this.mLocation.getLongitude());
            }
        }
        return true;
    }

    @TargetApi(value=17)
    private boolean mergePlaySound(boolean bl) {
        if (Build.VERSION.SDK_INT >= 17) {
            Camera.CameraInfo cameraInfo = new Camera.CameraInfo();
            Camera.getCameraInfo((int)this.mCameraId, (Camera.CameraInfo)cameraInfo);
            if (cameraInfo.canDisableShutterSound) {
                this.mCamera.enableShutterSound(this.mPlaySounds);
                return true;
            }
        }
        if (this.mPlaySounds) {
            return true;
        }
        this.mPlaySounds = bl;
        return false;
    }

    private boolean mergeWhiteBalance(Camera.Parameters parameters, WhiteBalance whiteBalance) {
        if (this.mCameraOptions.supports(this.mWhiteBalance)) {
            parameters.setWhiteBalance((String)this.mMapper.map(this.mWhiteBalance));
            return true;
        }
        this.mWhiteBalance = whiteBalance;
        return false;
    }

    private void schedule(final @Nullable Task<Void> task, final boolean bl, final Runnable runnable) {
        this.mHandler.post(new Runnable(){

            @Override
            public void run() {
                if (bl && !Camera1.this.isCameraAvailable()) {
                    if (task != null) {
                        task.end(null);
                        return;
                    }
                } else {
                    runnable.run();
                    if (task != null) {
                        task.end(null);
                    }
                }
            }
        });
    }

    private boolean shouldBindToSurface() {
        if (this.isCameraAvailable() && this.mPreview != null && this.mPreview.isReady() && !this.mIsBound) {
            return true;
        }
        return false;
    }

    @Nullable
    private List<Size> sizesFromList(List<Camera.Size> object) {
        if (object == null) {
            return null;
        }
        ArrayList<Size> arrayList = new ArrayList<Size>(object.size());
        object = object.iterator();
        while (object.hasNext()) {
            Object object2 = (Camera.Size)object.next();
            object2 = new Size(object2.width, object2.height);
            if (arrayList.contains(object2)) continue;
            arrayList.add((Size)object2);
        }
        LOG.i("size:", "sizesFromList:", arrayList);
        return arrayList;
    }

    @Override
    void capturePicture() {
        LOG.v("capturePicture: scheduling");
        this.schedule(null, true, new Runnable(){

            @Override
            public void run() {
                CameraLogger cameraLogger = LOG;
                final boolean bl = false;
                cameraLogger.v("capturePicture: performing.", Camera1.this.mIsCapturingImage);
                if (Camera1.this.mIsCapturingImage) {
                    return;
                }
                if (Camera1.this.mIsCapturingVideo && !Camera1.this.mCameraOptions.isVideoSnapshotSupported()) {
                    return;
                }
                Camera1.this.mIsCapturingImage = true;
                int n = Camera1.this.computeSensorToOutputOffset();
                final boolean bl2 = (Camera1.this.computeSensorToViewOffset() + n + 180) % 180 == 0;
                if (Camera1.this.mFacing == Facing.FRONT) {
                    bl = true;
                }
                cameraLogger = Camera1.this.mCamera.getParameters();
                cameraLogger.setRotation(n);
                Camera1.this.mCamera.setParameters((Camera.Parameters)cameraLogger);
                Camera1.this.mCamera.takePicture(new Camera.ShutterCallback(){

                    public void onShutter() {
                        Camera1.this.mCameraCallbacks.onShutter(false);
                    }
                }, null, null, new Camera.PictureCallback(){

                    public void onPictureTaken(byte[] arrby, Camera camera) {
                        Camera1.this.mIsCapturingImage = false;
                        Camera1.this.mCameraCallbacks.processImage(arrby, bl2, bl);
                        camera.startPreview();
                    }
                });
            }

        });
    }

    @Override
    void captureSnapshot() {
        LOG.v("captureSnapshot: scheduling");
        this.schedule(null, true, new Runnable(){

            @Override
            public void run() {
                LOG.v("captureSnapshot: performing.", Camera1.this.mIsCapturingImage);
                if (Camera1.this.mIsCapturingImage) {
                    return;
                }
                if (Camera1.this.mIsCapturingVideo) {
                    Camera1.this.capturePicture();
                    return;
                }
                Camera1.this.mIsCapturingImage = true;
                Camera1.this.mCamera.setOneShotPreviewCallback(new Camera.PreviewCallback(){

                    public void onPreviewFrame(final byte[] arrby, Camera object) {
                        object = Camera1.this.mCameraCallbacks;
                        int n = 1;
                        object.onShutter(true);
                        final int n2 = Camera1.this.computeSensorToOutputOffset();
                        boolean bl = (Camera1.this.computeSensorToViewOffset() + n2 + 180) % 180 == 0;
                        boolean bl2 = Camera1.this.mFacing == Facing.FRONT;
                        if (n2 % 180 == 0) {
                            n = 0;
                        }
                        final int n3 = Camera1.this.mPreviewSize.getWidth();
                        final int n4 = Camera1.this.mPreviewSize.getHeight();
                        int n5 = n != 0 ? n4 : n3;
                        n = n != 0 ? n3 : n4;
                        WorkerHandler.run(new Runnable(Camera1.this.mPreviewFormat, n5, n, bl, bl2){
                            final /* synthetic */ int val$format;
                            final /* synthetic */ boolean val$outputFlip;
                            final /* synthetic */ boolean val$outputMatchesView;
                            final /* synthetic */ int val$postHeight;
                            final /* synthetic */ int val$postWidth;
                            {
                                this.val$format = n42;
                                this.val$postWidth = n5;
                                this.val$postHeight = n6;
                                this.val$outputMatchesView = bl;
                                this.val$outputFlip = bl2;
                            }

                            @Override
                            public void run() {
                                LOG.v("captureSnapshot: rotating.");
                                YuvImage yuvImage = RotationHelper.rotate(arrby, n3, n4, n2);
                                LOG.v("captureSnapshot: rotated.");
                                yuvImage = new YuvImage((byte[])yuvImage, this.val$format, this.val$postWidth, this.val$postHeight, null);
                                Camera1.this.mCameraCallbacks.processSnapshot(yuvImage, this.val$outputMatchesView, this.val$outputFlip);
                                Camera1.this.mIsCapturingImage = false;
                            }
                        });
                        Camera1.this.mCamera.setPreviewCallbackWithBuffer(null);
                        Camera1.this.mCamera.setPreviewCallbackWithBuffer((Camera.PreviewCallback)Camera1.this);
                        Camera1.this.mFrameManager.allocate(ImageFormat.getBitsPerPixel((int)Camera1.this.mPreviewFormat), Camera1.this.mPreviewSize);
                    }

                });
            }

        });
    }

    @Override
    void endVideo() {
        this.schedule(null, false, new Runnable(){

            @Override
            public void run() {
                Camera1.this.endVideoImmediately();
            }
        });
    }

    @Override
    public void onBufferAvailable(byte[] arrby) {
        if (this.isCameraAvailable()) {
            this.mCamera.addCallbackBuffer(arrby);
        }
    }

    public void onError(int n, Camera camera) {
        if (n == 100) {
            LOG.w("Recoverable error inside the onError callback.", "CAMERA_ERROR_SERVER_DIED");
            this.stopImmediately();
            this.start();
            return;
        }
        LOG.e("Error inside the onError callback.", n);
        throw new CameraException(new RuntimeException(CameraLogger.lastMessage));
    }

    public void onPreviewFrame(byte[] object, Camera camera) {
        object = this.mFrameManager.getFrame((byte[])object, System.currentTimeMillis(), this.computeSensorToOutputOffset(), this.mPreviewSize, this.mPreviewFormat);
        this.mCameraCallbacks.dispatchFrame((Frame)object);
    }

    @WorkerThread
    @Override
    void onStart() {
        if (this.isCameraAvailable()) {
            LOG.w("onStart:", "Camera not available. Should not happen.");
            this.onStop();
        }
        if (this.collectCameraId()) {
            this.mCamera = Camera.open((int)this.mCameraId);
            this.mCamera.setErrorCallback((Camera.ErrorCallback)this);
            LOG.i("onStart:", "Applying default parameters.");
            Camera.Parameters parameters = this.mCamera.getParameters();
            this.mExtraProperties = new ExtraProperties(parameters);
            this.mCameraOptions = new CameraOptions(parameters, this.shouldFlipSizes());
            this.applyDefaultFocus(parameters);
            this.mergeFlash(parameters, Flash.DEFAULT);
            this.mergeLocation(parameters, null);
            this.mergeWhiteBalance(parameters, WhiteBalance.DEFAULT);
            this.mergeHdr(parameters, Hdr.DEFAULT);
            this.mergePlaySound(this.mPlaySounds);
            boolean bl = this.mSessionType == SessionType.VIDEO;
            parameters.setRecordingHint(bl);
            this.mCamera.setParameters(parameters);
            this.mCamera.setDisplayOrientation(this.computeSensorToViewOffset());
            if (this.shouldBindToSurface()) {
                this.bindToSurface();
            }
            LOG.i("onStart:", "Ended");
        }
    }

    @WorkerThread
    @Override
    void onStop() {
        Object var1_1;
        LOG.i("onStop:", "About to clean up.");
        this.mHandler.get().removeCallbacks(this.mPostFocusResetRunnable);
        this.mFrameManager.release();
        if (this.mCamera != null) {
            LOG.i("onStop:", "Clean up.", "Ending video.");
            this.endVideoImmediately();
            try {
                LOG.i("onStop:", "Clean up.", "Stopping preview.");
                this.mCamera.setPreviewCallbackWithBuffer(null);
                this.mCamera.stopPreview();
                LOG.i("onStop:", "Clean up.", "Stopped preview.");
                var1_1 = null;
            }
            catch (Exception exception) {
                LOG.w("onStop:", "Clean up.", "Exception while stopping preview.", exception);
            }
            try {
                LOG.i("onStop:", "Clean up.", "Releasing camera.");
                this.mCamera.release();
                LOG.i("onStop:", "Clean up.", "Released camera.");
            }
            catch (Exception exception) {
                LOG.w("onStop:", "Clean up.", "Exception while releasing camera.", exception);
            }
        } else {
            var1_1 = null;
        }
        this.mExtraProperties = null;
        this.mCameraOptions = null;
        this.mCamera = null;
        this.mPreviewSize = null;
        this.mPictureSize = null;
        this.mIsBound = false;
        this.mIsCapturingImage = false;
        this.mIsCapturingVideo = false;
        LOG.w("onStop:", "Clean up.", "Returning.");
        if (var1_1 != null) {
            throw new CameraException(var1_1);
        }
    }

    @Override
    public void onSurfaceAvailable() {
        LOG.i("onSurfaceAvailable:", "Size is", this.mPreview.getSurfaceSize());
        this.schedule(null, false, new Runnable(){

            @Override
            public void run() {
                if (Camera1.this.shouldBindToSurface()) {
                    LOG.i("onSurfaceAvailable:", "Inside handler. About to bind.");
                    try {
                        Camera1.this.bindToSurface();
                        return;
                    }
                    catch (Exception exception) {
                        LOG.e("onSurfaceAvailable:", "Exception while binding camera to preview.", exception);
                        throw new CameraException(exception);
                    }
                }
            }
        });
    }

    @Override
    public void onSurfaceChanged() {
        LOG.i("onSurfaceChanged, size is", this.mPreview.getSurfaceSize());
        this.schedule(null, true, new Runnable(){

            @Override
            public void run() {
                if (!Camera1.this.mIsBound) {
                    return;
                }
                Size size = Camera1.this.computePreviewSize(Camera1.this.sizesFromList(Camera1.this.mCamera.getParameters().getSupportedPreviewSizes()));
                if (size.equals(Camera1.this.mPreviewSize)) {
                    return;
                }
                LOG.i("onSurfaceChanged:", "Computed a new preview size. Going on.");
                Camera1.this.mPreviewSize = size;
                Camera1.this.mCamera.stopPreview();
                Camera1.this.applySizesAndStartPreview("onSurfaceChanged:");
            }
        });
    }

    @Override
    void setAudio(Audio audio) {
        if (this.mAudio != audio) {
            if (this.mIsCapturingVideo) {
                LOG.w("Audio setting was changed while recording. Changes will take place starting from next video");
            }
            this.mAudio = audio;
        }
    }

    @Override
    void setExposureCorrection(final float f, final float[] arrf, final PointF[] arrpointF, final boolean bl) {
        this.schedule(this.mExposureCorrectionTask, true, new Runnable(){

            @Override
            public void run() {
                if (!Camera1.this.mCameraOptions.isExposureCorrectionSupported()) {
                    return;
                }
                float f4 = f;
                float f2 = Camera1.this.mCameraOptions.getExposureCorrectionMaxValue();
                float f3 = Camera1.this.mCameraOptions.getExposureCorrectionMinValue();
                if (f4 >= f3) {
                    f3 = f4;
                    if (f4 > f2) {
                        f3 = f2;
                    }
                }
                Camera1.this.mExposureCorrectionValue = f3;
                Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
                parameters.setExposureCompensation((int)(f3 / parameters.getExposureCompensationStep()));
                Camera1.this.mCamera.setParameters(parameters);
                if (bl) {
                    Camera1.this.mCameraCallbacks.dispatchOnExposureCorrectionChanged(f3, arrf, arrpointF);
                }
            }
        });
    }

    @Override
    void setFacing(Facing facing) {
        if (facing != this.mFacing) {
            this.mFacing = facing;
            this.schedule(null, true, new Runnable(){

                @Override
                public void run() {
                    if (Camera1.this.collectCameraId()) {
                        Camera1.this.restart();
                    }
                }
            });
        }
    }

    @Override
    void setFlash(Flash flash) {
        final Flash flash2 = this.mFlash;
        this.mFlash = flash;
        this.schedule(this.mFlashTask, true, new Runnable(){

            @Override
            public void run() {
                Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
                if (Camera1.this.mergeFlash(parameters, flash2)) {
                    Camera1.this.mCamera.setParameters(parameters);
                }
            }
        });
    }

    @Override
    void setHdr(Hdr hdr) {
        final Hdr hdr2 = this.mHdr;
        this.mHdr = hdr;
        this.schedule(this.mHdrTask, true, new Runnable(){

            @Override
            public void run() {
                Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
                if (Camera1.this.mergeHdr(parameters, hdr2)) {
                    Camera1.this.mCamera.setParameters(parameters);
                }
            }
        });
    }

    @Override
    void setLocation(Location location) {
        final Location location2 = this.mLocation;
        this.mLocation = location;
        this.schedule(this.mLocationTask, true, new Runnable(){

            @Override
            public void run() {
                Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
                if (Camera1.this.mergeLocation(parameters, location2)) {
                    Camera1.this.mCamera.setParameters(parameters);
                }
            }
        });
    }

    @Override
    void setPlaySounds(boolean bl) {
        final boolean bl2 = this.mPlaySounds;
        this.mPlaySounds = bl;
        this.schedule(this.mPlaySoundsTask, true, new Runnable(){

            @Override
            public void run() {
                Camera1.this.mergePlaySound(bl2);
            }
        });
    }

    @Override
    void setSessionType(SessionType sessionType) {
        if (sessionType != this.mSessionType) {
            this.mSessionType = sessionType;
            this.schedule(null, true, new Runnable(){

                @Override
                public void run() {
                    Camera1.this.restart();
                }
            });
        }
    }

    @Override
    void setVideoQuality(VideoQuality videoQuality) {
        final VideoQuality videoQuality2 = this.mVideoQuality;
        this.mVideoQuality = videoQuality;
        this.schedule(this.mVideoQualityTask, true, new Runnable(){

            @Override
            public void run() {
                if (Camera1.this.mIsCapturingVideo) {
                    Camera1.this.mVideoQuality = videoQuality2;
                    throw new IllegalStateException("Can't change video quality while recording a video.");
                }
                if (Camera1.this.mSessionType == SessionType.VIDEO) {
                    Size size = Camera1.this.mPictureSize;
                    Camera1.this.mPictureSize = Camera1.this.computePictureSize();
                    if (!Camera1.this.mPictureSize.equals(size)) {
                        size = Camera1.this.mCamera.getParameters();
                        size.setPictureSize(Camera1.this.mPictureSize.getWidth(), Camera1.this.mPictureSize.getHeight());
                        Camera1.this.mCamera.setParameters((Camera.Parameters)size);
                        Camera1.this.onSurfaceChanged();
                    }
                    LOG.i("setVideoQuality:", "captureSize:", Camera1.this.mPictureSize);
                    LOG.i("setVideoQuality:", "previewSize:", Camera1.this.mPreviewSize);
                }
            }
        });
    }

    @Override
    void setWhiteBalance(WhiteBalance whiteBalance) {
        final WhiteBalance whiteBalance2 = this.mWhiteBalance;
        this.mWhiteBalance = whiteBalance;
        this.schedule(this.mWhiteBalanceTask, true, new Runnable(){

            @Override
            public void run() {
                Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
                if (Camera1.this.mergeWhiteBalance(parameters, whiteBalance2)) {
                    Camera1.this.mCamera.setParameters(parameters);
                }
            }
        });
    }

    @Override
    void setZoom(final float f, final PointF[] arrpointF, final boolean bl) {
        this.schedule(this.mZoomTask, true, new Runnable(){

            @Override
            public void run() {
                if (!Camera1.this.mCameraOptions.isZoomSupported()) {
                    return;
                }
                Camera1.this.mZoomValue = f;
                Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
                float f2 = parameters.getMaxZoom();
                parameters.setZoom((int)(f * f2));
                Camera1.this.mCamera.setParameters(parameters);
                if (bl) {
                    Camera1.this.mCameraCallbacks.dispatchOnZoomChanged(f, arrpointF);
                }
            }
        });
    }

    @Override
    void startAutoFocus(final @Nullable Gesture gesture, final PointF pointF) {
        int n;
        int n2;
        if (this.mPreview != null && this.mPreview.isReady()) {
            n = this.mPreview.getView().getWidth();
            n2 = this.mPreview.getView().getHeight();
        } else {
            n = 0;
            n2 = 0;
        }
        this.schedule(null, true, new Runnable(){

            @Override
            public void run() {
                if (!Camera1.this.mCameraOptions.isAutoFocusSupported()) {
                    return;
                }
                final PointF pointF2 = new PointF(pointF.x, pointF.y);
                List list = Camera1.computeMeteringAreas(pointF2.x, pointF2.y, n, n2, Camera1.this.computeSensorToViewOffset());
                List list2 = list.subList(0, 1);
                Camera.Parameters parameters = Camera1.this.mCamera.getParameters();
                int n3 = parameters.getMaxNumFocusAreas();
                int n22 = parameters.getMaxNumMeteringAreas();
                if (n3 > 0) {
                    List list3 = n3 > 1 ? list : list2;
                    parameters.setFocusAreas(list3);
                }
                if (n22 > 0) {
                    if (n22 <= 1) {
                        list = list2;
                    }
                    parameters.setMeteringAreas(list);
                }
                parameters.setFocusMode("auto");
                Camera1.this.mCamera.setParameters(parameters);
                Camera1.this.mCameraCallbacks.dispatchOnFocusStart(gesture, pointF2);
                Camera1.this.mCamera.autoFocus(new Camera.AutoFocusCallback(){

                    public void onAutoFocus(boolean bl, Camera camera) {
                        Camera1.this.mCameraCallbacks.dispatchOnFocusEnd(gesture, bl, pointF2);
                        Camera1.this.mHandler.get().removeCallbacks(Camera1.this.mPostFocusResetRunnable);
                        Camera1.this.mHandler.get().postDelayed(Camera1.this.mPostFocusResetRunnable, 3000L);
                    }
                });
            }

        });
    }

    @Override
    void startVideo(final @NonNull File file) {
        this.schedule(this.mStartVideoTask, true, new Runnable(){

            @Override
            public void run() {
                if (Camera1.this.mIsCapturingVideo) {
                    return;
                }
                if (Camera1.this.mSessionType == SessionType.VIDEO) {
                    Camera1.this.mVideoFile = file;
                    Camera1.this.mIsCapturingVideo = true;
                    Camera1.this.initMediaRecorder();
                    try {
                        Camera1.this.mMediaRecorder.prepare();
                        Camera1.this.mMediaRecorder.start();
                        return;
                    }
                    catch (Exception exception) {
                        LOG.e("Error while starting MediaRecorder. Swallowing.", exception);
                        Camera1.this.mVideoFile = null;
                        Camera1.this.mCamera.lock();
                        Camera1.this.endVideoImmediately();
                        return;
                    }
                }
                throw new IllegalStateException("Can't record video while session type is picture");
            }
        });
    }

}

