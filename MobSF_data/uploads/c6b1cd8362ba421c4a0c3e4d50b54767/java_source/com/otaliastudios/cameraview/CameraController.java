/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.graphics.PointF
 *  android.location.Location
 *  android.media.CamcorderProfile
 *  android.media.MediaRecorder
 *  android.os.Build
 *  android.os.Build$VERSION
 *  android.os.Handler
 *  android.os.Looper
 */
package com.otaliastudios.cameraview;

import android.graphics.PointF;
import android.location.Location;
import android.media.CamcorderProfile;
import android.media.MediaRecorder;
import android.os.Build;
import android.os.Handler;
import android.os.Looper;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.WorkerThread;
import com.otaliastudios.cameraview.AspectRatio;
import com.otaliastudios.cameraview.Audio;
import com.otaliastudios.cameraview.CameraException;
import com.otaliastudios.cameraview.CameraLogger;
import com.otaliastudios.cameraview.CameraOptions;
import com.otaliastudios.cameraview.CameraPreview;
import com.otaliastudios.cameraview.CameraView;
import com.otaliastudios.cameraview.ExtraProperties;
import com.otaliastudios.cameraview.Facing;
import com.otaliastudios.cameraview.Flash;
import com.otaliastudios.cameraview.FrameManager;
import com.otaliastudios.cameraview.Gesture;
import com.otaliastudios.cameraview.Hdr;
import com.otaliastudios.cameraview.Mapper;
import com.otaliastudios.cameraview.SessionType;
import com.otaliastudios.cameraview.Size;
import com.otaliastudios.cameraview.SizeSelector;
import com.otaliastudios.cameraview.SizeSelectors;
import com.otaliastudios.cameraview.Task;
import com.otaliastudios.cameraview.VideoCodec;
import com.otaliastudios.cameraview.VideoQuality;
import com.otaliastudios.cameraview.WhiteBalance;
import com.otaliastudios.cameraview.WorkerHandler;
import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

abstract class CameraController
implements CameraPreview.SurfaceCallback,
FrameManager.BufferCallback,
Thread.UncaughtExceptionHandler {
    private static final CameraLogger LOG = CameraLogger.create(TAG);
    static final int STATE_STARTED = 2;
    static final int STATE_STARTING = 1;
    static final int STATE_STOPPED = 0;
    static final int STATE_STOPPING = -1;
    private static final String TAG = "CameraController";
    protected Audio mAudio;
    protected final CameraView.CameraCallbacks mCameraCallbacks;
    protected int mCameraId;
    protected CameraOptions mCameraOptions;
    Handler mCrashHandler;
    private int mDeviceOrientation;
    private int mDisplayOffset;
    Task<Void> mExposureCorrectionTask = new Task();
    protected float mExposureCorrectionValue;
    protected ExtraProperties mExtraProperties;
    protected Facing mFacing;
    protected Flash mFlash;
    Task<Void> mFlashTask = new Task();
    protected FrameManager mFrameManager;
    protected WorkerHandler mHandler;
    protected Hdr mHdr;
    Task<Void> mHdrTask = new Task();
    protected boolean mIsCapturingImage = false;
    protected boolean mIsCapturingVideo = false;
    protected Location mLocation;
    Task<Void> mLocationTask = new Task();
    protected Mapper mMapper;
    protected MediaRecorder mMediaRecorder;
    protected Size mPictureSize;
    protected SizeSelector mPictureSizeSelector;
    protected boolean mPlaySounds;
    Task<Void> mPlaySoundsTask = new Task();
    protected CameraPreview mPreview;
    protected int mPreviewFormat;
    protected Size mPreviewSize;
    protected int mSensorOffset;
    protected SessionType mSessionType;
    Task<Void> mStartVideoTask = new Task();
    protected int mState = 0;
    protected VideoCodec mVideoCodec;
    protected File mVideoFile;
    protected int mVideoMaxDuration;
    protected long mVideoMaxSize;
    protected VideoQuality mVideoQuality;
    Task<Void> mVideoQualityTask = new Task();
    protected WhiteBalance mWhiteBalance;
    Task<Void> mWhiteBalanceTask = new Task();
    Task<Void> mZoomTask = new Task();
    protected float mZoomValue;

    CameraController(CameraView.CameraCallbacks cameraCallbacks) {
        this.mCameraCallbacks = cameraCallbacks;
        this.mCrashHandler = new Handler(Looper.getMainLooper());
        this.mHandler = WorkerHandler.get("CameraViewController");
        this.mHandler.getThread().setUncaughtExceptionHandler(this);
        this.mFrameManager = new FrameManager(2, this);
    }

    private String ss() {
        switch (this.mState) {
            default: {
                return "null";
            }
            case 2: {
                return "STATE_STARTED";
            }
            case 1: {
                return "STATE_STARTING";
            }
            case 0: {
                return "STATE_STOPPED";
            }
            case -1: 
        }
        return "STATE_STOPPING";
    }

    abstract void capturePicture();

    abstract void captureSnapshot();

    protected final Size computePictureSize() {
        Comparable<AspectRatio> comparable;
        Object object;
        boolean bl = this.shouldFlipSizes();
        if (this.mSessionType == SessionType.PICTURE) {
            object = SizeSelectors.or(this.mPictureSizeSelector, SizeSelectors.biggest());
        } else {
            object = this.getCamcorderProfile();
            comparable = AspectRatio.of(object.videoFrameWidth, object.videoFrameHeight);
            object = comparable;
            if (bl) {
                object = comparable.inverse();
            }
            LOG.i("size:", "computeCaptureSize:", "videoQuality:", this.mVideoQuality, "targetRatio:", object);
            object = SizeSelectors.aspectRatio((AspectRatio)object, 0.0f);
            object = SizeSelectors.or(SizeSelectors.and(new SizeSelector[]{object, this.mPictureSizeSelector}), SizeSelectors.and(new SizeSelector[]{object}), this.mPictureSizeSelector);
        }
        comparable = object.select(new ArrayList<Size>(this.mCameraOptions.getSupportedPictureSizes())).get(0);
        LOG.i("computePictureSize:", "result:", comparable, "flip:", bl);
        object = comparable;
        if (bl) {
            object = comparable.flip();
        }
        return object;
    }

    protected final Size computePreviewSize(List<Size> object) {
        boolean bl = this.shouldFlipSizes();
        AspectRatio aspectRatio = AspectRatio.of(this.mPictureSize.getWidth(), this.mPictureSize.getHeight());
        Object object2 = this.mPreview.getSurfaceSize();
        Size size = object2;
        if (bl) {
            size = object2.flip();
        }
        LOG.i("size:", "computePreviewSize:", "targetRatio:", aspectRatio, "targetMinSize:", size);
        object2 = SizeSelectors.aspectRatio(aspectRatio, 0.0f);
        object = SizeSelectors.or(SizeSelectors.and(new SizeSelector[]{object2, SizeSelectors.and(SizeSelectors.minHeight(size.getHeight()), SizeSelectors.minWidth(size.getWidth()))}), SizeSelectors.and(new SizeSelector[]{object2, SizeSelectors.biggest()}), SizeSelectors.biggest()).select((List<Size>)object).get(0);
        LOG.i("computePreviewSize:", "result:", object, "flip:", bl);
        return object;
    }

    protected final int computeSensorToOutputOffset() {
        if (this.mFacing == Facing.FRONT) {
            return (this.mSensorOffset - this.mDeviceOrientation + 360) % 360;
        }
        return (this.mSensorOffset + this.mDeviceOrientation) % 360;
    }

    protected final int computeSensorToViewOffset() {
        if (this.mFacing == Facing.FRONT) {
            return (360 - (this.mSensorOffset + this.mDisplayOffset) % 360) % 360;
        }
        return (this.mSensorOffset - this.mDisplayOffset + 360) % 360;
    }

    final void destroy() {
        LOG.i("destroy:", "state:", this.ss());
        this.mHandler.getThread().setUncaughtExceptionHandler(new NoOpExceptionHandler());
        this.stopImmediately();
    }

    abstract void endVideo();

    final Audio getAudio() {
        return this.mAudio;
    }

    @NonNull
    protected final CamcorderProfile getCamcorderProfile() {
        switch (.$SwitchMap$com$otaliastudios$cameraview$VideoQuality[this.mVideoQuality.ordinal()]) {
            default: {
                break;
            }
            case 2: {
                if (Build.VERSION.SDK_INT >= 21 && CamcorderProfile.hasProfile((int)8)) {
                    return CamcorderProfile.get((int)this.mCameraId, (int)8);
                }
            }
            case 3: {
                if (CamcorderProfile.hasProfile((int)this.mCameraId, (int)6)) {
                    return CamcorderProfile.get((int)this.mCameraId, (int)6);
                }
            }
            case 4: {
                if (CamcorderProfile.hasProfile((int)this.mCameraId, (int)5)) {
                    return CamcorderProfile.get((int)this.mCameraId, (int)5);
                }
            }
            case 5: {
                if (CamcorderProfile.hasProfile((int)this.mCameraId, (int)4)) {
                    return CamcorderProfile.get((int)this.mCameraId, (int)4);
                }
            }
            case 6: {
                if (!CamcorderProfile.hasProfile((int)this.mCameraId, (int)7)) break;
                return CamcorderProfile.get((int)this.mCameraId, (int)7);
            }
            case 1: {
                return CamcorderProfile.get((int)this.mCameraId, (int)1);
            }
        }
        return CamcorderProfile.get((int)this.mCameraId, (int)0);
    }

    @Nullable
    final CameraOptions getCameraOptions() {
        return this.mCameraOptions;
    }

    final float getExposureCorrectionValue() {
        return this.mExposureCorrectionValue;
    }

    @Nullable
    final ExtraProperties getExtraProperties() {
        return this.mExtraProperties;
    }

    final Facing getFacing() {
        return this.mFacing;
    }

    final Flash getFlash() {
        return this.mFlash;
    }

    final Hdr getHdr() {
        return this.mHdr;
    }

    final Location getLocation() {
        return this.mLocation;
    }

    final Size getPictureSize() {
        return this.mPictureSize;
    }

    final SizeSelector getPictureSizeSelector() {
        return this.mPictureSizeSelector;
    }

    final Size getPreviewSize() {
        return this.mPreviewSize;
    }

    final SessionType getSessionType() {
        return this.mSessionType;
    }

    final int getState() {
        return this.mState;
    }

    final VideoCodec getVideoCodec() {
        return this.mVideoCodec;
    }

    final int getVideoMaxDuration() {
        return this.mVideoMaxDuration;
    }

    final long getVideoMaxSize() {
        return this.mVideoMaxSize;
    }

    final VideoQuality getVideoQuality() {
        return this.mVideoQuality;
    }

    final WhiteBalance getWhiteBalance() {
        return this.mWhiteBalance;
    }

    final float getZoomValue() {
        return this.mZoomValue;
    }

    final boolean isCapturingVideo() {
        return this.mIsCapturingVideo;
    }

    @WorkerThread
    abstract void onStart();

    @WorkerThread
    abstract void onStop();

    protected final void restart() {
        LOG.i("Restart:", "posting runnable");
        this.mHandler.post(new Runnable(){

            @Override
            public void run() {
                CameraLogger cameraLogger = LOG;
                boolean bl = CameraController.this.mState > 0;
                cameraLogger.i("Restart:", "executing. Needs stopping:", bl, CameraController.this.ss());
                if (CameraController.this.mState > 0) {
                    CameraController.this.mState = -1;
                    CameraController.this.onStop();
                    CameraController.this.mState = 0;
                    LOG.i("Restart:", "stopped. Dispatching.", CameraController.this.ss());
                    CameraController.this.mCameraCallbacks.dispatchOnCameraClosed();
                }
                LOG.i("Restart: about to start. State:", CameraController.this.ss());
                CameraController.this.mState = 1;
                CameraController.this.onStart();
                CameraController.this.mState = 2;
                LOG.i("Restart: returned from start. Dispatching. State:", CameraController.this.ss());
                CameraController.this.mCameraCallbacks.dispatchOnCameraOpened(CameraController.this.mCameraOptions);
            }
        });
    }

    abstract void setAudio(Audio var1);

    final void setDeviceOrientation(int n) {
        this.mDeviceOrientation = n;
    }

    final void setDisplayOffset(int n) {
        this.mDisplayOffset = n;
    }

    abstract void setExposureCorrection(float var1, float[] var2, PointF[] var3, boolean var4);

    abstract void setFacing(Facing var1);

    abstract void setFlash(Flash var1);

    abstract void setHdr(Hdr var1);

    abstract void setLocation(Location var1);

    final void setPictureSizeSelector(SizeSelector sizeSelector) {
        this.mPictureSizeSelector = sizeSelector;
    }

    abstract void setPlaySounds(boolean var1);

    void setPreview(CameraPreview cameraPreview) {
        this.mPreview = cameraPreview;
        this.mPreview.setSurfaceCallback(this);
    }

    abstract void setSessionType(SessionType var1);

    final void setVideoCodec(VideoCodec videoCodec) {
        this.mVideoCodec = videoCodec;
    }

    final void setVideoMaxDuration(int n) {
        this.mVideoMaxDuration = n;
    }

    final void setVideoMaxSize(long l) {
        this.mVideoMaxSize = l;
    }

    abstract void setVideoQuality(VideoQuality var1);

    abstract void setWhiteBalance(WhiteBalance var1);

    abstract void setZoom(float var1, PointF[] var2, boolean var3);

    final boolean shouldFlipSizes() {
        int n = this.computeSensorToViewOffset();
        CameraLogger cameraLogger = LOG;
        boolean bl = false;
        cameraLogger.i("shouldFlipSizes:", "displayOffset=", this.mDisplayOffset, "sensorOffset=", this.mSensorOffset);
        LOG.i("shouldFlipSizes:", "sensorToDisplay=", n);
        if (n % 180 != 0) {
            bl = true;
        }
        return bl;
    }

    final void start() {
        LOG.i("Start:", "posting runnable. State:", this.ss());
        this.mHandler.post(new Runnable(){

            @Override
            public void run() {
                LOG.i("Start:", "executing. State:", CameraController.this.ss());
                if (CameraController.this.mState >= 1) {
                    return;
                }
                CameraController.this.mState = 1;
                LOG.i("Start:", "about to call onStart()", CameraController.this.ss());
                CameraController.this.onStart();
                LOG.i("Start:", "returned from onStart().", "Dispatching.", CameraController.this.ss());
                CameraController.this.mState = 2;
                CameraController.this.mCameraCallbacks.dispatchOnCameraOpened(CameraController.this.mCameraOptions);
            }
        });
    }

    abstract void startAutoFocus(@Nullable Gesture var1, PointF var2);

    abstract void startVideo(@NonNull File var1);

    final void stop() {
        LOG.i("Stop:", "posting runnable. State:", this.ss());
        this.mHandler.post(new Runnable(){

            @Override
            public void run() {
                LOG.i("Stop:", "executing. State:", CameraController.this.ss());
                if (CameraController.this.mState <= 0) {
                    return;
                }
                CameraController.this.mState = -1;
                LOG.i("Stop:", "about to call onStop()");
                CameraController.this.onStop();
                LOG.i("Stop:", "returned from onStop().", "Dispatching.");
                CameraController.this.mState = 0;
                CameraController.this.mCameraCallbacks.dispatchOnCameraClosed();
            }
        });
    }

    final void stopImmediately() {
        try {
            LOG.i("stopImmediately:", "State was:", this.ss());
            if (this.mState == 0) {
                return;
            }
            this.mState = -1;
            this.onStop();
            this.mState = 0;
            LOG.i("stopImmediately:", "Stopped. State is:", this.ss());
            return;
        }
        catch (Exception exception) {
            LOG.i("stopImmediately:", "Swallowing exception while stopping.", exception);
            this.mState = 0;
            return;
        }
    }

    @Override
    public void uncaughtException(Thread thread, final Throwable throwable) {
        if (!(throwable instanceof CameraException)) {
            LOG.e("uncaughtException:", "Unexpected exception:", throwable);
            this.destroy();
            this.mCrashHandler.post(new Runnable(){

                @Override
                public void run() {
                    RuntimeException runtimeException = throwable instanceof RuntimeException ? (RuntimeException)throwable : new RuntimeException(throwable);
                    throw runtimeException;
                }
            });
            return;
        }
        throwable = (CameraException)throwable;
        LOG.e("uncaughtException:", "Interrupting thread with state:", this.ss(), "due to CameraException:", throwable);
        thread.interrupt();
        this.mHandler = WorkerHandler.get("CameraViewController");
        this.mHandler.getThread().setUncaughtExceptionHandler(this);
        LOG.i("uncaughtException:", "Calling stopImmediately and notifying.");
        this.mHandler.post(new Runnable((CameraException)throwable){
            final /* synthetic */ CameraException val$error;
            {
                this.val$error = cameraException;
            }

            @Override
            public void run() {
                CameraController.this.stopImmediately();
                CameraController.this.mCameraCallbacks.dispatchError(this.val$error);
            }
        });
    }

    private static class NoOpExceptionHandler
    implements Thread.UncaughtExceptionHandler {
        private NoOpExceptionHandler() {
        }

        @Override
        public void uncaughtException(Thread thread, Throwable throwable) {
        }
    }

}

