/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  javax.annotation.Nullable
 *  okhttp3.Call
 *  retrofit2.BuiltInConverters
 *  retrofit2.BuiltInConverters$ToStringConverter
 *  retrofit2.CallAdapter
 *  retrofit2.Converter
 *  retrofit2.ServiceMethod$Builder
 */
package retrofit2;

import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import javax.annotation.Nullable;
import okhttp3.Call;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import retrofit2.BuiltInConverters;
import retrofit2.Call;
import retrofit2.CallAdapter;
import retrofit2.Converter;
import retrofit2.OkHttpCall;
import retrofit2.Platform;
import retrofit2.ServiceMethod;
import retrofit2.Utils;

public final class Retrofit {
    final HttpUrl baseUrl;
    final List<CallAdapter.Factory> callAdapterFactories;
    final Call.Factory callFactory;
    @Nullable
    final Executor callbackExecutor;
    final List<Converter.Factory> converterFactories;
    private final Map<Method, ServiceMethod<?, ?>> serviceMethodCache = new ConcurrentHashMap();
    final boolean validateEagerly;

    Retrofit(Call.Factory factory, HttpUrl httpUrl, List<Converter.Factory> list, List<CallAdapter.Factory> list2, @Nullable Executor executor, boolean bl) {
        this.callFactory = factory;
        this.baseUrl = httpUrl;
        this.converterFactories = list;
        this.callAdapterFactories = list2;
        this.callbackExecutor = executor;
        this.validateEagerly = bl;
    }

    private void eagerlyValidateMethods(Class<?> arrmethod) {
        Platform platform = Platform.get();
        for (Method method : arrmethod.getDeclaredMethods()) {
            if (platform.isDefaultMethod(method)) continue;
            this.loadServiceMethod(method);
        }
    }

    public HttpUrl baseUrl() {
        return this.baseUrl;
    }

    public CallAdapter<?, ?> callAdapter(Type type, Annotation[] arrannotation) {
        return this.nextCallAdapter(null, type, arrannotation);
    }

    public List<CallAdapter.Factory> callAdapterFactories() {
        return this.callAdapterFactories;
    }

    public Call.Factory callFactory() {
        return this.callFactory;
    }

    @Nullable
    public Executor callbackExecutor() {
        return this.callbackExecutor;
    }

    public List<Converter.Factory> converterFactories() {
        return this.converterFactories;
    }

    public <T> T create(final Class<T> class_) {
        Utils.validateServiceInterface(class_);
        if (this.validateEagerly) {
            this.eagerlyValidateMethods(class_);
        }
        ClassLoader classLoader = class_.getClassLoader();
        InvocationHandler invocationHandler = new InvocationHandler(){
            private final Platform platform = Platform.get();

            @Override
            public Object invoke(Object serviceMethod, Method method, @Nullable Object[] arrobject) throws Throwable {
                if (method.getDeclaringClass() == Object.class) {
                    return method.invoke(this, arrobject);
                }
                if (this.platform.isDefaultMethod(method)) {
                    return this.platform.invokeDefaultMethod(method, class_, serviceMethod, arrobject);
                }
                serviceMethod = Retrofit.this.loadServiceMethod(method);
                return serviceMethod.adapt(new OkHttpCall(serviceMethod, arrobject));
            }
        };
        return (T)Proxy.newProxyInstance(classLoader, new Class[]{class_}, invocationHandler);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    ServiceMethod<?, ?> loadServiceMethod(Method method) {
        ServiceMethod serviceMethod = this.serviceMethodCache.get(method);
        if (serviceMethod != null) {
            return serviceMethod;
        }
        Map<Method, ServiceMethod<?, ?>> map = this.serviceMethodCache;
        synchronized (map) {
            ServiceMethod<?, ?> serviceMethod2 = this.serviceMethodCache.get(method);
            serviceMethod = serviceMethod2;
            if (serviceMethod2 == null) {
                serviceMethod = new /* Unavailable Anonymous Inner Class!! */.build();
                this.serviceMethodCache.put(method, serviceMethod);
            }
            return serviceMethod;
        }
    }

    public Builder newBuilder() {
        return new Builder(this);
    }

    public CallAdapter<?, ?> nextCallAdapter(@Nullable CallAdapter.Factory factory, Type type, Annotation[] object) {
        int n;
        Utils.checkNotNull(type, "returnType == null");
        Utils.checkNotNull(object, "annotations == null");
        int n2 = this.callAdapterFactories.indexOf(factory) + 1;
        int n3 = this.callAdapterFactories.size();
        for (n = n2; n < n3; ++n) {
            CallAdapter<?, ?> callAdapter = this.callAdapterFactories.get(n).get(type, (Annotation[])object, this);
            if (callAdapter == null) continue;
            return callAdapter;
        }
        object = new StringBuilder("Could not locate call adapter for ");
        object.append(type);
        object.append(".\n");
        if (factory != null) {
            object.append("  Skipped:");
            for (n = 0; n < n2; ++n) {
                object.append("\n   * ");
                object.append(this.callAdapterFactories.get(n).getClass().getName());
            }
            object.append('\n');
        }
        object.append("  Tried:");
        n = this.callAdapterFactories.size();
        while (n2 < n) {
            object.append("\n   * ");
            object.append(this.callAdapterFactories.get(n2).getClass().getName());
            ++n2;
        }
        throw new IllegalArgumentException(object.toString());
    }

    public <T> Converter<T, RequestBody> nextRequestBodyConverter(@Nullable Converter.Factory factory, Type type, Annotation[] object, Annotation[] arrannotation) {
        int n;
        Utils.checkNotNull(type, "type == null");
        Utils.checkNotNull(object, "parameterAnnotations == null");
        Utils.checkNotNull(arrannotation, "methodAnnotations == null");
        int n2 = this.converterFactories.indexOf(factory) + 1;
        int n3 = this.converterFactories.size();
        for (n = n2; n < n3; ++n) {
            Converter<?, RequestBody> converter = this.converterFactories.get(n).requestBodyConverter(type, (Annotation[])object, arrannotation, this);
            if (converter == null) continue;
            return converter;
        }
        object = new StringBuilder("Could not locate RequestBody converter for ");
        object.append(type);
        object.append(".\n");
        if (factory != null) {
            object.append("  Skipped:");
            for (n = 0; n < n2; ++n) {
                object.append("\n   * ");
                object.append(this.converterFactories.get(n).getClass().getName());
            }
            object.append('\n');
        }
        object.append("  Tried:");
        n = this.converterFactories.size();
        while (n2 < n) {
            object.append("\n   * ");
            object.append(this.converterFactories.get(n2).getClass().getName());
            ++n2;
        }
        throw new IllegalArgumentException(object.toString());
    }

    public <T> Converter<ResponseBody, T> nextResponseBodyConverter(@Nullable Converter.Factory factory, Type type, Annotation[] object) {
        int n;
        Utils.checkNotNull(type, "type == null");
        Utils.checkNotNull(object, "annotations == null");
        int n2 = this.converterFactories.indexOf(factory) + 1;
        int n3 = this.converterFactories.size();
        for (n = n2; n < n3; ++n) {
            Converter<ResponseBody, ?> converter = this.converterFactories.get(n).responseBodyConverter(type, (Annotation[])object, this);
            if (converter == null) continue;
            return converter;
        }
        object = new StringBuilder("Could not locate ResponseBody converter for ");
        object.append(type);
        object.append(".\n");
        if (factory != null) {
            object.append("  Skipped:");
            for (n = 0; n < n2; ++n) {
                object.append("\n   * ");
                object.append(this.converterFactories.get(n).getClass().getName());
            }
            object.append('\n');
        }
        object.append("  Tried:");
        n = this.converterFactories.size();
        while (n2 < n) {
            object.append("\n   * ");
            object.append(this.converterFactories.get(n2).getClass().getName());
            ++n2;
        }
        throw new IllegalArgumentException(object.toString());
    }

    public <T> Converter<T, RequestBody> requestBodyConverter(Type type, Annotation[] arrannotation, Annotation[] arrannotation2) {
        return this.nextRequestBodyConverter(null, type, arrannotation, arrannotation2);
    }

    public <T> Converter<ResponseBody, T> responseBodyConverter(Type type, Annotation[] arrannotation) {
        return this.nextResponseBodyConverter(null, type, arrannotation);
    }

    public <T> Converter<T, String> stringConverter(Type type, Annotation[] arrannotation) {
        Utils.checkNotNull(type, "type == null");
        Utils.checkNotNull(arrannotation, "annotations == null");
        int n = this.converterFactories.size();
        for (int i = 0; i < n; ++i) {
            Converter<?, String> converter = this.converterFactories.get(i).stringConverter(type, arrannotation, this);
            if (converter == null) continue;
            return converter;
        }
        return BuiltInConverters.ToStringConverter.INSTANCE;
    }

    public static final class Builder {
        private HttpUrl baseUrl;
        private final List<CallAdapter.Factory> callAdapterFactories = new ArrayList<CallAdapter.Factory>();
        @Nullable
        private Call.Factory callFactory;
        @Nullable
        private Executor callbackExecutor;
        private final List<Converter.Factory> converterFactories = new ArrayList<Converter.Factory>();
        private final Platform platform;
        private boolean validateEagerly;

        public Builder() {
            this(Platform.get());
        }

        Builder(Platform platform) {
            this.platform = platform;
        }

        Builder(Retrofit retrofit) {
            this.platform = Platform.get();
            this.callFactory = retrofit.callFactory;
            this.baseUrl = retrofit.baseUrl;
            this.converterFactories.addAll(retrofit.converterFactories);
            this.converterFactories.remove(0);
            this.callAdapterFactories.addAll(retrofit.callAdapterFactories);
            this.callAdapterFactories.remove(this.callAdapterFactories.size() - 1);
            this.callbackExecutor = retrofit.callbackExecutor;
            this.validateEagerly = retrofit.validateEagerly;
        }

        public Builder addCallAdapterFactory(CallAdapter.Factory factory) {
            this.callAdapterFactories.add(Utils.checkNotNull(factory, "factory == null"));
            return this;
        }

        public Builder addConverterFactory(Converter.Factory factory) {
            this.converterFactories.add(Utils.checkNotNull(factory, "factory == null"));
            return this;
        }

        public Builder baseUrl(String string2) {
            Utils.checkNotNull(string2, "baseUrl == null");
            Object object = HttpUrl.parse(string2);
            if (object == null) {
                object = new StringBuilder();
                object.append("Illegal URL: ");
                object.append(string2);
                throw new IllegalArgumentException(object.toString());
            }
            return this.baseUrl((HttpUrl)object);
        }

        public Builder baseUrl(HttpUrl httpUrl) {
            Utils.checkNotNull(httpUrl, "baseUrl == null");
            Object object = httpUrl.pathSegments();
            if (!"".equals(object.get(object.size() - 1))) {
                object = new StringBuilder();
                object.append("baseUrl must end in /: ");
                object.append(httpUrl);
                throw new IllegalArgumentException(object.toString());
            }
            this.baseUrl = httpUrl;
            return this;
        }

        public Retrofit build() {
            Object object;
            if (this.baseUrl == null) {
                throw new IllegalStateException("Base URL required.");
            }
            Object object2 = this.callFactory;
            Call.Factory factory = object2;
            if (object2 == null) {
                factory = new OkHttpClient();
            }
            object2 = object = this.callbackExecutor;
            if (object == null) {
                object2 = this.platform.defaultCallbackExecutor();
            }
            object = new ArrayList<CallAdapter.Factory>(this.callAdapterFactories);
            object.add(this.platform.defaultCallAdapterFactory((Executor)object2));
            ArrayList<Object> arrayList = new ArrayList<Object>(this.converterFactories.size() + 1);
            arrayList.add((Object)new BuiltInConverters());
            arrayList.addAll(this.converterFactories);
            return new Retrofit(factory, this.baseUrl, Collections.unmodifiableList(arrayList), Collections.unmodifiableList(object), (Executor)object2, this.validateEagerly);
        }

        public List<CallAdapter.Factory> callAdapterFactories() {
            return this.callAdapterFactories;
        }

        public Builder callFactory(Call.Factory factory) {
            this.callFactory = Utils.checkNotNull(factory, "factory == null");
            return this;
        }

        public Builder callbackExecutor(Executor executor) {
            this.callbackExecutor = Utils.checkNotNull(executor, "executor == null");
            return this;
        }

        public Builder client(OkHttpClient okHttpClient) {
            return this.callFactory(Utils.checkNotNull(okHttpClient, "client == null"));
        }

        public List<Converter.Factory> converterFactories() {
            return this.converterFactories;
        }

        public Builder validateEagerly(boolean bl) {
            this.validateEagerly = bl;
            return this;
        }
    }

}

