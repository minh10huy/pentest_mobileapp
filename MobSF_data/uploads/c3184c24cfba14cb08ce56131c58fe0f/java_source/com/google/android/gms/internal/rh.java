/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.content.Context
 *  android.database.Cursor
 *  android.database.sqlite.SQLiteDatabase
 *  android.database.sqlite.SQLiteDatabase$CursorFactory
 *  android.database.sqlite.SQLiteException
 *  android.database.sqlite.SQLiteOpenHelper
 *  android.os.Build
 *  android.os.Build$VERSION
 */
package com.google.android.gms.internal;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
import android.database.sqlite.SQLiteOpenHelper;
import android.os.Build;
import com.google.android.gms.internal.rg;
import com.google.android.gms.internal.sg;
import java.io.File;
import java.util.HashSet;
import java.util.Set;

final class rh
extends SQLiteOpenHelper {
    private /* synthetic */ rg a;

    rh(rg rg2, Context context, String string2) {
        this.a = rg2;
        super(context, string2, null, 1);
    }

    private static void a(SQLiteDatabase object) {
        object = rh.b((SQLiteDatabase)object, "properties");
        for (int i2 = 0; i2 < 6; ++i2) {
            String string2 = new String[]{"app_uid", "cid", "tid", "params", "adid", "hits_count"}[i2];
            if (object.remove(string2)) continue;
            object = String.valueOf(string2);
            object = object.length() != 0 ? "Database properties is missing required column: ".concat((String)object) : new String("Database properties is missing required column: ");
            throw new SQLiteException((String)object);
        }
        if (object.isEmpty()) {
            return;
        }
        throw new SQLiteException("Database properties table has extra columns");
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private final boolean a(SQLiteDatabase object, String string2) {
        Object sQLiteDatabase;
        block7 : {
            block8 : {
                boolean bl2;
                Object var6_5 = null;
                sQLiteDatabase = null;
                object = object.query("SQLITE_MASTER", new String[]{"name"}, "name=?", new String[]{string2}, null, null, null);
                try {
                    bl2 = object.moveToFirst();
                    if (object == null) return bl2;
                }
                catch (Throwable throwable) {
                    sQLiteDatabase = object;
                    object = throwable;
                    break block7;
                }
                catch (SQLiteException sQLiteException) {
                    break block8;
                }
                object.close();
                return bl2;
                catch (Throwable throwable) {
                    break block7;
                }
                catch (SQLiteException sQLiteException) {
                    object = var6_5;
                }
            }
            sQLiteDatabase = object;
            {
                void var5_10;
                this.a.c("Error querying for table", string2, var5_10);
                if (object == null) return false;
            }
            object.close();
            return false;
        }
        if (sQLiteDatabase == null) throw object;
        sQLiteDatabase.close();
        throw object;
    }

    private static Set<String> b(SQLiteDatabase sQLiteDatabase, String arrstring) {
        int n2;
        HashSet<String> hashSet = new HashSet<String>();
        StringBuilder stringBuilder = new StringBuilder(String.valueOf(arrstring).length() + 22);
        stringBuilder.append("SELECT * FROM ");
        stringBuilder.append((String)arrstring);
        stringBuilder.append(" LIMIT 0");
        sQLiteDatabase = sQLiteDatabase.rawQuery(stringBuilder.toString(), null);
        try {
            arrstring = sQLiteDatabase.getColumnNames();
            n2 = 0;
        }
        catch (Throwable throwable) {
            sQLiteDatabase.close();
            throw throwable;
        }
        do {
            if (n2 >= arrstring.length) break;
            hashSet.add(arrstring[n2]);
            ++n2;
        } while (true);
        sQLiteDatabase.close();
        return hashSet;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public final SQLiteDatabase getWritableDatabase() {
        if (!rg.a(this.a).a(3600000L)) {
            throw new SQLiteException("Database open failed");
        }
        try {
            return super.getWritableDatabase();
        }
        catch (SQLiteException sQLiteException) {}
        rg.a(this.a).a();
        this.a.f("Opening the database failed, dropping the table and recreating it");
        String string2 = rg.b(this.a);
        this.a.i().getDatabasePath(string2).delete();
        try {
            string2 = super.getWritableDatabase();
            rg.a(this.a).b();
            return string2;
        }
        catch (SQLiteException sQLiteException) {
            this.a.e("Failed to open freshly created database", (Object)sQLiteException);
            throw sQLiteException;
        }
    }

    public final void onCreate(SQLiteDatabase object) {
        object = object.getPath();
        if (sg.a() >= 9) {
            object = new File((String)object);
            object.setReadable(false, false);
            object.setWritable(false, false);
            object.setReadable(true, true);
            object.setWritable(true, true);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public final void onOpen(SQLiteDatabase var1_1) {
        block12 : {
            if (Build.VERSION.SDK_INT < 15) {
                var4_3 = var1_1.rawQuery("PRAGMA journal_mode=memory", null);
                try {
                    var4_3.moveToFirst();
                }
                finally {
                    var4_3.close();
                }
            }
            if (this.a((SQLiteDatabase)var1_1, "hits2")) {
                var4_3 = rh.b((SQLiteDatabase)var1_1, "hits2");
            } else {
                var4_3 = rg.B();
lbl14: // 2 sources:
                do {
                    var1_1.execSQL((String)var4_3);
                    break block12;
                    break;
                } while (true);
            }
            for (var2_4 = 0; var2_4 < 4; ++var2_4) {
                var5_5 = new String[]{"hit_id", "hit_string", "hit_time", "hit_url"}[var2_4];
                if (var4_3.remove(var5_5)) continue;
                var1_1 = String.valueOf(var5_5);
                if (var1_1.length() != 0) {
                    var1_1 = "Database hits2 is missing required column: ".concat((String)var1_1);
                    throw new SQLiteException((String)var1_1);
                }
                var1_1 = new String("Database hits2 is missing required column: ");
                throw new SQLiteException((String)var1_1);
            }
            var3_6 = var4_3.remove("hit_app_id");
            if (var4_3.isEmpty() == false) throw new SQLiteException("Database hits2 has extra columns");
            if (var3_6 ^ true) {
                var4_3 = "ALTER TABLE hits2 ADD COLUMN hit_app_id INTEGER";
                ** continue;
            }
        }
        if (!this.a((SQLiteDatabase)var1_1, "properties")) {
            var1_1.execSQL("CREATE TABLE IF NOT EXISTS properties ( app_uid INTEGER NOT NULL, cid TEXT NOT NULL, tid TEXT NOT NULL, params TEXT NOT NULL, adid INTEGER NOT NULL, hits_count INTEGER NOT NULL, PRIMARY KEY (app_uid, cid, tid)) ;");
            return;
        }
        rh.a((SQLiteDatabase)var1_1);
    }

    public final void onUpgrade(SQLiteDatabase sQLiteDatabase, int n2, int n3) {
    }
}

