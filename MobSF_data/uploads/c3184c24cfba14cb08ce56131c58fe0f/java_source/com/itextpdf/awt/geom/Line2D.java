/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.awt.geom;

import com.itextpdf.awt.geom.AffineTransform;
import com.itextpdf.awt.geom.PathIterator;
import com.itextpdf.awt.geom.Point2D;
import com.itextpdf.awt.geom.Rectangle;
import com.itextpdf.awt.geom.Rectangle2D;
import com.itextpdf.awt.geom.Shape;
import com.itextpdf.awt.geom.misc.Messages;
import java.util.NoSuchElementException;

public abstract class Line2D
implements Shape,
Cloneable {
    protected Line2D() {
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static boolean linesIntersect(double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9) {
        d2 = d8 - d2;
        d3 = (d4 -= d2) * (d7 -= d3) - (d6 -= d2) * (d5 -= d3);
        d8 = d4 * (d9 -= d3) - d2 * d5;
        boolean bl2 = true;
        boolean bl3 = true;
        if (d3 == 0.0 && d8 == 0.0) {
            double d10 = d4 DCMPL 0.0;
            if (d10 != false) {
                boolean bl4 = bl3;
                if (d2 * d6 <= 0.0) return bl4;
                if (d6 * d4 < 0.0) return false;
                if (d10 > 0) {
                    bl4 = bl3;
                    if (d6 <= d4) return bl4;
                    if (d2 > d4) return false;
                    return true;
                }
                bl4 = bl3;
                if (d6 >= d4) return bl4;
                if (d2 < d4) return false;
                return true;
            }
            d10 = d5 DCMPL 0.0;
            if (d10 == false) return false;
            boolean bl5 = bl2;
            if (d9 * d7 <= 0.0) return bl5;
            if (d7 * d5 < 0.0) return false;
            if (d10 > 0) {
                bl5 = bl2;
                if (d7 <= d5) return bl5;
                if (d9 > d5) return false;
                return true;
            }
            bl5 = bl2;
            if (d7 >= d5) return bl5;
            if (d9 < d5) return false;
            return true;
        }
        d2 = d6 * d9 - d2 * d7;
        if (d3 * d8 > 0.0) return false;
        if (d2 * (d3 + d2 - d8) > 0.0) return false;
        return true;
    }

    public static double ptLineDist(double d2, double d3, double d4, double d5, double d6, double d7) {
        return Math.sqrt(Line2D.ptLineDistSq(d2, d3, d4, d5, d6, d7));
    }

    public static double ptLineDistSq(double d2, double d3, double d4, double d5, double d6, double d7) {
        d2 = (d6 - d2) * (d5 -= d3) - (d7 - d3) * (d4 -= d2);
        return d2 * d2 / (d4 * d4 + d5 * d5);
    }

    public static double ptSegDist(double d2, double d3, double d4, double d5, double d6, double d7) {
        return Math.sqrt(Line2D.ptSegDistSq(d2, d3, d4, d5, d6, d7));
    }

    public static double ptSegDistSq(double d2, double d3, double d4, double d5, double d6, double d7) {
        if ((d2 = d6 - d2) * (d4 -= d2) + (d3 = d7 - d3) * (d5 -= d3) <= 0.0) {
            d2 = d2 * d2 + d3 * d3;
        } else if ((d2 = d4 - d2) * d4 + (d3 = d5 - d3) * d5 <= 0.0) {
            d2 = d2 * d2 + d3 * d3;
        } else {
            d2 = d2 * d5 - d3 * d4;
            d2 = d2 * d2 / (d4 * d4 + d5 * d5);
        }
        d3 = d2;
        if (d2 < 0.0) {
            d3 = 0.0;
        }
        return d3;
    }

    public static int relativeCCW(double d2, double d3, double d4, double d5, double d6, double d7) {
        d2 = d3 = (d6 -= d2) * (d5 -= d3) - (d7 -= d3) * (d4 -= d2);
        if (d3 == 0.0) {
            d2 = d3 = d6 * d4 + d7 * d5;
            if (d3 > 0.0) {
                d2 = d3 = (d6 - d4) * d4 + (d7 - d5) * d5;
                if (d3 < 0.0) {
                    d2 = 0.0;
                }
            }
        }
        if (d2 < 0.0) {
            return -1;
        }
        if (d2 > 0.0) {
            return 1;
        }
        return 0;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public Object clone() {
        try {
            return super.clone();
        }
        catch (CloneNotSupportedException cloneNotSupportedException) {
            throw new InternalError();
        }
    }

    @Override
    public boolean contains(double d2, double d3) {
        return false;
    }

    @Override
    public boolean contains(double d2, double d3, double d4, double d5) {
        return false;
    }

    @Override
    public boolean contains(Point2D point2D) {
        return false;
    }

    @Override
    public boolean contains(Rectangle2D rectangle2D) {
        return false;
    }

    @Override
    public Rectangle getBounds() {
        return this.getBounds2D().getBounds();
    }

    public abstract Point2D getP1();

    public abstract Point2D getP2();

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform) {
        return new Iterator(this, affineTransform);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform, double d2) {
        return new Iterator(this, affineTransform);
    }

    public abstract double getX1();

    public abstract double getX2();

    public abstract double getY1();

    public abstract double getY2();

    @Override
    public boolean intersects(double d2, double d3, double d4, double d5) {
        return this.intersects(new Rectangle2D.Double(d2, d3, d4, d5));
    }

    @Override
    public boolean intersects(Rectangle2D rectangle2D) {
        return rectangle2D.intersectsLine(this.getX1(), this.getY1(), this.getX2(), this.getY2());
    }

    public boolean intersectsLine(double d2, double d3, double d4, double d5) {
        return Line2D.linesIntersect(d2, d3, d4, d5, this.getX1(), this.getY1(), this.getX2(), this.getY2());
    }

    public boolean intersectsLine(Line2D line2D) {
        return Line2D.linesIntersect(line2D.getX1(), line2D.getY1(), line2D.getX2(), line2D.getY2(), this.getX1(), this.getY1(), this.getX2(), this.getY2());
    }

    public double ptLineDist(double d2, double d3) {
        return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), d2, d3);
    }

    public double ptLineDist(Point2D point2D) {
        return Line2D.ptLineDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), point2D.getX(), point2D.getY());
    }

    public double ptLineDistSq(double d2, double d3) {
        return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), d2, d3);
    }

    public double ptLineDistSq(Point2D point2D) {
        return Line2D.ptLineDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), point2D.getX(), point2D.getY());
    }

    public double ptSegDist(double d2, double d3) {
        return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), d2, d3);
    }

    public double ptSegDist(Point2D point2D) {
        return Line2D.ptSegDist(this.getX1(), this.getY1(), this.getX2(), this.getY2(), point2D.getX(), point2D.getY());
    }

    public double ptSegDistSq(double d2, double d3) {
        return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), d2, d3);
    }

    public double ptSegDistSq(Point2D point2D) {
        return Line2D.ptSegDistSq(this.getX1(), this.getY1(), this.getX2(), this.getY2(), point2D.getX(), point2D.getY());
    }

    public int relativeCCW(double d2, double d3) {
        return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), d2, d3);
    }

    public int relativeCCW(Point2D point2D) {
        return Line2D.relativeCCW(this.getX1(), this.getY1(), this.getX2(), this.getY2(), point2D.getX(), point2D.getY());
    }

    public abstract void setLine(double var1, double var3, double var5, double var7);

    public void setLine(Line2D line2D) {
        this.setLine(line2D.getX1(), line2D.getY1(), line2D.getX2(), line2D.getY2());
    }

    public void setLine(Point2D point2D, Point2D point2D2) {
        this.setLine(point2D.getX(), point2D.getY(), point2D2.getX(), point2D2.getY());
    }

    public static class Double
    extends Line2D {
        public double x1;
        public double x2;
        public double y1;
        public double y2;

        public Double() {
        }

        public Double(double d2, double d3, double d4, double d5) {
            this.setLine(d2, d3, d4, d5);
        }

        public Double(Point2D point2D, Point2D point2D2) {
            this.setLine(point2D, point2D2);
        }

        @Override
        public Rectangle2D getBounds2D() {
            double d2;
            double d3;
            double d4;
            double d5;
            double d6;
            double d7;
            if (this.x1 < this.x2) {
                d3 = this.x1;
                d7 = this.x2;
                d5 = this.x1;
            } else {
                d3 = this.x2;
                d7 = this.x1;
                d5 = this.x2;
            }
            if (this.y1 < this.y2) {
                d2 = this.y1;
                d6 = this.y2;
                d4 = this.y1;
            } else {
                d2 = this.y2;
                d6 = this.y1;
                d4 = this.y2;
            }
            return new Rectangle2D.Double(d3, d2, d7 - d5, d6 - d4);
        }

        @Override
        public Point2D getP1() {
            return new Point2D.Double(this.x1, this.y1);
        }

        @Override
        public Point2D getP2() {
            return new Point2D.Double(this.x2, this.y2);
        }

        @Override
        public double getX1() {
            return this.x1;
        }

        @Override
        public double getX2() {
            return this.x2;
        }

        @Override
        public double getY1() {
            return this.y1;
        }

        @Override
        public double getY2() {
            return this.y2;
        }

        @Override
        public void setLine(double d2, double d3, double d4, double d5) {
            this.x1 = d2;
            this.y1 = d3;
            this.x2 = d4;
            this.y2 = d5;
        }
    }

    public static class Float
    extends Line2D {
        public float x1;
        public float x2;
        public float y1;
        public float y2;

        public Float() {
        }

        public Float(float f2, float f3, float f4, float f5) {
            this.setLine(f2, f3, f4, f5);
        }

        public Float(Point2D point2D, Point2D point2D2) {
            this.setLine(point2D, point2D2);
        }

        @Override
        public Rectangle2D getBounds2D() {
            float f2;
            float f3;
            float f4;
            float f5;
            float f6;
            float f7;
            if (this.x1 < this.x2) {
                f5 = this.x1;
                f3 = this.x2;
                f6 = this.x1;
            } else {
                f5 = this.x2;
                f3 = this.x1;
                f6 = this.x2;
            }
            if (this.y1 < this.y2) {
                f7 = this.y1;
                f2 = this.y2;
                f4 = this.y1;
            } else {
                f7 = this.y2;
                f2 = this.y1;
                f4 = this.y2;
            }
            return new Rectangle2D.Float(f5, f7, f3 - f6, f2 - f4);
        }

        @Override
        public Point2D getP1() {
            return new Point2D.Float(this.x1, this.y1);
        }

        @Override
        public Point2D getP2() {
            return new Point2D.Float(this.x2, this.y2);
        }

        @Override
        public double getX1() {
            return this.x1;
        }

        @Override
        public double getX2() {
            return this.x2;
        }

        @Override
        public double getY1() {
            return this.y1;
        }

        @Override
        public double getY2() {
            return this.y2;
        }

        @Override
        public void setLine(double d2, double d3, double d4, double d5) {
            this.x1 = (float)d2;
            this.y1 = (float)d3;
            this.x2 = (float)d4;
            this.y2 = (float)d5;
        }

        public void setLine(float f2, float f3, float f4, float f5) {
            this.x1 = f2;
            this.y1 = f3;
            this.x2 = f4;
            this.y2 = f5;
        }
    }

    class Iterator
    implements PathIterator {
        int index;
        AffineTransform t;
        double x1;
        double x2;
        double y1;
        double y2;

        Iterator(Line2D line2D2, AffineTransform affineTransform) {
            this.x1 = line2D2.getX1();
            this.y1 = line2D2.getY1();
            this.x2 = line2D2.getX2();
            this.y2 = line2D2.getY2();
            this.t = affineTransform;
        }

        @Override
        public int currentSegment(double[] arrd) {
            if (!this.isDone()) {
                int n2 = this.index;
                int n3 = 1;
                if (n2 == 0) {
                    arrd[0] = this.x1;
                    arrd[1] = this.y1;
                    n3 = 0;
                } else {
                    arrd[0] = this.x2;
                    arrd[1] = this.y2;
                }
                if (this.t != null) {
                    this.t.transform(arrd, 0, arrd, 0, 1);
                }
                return n3;
            }
            throw new NoSuchElementException(Messages.getString("awt.4B"));
        }

        @Override
        public int currentSegment(float[] arrf) {
            if (!this.isDone()) {
                int n2 = this.index;
                int n3 = 1;
                if (n2 == 0) {
                    arrf[0] = (float)this.x1;
                    arrf[1] = (float)this.y1;
                    n3 = 0;
                } else {
                    arrf[0] = (float)this.x2;
                    arrf[1] = (float)this.y2;
                }
                if (this.t != null) {
                    this.t.transform(arrf, 0, arrf, 0, 1);
                }
                return n3;
            }
            throw new NoSuchElementException(Messages.getString("awt.4B"));
        }

        @Override
        public int getWindingRule() {
            return 1;
        }

        @Override
        public boolean isDone() {
            if (this.index > 1) {
                return true;
            }
            return false;
        }

        @Override
        public void next() {
            ++this.index;
        }
    }

}

