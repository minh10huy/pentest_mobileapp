/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.awt.geom.misc;

import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class RenderingHints
implements Cloneable,
Map<Object, Object> {
    public static final Key KEY_ALPHA_INTERPOLATION = new KeyImpl(1);
    public static final Key KEY_ANTIALIASING;
    public static final Key KEY_COLOR_RENDERING;
    public static final Key KEY_DITHERING;
    public static final Key KEY_FRACTIONALMETRICS;
    public static final Key KEY_INTERPOLATION;
    public static final Key KEY_RENDERING;
    public static final Key KEY_STROKE_CONTROL;
    public static final Key KEY_TEXT_ANTIALIASING;
    public static final Object VALUE_ALPHA_INTERPOLATION_DEFAULT;
    public static final Object VALUE_ALPHA_INTERPOLATION_QUALITY;
    public static final Object VALUE_ALPHA_INTERPOLATION_SPEED;
    public static final Object VALUE_ANTIALIAS_DEFAULT;
    public static final Object VALUE_ANTIALIAS_OFF;
    public static final Object VALUE_ANTIALIAS_ON;
    public static final Object VALUE_COLOR_RENDER_DEFAULT;
    public static final Object VALUE_COLOR_RENDER_QUALITY;
    public static final Object VALUE_COLOR_RENDER_SPEED;
    public static final Object VALUE_DITHER_DEFAULT;
    public static final Object VALUE_DITHER_DISABLE;
    public static final Object VALUE_DITHER_ENABLE;
    public static final Object VALUE_FRACTIONALMETRICS_DEFAULT;
    public static final Object VALUE_FRACTIONALMETRICS_OFF;
    public static final Object VALUE_FRACTIONALMETRICS_ON;
    public static final Object VALUE_INTERPOLATION_BICUBIC;
    public static final Object VALUE_INTERPOLATION_BILINEAR;
    public static final Object VALUE_INTERPOLATION_NEAREST_NEIGHBOR;
    public static final Object VALUE_RENDER_DEFAULT;
    public static final Object VALUE_RENDER_QUALITY;
    public static final Object VALUE_RENDER_SPEED;
    public static final Object VALUE_STROKE_DEFAULT;
    public static final Object VALUE_STROKE_NORMALIZE;
    public static final Object VALUE_STROKE_PURE;
    public static final Object VALUE_TEXT_ANTIALIAS_DEFAULT;
    public static final Object VALUE_TEXT_ANTIALIAS_OFF;
    public static final Object VALUE_TEXT_ANTIALIAS_ON;
    private HashMap<Object, Object> map = new HashMap();

    static {
        VALUE_ALPHA_INTERPOLATION_DEFAULT = new KeyValue(KEY_ALPHA_INTERPOLATION);
        VALUE_ALPHA_INTERPOLATION_SPEED = new KeyValue(KEY_ALPHA_INTERPOLATION);
        VALUE_ALPHA_INTERPOLATION_QUALITY = new KeyValue(KEY_ALPHA_INTERPOLATION);
        KEY_ANTIALIASING = new KeyImpl(2);
        VALUE_ANTIALIAS_DEFAULT = new KeyValue(KEY_ANTIALIASING);
        VALUE_ANTIALIAS_ON = new KeyValue(KEY_ANTIALIASING);
        VALUE_ANTIALIAS_OFF = new KeyValue(KEY_ANTIALIASING);
        KEY_COLOR_RENDERING = new KeyImpl(3);
        VALUE_COLOR_RENDER_DEFAULT = new KeyValue(KEY_COLOR_RENDERING);
        VALUE_COLOR_RENDER_SPEED = new KeyValue(KEY_COLOR_RENDERING);
        VALUE_COLOR_RENDER_QUALITY = new KeyValue(KEY_COLOR_RENDERING);
        KEY_DITHERING = new KeyImpl(4);
        VALUE_DITHER_DEFAULT = new KeyValue(KEY_DITHERING);
        VALUE_DITHER_DISABLE = new KeyValue(KEY_DITHERING);
        VALUE_DITHER_ENABLE = new KeyValue(KEY_DITHERING);
        KEY_FRACTIONALMETRICS = new KeyImpl(5);
        VALUE_FRACTIONALMETRICS_DEFAULT = new KeyValue(KEY_FRACTIONALMETRICS);
        VALUE_FRACTIONALMETRICS_ON = new KeyValue(KEY_FRACTIONALMETRICS);
        VALUE_FRACTIONALMETRICS_OFF = new KeyValue(KEY_FRACTIONALMETRICS);
        KEY_INTERPOLATION = new KeyImpl(6);
        VALUE_INTERPOLATION_BICUBIC = new KeyValue(KEY_INTERPOLATION);
        VALUE_INTERPOLATION_BILINEAR = new KeyValue(KEY_INTERPOLATION);
        VALUE_INTERPOLATION_NEAREST_NEIGHBOR = new KeyValue(KEY_INTERPOLATION);
        KEY_RENDERING = new KeyImpl(7);
        VALUE_RENDER_DEFAULT = new KeyValue(KEY_RENDERING);
        VALUE_RENDER_SPEED = new KeyValue(KEY_RENDERING);
        VALUE_RENDER_QUALITY = new KeyValue(KEY_RENDERING);
        KEY_STROKE_CONTROL = new KeyImpl(8);
        VALUE_STROKE_DEFAULT = new KeyValue(KEY_STROKE_CONTROL);
        VALUE_STROKE_NORMALIZE = new KeyValue(KEY_STROKE_CONTROL);
        VALUE_STROKE_PURE = new KeyValue(KEY_STROKE_CONTROL);
        KEY_TEXT_ANTIALIASING = new KeyImpl(9);
        VALUE_TEXT_ANTIALIAS_DEFAULT = new KeyValue(KEY_TEXT_ANTIALIASING);
        VALUE_TEXT_ANTIALIAS_ON = new KeyValue(KEY_TEXT_ANTIALIASING);
        VALUE_TEXT_ANTIALIAS_OFF = new KeyValue(KEY_TEXT_ANTIALIASING);
    }

    public RenderingHints(Key key, Object object) {
        this.put(key, object);
    }

    public RenderingHints(Map<Key, ?> map) {
        if (map != null) {
            this.putAll(map);
        }
    }

    public void add(RenderingHints renderingHints) {
        this.map.putAll(renderingHints.map);
    }

    @Override
    public void clear() {
        this.map.clear();
    }

    public Object clone() {
        RenderingHints renderingHints = new RenderingHints(null);
        renderingHints.map = (HashMap)this.map.clone();
        return renderingHints;
    }

    @Override
    public boolean containsKey(Object object) {
        if (object != null) {
            return this.map.containsKey(object);
        }
        throw new NullPointerException();
    }

    @Override
    public boolean containsValue(Object object) {
        return this.map.containsValue(object);
    }

    @Override
    public Set<Map.Entry<Object, Object>> entrySet() {
        return this.map.entrySet();
    }

    @Override
    public boolean equals(Object object) {
        if (!(object instanceof Map)) {
            return false;
        }
        object = (Map)object;
        Set<Object> set = this.keySet();
        if (!set.equals(object.keySet())) {
            return false;
        }
        for (Key key : set) {
            Object object2 = this.get(key);
            Object key2 = object.get(key);
            if (object2 != null ? object2.equals(key2) : key2 == null) continue;
            return false;
        }
        return true;
    }

    @Override
    public Object get(Object object) {
        return this.map.get(object);
    }

    @Override
    public int hashCode() {
        return this.map.hashCode();
    }

    @Override
    public boolean isEmpty() {
        return this.map.isEmpty();
    }

    @Override
    public Set<Object> keySet() {
        return this.map.keySet();
    }

    @Override
    public Object put(Object object, Object object2) {
        if (((Key)object).isCompatibleValue(object2)) {
            return this.map.put(object, object2);
        }
        throw new IllegalArgumentException();
    }

    @Override
    public void putAll(Map<?, ?> iterator) {
        if (iterator instanceof RenderingHints) {
            this.map.putAll(((RenderingHints)iterator).map);
            return;
        }
        if ((iterator = iterator.entrySet()) != null) {
            iterator = iterator.iterator();
            while (iterator.hasNext()) {
                Map.Entry entry = (Map.Entry)iterator.next();
                this.put((Key)entry.getKey(), entry.getValue());
            }
        }
    }

    @Override
    public Object remove(Object object) {
        return this.map.remove(object);
    }

    @Override
    public int size() {
        return this.map.size();
    }

    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("RenderingHints[");
        stringBuilder.append(this.map.toString());
        stringBuilder.append("]");
        return stringBuilder.toString();
    }

    @Override
    public Collection<Object> values() {
        return this.map.values();
    }

    public static abstract class Key {
        private final int key;

        protected Key(int n2) {
            this.key = n2;
        }

        public final boolean equals(Object object) {
            if (this == object) {
                return true;
            }
            return false;
        }

        public final int hashCode() {
            return System.identityHashCode(this);
        }

        protected final int intKey() {
            return this.key;
        }

        public abstract boolean isCompatibleValue(Object var1);
    }

    private static class KeyImpl
    extends Key {
        protected KeyImpl(int n2) {
            super(n2);
        }

        @Override
        public boolean isCompatibleValue(Object object) {
            boolean bl2 = object instanceof KeyValue;
            boolean bl3 = false;
            if (!bl2) {
                return false;
            }
            if (((KeyValue)object).key == this) {
                bl3 = true;
            }
            return bl3;
        }
    }

    private static class KeyValue {
        private final Key key;

        protected KeyValue(Key key) {
            this.key = key;
        }
    }

}

