/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.awt.geom;

import com.itextpdf.awt.geom.AffineTransform;
import com.itextpdf.awt.geom.FlatteningPathIterator;
import com.itextpdf.awt.geom.IllegalPathStateException;
import com.itextpdf.awt.geom.PathIterator;
import com.itextpdf.awt.geom.Point2D;
import com.itextpdf.awt.geom.Rectangle;
import com.itextpdf.awt.geom.Rectangle2D;
import com.itextpdf.awt.geom.Shape;
import com.itextpdf.awt.geom.gl.Crossing;
import com.itextpdf.awt.geom.misc.Messages;
import java.util.NoSuchElementException;

public final class GeneralPath
implements Shape,
Cloneable {
    private static final int BUFFER_CAPACITY = 10;
    private static final int BUFFER_SIZE = 10;
    public static final int WIND_EVEN_ODD = 0;
    public static final int WIND_NON_ZERO = 1;
    static int[] pointShift = new int[]{2, 2, 4, 6, 0};
    int pointSize;
    float[] points;
    int rule;
    int typeSize;
    byte[] types;

    public GeneralPath() {
        this(1, 10);
    }

    public GeneralPath(int n2) {
        this(n2, 10);
    }

    public GeneralPath(int n2, int n3) {
        this.setWindingRule(n2);
        this.types = new byte[n3];
        this.points = new float[n3 * 2];
    }

    public GeneralPath(Shape object) {
        this(1, 10);
        object = object.getPathIterator(null);
        this.setWindingRule(object.getWindingRule());
        this.append((PathIterator)object, false);
    }

    public void append(PathIterator pathIterator, boolean bl2) {
        while (!pathIterator.isDone()) {
            block10 : {
                float[] arrf = new float[6];
                switch (pathIterator.currentSegment(arrf)) {
                    default: {
                        break block10;
                    }
                    case 4: {
                        this.closePath();
                        break block10;
                    }
                    case 3: {
                        this.curveTo(arrf[0], arrf[1], arrf[2], arrf[3], arrf[4], arrf[5]);
                        break block10;
                    }
                    case 2: {
                        this.quadTo(arrf[0], arrf[1], arrf[2], arrf[3]);
                        break block10;
                    }
                    case 0: {
                        if (!bl2 || this.typeSize == 0) break;
                        if (this.types[this.typeSize - 1] != 4 && this.points[this.pointSize - 2] == arrf[0] && this.points[this.pointSize - 1] == arrf[1]) break block10;
                    }
                    case 1: {
                        this.lineTo(arrf[0], arrf[1]);
                    }
                    {
                        break block10;
                    }
                }
                this.moveTo(arrf[0], arrf[1]);
            }
            pathIterator.next();
            bl2 = false;
        }
    }

    public void append(Shape shape, boolean bl2) {
        this.append(shape.getPathIterator(null), bl2);
    }

    void checkBuf(int n2, boolean bl2) {
        byte[] arrby;
        if (bl2 && this.typeSize == 0) {
            throw new IllegalPathStateException(Messages.getString("awt.20A"));
        }
        if (this.typeSize == this.types.length) {
            arrby = new byte[this.typeSize + 10];
            System.arraycopy(this.types, 0, arrby, 0, this.typeSize);
            this.types = arrby;
        }
        if (this.pointSize + n2 > this.points.length) {
            arrby = new float[this.pointSize + Math.max(20, n2)];
            System.arraycopy(this.points, 0, arrby, 0, this.pointSize);
            this.points = arrby;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public Object clone() {
        try {
            GeneralPath generalPath = (GeneralPath)super.clone();
            generalPath.types = (byte[])this.types.clone();
            generalPath.points = (float[])this.points.clone();
            return generalPath;
        }
        catch (CloneNotSupportedException cloneNotSupportedException) {
            throw new InternalError();
        }
    }

    public void closePath() {
        if (this.typeSize == 0 || this.types[this.typeSize - 1] != 4) {
            this.checkBuf(0, true);
            byte[] arrby = this.types;
            int n2 = this.typeSize;
            this.typeSize = n2 + 1;
            arrby[n2] = 4;
        }
    }

    @Override
    public boolean contains(double d2, double d3) {
        return this.isInside(Crossing.crossShape(this, d2, d3));
    }

    @Override
    public boolean contains(double d2, double d3, double d4, double d5) {
        int n2 = Crossing.intersectShape(this, d2, d3, d4, d5);
        if (n2 != 255 && this.isInside(n2)) {
            return true;
        }
        return false;
    }

    @Override
    public boolean contains(Point2D point2D) {
        return this.contains(point2D.getX(), point2D.getY());
    }

    @Override
    public boolean contains(Rectangle2D rectangle2D) {
        return this.contains(rectangle2D.getX(), rectangle2D.getY(), rectangle2D.getWidth(), rectangle2D.getHeight());
    }

    public Shape createTransformedShape(AffineTransform affineTransform) {
        GeneralPath generalPath = (GeneralPath)this.clone();
        if (affineTransform != null) {
            generalPath.transform(affineTransform);
        }
        return generalPath;
    }

    public void curveTo(float f2, float f3, float f4, float f5, float f6, float f7) {
        this.checkBuf(6, true);
        byte[] arrby = this.types;
        int n2 = this.typeSize;
        this.typeSize = n2 + 1;
        arrby[n2] = 3;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f2;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f3;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f4;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f5;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f6;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f7;
    }

    @Override
    public Rectangle getBounds() {
        return this.getBounds2D().getBounds();
    }

    @Override
    public Rectangle2D getBounds2D() {
        float f2;
        float f3;
        float f4;
        float f5;
        if (this.pointSize == 0) {
            f4 = 0.0f;
            f3 = 0.0f;
            f2 = 0.0f;
            f5 = 0.0f;
        } else {
            float f6;
            int n2 = this.pointSize - 1;
            float[] arrf = this.points;
            int n3 = n2 - 1;
            float f7 = arrf[n2];
            arrf = this.points;
            n2 = n3 - 1;
            float f8 = f6 = arrf[n3];
            float f9 = f7;
            do {
                f4 = f8;
                f3 = f9;
                f2 = f6;
                f5 = f7;
                if (n2 <= 0) break;
                arrf = this.points;
                n3 = n2 - 1;
                f4 = arrf[n2];
                f5 = this.points[n3];
                if (f5 < f8) {
                    f3 = f5;
                    f2 = f6;
                } else {
                    f3 = f8;
                    f2 = f6;
                    if (f5 > f6) {
                        f2 = f5;
                        f3 = f8;
                    }
                }
                if (f4 < f9) {
                    f6 = f4;
                    f5 = f7;
                } else {
                    f6 = f9;
                    f5 = f7;
                    if (f4 > f7) {
                        f5 = f4;
                        f6 = f9;
                    }
                }
                n2 = n3 - 1;
                f8 = f3;
                f9 = f6;
                f6 = f2;
                f7 = f5;
            } while (true);
        }
        return new Rectangle2D.Float(f4, f3, f2 - f4, f5 - f3);
    }

    public Point2D getCurrentPoint() {
        int n2;
        if (this.typeSize == 0) {
            return null;
        }
        int n3 = n2 = this.pointSize - 2;
        if (this.types[this.typeSize - 1] == 4) {
            int n4 = this.typeSize - 2;
            do {
                n3 = n2;
                if (n4 <= 0) break;
                n3 = this.types[n4];
                if (n3 == 0) {
                    n3 = n2;
                    break;
                }
                n2 -= pointShift[n3];
                --n4;
            } while (true);
        }
        return new Point2D.Float(this.points[n3], this.points[n3 + 1]);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform) {
        return new Iterator(this, affineTransform);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform, double d2) {
        return new FlatteningPathIterator(this.getPathIterator(affineTransform), d2);
    }

    public int getWindingRule() {
        return this.rule;
    }

    @Override
    public boolean intersects(double d2, double d3, double d4, double d5) {
        int n2 = Crossing.intersectShape(this, d2, d3, d4, d5);
        if (n2 != 255 && !this.isInside(n2)) {
            return false;
        }
        return true;
    }

    @Override
    public boolean intersects(Rectangle2D rectangle2D) {
        return this.intersects(rectangle2D.getX(), rectangle2D.getY(), rectangle2D.getWidth(), rectangle2D.getHeight());
    }

    boolean isInside(int n2) {
        if (this.rule == 1) {
            return Crossing.isInsideNonZero(n2);
        }
        return Crossing.isInsideEvenOdd(n2);
    }

    public void lineTo(float f2, float f3) {
        this.checkBuf(2, true);
        byte[] arrby = this.types;
        int n2 = this.typeSize;
        this.typeSize = n2 + 1;
        arrby[n2] = 1;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f2;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f3;
    }

    public void moveTo(float f2, float f3) {
        if (this.typeSize > 0 && this.types[this.typeSize - 1] == 0) {
            this.points[this.pointSize - 2] = f2;
            this.points[this.pointSize - 1] = f3;
            return;
        }
        this.checkBuf(2, false);
        byte[] arrby = this.types;
        int n2 = this.typeSize;
        this.typeSize = n2 + 1;
        arrby[n2] = 0;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f2;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f3;
    }

    public void quadTo(float f2, float f3, float f4, float f5) {
        this.checkBuf(4, true);
        byte[] arrby = this.types;
        int n2 = this.typeSize;
        this.typeSize = n2 + 1;
        arrby[n2] = 2;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f2;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f3;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f4;
        arrby = this.points;
        n2 = this.pointSize;
        this.pointSize = n2 + 1;
        arrby[n2] = (byte)f5;
    }

    public void reset() {
        this.typeSize = 0;
        this.pointSize = 0;
    }

    public void setWindingRule(int n2) {
        if (n2 != 0 && n2 != 1) {
            throw new IllegalArgumentException(Messages.getString("awt.209"));
        }
        this.rule = n2;
    }

    public void transform(AffineTransform affineTransform) {
        affineTransform.transform(this.points, 0, this.points, 0, this.pointSize / 2);
    }

    class Iterator
    implements PathIterator {
        GeneralPath p;
        int pointIndex;
        AffineTransform t;
        int typeIndex;

        Iterator(GeneralPath generalPath2) {
            this(generalPath2, null);
        }

        Iterator(GeneralPath generalPath2, AffineTransform affineTransform) {
            this.p = generalPath2;
            this.t = affineTransform;
        }

        @Override
        public int currentSegment(double[] arrd) {
            if (!this.isDone()) {
                byte by2 = this.p.types[this.typeIndex];
                int n2 = GeneralPath.pointShift[by2];
                for (int i2 = 0; i2 < n2; ++i2) {
                    arrd[i2] = this.p.points[this.pointIndex + i2];
                }
                if (this.t != null) {
                    this.t.transform(arrd, 0, arrd, 0, n2 / 2);
                }
                this.pointIndex += n2;
                return by2;
            }
            throw new NoSuchElementException(Messages.getString("awt.4B"));
        }

        @Override
        public int currentSegment(float[] arrf) {
            if (!this.isDone()) {
                byte by2 = this.p.types[this.typeIndex];
                int n2 = GeneralPath.pointShift[by2];
                System.arraycopy(this.p.points, this.pointIndex, arrf, 0, n2);
                if (this.t != null) {
                    this.t.transform(arrf, 0, arrf, 0, n2 / 2);
                }
                this.pointIndex += n2;
                return by2;
            }
            throw new NoSuchElementException(Messages.getString("awt.4B"));
        }

        @Override
        public int getWindingRule() {
            return this.p.getWindingRule();
        }

        @Override
        public boolean isDone() {
            if (this.typeIndex >= this.p.typeSize) {
                return true;
            }
            return false;
        }

        @Override
        public void next() {
            ++this.typeIndex;
        }
    }

}

