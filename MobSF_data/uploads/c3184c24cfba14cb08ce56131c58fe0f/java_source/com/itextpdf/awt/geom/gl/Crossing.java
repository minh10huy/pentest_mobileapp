/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.awt.geom.gl;

import com.itextpdf.awt.geom.AffineTransform;
import com.itextpdf.awt.geom.PathIterator;
import com.itextpdf.awt.geom.Rectangle2D;
import com.itextpdf.awt.geom.Shape;

public class Crossing {
    public static final int CROSSING = 255;
    static final double DELTA = 1.0E-5;
    static final double ROOT_DELTA = 1.0E-10;
    static final int UNKNOWN = 254;

    static int crossBound(double[] arrd, int n2, double d2, double d3) {
        int n3;
        if (n2 == 0) {
            return 0;
        }
        int n4 = 0;
        int n5 = 0;
        for (n3 = 2; n3 < n2; n3 += 4) {
            if (arrd[n3] < d2) {
                ++n5;
                continue;
            }
            if (arrd[n3] > d3) {
                ++n4;
                continue;
            }
            return 255;
        }
        if (n4 == 0) {
            return 0;
        }
        if (n5 != 0) {
            Crossing.sortBound(arrd, n2);
            n3 = arrd[2] > d3 ? 1 : 0;
            n5 = n3;
            for (n4 = 6; n4 < n2; n4 += 4) {
                n3 = arrd[n4] > d3 ? 1 : 0;
                if (n5 != n3 && arrd[n4 + 1] != arrd[n4 - 3]) {
                    return 255;
                }
                n5 = n3;
            }
        }
        return 254;
    }

    public static int crossCubic(double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10, double d11) {
        double d12;
        double d13 = d10 DCMPG d2;
        boolean bl2 = false;
        boolean bl3 = false;
        if (d13 < 0 && d10 < d4 && d10 < d6 && d10 < d8 || (d12 = (d10 DCMPL d2)) > 0 && d10 > d4 && d10 > d6 && d10 > d8 || d11 > d3 && d11 > d5 && d11 > d7 && d11 > d9 || d2 == d4 && d4 == d6 && d6 == d8) {
            return 0;
        }
        if (d11 < d3 && d11 < d5 && d11 < d7 && d11 < d9 && d12 != false && d10 != d8) {
            if (d2 < d8) {
                d12 = (double)bl3;
                if (d2 < d10) {
                    d12 = (double)bl3;
                    if (d10 < d8) {
                        d12 = (double)true;
                    }
                }
                return (int)d12;
            }
            d12 = (double)bl2;
            if (d8 < d10) {
                d12 = (double)bl2;
                if (d13 < 0) {
                    d12 = -1;
                }
            }
            return (int)d12;
        }
        CubicCurve cubicCurve = new CubicCurve(d2, d3, d4, d5, d6, d7, d8, d9);
        d3 = d11 - d3;
        double[] arrd = new double[3];
        return cubicCurve.cross(arrd, cubicCurve.solvePoint(arrd, d10 - d2), d3, d3);
    }

    public static int crossLine(double d2, double d3, double d4, double d5, double d6, double d7) {
        double d8;
        if (d6 < d2 && d6 < d4 || (d8 = (d6 DCMPL d2)) > 0 && d6 > d4 || d7 > d3 && d7 > d5 || d2 == d4) {
            return 0;
        }
        if ((d7 >= d3 || d7 >= d5) && (d5 - d3) * (d6 - d2) / (d4 - d2) <= d7 - d3) {
            return 0;
        }
        int n2 = -1;
        if (d8 == false) {
            if (d2 < d4) {
                n2 = 0;
            }
            return n2;
        }
        if (d6 == d4) {
            if (d2 < d4) {
                return 1;
            }
            return 0;
        }
        if (d2 < d4) {
            n2 = 1;
        }
        return n2;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public static int crossPath(PathIterator var0, double var1_1, double var3_2) {
        block14 : {
            var28_3 = new double[6];
            var27_4 = 0;
            var11_5 = 0.0;
            var9_8 = var15_7 = (var13_6 = 0.0);
            var26_9 = 0;
            while (!var0.isDone()) {
                switch (var0.currentSegment(var28_3)) {
                    default: {
                        var17_12 = var11_5;
                        var5_10 = var13_6;
                        var7_11 = var15_7;
                        var25_16 = var26_9;
                        var19_13 = var9_8;
                        break;
                    }
                    case 4: {
                        if (var15_7 == var9_8) {
                            var17_12 = var11_5;
                            var5_10 = var13_6;
                            var7_11 = var15_7;
                            var25_16 = var26_9;
                            var19_13 = var9_8;
                            if (var13_6 == var11_5) break;
                        }
                        var25_16 = var26_9 + Crossing.crossLine(var13_6, var15_7, var11_5, var9_8, var1_1, var3_2);
                        var5_10 = var11_5;
                        var7_11 = var9_8;
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 3: {
                        var17_12 = var28_3[0];
                        var19_13 = var28_3[1];
                        var21_14 = var28_3[2];
                        var23_15 = var28_3[3];
                        var5_10 = var28_3[4];
                        var7_11 = var28_3[5];
                        var25_16 = var26_9 + Crossing.crossCubic(var13_6, var15_7, var17_12, var19_13, var21_14, var23_15, var5_10, var7_11, var1_1, var3_2);
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 2: {
                        var17_12 = var28_3[0];
                        var19_13 = var28_3[1];
                        var5_10 = var28_3[2];
                        var7_11 = var28_3[3];
                        var25_16 = var26_9 + Crossing.crossQuad(var13_6, var15_7, var17_12, var19_13, var5_10, var7_11, var1_1, var3_2);
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 1: {
                        var5_10 = var28_3[0];
                        var7_11 = var28_3[1];
                        var25_16 = var26_9 + Crossing.crossLine(var13_6, var15_7, var5_10, var7_11, var1_1, var3_2);
                        var17_12 = var11_5;
                        var19_13 = var9_8;
                        break;
                    }
                    case 0: {
                        if (var13_6 != var11_5) ** GOTO lbl60
                        var25_16 = var26_9;
                        if (var15_7 == var9_8) ** GOTO lbl61
lbl60: // 2 sources:
                        var25_16 = var26_9 + Crossing.crossLine(var13_6, var15_7, var11_5, var9_8, var1_1, var3_2);
lbl61: // 2 sources:
                        var17_12 = var28_3[0];
                        var19_13 = var7_11 = var28_3[1];
                        var5_10 = var17_12;
                    }
                }
                if (var1_1 == var5_10 && var3_2 == var7_11) {
                    var13_6 = var5_10;
                    var5_10 = var19_13;
                    var25_16 = var27_4;
                    var15_7 = var19_13;
                    var11_5 = var17_12;
                    break block14;
                }
                var0.next();
                var11_5 = var17_12;
                var13_6 = var5_10;
                var15_7 = var7_11;
                var26_9 = var25_16;
                var9_8 = var19_13;
            }
            var25_16 = var26_9;
            var5_10 = var9_8;
        }
        var26_9 = var25_16;
        if (var15_7 == var5_10) return var26_9;
        return var25_16 + Crossing.crossLine(var13_6, var15_7, var11_5, var5_10, var1_1, var3_2);
    }

    public static int crossQuad(double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9) {
        double d10;
        double d11 = d8 DCMPG d2;
        boolean bl2 = false;
        boolean bl3 = false;
        if (d11 < 0 && d8 < d4 && d8 < d6 || (d10 = (d8 DCMPL d2)) > 0 && d8 > d4 && d8 > d6 || d9 > d3 && d9 > d5 && d9 > d7 || d2 == d4 && d4 == d6) {
            return 0;
        }
        if (d9 < d3 && d9 < d5 && d9 < d7 && d10 != false && d8 != d6) {
            if (d2 < d6) {
                d10 = (double)bl3;
                if (d2 < d8) {
                    d10 = (double)bl3;
                    if (d8 < d6) {
                        d10 = (double)true;
                    }
                }
                return (int)d10;
            }
            d10 = (double)bl2;
            if (d6 < d8) {
                d10 = (double)bl2;
                if (d11 < 0) {
                    d10 = -1;
                }
            }
            return (int)d10;
        }
        QuadCurve quadCurve = new QuadCurve(d2, d3, d4, d5, d6, d7);
        d3 = d9 - d3;
        double[] arrd = new double[3];
        return quadCurve.cross(arrd, quadCurve.solvePoint(arrd, d8 - d2), d3, d3);
    }

    public static int crossShape(Shape shape, double d2, double d3) {
        if (!shape.getBounds2D().contains(d2, d3)) {
            return 0;
        }
        return Crossing.crossPath(shape.getPathIterator(null), d2, d3);
    }

    static int fixRoots(double[] arrd, int n2) {
        int n3 = 0;
        int n4 = 0;
        while (n3 < n2) {
            int n5;
            block3 : {
                for (int i2 = n5 = n3 + 1; i2 < n2; ++i2) {
                    if (!Crossing.isZero(arrd[n3] - arrd[i2])) {
                        continue;
                    }
                    break block3;
                }
                arrd[n4] = arrd[n3];
                ++n4;
            }
            n3 = n5;
        }
        return n4;
    }

    public static int intersectCubic(double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10, double d11, double d12, double d13) {
        int n2;
        double d14;
        int n3 = 0;
        int n4 = 0;
        if (d12 < d2 && d12 < d4 && d12 < d6 && d12 < d8 || (d14 = (d10 DCMPL d2)) > 0 && d10 > d4 && d10 > d6 && d10 > d8 || d11 > d3 && d11 > d5 && d11 > d7 && d11 > d9) {
            return 0;
        }
        if (d13 < d3 && d13 < d5 && d13 < d7 && d13 < d9 && d14 != false && d10 != d8) {
            if (d2 < d8) {
                d14 = n4;
                if (d2 < d10) {
                    d14 = n4;
                    if (d10 < d8) {
                        d14 = (double)true;
                    }
                }
                return (int)d14;
            }
            d14 = n3;
            if (d8 < d10) {
                d14 = n3;
                if (d10 < d2) {
                    d14 = -1;
                }
            }
            return (int)d14;
        }
        CubicCurve cubicCurve = new CubicCurve(d2, d3, d4, d5, d6, d7, d8, d9);
        d5 = d10 - d2;
        d4 = d11 - d3;
        d6 = d12 - d2;
        d3 = d13 - d3;
        double[] arrd = new double[3];
        double[] arrd2 = new double[3];
        n3 = cubicCurve.solvePoint(arrd, d5);
        d14 = cubicCurve.solvePoint(arrd2, d6);
        if (n3 == 0 && d14 == false) {
            return 0;
        }
        double[] arrd3 = new double[40];
        n4 = cubicCurve.addBound(arrd3, cubicCurve.addBound(arrd3, cubicCurve.addBound(arrd3, cubicCurve.addBound(arrd3, 0, arrd, n3, d5, d6, false, 0), arrd2, (int)d14, d5, d6, false, 1), arrd2, cubicCurve.solveExtremX(arrd2), d5, d6, true, 2), arrd2, cubicCurve.solveExtremY(arrd2), d5 -= 1.0E-5, d6 += 1.0E-5, true, 4);
        d14 = n4;
        if (d10 < d2) {
            d14 = n4;
            if (d2 < d12) {
                d14 = n4 + 1;
                arrd3[n4] = 0.0;
                n4 = (int)(d14 + true);
                arrd3[d14] = 0.0;
                n2 = n4 + 1;
                arrd3[n4] = 0.0;
                d14 = n2 + 1;
                arrd3[n2] = 6.0;
            }
        }
        n4 = (int)d14;
        if (d10 < d8) {
            n4 = (int)d14;
            if (d8 < d12) {
                n4 = (int)(d14 + true);
                arrd3[d14] = 1.0;
                d14 = n4 + 1;
                arrd3[n4] = cubicCurve.ax;
                n2 = (int)(d14 + true);
                arrd3[d14] = cubicCurve.ay;
                n4 = n2 + 1;
                arrd3[n2] = 7.0;
            }
        }
        if ((d14 = (double)Crossing.crossBound(arrd3, n4, d4, d3)) != 254) {
            return (int)d14;
        }
        return cubicCurve.cross(arrd, n3, d4, d3);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public static int intersectLine(double var0, double var2_1, double var4_2, double var6_3, double var8_4, double var10_5, double var12_6, double var14_7) {
        block11 : {
            block13 : {
                block12 : {
                    var21_8 = 0;
                    var22_9 = 0;
                    var20_10 = 0;
                    if (var12_6 < var0) {
                        if (var12_6 < var4_2) return 0;
                    }
                    if ((var23_11 = (var8_4 DCMPL var0)) > 0) {
                        if (var8_4 > var4_2) return 0;
                    }
                    if (var10_5 > var2_1 && var10_5 > var6_3) {
                        return 0;
                    }
                    if (var14_7 < var2_1 && var14_7 < var6_3) break block11;
                    if (var0 == var4_2) {
                        return 255;
                    }
                    if (var0 >= var4_2) break block12;
                    var16_12 = var0 < var8_4 ? var8_4 : var0;
                    var18_13 = var16_12;
                    if (var4_2 >= var12_6) ** GOTO lbl-1000
                    var12_6 = var4_2;
                    break block13;
                }
                var16_12 = var4_2 < var8_4 ? var8_4 : var4_2;
                var18_13 = var16_12;
                if (var0 < var12_6) {
                    var12_6 = var0;
                } else lbl-1000: // 2 sources:
                {
                    var16_12 = var18_13;
                }
            }
            var6_3 = (var6_3 - var2_1) / (var4_2 - var0);
            var16_12 = (var16_12 - var0) * var6_3 + var2_1;
            var2_1 = var6_3 * (var12_6 - var0) + var2_1;
            if (var16_12 < var10_5 && var2_1 < var10_5) {
                return 0;
            }
            if (var16_12 <= var14_7) return 255;
            if (var2_1 <= var14_7) return 255;
        }
        if (var0 == var4_2) {
            return 0;
        }
        if (var23_11 == false) {
            if (var0 >= var4_2) return -1;
            return 0;
        }
        if (var8_4 == var4_2) {
            if (var0 >= var4_2) return var20_10;
            return 1;
        }
        if (var0 < var4_2) {
            var20_10 = var21_8;
            if (var0 >= var8_4) return var20_10;
            var20_10 = var21_8;
            if (var8_4 >= var4_2) return var20_10;
            return 1;
        }
        var20_10 = var22_9;
        if (var4_2 >= var8_4) return var20_10;
        var20_10 = var22_9;
        if (var8_4 >= var0) return var20_10;
        return -1;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public static int intersectPath(PathIterator var0, double var1_1, double var3_2, double var5_3, double var7_4) {
        var31_5 = new double[6];
        var17_6 = var1_1 + var5_3;
        var19_7 = var3_2 + var7_4;
        var5_3 = 0.0;
        var9_9 = var11_8 = (var7_4 = 0.0);
        var30_10 = 0;
        while (!var0.isDone()) {
            block9 : {
                switch (var0.currentSegment(var31_5)) {
                    default: {
                        var29_17 = 0;
                        var13_11 = var9_9;
                        break block9;
                    }
                    case 4: {
                        var29_17 = var7_4 == var11_8 && var5_3 == var9_9 ? 0 : Crossing.intersectLine(var5_3, var7_4, var9_9, var11_8, var1_1, var3_2, var17_6, var19_7);
                        var7_4 = var11_8;
                        var5_3 = var9_9;
                        ** GOTO lbl44
                    }
                    case 3: {
                        var21_13 = var31_5[0];
                        var23_14 = var31_5[1];
                        var25_15 = var31_5[2];
                        var27_16 = var31_5[3];
                        var13_11 = var31_5[4];
                        var15_12 = var31_5[5];
                        var29_17 = Crossing.intersectCubic(var5_3, var7_4, var21_13, var23_14, var25_15, var27_16, var13_11, var15_12, var1_1, var3_2, var17_6, var19_7);
                        var7_4 = var15_12;
                        var5_3 = var13_11;
                        ** GOTO lbl44
                    }
                    case 2: {
                        var21_13 = var31_5[0];
                        var23_14 = var31_5[1];
                        var15_12 = var31_5[2];
                        var13_11 = var31_5[3];
                        var29_17 = Crossing.intersectQuad(var5_3, var7_4, var21_13, var23_14, var15_12, var13_11, var1_1, var3_2, var17_6, var19_7);
                        var5_3 = var15_12;
                        var7_4 = var13_11;
                        ** GOTO lbl44
                    }
                    case 1: {
                        var15_12 = var31_5[0];
                        var13_11 = var31_5[1];
                        var29_17 = Crossing.intersectLine(var5_3, var7_4, var15_12, var13_11, var1_1, var3_2, var17_6, var19_7);
                        var5_3 = var15_12;
                        var7_4 = var13_11;
lbl44: // 4 sources:
                        var13_11 = var9_9;
                        break block9;
                    }
                    case 0: 
                }
                var29_17 = var5_3 == var9_9 && var7_4 == var11_8 ? 0 : Crossing.intersectLine(var5_3, var7_4, var9_9, var11_8, var1_1, var3_2, var17_6, var19_7);
                var7_4 = var31_5[0];
                var9_9 = var31_5[1];
                var5_3 = var7_4;
                var15_12 = var9_9;
                var13_11 = var7_4;
                var11_8 = var9_9;
                var7_4 = var15_12;
            }
            if (var29_17 == 255) {
                return 255;
            }
            var30_10 += var29_17;
            var0.next();
            var9_9 = var13_11;
        }
        var29_17 = var30_10;
        if (var7_4 == var11_8) return var29_17;
        var29_17 = Crossing.intersectLine(var5_3, var7_4, var9_9, var11_8, var1_1, var3_2, var17_6, var19_7);
        if (var29_17 != 255) return var30_10 + var29_17;
        return 255;
    }

    public static int intersectQuad(double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9, double d10, double d11) {
        int n2;
        double d12;
        int n3 = 0;
        int n4 = 0;
        if (d10 < d2 && d10 < d4 && d10 < d6 || (d12 = (d8 DCMPL d2)) > 0 && d8 > d4 && d8 > d6 || d9 > d3 && d9 > d5 && d9 > d7) {
            return 0;
        }
        if (d11 < d3 && d11 < d5 && d11 < d7 && d12 != false && d8 != d6) {
            if (d2 < d6) {
                d12 = n4;
                if (d2 < d8) {
                    d12 = n4;
                    if (d8 < d6) {
                        d12 = (double)true;
                    }
                }
                return (int)d12;
            }
            d12 = n3;
            if (d6 < d8) {
                d12 = n3;
                if (d8 < d2) {
                    d12 = -1;
                }
            }
            return (int)d12;
        }
        QuadCurve quadCurve = new QuadCurve(d2, d3, d4, d5, d6, d7);
        d5 = d8 - d2;
        d4 = d9 - d3;
        d7 = d10 - d2;
        d3 = d11 - d3;
        double[] arrd = new double[3];
        double[] arrd2 = new double[3];
        n3 = quadCurve.solvePoint(arrd, d5);
        d12 = quadCurve.solvePoint(arrd2, d7);
        if (n3 == 0 && d12 == false) {
            return 0;
        }
        double[] arrd3 = new double[28];
        n4 = quadCurve.addBound(arrd3, quadCurve.addBound(arrd3, quadCurve.addBound(arrd3, 0, arrd, n3, d5, d7, false, 0), arrd2, (int)d12, d5, d7, false, 1), arrd2, quadCurve.solveExtrem(arrd2), d5 -= 1.0E-5, d7 += 1.0E-5, true, 2);
        d12 = n4;
        if (d8 < d2) {
            d12 = n4;
            if (d2 < d10) {
                d12 = n4 + 1;
                arrd3[n4] = 0.0;
                n4 = (int)(d12 + true);
                arrd3[d12] = 0.0;
                n2 = n4 + 1;
                arrd3[n4] = 0.0;
                d12 = n2 + 1;
                arrd3[n2] = 4.0;
            }
        }
        n4 = (int)d12;
        if (d8 < d6) {
            n4 = (int)d12;
            if (d6 < d10) {
                n4 = (int)(d12 + true);
                arrd3[d12] = 1.0;
                d12 = n4 + 1;
                arrd3[n4] = quadCurve.ax;
                n2 = (int)(d12 + true);
                arrd3[d12] = quadCurve.ay;
                n4 = n2 + 1;
                arrd3[n2] = 5.0;
            }
        }
        if ((d12 = (double)Crossing.crossBound(arrd3, n4, d4, d3)) != 254) {
            return (int)d12;
        }
        return quadCurve.cross(arrd, n3, d4, d3);
    }

    public static int intersectShape(Shape shape, double d2, double d3, double d4, double d5) {
        if (!shape.getBounds2D().intersects(d2, d3, d4, d5)) {
            return 0;
        }
        return Crossing.intersectPath(shape.getPathIterator(null), d2, d3, d4, d5);
    }

    public static boolean isInsideEvenOdd(int n2) {
        if ((n2 & 1) != 0) {
            return true;
        }
        return false;
    }

    public static boolean isInsideNonZero(int n2) {
        if (n2 != 0) {
            return true;
        }
        return false;
    }

    public static boolean isZero(double d2) {
        if (-1.0E-5 < d2 && d2 < 1.0E-5) {
            return true;
        }
        return false;
    }

    public static int solveCubic(double[] arrd, double[] arrd2) {
        int n2;
        double d2 = arrd[3];
        if (d2 == 0.0) {
            return Crossing.solveQuad(arrd, arrd2);
        }
        double d3 = arrd[2] / d2;
        int n3 = 1;
        double d4 = arrd[1] / d2;
        double d5 = arrd[0] / d2;
        d2 = (d3 * d3 - d4 * 3.0) / 9.0;
        double d6 = (d3 * 2.0 * d3 * d3 - 9.0 * d3 * d4 + d5 * 27.0) / 54.0;
        d4 = d2 * d2 * d2;
        double d7 = d6 * d6;
        d5 = (- d3) / 3.0;
        if (d7 < d4) {
            d3 = Math.acos(d6 / Math.sqrt(d4)) / 3.0;
            d4 = Math.sqrt(d2) * -2.0;
            arrd2[0] = Math.cos(d3) * d4 + d5;
            arrd2[1] = Math.cos(d3 + 2.0943951023931953) * d4 + d5;
            arrd2[2] = d4 * Math.cos(d3 - 2.0943951023931953) + d5;
            n2 = 3;
        } else {
            d3 = Math.abs(d6);
            d3 = d4 = Math.pow(d3 + Math.sqrt(d7 -= d4), 0.3333333333333333);
            if (d6 > 0.0) {
                d3 = - d4;
            }
            if (-1.0E-10 < d3 && d3 < 1.0E-10) {
                arrd2[0] = d5;
                n2 = n3;
            } else {
                d3 += d2 / d3;
                arrd2[0] = d3 + d5;
                n2 = n3;
                if (-1.0E-10 < d7) {
                    n2 = n3;
                    if (d7 < 1.0E-10) {
                        arrd2[1] = (- d3) / 2.0 + d5;
                        n2 = 2;
                    }
                }
            }
        }
        return Crossing.fixRoots(arrd2, n2);
    }

    public static int solveQuad(double[] arrd, double[] arrd2) {
        double d2 = arrd[2];
        int n2 = 1;
        double d3 = arrd[1];
        double d4 = arrd[0];
        if (d2 == 0.0) {
            if (d3 == 0.0) {
                return -1;
            }
            arrd2[0] = (- d4) / d3;
        } else {
            if ((d4 = d3 * d3 - 4.0 * d2 * d4) < 0.0) {
                return 0;
            }
            d4 = Math.sqrt(d4);
            d3 = - d3;
            arrd2[0] = (d3 + d4) / (d2 *= 2.0);
            if (d4 != 0.0) {
                arrd2[1] = (d3 - d4) / d2;
                n2 = 2;
            }
        }
        return Crossing.fixRoots(arrd2, n2);
    }

    static void sortBound(double[] arrd, int n2) {
        int n3 = 0;
        while (n3 < n2 - 4) {
            int n4;
            int n5;
            int n6 = n3 + 4;
            int n7 = n3;
            for (n5 = n6; n5 < n2; n5 += 4) {
                n4 = n7;
                if (arrd[n7] > arrd[n5]) {
                    n4 = n5;
                }
                n7 = n4;
            }
            if (n7 != n3) {
                double d2 = arrd[n3];
                arrd[n3] = arrd[n7];
                arrd[n7] = d2;
                n5 = n3 + 1;
                d2 = arrd[n5];
                n4 = n7 + 1;
                arrd[n5] = arrd[n4];
                arrd[n4] = d2;
                n5 = n3 + 2;
                d2 = arrd[n5];
                n4 = n7 + 2;
                arrd[n5] = arrd[n4];
                arrd[n4] = d2;
                d2 = arrd[n3 += 3];
                n5 = n7 + 3;
                arrd[n3] = arrd[n5];
                arrd[n5] = d2;
            }
            n3 = n6;
        }
    }

    public static class CubicCurve {
        double Ax;
        double Ax3;
        double Ay;
        double Bx;
        double Bx2;
        double By;
        double Cx;
        double Cy;
        double ax;
        double ay;
        double bx;
        double by;
        double cx;
        double cy;

        public CubicCurve(double d2, double d3, double d4, double d5, double d6, double d7, double d8, double d9) {
            this.ax = d8 - d2;
            this.ay = d9 - d3;
            this.bx = d4 - d2;
            this.by = d5 - d3;
            this.cx = d6 - d2;
            this.cy = d7 - d3;
            this.Cx = this.bx + this.bx + this.bx;
            this.Bx = this.cx + this.cx + this.cx - this.Cx - this.Cx;
            this.Ax = this.ax - this.Bx - this.Cx;
            this.Cy = this.by + this.by + this.by;
            this.By = this.cy + this.cy + this.cy - this.Cy - this.Cy;
            this.Ay = this.ay - this.By - this.Cy;
            this.Ax3 = this.Ax + this.Ax + this.Ax;
            this.Bx2 = this.Bx + this.Bx;
        }

        int addBound(double[] arrd, int n2, double[] arrd2, int n3, double d2, double d3, boolean bl2, int n4) {
            int n5 = n2;
            n2 = n4;
            for (n4 = 0; n4 < n3; ++n4) {
                double d4 = arrd2[n4];
                int n6 = n5;
                int n7 = n2;
                if (d4 > -1.0E-5) {
                    n6 = n5;
                    n7 = n2;
                    if (d4 < 1.00001) {
                        double d5 = ((this.Ax * d4 + this.Bx) * d4 + this.Cx) * d4;
                        n6 = n5;
                        n7 = n2;
                        if (d2 <= d5) {
                            n6 = n5;
                            n7 = n2;
                            if (d5 <= d3) {
                                n6 = n5 + 1;
                                arrd[n5] = d4;
                                n5 = n6 + 1;
                                arrd[n6] = d5;
                                n6 = n5 + 1;
                                arrd[n5] = d4 * ((this.Ay * d4 + this.By) * d4 + this.Cy);
                                n5 = n6 + 1;
                                arrd[n6] = n2;
                                n6 = n5;
                                n7 = n2;
                                if (bl2) {
                                    n7 = n2 + 1;
                                    n6 = n5;
                                }
                            }
                        }
                    }
                }
                n5 = n6;
                n2 = n7;
            }
            return n5;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        int cross(double[] var1_1, int var2_2, double var3_3, double var5_4) {
            var14_5 = 0;
            var15_6 = 0;
            while (var14_5 < var2_2) {
                block17 : {
                    block20 : {
                        block21 : {
                            block19 : {
                                block18 : {
                                    var11_9 = var1_1[var14_5];
                                    var13_10 = var15_6;
                                    if (var11_9 < -1.0E-5) break block17;
                                    if (var11_9 <= 1.00001) break block18;
                                    var13_10 = var15_6;
                                    break block17;
                                }
                                if (var11_9 >= 1.0E-5) break block19;
                                var13_10 = var15_6;
                                if (var3_3 < 0.0) {
                                    if (this.bx != 0.0) {
                                        var7_7 = this.bx;
                                    } else {
                                        if (this.cx != this.bx) {
                                            var7_7 = this.cx;
                                            var9_8 = this.bx;
                                        } else {
                                            var7_7 = this.ax;
                                            var9_8 = this.cx;
                                        }
                                        var7_7 -= var9_8;
                                    }
                                    var13_10 = var15_6;
                                    if (var7_7 < 0.0) {
                                        var13_10 = var15_6 - 1;
                                    }
                                }
                                break block17;
                            }
                            if (var11_9 <= 0.99999) break block20;
                            var13_10 = var15_6;
                            if (var3_3 >= this.ay) break block17;
                            if (this.ax == this.cx) break block21;
                            var7_7 = this.ax;
                            var9_8 = this.cx;
                            ** GOTO lbl40
                        }
                        if (this.cx != this.bx) {
                            var7_7 = this.cx;
                            var9_8 = this.bx;
lbl40: // 2 sources:
                            var7_7 -= var9_8;
                        } else {
                            var7_7 = this.bx;
                        }
                        var13_10 = var15_6;
                        if (var7_7 > 0.0) {
                            var13_10 = var15_6 + 1;
                        }
                        break block17;
                    }
                    var13_10 = var15_6;
                    if (((this.Ay * var11_9 + this.By) * var11_9 + this.Cy) * var11_9 <= var5_4) break block17;
                    var7_7 = var9_8 = (this.Ax3 * var11_9 + this.Bx2) * var11_9 + this.Cx;
                    if (var9_8 <= -1.0E-5) ** GOTO lbl61
                    var7_7 = var9_8;
                    if (var9_8 >= 1.0E-5) ** GOTO lbl61
                    var7_7 = var11_9 * (this.Ax3 + this.Ax3) + this.Bx2;
                    var13_10 = var15_6;
                    if (var7_7 < -1.0E-5) break block17;
                    if (var7_7 > 1.0E-5) {
                        var13_10 = var15_6;
                    } else {
                        var7_7 = this.ax;
lbl61: // 3 sources:
                        var13_10 = var7_7 > 0.0 ? 1 : -1;
                        var13_10 = var15_6 + var13_10;
                    }
                }
                ++var14_5;
                var15_6 = var13_10;
            }
            return var15_6;
        }

        int solveExtremX(double[] arrd) {
            return Crossing.solveQuad(new double[]{this.Cx, this.Bx2, this.Ax3}, arrd);
        }

        int solveExtremY(double[] arrd) {
            return Crossing.solveQuad(new double[]{this.Cy, this.By + this.By, this.Ay + this.Ay + this.Ay}, arrd);
        }

        int solvePoint(double[] arrd, double d2) {
            return Crossing.solveCubic(new double[]{- d2, this.Cx, this.Bx, this.Ax}, arrd);
        }
    }

    public static class QuadCurve {
        double Ax;
        double Ay;
        double Bx;
        double By;
        double ax;
        double ay;
        double bx;
        double by;

        public QuadCurve(double d2, double d3, double d4, double d5, double d6, double d7) {
            this.ax = d6 - d2;
            this.ay = d7 - d3;
            this.bx = d4 - d2;
            this.by = d5 - d3;
            this.Bx = this.bx + this.bx;
            this.Ax = this.ax - this.Bx;
            this.By = this.by + this.by;
            this.Ay = this.ay - this.By;
        }

        int addBound(double[] arrd, int n2, double[] arrd2, int n3, double d2, double d3, boolean bl2, int n4) {
            int n5 = n2;
            n2 = n4;
            for (n4 = 0; n4 < n3; ++n4) {
                double d4 = arrd2[n4];
                int n6 = n5;
                int n7 = n2;
                if (d4 > -1.0E-5) {
                    n6 = n5;
                    n7 = n2;
                    if (d4 < 1.00001) {
                        double d5 = (this.Ax * d4 + this.Bx) * d4;
                        n6 = n5;
                        n7 = n2;
                        if (d2 <= d5) {
                            n6 = n5;
                            n7 = n2;
                            if (d5 <= d3) {
                                n6 = n5 + 1;
                                arrd[n5] = d4;
                                n5 = n6 + 1;
                                arrd[n6] = d5;
                                n6 = n5 + 1;
                                arrd[n5] = d4 * (this.Ay * d4 + this.By);
                                n5 = n6 + 1;
                                arrd[n6] = n2;
                                n6 = n5;
                                n7 = n2;
                                if (bl2) {
                                    n7 = n2 + 1;
                                    n6 = n5;
                                }
                            }
                        }
                    }
                }
                n5 = n6;
                n2 = n7;
            }
            return n5;
        }

        int cross(double[] arrd, int n2, double d2, double d3) {
            int n3 = 0;
            for (int i2 = 0; i2 < n2; ++i2) {
                double d4 = arrd[i2];
                int n4 = n3;
                if (d4 >= -1.0E-5) {
                    if (d4 > 1.00001) {
                        n4 = n3;
                    } else if (d4 < 1.0E-5) {
                        n4 = n3;
                        if (d2 < 0.0) {
                            d4 = this.bx != 0.0 ? this.bx : this.ax - this.bx;
                            n4 = n3;
                            if (d4 < 0.0) {
                                n4 = n3 - 1;
                            }
                        }
                    } else if (d4 > 0.99999) {
                        n4 = n3;
                        if (d2 < this.ay) {
                            d4 = this.ax != this.bx ? this.ax - this.bx : this.bx;
                            n4 = n3;
                            if (d4 > 0.0) {
                                n4 = n3 + 1;
                            }
                        }
                    } else {
                        n4 = n3;
                        if ((this.Ay * d4 + this.By) * d4 > d3) {
                            if ((d4 = d4 * this.Ax + this.bx) > -1.0E-5 && d4 < 1.0E-5) {
                                n4 = n3;
                            } else {
                                n4 = d4 > 0.0 ? 1 : -1;
                                n4 = n3 + n4;
                            }
                        }
                    }
                }
                n3 = n4;
            }
            return n3;
        }

        int solveExtrem(double[] arrd) {
            double d2 = this.Ax;
            int n2 = 0;
            if (d2 != 0.0) {
                arrd[0] = (- this.Bx) / (this.Ax + this.Ax);
                n2 = 1;
            }
            if (this.Ay != 0.0) {
                arrd[n2] = (- this.By) / (this.Ay + this.Ay);
                return n2 + 1;
            }
            return n2;
        }

        int solvePoint(double[] arrd, double d2) {
            return Crossing.solveQuad(new double[]{- d2, this.Bx, this.Ax}, arrd);
        }
    }

}

