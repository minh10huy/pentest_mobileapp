/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text;

import com.itextpdf.text.pdf.draw.DrawInterface;

public class TabStop {
    protected Alignment alignment = Alignment.LEFT;
    protected char anchorChar = (char)46;
    protected DrawInterface leader;
    protected float position;

    public TabStop(float f2) {
        this(f2, Alignment.LEFT);
    }

    public TabStop(float f2, Alignment alignment) {
        this(f2, null, alignment);
    }

    public TabStop(float f2, Alignment alignment, char c2) {
        this(f2, null, alignment, c2);
    }

    public TabStop(float f2, DrawInterface drawInterface) {
        this(f2, drawInterface, Alignment.LEFT);
    }

    public TabStop(float f2, DrawInterface drawInterface, Alignment alignment) {
        this(f2, drawInterface, alignment, '.');
    }

    public TabStop(float f2, DrawInterface drawInterface, Alignment alignment, char c2) {
        this.position = f2;
        this.leader = drawInterface;
        this.alignment = alignment;
        this.anchorChar = c2;
    }

    public TabStop(TabStop tabStop) {
        this(tabStop.getPosition(), tabStop.getLeader(), tabStop.getAlignment(), tabStop.getAnchorChar());
    }

    public static TabStop newInstance(float f2, float f3) {
        f2 = (float)Math.round(f2 * 1000.0f) / 1000.0f;
        f3 = (float)Math.round(f3 * 1000.0f) / 1000.0f;
        return new TabStop(f2 + f3 - f2 % f3);
    }

    public Alignment getAlignment() {
        return this.alignment;
    }

    public char getAnchorChar() {
        return this.anchorChar;
    }

    public DrawInterface getLeader() {
        return this.leader;
    }

    public float getPosition() {
        return this.position;
    }

    public float getPosition(float f2, float f3, float f4) {
        block10 : {
            float f5 = this.position;
            float f6 = f3 - f2;
            switch (.$SwitchMap$com$itextpdf$text$TabStop$Alignment[this.alignment.ordinal()]) {
                default: {
                    return f5;
                }
                case 3: {
                    if (!Float.isNaN(f4)) {
                        f3 = f2;
                        if (f4 < this.position) {
                            return this.position - (f4 - f2);
                        }
                    } else {
                        f3 = f2;
                        if (f2 + f6 < this.position) {
                            f2 = f6;
                            break;
                        }
                    }
                    break block10;
                }
                case 2: {
                    f4 = f6 / 2.0f;
                    f3 = f2;
                    if (f2 + f4 < this.position) {
                        f2 = f4;
                        break;
                    }
                    break block10;
                }
                case 1: {
                    f3 = f2;
                    if (f2 + f6 >= this.position) break block10;
                    f2 = f6;
                }
            }
            f3 = this.position - f2;
        }
        return f3;
    }

    public void setAlignment(Alignment alignment) {
        this.alignment = alignment;
    }

    public void setAnchorChar(char c2) {
        this.anchorChar = c2;
    }

    public void setLeader(DrawInterface drawInterface) {
        this.leader = drawInterface;
    }

    public void setPosition(float f2) {
        this.position = f2;
    }

    public static enum Alignment {
        LEFT,
        RIGHT,
        CENTER,
        ANCHOR;
        

        private Alignment() {
        }
    }

}

