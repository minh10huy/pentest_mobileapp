/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Font;
import com.itextpdf.text.FontProvider;
import com.itextpdf.text.log.Level;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.BaseFont;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Set;

public class FontFactoryImp
implements FontProvider {
    private static final Logger LOGGER = LoggerFactory.getLogger(FontFactoryImp.class);
    private static String[] TTFamilyOrder = new String[]{"3", "1", "1033", "3", "0", "1033", "1", "0", "0", "0", "3", "0"};
    public boolean defaultEmbedding = false;
    public String defaultEncoding = "Cp1252";
    private final Hashtable<String, ArrayList<String>> fontFamilies = new Hashtable();
    private final Hashtable<String, String> trueTypeFonts = new Hashtable();

    public FontFactoryImp() {
        this.trueTypeFonts.put("Courier".toLowerCase(), "Courier");
        this.trueTypeFonts.put("Courier-Bold".toLowerCase(), "Courier-Bold");
        this.trueTypeFonts.put("Courier-Oblique".toLowerCase(), "Courier-Oblique");
        this.trueTypeFonts.put("Courier-BoldOblique".toLowerCase(), "Courier-BoldOblique");
        this.trueTypeFonts.put("Helvetica".toLowerCase(), "Helvetica");
        this.trueTypeFonts.put("Helvetica-Bold".toLowerCase(), "Helvetica-Bold");
        this.trueTypeFonts.put("Helvetica-Oblique".toLowerCase(), "Helvetica-Oblique");
        this.trueTypeFonts.put("Helvetica-BoldOblique".toLowerCase(), "Helvetica-BoldOblique");
        this.trueTypeFonts.put("Symbol".toLowerCase(), "Symbol");
        this.trueTypeFonts.put("Times-Roman".toLowerCase(), "Times-Roman");
        this.trueTypeFonts.put("Times-Bold".toLowerCase(), "Times-Bold");
        this.trueTypeFonts.put("Times-Italic".toLowerCase(), "Times-Italic");
        this.trueTypeFonts.put("Times-BoldItalic".toLowerCase(), "Times-BoldItalic");
        this.trueTypeFonts.put("ZapfDingbats".toLowerCase(), "ZapfDingbats");
        ArrayList<String> arrayList = new ArrayList<String>();
        arrayList.add("Courier");
        arrayList.add("Courier-Bold");
        arrayList.add("Courier-Oblique");
        arrayList.add("Courier-BoldOblique");
        this.fontFamilies.put("Courier".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("Helvetica");
        arrayList.add("Helvetica-Bold");
        arrayList.add("Helvetica-Oblique");
        arrayList.add("Helvetica-BoldOblique");
        this.fontFamilies.put("Helvetica".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("Symbol");
        this.fontFamilies.put("Symbol".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("Times-Roman");
        arrayList.add("Times-Bold");
        arrayList.add("Times-Italic");
        arrayList.add("Times-BoldItalic");
        this.fontFamilies.put("Times".toLowerCase(), arrayList);
        this.fontFamilies.put("Times-Roman".toLowerCase(), arrayList);
        arrayList = new ArrayList();
        arrayList.add("ZapfDingbats");
        this.fontFamilies.put("ZapfDingbats".toLowerCase(), arrayList);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected BaseFont getBaseFont(String string2, String string3, boolean bl2, boolean bl3) {
        BaseFont baseFont;
        block2 : {
            try {
                baseFont = BaseFont.createFont(string2, string3, bl2, bl3, null, null, true);
                break block2;
            }
            catch (DocumentException documentException) {}
            baseFont = null;
        }
        BaseFont baseFont2 = baseFont;
        if (baseFont != null) return baseFont2;
        string2 = this.trueTypeFonts.get(string2.toLowerCase());
        baseFont2 = baseFont;
        if (string2 == null) return baseFont2;
        return BaseFont.createFont(string2, string3, bl2, bl3, null, null);
    }

    public Font getFont(String string2) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, -1.0f, -1, null);
    }

    public Font getFont(String string2, float f2) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f2, -1, null);
    }

    public Font getFont(String string2, float f2, int n2) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f2, n2, null);
    }

    public Font getFont(String string2, float f2, int n2, BaseColor baseColor) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f2, n2, baseColor);
    }

    public Font getFont(String string2, float f2, BaseColor baseColor) {
        return this.getFont(string2, this.defaultEncoding, this.defaultEmbedding, f2, -1, baseColor);
    }

    public Font getFont(String string2, String string3) {
        return this.getFont(string2, string3, this.defaultEmbedding, -1.0f, -1, null);
    }

    public Font getFont(String string2, String string3, float f2) {
        return this.getFont(string2, string3, this.defaultEmbedding, f2, -1, null);
    }

    public Font getFont(String string2, String string3, float f2, int n2) {
        return this.getFont(string2, string3, this.defaultEmbedding, f2, n2, null);
    }

    public Font getFont(String string2, String string3, float f2, int n2, BaseColor baseColor) {
        return this.getFont(string2, string3, this.defaultEmbedding, f2, n2, baseColor);
    }

    public Font getFont(String string2, String string3, boolean bl2) {
        return this.getFont(string2, string3, bl2, -1.0f, -1, null);
    }

    public Font getFont(String string2, String string3, boolean bl2, float f2) {
        return this.getFont(string2, string3, bl2, f2, -1, null);
    }

    public Font getFont(String string2, String string3, boolean bl2, float f2, int n2) {
        return this.getFont(string2, string3, bl2, f2, n2, null);
    }

    @Override
    public Font getFont(String string2, String string3, boolean bl2, float f2, int n2, BaseColor baseColor) {
        return this.getFont(string2, string3, bl2, f2, n2, baseColor, true);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public Font getFont(String object, String string2, boolean bl2, float f2, int n2, BaseColor baseColor, boolean bl3) {
        block11 : {
            int n3;
            if (object == null) {
                return new Font(Font.FontFamily.UNDEFINED, f2, n2, baseColor);
            }
            String string3 = object.toLowerCase();
            ArrayList<String> arrayList = this.fontFamilies.get(string3);
            if (arrayList == null) break block11;
            synchronized (arrayList) {
                boolean bl4;
                int n4;
                block12 : {
                    block10 : {
                        n4 = n2 == -1 ? 0 : n2;
                        Iterator<String> iterator = arrayList.iterator();
                        n3 = 0;
                        do {
                            boolean bl5 = iterator.hasNext();
                            bl4 = true;
                            if (!bl5) break block10;
                            string3 = iterator.next();
                            String string4 = string3.toLowerCase();
                            n3 = string4.indexOf("bold") != -1 ? 1 : 0;
                            if (string4.indexOf("italic") == -1 && string4.indexOf("oblique") == -1) continue;
                            n3 |= 2;
                        } while ((n4 & 3) != n3);
                        object = string3;
                        n4 = n3;
                        break block12;
                    }
                    bl4 = false;
                    n4 = n3;
                }
                n3 = n2;
                if (n2 != -1) {
                    n3 = n2;
                    if (bl4) {
                        n3 = n2 & n4;
                    }
                }
            }
            n2 = n3;
        }
        try {
            object = this.getBaseFont((String)object, string2, bl2, bl3);
            if (object != null) return new Font((BaseFont)object, f2, n2, baseColor);
            return new Font(Font.FontFamily.UNDEFINED, f2, n2, baseColor);
        }
        catch (DocumentException documentException) {
            throw new ExceptionConverter(documentException);
        }
        catch (IOException iOException) {
            return new Font(Font.FontFamily.UNDEFINED, f2, n2, baseColor);
        }
        catch (NullPointerException nullPointerException) {
            return new Font(Font.FontFamily.UNDEFINED, f2, n2, baseColor);
        }
    }

    public Set<String> getRegisteredFamilies() {
        return this.fontFamilies.keySet();
    }

    public Set<String> getRegisteredFonts() {
        return this.trueTypeFonts.keySet();
    }

    @Override
    public boolean isRegistered(String string2) {
        return this.trueTypeFonts.containsKey(string2.toLowerCase());
    }

    public void register(String string2) {
        this.register(string2, null);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void register(String var1_1, String var2_4) {
        block20 : {
            if (!var1_1.toLowerCase().endsWith(".ttf") && !var1_1.toLowerCase().endsWith(".otf") && var1_1.toLowerCase().indexOf(".ttc,") <= 0) {
                if (var1_1.toLowerCase().endsWith(".ttc")) {
                    if (var2_4 != null) {
                        FontFactoryImp.LOGGER.error("You can't define an alias for a true type collection.");
                    }
                    var2_4 = BaseFont.enumerateTTCNames(var1_1);
                    for (var3_5 = 0; var3_5 < ((Object)var2_4).length; ++var3_5) {
                        var7_7 = new StringBuilder();
                        var7_7.append(var1_1);
                        var7_7.append(",");
                        var7_7.append(var3_5);
                        this.register(var7_7.toString());
                    }
                    break block20;
                }
                if (!var1_1.toLowerCase().endsWith(".afm") && !var1_1.toLowerCase().endsWith(".pfm")) break block20;
                var8_19 = BaseFont.createFont(var1_1, "Cp1252", false);
                var2_4 = var8_19.getFullFontName()[0][3].toLowerCase();
                var7_8 = var8_19.getFamilyFontName()[0][3].toLowerCase();
                var8_19 = var8_19.getPostscriptFontName().toLowerCase();
                this.registerFamily(var7_8, (String)var2_4, null);
                this.trueTypeFonts.put((String)var8_19, var1_1);
                this.trueTypeFonts.put((String)var2_4, var1_1);
                break block20;
            }
            var8_20 = BaseFont.getAllFontNames(var1_1, "Cp1252", null);
            this.trueTypeFonts.put(((String)var8_20[0]).toLowerCase(), var1_1);
            if (var2_4 != null) {
                var2_4 = var2_4.toLowerCase();
                this.trueTypeFonts.put((String)var2_4, var1_1);
                if (var2_4.endsWith("regular")) {
                    this.saveCopyOfRegularFont((String)var2_4, var1_1);
                }
            }
            var2_4 = (String[][])var8_20[2];
            var4_21 = ((Object)var2_4).length;
            var3_6 = 0;
            do {
                if (var3_6 < var4_21) {
                    var7_9 = var2_4[var3_6][3].toLowerCase();
                    this.trueTypeFonts.put(var7_9, var1_1);
                    if (var7_9.endsWith("regular")) {
                        this.saveCopyOfRegularFont(var7_9, var1_1);
                    }
                } else {
                    var9_22 = (String[][])var8_20[1];
                    var2_4 = null;
                    var3_6 = 0;
                    break;
                }
                ++var3_6;
            } while (true);
lbl47: // 2 sources:
            if (var3_6 >= FontFactoryImp.TTFamilyOrder.length) break block20;
            var6_24 = var9_22.length;
            var4_21 = 0;
            do {
                var5_23 = var3_6;
                var7_12 = var2_4;
                if (var4_21 >= var6_24) break;
                var7_13 = var9_22[var4_21];
                try {
                    if (FontFactoryImp.TTFamilyOrder[var3_6].equals(var7_13[0]) && FontFactoryImp.TTFamilyOrder[var3_6 + 1].equals(var7_13[1]) && FontFactoryImp.TTFamilyOrder[var3_6 + 2].equals(var7_13[2])) {
                        var7_14 = var7_13[3].toLowerCase();
                        var5_23 = FontFactoryImp.TTFamilyOrder.length;
                        break;
                    }
                }
                catch (IOException var1_2) {
                    throw new ExceptionConverter(var1_2);
                }
                catch (DocumentException var1_3) {
                    throw new ExceptionConverter(var1_3);
                }
                ++var4_21;
            } while (true);
            var3_6 = var5_23 + 3;
            var2_4 = var7_17;
            ** GOTO lbl47
        }
        if (FontFactoryImp.LOGGER.isLogging(Level.TRACE) == false) return;
        FontFactoryImp.LOGGER.trace(String.format("Registered %s", new Object[]{var1_1}));
    }

    public int registerDirectories() {
        int n2;
        String string2 = System.getenv("windir");
        String string3 = System.getProperty("file.separator");
        int n3 = n2 = 0;
        if (string2 != null) {
            n3 = n2;
            if (string3 != null) {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append(string3);
                stringBuilder.append("fonts");
                n3 = 0 + this.registerDirectory(stringBuilder.toString());
            }
        }
        return n3 + this.registerDirectory("/usr/share/X11/fonts", true) + this.registerDirectory("/usr/X/lib/X11/fonts", true) + this.registerDirectory("/usr/openwin/lib/X11/fonts", true) + this.registerDirectory("/usr/share/fonts", true) + this.registerDirectory("/usr/X11R6/lib/X11/fonts", true) + this.registerDirectory("/Library/Fonts") + this.registerDirectory("/System/Library/Fonts");
    }

    public int registerDirectory(String string2) {
        return this.registerDirectory(string2, false);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public int registerDirectory(String string2, boolean bl2) {
        int n2;
        Object object;
        String[] arrstring;
        int n3;
        block16 : {
            if (LOGGER.isLogging(Level.DEBUG)) {
                LOGGER.debug(String.format("Registering directory %s, looking for fonts", string2));
            }
            try {
                object = new File(string2);
                if (!object.exists()) return 0;
                if (!object.isDirectory()) {
                    return 0;
                }
                arrstring = object.list();
                if (arrstring == null) {
                    return 0;
                }
                n3 = 0;
                n2 = 0;
                break block16;
            }
            catch (Exception exception) {}
            return 0;
        }
        do {
            int n4;
            block17 : {
                try {
                    int n5 = arrstring.length;
                    n4 = n2;
                    if (n3 >= n5) return n4;
                }
                catch (Exception exception) {
                    return n2;
                }
                try {
                    object = new File(string2, arrstring[n3]);
                    if (object.isDirectory()) {
                        n4 = n2;
                        if (bl2) {
                            n4 = n2 + this.registerDirectory(object.getAbsolutePath(), true);
                        }
                        break block17;
                    }
                    String string3 = object.getPath();
                    object = string3.length() < 4 ? null : string3.substring(string3.length() - 4).toLowerCase();
                    if (!".afm".equals(object) && !".pfm".equals(object)) {
                        if (!".ttf".equals(object) && !".otf".equals(object)) {
                            n4 = n2;
                            if (!".ttc".equals(object)) break block17;
                        }
                    } else {
                        object = new StringBuilder();
                        object.append(string3.substring(0, string3.length() - 4));
                        object.append(".pfb");
                        n4 = n2;
                        if (!new File(object.toString()).exists()) break block17;
                    }
                    this.register(string3, null);
                }
                catch (Exception exception) {
                    n4 = n2;
                }
                n4 = n2 + 1;
                {
                }
            }
            ++n3;
            n2 = n4;
        } while (true);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void registerFamily(String string2, String string3, String arrayList) {
        if (arrayList != null) {
            this.trueTypeFonts.put(string3, (String)((Object)arrayList));
        }
        Hashtable<String, ArrayList<String>> hashtable = this.fontFamilies;
        synchronized (hashtable) {
            ArrayList<String> arrayList2 = this.fontFamilies.get(string2);
            arrayList = arrayList2;
            if (arrayList2 == null) {
                arrayList = new ArrayList<String>();
                this.fontFamilies.put(string2, arrayList);
            }
        }
        synchronized (arrayList) {
            if (!arrayList.contains(string3)) {
                int n2;
                int n3 = string3.length();
                for (n2 = 0; n2 < arrayList.size(); ++n2) {
                    if (((String)arrayList.get(n2)).length() < n3) continue;
                    arrayList.add(n2, string3);
                    return;
                }
                n2 = 0;
                if (n2 == 0) {
                    arrayList.add(string3);
                    string2 = string3.toLowerCase();
                    if (string2.endsWith("regular")) {
                        arrayList.add(0, string3.substring(0, string2.substring(0, string2.length() - 7).trim().length()));
                    }
                }
            }
            return;
        }
    }

    protected boolean saveCopyOfRegularFont(String string2, String string3) {
        if (!this.trueTypeFonts.containsKey(string2 = string2.substring(0, string2.length() - 7).trim())) {
            this.trueTypeFonts.put(string2, string3);
            return true;
        }
        return false;
    }
}

