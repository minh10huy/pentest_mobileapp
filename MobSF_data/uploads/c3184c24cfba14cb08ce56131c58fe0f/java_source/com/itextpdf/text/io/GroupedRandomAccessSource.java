/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.io;

import com.itextpdf.text.io.RandomAccessSource;

class GroupedRandomAccessSource
implements RandomAccessSource {
    private SourceEntry currentSourceEntry;
    private final long size;
    private final SourceEntry[] sources;

    public GroupedRandomAccessSource(RandomAccessSource[] arrrandomAccessSource) {
        this.sources = new SourceEntry[arrrandomAccessSource.length];
        long l2 = 0L;
        for (int i2 = 0; i2 < arrrandomAccessSource.length; ++i2) {
            this.sources[i2] = new SourceEntry(i2, arrrandomAccessSource[i2], l2);
            l2 += arrrandomAccessSource[i2].length();
        }
        this.size = l2;
        this.currentSourceEntry = this.sources[arrrandomAccessSource.length - 1];
        this.sourceInUse(this.currentSourceEntry.source);
    }

    private SourceEntry getSourceEntryForOffset(long l2) {
        if (l2 >= this.size) {
            return null;
        }
        if (l2 >= this.currentSourceEntry.firstByte && l2 <= this.currentSourceEntry.lastByte) {
            return this.currentSourceEntry;
        }
        this.sourceReleased(this.currentSourceEntry.source);
        for (int i2 = this.getStartingSourceIndex((long)l2); i2 < this.sources.length; ++i2) {
            if (l2 < this.sources[i2].firstByte || l2 > this.sources[i2].lastByte) continue;
            this.currentSourceEntry = this.sources[i2];
            this.sourceInUse(this.currentSourceEntry.source);
            return this.currentSourceEntry;
        }
        return null;
    }

    @Override
    public void close() {
        SourceEntry[] arrsourceEntry = this.sources;
        int n2 = arrsourceEntry.length;
        for (int i2 = 0; i2 < n2; ++i2) {
            arrsourceEntry[i2].source.close();
        }
    }

    @Override
    public int get(long l2) {
        SourceEntry sourceEntry = this.getSourceEntryForOffset(l2);
        if (sourceEntry == null) {
            return -1;
        }
        return sourceEntry.source.get(sourceEntry.offsetN(l2));
    }

    @Override
    public int get(long l2, byte[] arrby, int n2, int n3) {
        SourceEntry sourceEntry = this.getSourceEntryForOffset(l2);
        if (sourceEntry == null) {
            return -1;
        }
        long l3 = sourceEntry.offsetN(l2);
        int n4 = n3;
        int n5 = n2;
        n2 = n4;
        while (n2 > 0 && sourceEntry != null && l3 <= sourceEntry.source.length() && (n4 = sourceEntry.source.get(l3, arrby, n5, n2)) != -1) {
            n5 += n4;
            n2 -= n4;
            l3 = 0L;
            sourceEntry = this.getSourceEntryForOffset(l2 += (long)n4);
        }
        if (n2 == n3) {
            return -1;
        }
        return n3 - n2;
    }

    protected int getStartingSourceIndex(long l2) {
        if (l2 >= this.currentSourceEntry.firstByte) {
            return this.currentSourceEntry.index;
        }
        return 0;
    }

    @Override
    public long length() {
        return this.size;
    }

    protected void sourceInUse(RandomAccessSource randomAccessSource) {
    }

    protected void sourceReleased(RandomAccessSource randomAccessSource) {
    }

    private static class SourceEntry {
        final long firstByte;
        final int index;
        final long lastByte;
        final RandomAccessSource source;

        public SourceEntry(int n2, RandomAccessSource randomAccessSource, long l2) {
            this.index = n2;
            this.source = randomAccessSource;
            this.firstByte = l2;
            this.lastByte = l2 + randomAccessSource.length() - 1L;
        }

        public long offsetN(long l2) {
            return l2 - this.firstByte;
        }
    }

}

