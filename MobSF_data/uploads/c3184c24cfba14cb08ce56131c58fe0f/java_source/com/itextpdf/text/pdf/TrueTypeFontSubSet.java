/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;

class TrueTypeFontSubSet {
    static final int ARG_1_AND_2_ARE_WORDS = 1;
    static final int HEAD_LOCA_FORMAT_OFFSET = 51;
    static final int MORE_COMPONENTS = 32;
    static final int TABLE_CHECKSUM = 0;
    static final int TABLE_LENGTH = 2;
    static final int TABLE_OFFSET = 1;
    static final int WE_HAVE_AN_X_AND_Y_SCALE = 64;
    static final int WE_HAVE_A_SCALE = 8;
    static final int WE_HAVE_A_TWO_BY_TWO = 128;
    static final int[] entrySelectors;
    static final String[] tableNamesCmap;
    static final String[] tableNamesExtra;
    static final String[] tableNamesSimple;
    protected int directoryOffset;
    protected String fileName;
    protected int fontPtr;
    protected int glyfTableRealSize;
    protected ArrayList<Integer> glyphsInList;
    protected HashSet<Integer> glyphsUsed;
    protected boolean includeCmap;
    protected boolean includeExtras;
    protected boolean locaShortTable;
    protected int[] locaTable;
    protected int locaTableRealSize;
    protected byte[] newGlyfTable;
    protected int[] newLocaTable;
    protected byte[] newLocaTableOut;
    protected byte[] outFont;
    protected RandomAccessFileOrArray rf;
    protected HashMap<String, int[]> tableDirectory;
    protected int tableGlyphOffset;

    static {
        tableNamesSimple = new String[]{"cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "prep"};
        tableNamesCmap = new String[]{"cmap", "cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "prep"};
        tableNamesExtra = new String[]{"OS/2", "cmap", "cvt ", "fpgm", "glyf", "head", "hhea", "hmtx", "loca", "maxp", "name, prep"};
        entrySelectors = new int[]{0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4};
    }

    TrueTypeFontSubSet(String string2, RandomAccessFileOrArray randomAccessFileOrArray, HashSet<Integer> hashSet, int n2, boolean bl2, boolean bl3) {
        this.fileName = string2;
        this.rf = randomAccessFileOrArray;
        this.glyphsUsed = hashSet;
        this.includeCmap = bl2;
        this.includeExtras = bl3;
        this.directoryOffset = n2;
        this.glyphsInList = new ArrayList<Integer>(hashSet);
    }

    protected void assembleFont() {
        int n2;
        int n3;
        Object object;
        int n4;
        int[] arrn;
        String[] arrstring = this.includeExtras ? tableNamesExtra : (this.includeCmap ? tableNamesCmap : tableNamesSimple);
        int n5 = 0;
        int n6 = 2;
        for (n4 = 0; n4 < arrstring.length; ++n4) {
            object = arrstring[n4];
            n2 = n5;
            n3 = n6;
            if (!object.equals("glyf")) {
                if (object.equals("loca")) {
                    n2 = n5;
                    n3 = n6;
                } else if ((object = this.tableDirectory.get(object)) == null) {
                    n2 = n5;
                    n3 = n6;
                } else {
                    n3 = n6 + 1;
                    n2 = n5 + (object[2] + 3 & -4);
                }
            }
            n5 = n2;
            n6 = n3;
        }
        n3 = this.newLocaTableOut.length;
        n2 = this.newGlyfTable.length;
        n4 = n6 * 16 + 12;
        this.outFont = new byte[n5 + n3 + n2 + n4];
        this.fontPtr = 0;
        this.writeFontInt(65536);
        this.writeFontShort(n6);
        n5 = entrySelectors[n6];
        n3 = 1 << n5;
        this.writeFontShort(n3 * 16);
        this.writeFontShort(n5);
        this.writeFontShort((n6 - n3) * 16);
        for (n5 = 0; n5 < arrstring.length; ++n5) {
            object = arrstring[n5];
            arrn = this.tableDirectory.get(object);
            if (arrn == null) continue;
            this.writeFontString((String)object);
            if (object.equals("glyf")) {
                this.writeFontInt(this.calculateChecksum(this.newGlyfTable));
                n6 = this.glyfTableRealSize;
            } else if (object.equals("loca")) {
                this.writeFontInt(this.calculateChecksum(this.newLocaTableOut));
                n6 = this.locaTableRealSize;
            } else {
                this.writeFontInt(arrn[0]);
                n6 = arrn[2];
            }
            this.writeFontInt(n4);
            this.writeFontInt(n6);
            n4 += n6 + 3 & -4;
        }
        for (n6 = 0; n6 < arrstring.length; ++n6) {
            object = arrstring[n6];
            arrn = this.tableDirectory.get(object);
            if (arrn == null) continue;
            if (object.equals("glyf")) {
                System.arraycopy(this.newGlyfTable, 0, this.outFont, this.fontPtr, this.newGlyfTable.length);
                this.fontPtr += this.newGlyfTable.length;
                this.newGlyfTable = null;
                continue;
            }
            if (object.equals("loca")) {
                System.arraycopy(this.newLocaTableOut, 0, this.outFont, this.fontPtr, this.newLocaTableOut.length);
                this.fontPtr += this.newLocaTableOut.length;
                this.newLocaTableOut = null;
                continue;
            }
            this.rf.seek(arrn[1]);
            this.rf.readFully(this.outFont, this.fontPtr, arrn[2]);
            this.fontPtr += arrn[2] + 3 & -4;
        }
    }

    protected int calculateChecksum(byte[] arrby) {
        int n2 = arrby.length / 4;
        int n3 = 0;
        int n4 = 0;
        int n5 = 0;
        int n6 = 0;
        int n7 = 0;
        for (int i2 = 0; i2 < n2; ++i2) {
            int n8 = n4 + 1;
            n3 += arrby[n4] & 255;
            n4 = n8 + 1;
            n5 += arrby[n8] & 255;
            n8 = n4 + 1;
            n6 += arrby[n4] & 255;
            n4 = n8 + 1;
            n7 += arrby[n8] & 255;
        }
        return n7 + (n6 << 8) + (n5 << 16) + (n3 << 24);
    }

    protected void checkGlyphComposite(int n2) {
        int n3 = this.locaTable[n2];
        if (n3 == this.locaTable[n2 + 1]) {
            return;
        }
        this.rf.seek(this.tableGlyphOffset + n3);
        if (this.rf.readShort() >= 0) {
            return;
        }
        Object object = this.rf;
        n3 = 8;
        do {
            object.skipBytes(n3);
            int n4 = this.rf.readUnsignedShort();
            object = this.rf.readUnsignedShort();
            if (!this.glyphsUsed.contains(object)) {
                this.glyphsUsed.add((Integer)object);
                this.glyphsInList.add((Integer)object);
            }
            if ((n4 & 32) == 0) {
                return;
            }
            n3 = (n4 & 1) != 0 ? 4 : 2;
            if ((n4 & 8) != 0) {
                n2 = n3 + 2;
            } else {
                n2 = n3;
                if ((n4 & 64) != 0) {
                    n2 = n3 + 4;
                }
            }
            n3 = n2;
            if ((n4 & 128) != 0) {
                n3 = n2 + 8;
            }
            object = this.rf;
        } while (true);
    }

    protected void createNewGlyphTables() {
        int n2;
        int n3;
        this.newLocaTable = new int[this.locaTable.length];
        int[] arrn = new int[this.glyphsInList.size()];
        int n4 = 0;
        for (n2 = 0; n2 < arrn.length; ++n2) {
            arrn[n2] = this.glyphsInList.get(n2);
        }
        Arrays.sort(arrn);
        int n5 = 0;
        for (n2 = 0; n2 < arrn.length; ++n2) {
            n3 = arrn[n2];
            n5 += this.locaTable[n3 + 1] - this.locaTable[n3];
        }
        this.glyfTableRealSize = n5;
        this.newGlyfTable = new byte[n5 + 3 & -4];
        n3 = 0;
        int n6 = 0;
        for (n5 = n4; n5 < this.newLocaTable.length; ++n5) {
            this.newLocaTable[n5] = n3;
            n4 = n3;
            n2 = n6;
            if (n6 < arrn.length) {
                n4 = n3;
                n2 = n6;
                if (arrn[n6] == n5) {
                    this.newLocaTable[n5] = n3;
                    int n7 = this.locaTable[n5];
                    int n8 = this.locaTable[n5 + 1] - n7;
                    n4 = n3;
                    n2 = ++n6;
                    if (n8 > 0) {
                        this.rf.seek(this.tableGlyphOffset + n7);
                        this.rf.readFully(this.newGlyfTable, n3, n8);
                        n4 = n3 + n8;
                        n2 = n6;
                    }
                }
            }
            n3 = n4;
            n6 = n2;
        }
    }

    protected void createTableDirectory() {
        this.tableDirectory = new HashMap();
        this.rf.seek(this.directoryOffset);
        if (this.rf.readInt() == 65536) {
            int n2 = this.rf.readUnsignedShort();
            this.rf.skipBytes(6);
            for (int i2 = 0; i2 < n2; ++i2) {
                String string2 = this.readStandardString(4);
                int n3 = this.rf.readInt();
                int n4 = this.rf.readInt();
                int n5 = this.rf.readInt();
                this.tableDirectory.put(string2, new int[]{n3, n4, n5});
            }
            return;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.true.type.file", this.fileName));
    }

    protected void flatGlyphs() {
        int[] arrn = this.tableDirectory.get("glyf");
        int n2 = 0;
        if (arrn != null) {
            Integer n3 = 0;
            if (!this.glyphsUsed.contains(n3)) {
                this.glyphsUsed.add(n3);
                this.glyphsInList.add(n3);
            }
            this.tableGlyphOffset = arrn[1];
            while (n2 < this.glyphsInList.size()) {
                this.checkGlyphComposite(this.glyphsInList.get(n2));
                ++n2;
            }
            return;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "glyf", this.fileName));
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void locaTobytes() {
        int n2 = this.locaShortTable ? this.newLocaTable.length * 2 : this.newLocaTable.length * 4;
        this.locaTableRealSize = n2;
        this.newLocaTableOut = new byte[this.locaTableRealSize + 3 & -4];
        this.outFont = this.newLocaTableOut;
        n2 = 0;
        this.fontPtr = 0;
        while (n2 < this.newLocaTable.length) {
            if (this.locaShortTable) {
                this.writeFontShort(this.newLocaTable[n2] / 2);
            } else {
                this.writeFontInt(this.newLocaTable[n2]);
            }
            ++n2;
        }
        return;
    }

    byte[] process() {
        try {
            this.rf.reOpen();
            this.createTableDirectory();
            this.readLoca();
            this.flatGlyphs();
            this.createNewGlyphTables();
            this.locaTobytes();
            this.assembleFont();
            byte[] arrby = this.outFont;
            return arrby;
        }
        finally {
            this.rf.close();
        }
    }

    protected void readLoca() {
        int[] arrn = this.tableDirectory.get("head");
        int n2 = 0;
        if (arrn != null) {
            this.rf.seek(arrn[1] + 51);
            boolean bl2 = this.rf.readUnsignedShort() == 0;
            this.locaShortTable = bl2;
            arrn = this.tableDirectory.get("loca");
            if (arrn != null) {
                int n3;
                this.rf.seek(arrn[1]);
                if (this.locaShortTable) {
                    n2 = arrn[2] / 2;
                    this.locaTable = new int[n2];
                    for (n3 = 0; n3 < n2; ++n3) {
                        this.locaTable[n3] = this.rf.readUnsignedShort() * 2;
                    }
                } else {
                    int n4 = arrn[2] / 4;
                    this.locaTable = new int[n4];
                    for (n3 = n2; n3 < n4; ++n3) {
                        this.locaTable[n3] = this.rf.readInt();
                    }
                }
                return;
            }
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "loca", this.fileName));
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "head", this.fileName));
    }

    protected String readStandardString(int n2) {
        Object object = new byte[n2];
        this.rf.readFully((byte[])object);
        try {
            object = new String((byte[])object, "Cp1252");
            return object;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    protected void writeFontInt(int n2) {
        byte[] arrby = this.outFont;
        int n3 = this.fontPtr;
        this.fontPtr = n3 + 1;
        arrby[n3] = (byte)(n2 >> 24);
        arrby = this.outFont;
        n3 = this.fontPtr;
        this.fontPtr = n3 + 1;
        arrby[n3] = (byte)(n2 >> 16);
        arrby = this.outFont;
        n3 = this.fontPtr;
        this.fontPtr = n3 + 1;
        arrby[n3] = (byte)(n2 >> 8);
        arrby = this.outFont;
        n3 = this.fontPtr;
        this.fontPtr = n3 + 1;
        arrby[n3] = (byte)n2;
    }

    protected void writeFontShort(int n2) {
        byte[] arrby = this.outFont;
        int n3 = this.fontPtr;
        this.fontPtr = n3 + 1;
        arrby[n3] = (byte)(n2 >> 8);
        arrby = this.outFont;
        n3 = this.fontPtr;
        this.fontPtr = n3 + 1;
        arrby[n3] = (byte)n2;
    }

    protected void writeFontString(String arrby) {
        arrby = PdfEncodings.convertToBytes((String)arrby, "Cp1252");
        System.arraycopy(arrby, 0, this.outFont, this.fontPtr, arrby.length);
        this.fontPtr += arrby.length;
    }
}

