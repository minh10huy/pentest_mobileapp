/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.awt.geom.Point2D;
import com.itextpdf.text.pdf.parser.BezierCurve;
import com.itextpdf.text.pdf.parser.Line;
import com.itextpdf.text.pdf.parser.Shape;
import com.itextpdf.text.pdf.parser.Subpath;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

public class Path {
    private static final String START_PATH_ERR_MSG = "Path shall start with \"re\" or \"m\" operator";
    private Point2D currentPoint;
    private List<Subpath> subpaths = new ArrayList<Subpath>();

    public Path() {
    }

    public Path(List<? extends Subpath> list) {
        this.addSubpaths(list);
    }

    private Subpath getLastSubpath() {
        if (this.subpaths.size() > 0) {
            return this.subpaths.get(this.subpaths.size() - 1);
        }
        return null;
    }

    public void addSubpath(Subpath subpath) {
        this.subpaths.add(subpath);
        this.currentPoint = subpath.getLastPoint();
    }

    public void addSubpaths(List<? extends Subpath> list) {
        if (list.size() > 0) {
            this.subpaths.addAll(list);
            this.currentPoint = this.subpaths.get(list.size() - 1).getLastPoint();
        }
    }

    public void closeAllSubpaths() {
        Iterator<Subpath> iterator = this.subpaths.iterator();
        while (iterator.hasNext()) {
            iterator.next().setClosed(true);
        }
    }

    public void closeSubpath() {
        Object object = this.getLastSubpath();
        object.setClosed(true);
        object = object.getStartPoint();
        this.moveTo((float)object.getX(), (float)object.getY());
    }

    public void curveFromTo(float f2, float f3, float f4, float f5) {
        if (this.currentPoint != null) {
            this.curveTo(f2, f3, f4, f5, f4, f5);
            return;
        }
        throw new RuntimeException(START_PATH_ERR_MSG);
    }

    public void curveTo(float f2, float f3, float f4, float f5) {
        if (this.currentPoint != null) {
            this.curveTo((float)this.currentPoint.getX(), (float)this.currentPoint.getY(), f2, f3, f4, f5);
            return;
        }
        throw new RuntimeException(START_PATH_ERR_MSG);
    }

    public void curveTo(float f2, float f3, float f4, float f5, float f6, float f7) {
        if (this.currentPoint != null) {
            Cloneable cloneable = new Point2D.Float(f2, f3);
            Point2D.Float float_ = new Point2D.Float(f4, f5);
            Point2D.Float float_2 = new Point2D.Float(f6, f7);
            cloneable = new ArrayList<Point2D>(Arrays.asList(this.currentPoint, cloneable, float_, float_2));
            this.getLastSubpath().addSegment(new BezierCurve((List<Point2D>)((Object)cloneable)));
            this.currentPoint = float_2;
            return;
        }
        throw new RuntimeException(START_PATH_ERR_MSG);
    }

    public Point2D getCurrentPoint() {
        return this.currentPoint;
    }

    public List<Subpath> getSubpaths() {
        return this.subpaths;
    }

    public boolean isEmpty() {
        if (this.subpaths.size() == 0) {
            return true;
        }
        return false;
    }

    public void lineTo(float f2, float f3) {
        if (this.currentPoint != null) {
            Point2D.Float float_ = new Point2D.Float(f2, f3);
            this.getLastSubpath().addSegment(new Line(this.currentPoint, float_));
            this.currentPoint = float_;
            return;
        }
        throw new RuntimeException(START_PATH_ERR_MSG);
    }

    public void moveTo(float f2, float f3) {
        this.currentPoint = new Point2D.Float(f2, f3);
        Subpath subpath = this.getLastSubpath();
        if (subpath != null && subpath.isSinglePointOpen()) {
            subpath.setStartPoint(this.currentPoint);
            return;
        }
        this.subpaths.add(new Subpath(this.currentPoint));
    }

    public void rectangle(float f2, float f3, float f4, float f5) {
        this.moveTo(f2, f3);
        this.lineTo(f4 += f2, f3);
        this.lineTo(f4, f3 += f5);
        this.lineTo(f2, f3);
        this.closeSubpath();
    }

    public List<Integer> replaceCloseWithLine() {
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        Iterator<Subpath> iterator = this.subpaths.iterator();
        int n2 = 0;
        while (iterator.hasNext()) {
            Subpath subpath = iterator.next();
            if (subpath.isClosed()) {
                subpath.setClosed(false);
                subpath.addSegment(new Line(subpath.getLastPoint(), subpath.getStartPoint()));
                arrayList.add(n2);
            }
            ++n2;
        }
        return arrayList;
    }
}

