/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Clipper;
import com.itextpdf.text.pdf.parser.clipper.ClipperBase;
import com.itextpdf.text.pdf.parser.clipper.Edge;
import com.itextpdf.text.pdf.parser.clipper.Path;
import com.itextpdf.text.pdf.parser.clipper.Paths;
import com.itextpdf.text.pdf.parser.clipper.Point;
import com.itextpdf.text.pdf.parser.clipper.PolyNode;
import com.itextpdf.text.pdf.parser.clipper.PolyTree;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.logging.Logger;

public class DefaultClipper
extends ClipperBase {
    private static final Logger LOGGER = Logger.getLogger(DefaultClipper.class.getName());
    private Edge activeEdges;
    private Clipper.PolyFillType clipFillType;
    private Clipper.ClipType clipType;
    private final List<Path.Join> ghostJoins;
    private final List<IntersectNode> intersectList;
    private final Comparator<IntersectNode> intersectNodeComparer;
    private final List<Path.Join> joins;
    private Path.Maxima maxima;
    protected final List<Path.OutRec> polyOuts;
    private final boolean reverseSolution;
    private ClipperBase.Scanbeam scanbeam;
    private Edge sortedEdges;
    private final boolean strictlySimple;
    private Clipper.PolyFillType subjFillType;
    private boolean usingPolyTree;
    public Clipper.ZFillCallback zFillFunction;

    public DefaultClipper() {
        this(0);
    }

    public DefaultClipper(int n2) {
        boolean bl2 = false;
        boolean bl3 = (n2 & 4) != 0;
        super(bl3);
        this.scanbeam = null;
        this.maxima = null;
        this.activeEdges = null;
        this.sortedEdges = null;
        this.intersectList = new ArrayList<IntersectNode>();
        this.intersectNodeComparer = new Comparator<IntersectNode>(){

            @Override
            public int compare(IntersectNode intersectNode, IntersectNode intersectNode2) {
                long l2 = intersectNode2.getPt().getY() - intersectNode.getPt().getY() LCMP 0L;
                if (l2 > 0) {
                    return 1;
                }
                if (l2 < 0) {
                    return -1;
                }
                return 0;
            }
        };
        this.usingPolyTree = false;
        this.polyOuts = new ArrayList<Path.OutRec>();
        this.joins = new ArrayList<Path.Join>();
        this.ghostJoins = new ArrayList<Path.Join>();
        bl3 = (n2 & 1) != 0;
        this.reverseSolution = bl3;
        bl3 = bl2;
        if ((n2 & 2) != 0) {
            bl3 = true;
        }
        this.strictlySimple = bl3;
        this.zFillFunction = null;
    }

    private boolean EdgesAdjacent(IntersectNode intersectNode) {
        if (intersectNode.edge1.nextInSEL != intersectNode.Edge2 && intersectNode.edge1.prevInSEL != intersectNode.Edge2) {
            return false;
        }
        return true;
    }

    private Path.OutPt GetLastOutPt(Edge edge) {
        Path.OutRec outRec = this.polyOuts.get(edge.outIdx);
        if (edge.side == Edge.Side.LEFT) {
            return outRec.pts;
        }
        return outRec.pts.prev;
    }

    private void InsertMaxima(long l2) {
        Path.Maxima maxima = new Path.Maxima();
        maxima.X = l2;
        if (this.maxima == null) {
            this.maxima = maxima;
            this.maxima.Next = null;
            this.maxima.Prev = null;
            return;
        }
        if (l2 < this.maxima.X) {
            maxima.Next = this.maxima;
            maxima.Prev = null;
            this.maxima = maxima;
            return;
        }
        Path.Maxima maxima2 = this.maxima;
        while (maxima2.Next != null && l2 >= maxima2.Next.X) {
            maxima2 = maxima2.Next;
        }
        if (l2 == maxima2.X) {
            return;
        }
        maxima.Next = maxima2.Next;
        maxima.Prev = maxima2;
        if (maxima2.Next != null) {
            maxima2.Next.Prev = maxima;
        }
        maxima2.Next = maxima;
    }

    private void addEdgeToSEL(Edge edge) {
        LOGGER.entering(DefaultClipper.class.getName(), "addEdgeToSEL");
        if (this.sortedEdges == null) {
            this.sortedEdges = edge;
            edge.prevInSEL = null;
            edge.nextInSEL = null;
            return;
        }
        edge.nextInSEL = this.sortedEdges;
        edge.prevInSEL = null;
        this.sortedEdges.prevInSEL = edge;
        this.sortedEdges = edge;
    }

    private void addGhostJoin(Path.OutPt outPt, Point.LongPoint longPoint) {
        Path.Join join = new Path.Join();
        join.outPt1 = outPt;
        join.setOffPt(longPoint);
        this.ghostJoins.add(join);
    }

    private void addJoin(Path.OutPt outPt, Path.OutPt outPt2, Point.LongPoint longPoint) {
        LOGGER.entering(DefaultClipper.class.getName(), "addJoin");
        Path.Join join = new Path.Join();
        join.outPt1 = outPt;
        join.outPt2 = outPt2;
        join.setOffPt(longPoint);
        this.joins.add(join);
    }

    private void addLocalMaxPoly(Edge edge, Edge edge2, Point.LongPoint longPoint) {
        this.addOutPt(edge, longPoint);
        if (edge2.windDelta == 0) {
            this.addOutPt(edge2, longPoint);
        }
        if (edge.outIdx == edge2.outIdx) {
            edge.outIdx = -1;
            edge2.outIdx = -1;
            return;
        }
        if (edge.outIdx < edge2.outIdx) {
            this.appendPolygon(edge, edge2);
            return;
        }
        this.appendPolygon(edge2, edge);
    }

    /*
     * Enabled aggressive block sorting
     */
    private Path.OutPt addLocalMinPoly(Edge edge, Edge edge2, Point.LongPoint longPoint) {
        Path.OutPt outPt;
        LOGGER.entering(DefaultClipper.class.getName(), "addLocalMinPoly");
        if (!edge2.isHorizontal() && edge.deltaX <= edge2.deltaX) {
            outPt = this.addOutPt(edge2, longPoint);
            edge.outIdx = edge2.outIdx;
            edge.side = Edge.Side.RIGHT;
            edge2.side = Edge.Side.LEFT;
            edge = edge2.prevInAEL == edge ? edge.prevInAEL : edge2.prevInAEL;
        } else {
            outPt = this.addOutPt(edge, longPoint);
            edge2.outIdx = edge.outIdx;
            edge.side = Edge.Side.LEFT;
            edge2.side = Edge.Side.RIGHT;
            edge2 = edge.prevInAEL == edge2 ? edge2.prevInAEL : edge.prevInAEL;
            Edge edge3 = edge;
            edge = edge2;
            edge2 = edge3;
        }
        if (edge != null && edge.outIdx >= 0 && Edge.topX(edge, longPoint.getY()) == Edge.topX(edge2, longPoint.getY()) && Edge.slopesEqual(edge2, edge, this.useFullRange) && edge2.windDelta != 0 && edge.windDelta != 0) {
            this.addJoin(outPt, this.addOutPt(edge, longPoint), edge2.getTop());
        }
        return outPt;
    }

    private Path.OutPt addOutPt(Edge object, Point.LongPoint longPoint) {
        LOGGER.entering(DefaultClipper.class.getName(), "addOutPt");
        int n2 = object.outIdx;
        boolean bl2 = false;
        boolean bl3 = false;
        if (n2 < 0) {
            Path.OutPt outPt;
            Path.OutRec outRec = this.createOutRec();
            if (object.windDelta == 0) {
                bl3 = true;
            }
            outRec.isOpen = bl3;
            outRec.pts = outPt = new Path.OutPt();
            outPt.idx = outRec.Idx;
            outPt.pt = longPoint;
            outPt.next = outPt;
            outPt.prev = outPt;
            if (!outRec.isOpen) {
                this.setHoleState((Edge)object, outRec);
            }
            object.outIdx = outRec.Idx;
            return outPt;
        }
        Path.OutRec outRec = this.polyOuts.get(object.outIdx);
        Path.OutPt outPt = outRec.getPoints();
        bl3 = bl2;
        if (object.side == Edge.Side.LEFT) {
            bl3 = true;
        }
        object = LOGGER;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("op=");
        stringBuilder.append(outPt.getPointCount());
        object.finest(stringBuilder.toString());
        object = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append(bl3);
        stringBuilder.append(" ");
        stringBuilder.append(longPoint);
        stringBuilder.append(" ");
        stringBuilder.append(outPt.getPt());
        object.finest(stringBuilder.toString());
        if (bl3 && longPoint.equals(outPt.getPt())) {
            return outPt;
        }
        if (!bl3 && longPoint.equals(outPt.prev.getPt())) {
            return outPt.prev;
        }
        object = new Path.OutPt();
        object.idx = outRec.Idx;
        object.setPt(new Point.LongPoint(longPoint));
        object.next = outPt;
        object.prev = outPt.prev;
        object.prev.next = object;
        outPt.prev = object;
        if (bl3) {
            outRec.setPoints((Path.OutPt)object);
        }
        return object;
    }

    private void appendPolygon(Edge edge, Edge edge2) {
        LOGGER.entering(DefaultClipper.class.getName(), "appendPolygon");
        Path.OutRec outRec = this.polyOuts.get(edge.outIdx);
        Path.OutRec outRec2 = this.polyOuts.get(edge2.outIdx);
        Object object = LOGGER;
        Object object2 = new StringBuilder();
        object2.append("");
        object2.append(edge.outIdx);
        object.finest(object2.toString());
        object = LOGGER;
        object2 = new StringBuilder();
        object2.append("");
        object2.append(edge2.outIdx);
        object.finest(object2.toString());
        object = DefaultClipper.isParam1RightOfParam2(outRec, outRec2) ? outRec2 : (DefaultClipper.isParam1RightOfParam2(outRec2, outRec) ? outRec : Path.OutPt.getLowerMostRec(outRec, outRec2));
        object2 = outRec.getPoints();
        Path.OutPt outPt = object2.prev;
        Path.OutPt outPt2 = outRec2.getPoints();
        Path.OutPt outPt3 = outPt2.prev;
        Logger logger = LOGGER;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("p1_lft.getPointCount() = ");
        stringBuilder.append(object2.getPointCount());
        logger.finest(stringBuilder.toString());
        logger = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append("p1_rt.getPointCount() = ");
        stringBuilder.append(outPt.getPointCount());
        logger.finest(stringBuilder.toString());
        logger = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append("p2_lft.getPointCount() = ");
        stringBuilder.append(outPt2.getPointCount());
        logger.finest(stringBuilder.toString());
        logger = LOGGER;
        stringBuilder = new StringBuilder();
        stringBuilder.append("p2_rt.getPointCount() = ");
        stringBuilder.append(outPt3.getPointCount());
        logger.finest(stringBuilder.toString());
        if (edge.side == Edge.Side.LEFT) {
            if (edge2.side == Edge.Side.LEFT) {
                outPt2.reversePolyPtLinks();
                outPt2.next = object2;
                object2.prev = outPt2;
                outPt.next = outPt3;
                outPt3.prev = outPt;
                outRec.setPoints(outPt3);
            } else {
                outPt3.next = object2;
                object2.prev = outPt3;
                outPt2.prev = outPt;
                outPt.next = outPt2;
                outRec.setPoints(outPt2);
            }
            object2 = Edge.Side.LEFT;
        } else {
            if (edge2.side == Edge.Side.RIGHT) {
                outPt2.reversePolyPtLinks();
                outPt.next = outPt3;
                outPt3.prev = outPt;
                outPt2.next = object2;
                object2.prev = outPt2;
            } else {
                outPt.next = outPt2;
                outPt2.prev = outPt;
                object2.prev = outPt3;
                outPt3.next = object2;
            }
            object2 = Edge.Side.RIGHT;
        }
        outRec.bottomPt = null;
        if (object.equals(outRec2)) {
            if (outRec2.firstLeft != outRec) {
                outRec.firstLeft = outRec2.firstLeft;
            }
            outRec.isHole = outRec2.isHole;
        }
        outRec2.setPoints(null);
        outRec2.bottomPt = null;
        outRec2.firstLeft = outRec;
        int n2 = edge.outIdx;
        int n3 = edge2.outIdx;
        edge.outIdx = -1;
        edge2.outIdx = -1;
        edge = this.activeEdges;
        while (edge != null) {
            if (edge.outIdx == n3) {
                edge.outIdx = n2;
                edge.side = object2;
                break;
            }
            edge = edge.nextInAEL;
        }
        outRec2.Idx = outRec.Idx;
    }

    private void buildIntersectList(long l2) {
        Edge edge;
        if (this.activeEdges == null) {
            return;
        }
        this.sortedEdges = edge = this.activeEdges;
        while (edge != null) {
            edge.prevInSEL = edge.prevInAEL;
            edge.nextInSEL = edge.nextInAEL;
            edge.getCurrent().setX(Edge.topX(edge, l2));
            edge = edge.nextInAEL;
        }
        boolean bl2 = true;
        while (bl2 && this.sortedEdges != null) {
            edge = this.sortedEdges;
            bl2 = false;
            while (edge.nextInSEL != null) {
                Edge edge2 = edge.nextInSEL;
                Point.LongPoint[] arrlongPoint = new Point.LongPoint[1];
                if (edge.getCurrent().getX() > edge2.getCurrent().getX()) {
                    this.intersectPoint(edge, edge2, arrlongPoint);
                    IntersectNode intersectNode = new IntersectNode();
                    intersectNode.edge1 = edge;
                    intersectNode.Edge2 = edge2;
                    intersectNode.setPt(arrlongPoint[0]);
                    this.intersectList.add(intersectNode);
                    this.swapPositionsInSEL(edge, edge2);
                    bl2 = true;
                    continue;
                }
                edge = edge2;
            }
            if (edge.prevInSEL == null) break;
            edge.prevInSEL.nextInSEL = null;
        }
        this.sortedEdges = null;
    }

    private void buildResult(Paths paths) {
        paths.clear();
        for (int i2 = 0; i2 < this.polyOuts.size(); ++i2) {
            Object object = this.polyOuts.get(i2);
            if (object.getPoints() == null) continue;
            object = object.getPoints().prev;
            int n2 = object.getPointCount();
            Object object2 = LOGGER;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("cnt = ");
            stringBuilder.append(n2);
            object2.finest(stringBuilder.toString());
            if (n2 < 2) continue;
            object2 = new Path(n2);
            for (int i3 = 0; i3 < n2; ++i3) {
                object2.add(object.getPt());
                object = object.prev;
            }
            paths.add(object2);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void buildResult2(PolyTree var1_1) {
        var1_1.Clear();
        var5_2 = 0;
        var2_3 = 0;
        do {
            var3_4 = var5_2;
            if (var2_3 >= this.polyOuts.size()) break;
            var6_6 = this.polyOuts.get(var2_3);
            var3_4 = var6_6.getPoints() != null ? var6_6.getPoints().getPointCount() : 0;
            if (!(var6_6.isOpen && var3_4 < 2 || !var6_6.isOpen && var3_4 < 3)) {
                var6_6.fixHoleLinkage();
                var7_7 = new PolyNode();
                var1_1.getAllPolys().add(var7_7);
                var6_6.polyNode = var7_7;
                var6_6 = var6_6.getPoints().prev;
                for (var4_5 = 0; var4_5 < var3_4; ++var4_5) {
                    var7_7.getPolygon().add(var6_6.getPt());
                    var6_6 = var6_6.prev;
                }
            }
            ++var2_3;
        } while (true);
        while (var3_4 < this.polyOuts.size()) {
            block6 : {
                block7 : {
                    var6_6 = this.polyOuts.get(var3_4);
                    if (var6_6.polyNode == null) break block6;
                    if (!var6_6.isOpen) break block7;
                    var6_6.polyNode.setOpen(true);
                    ** GOTO lbl-1000
                }
                if (var6_6.firstLeft != null && var6_6.firstLeft.polyNode != null) {
                    var6_6.firstLeft.polyNode.addChild(var6_6.polyNode);
                } else lbl-1000: // 2 sources:
                {
                    var1_1.addChild(var6_6.polyNode);
                }
            }
            ++var3_4;
        }
    }

    private void copyAELToSEL() {
        Edge edge;
        this.sortedEdges = edge = this.activeEdges;
        while (edge != null) {
            edge.prevInSEL = edge.prevInAEL;
            edge.nextInSEL = edge.nextInAEL;
            edge = edge.nextInAEL;
        }
    }

    private Path.OutRec createOutRec() {
        Path.OutRec outRec = new Path.OutRec();
        outRec.Idx = -1;
        outRec.isHole = false;
        outRec.isOpen = false;
        outRec.firstLeft = null;
        outRec.setPoints(null);
        outRec.bottomPt = null;
        outRec.polyNode = null;
        this.polyOuts.add(outRec);
        outRec.Idx = this.polyOuts.size() - 1;
        return outRec;
    }

    private void deleteFromAEL(Edge edge) {
        LOGGER.entering(DefaultClipper.class.getName(), "deleteFromAEL");
        Edge edge2 = edge.prevInAEL;
        Edge edge3 = edge.nextInAEL;
        if (edge2 == null && edge3 == null && edge != this.activeEdges) {
            return;
        }
        if (edge2 != null) {
            edge2.nextInAEL = edge3;
        } else {
            this.activeEdges = edge3;
        }
        if (edge3 != null) {
            edge3.prevInAEL = edge2;
        }
        edge.nextInAEL = null;
        edge.prevInAEL = null;
        LOGGER.exiting(DefaultClipper.class.getName(), "deleteFromAEL");
    }

    private void deleteFromSEL(Edge edge) {
        LOGGER.entering(DefaultClipper.class.getName(), "deleteFromSEL");
        Edge edge2 = edge.prevInSEL;
        Edge edge3 = edge.nextInSEL;
        if (edge2 == null && edge3 == null && !edge.equals(this.sortedEdges)) {
            return;
        }
        if (edge2 != null) {
            edge2.nextInSEL = edge3;
        } else {
            this.sortedEdges = edge3;
        }
        if (edge3 != null) {
            edge3.prevInSEL = edge2;
        }
        edge.nextInSEL = null;
        edge.prevInSEL = null;
    }

    private boolean doHorzSegmentsOverlap(long l2, long l3, long l4, long l5) {
        long l6 = l2;
        long l7 = l3;
        if (l2 > l3) {
            l7 = l2;
            l6 = l3;
        }
        if (l4 > l5) {
            l2 = l5;
        } else {
            l2 = l4;
            l4 = l5;
        }
        if (l6 < l4 && l2 < l7) {
            return true;
        }
        return false;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void doMaxima(Edge var1_1) {
        var2_2 = var1_1.getMaximaPair();
        if (var2_2 == null) {
            if (var1_1.outIdx >= 0) {
                this.addOutPt(var1_1, var1_1.getTop());
            }
            this.deleteFromAEL(var1_1);
            return;
        }
        while ((var3_3 = var1_1.nextInAEL) != null && var3_3 != var2_2) {
            var4_4 = new Point.LongPoint(var1_1.getTop());
            this.intersectEdges(var1_1, var3_3, var4_4);
            var1_1.setTop(var4_4);
            this.swapPositionsInAEL(var1_1, var3_3);
        }
        if (var1_1.outIdx == -1 && var2_2.outIdx == -1) ** GOTO lbl17
        if (var1_1.outIdx >= 0 && var2_2.outIdx >= 0) {
            if (var1_1.outIdx >= 0) {
                this.addLocalMaxPoly(var1_1, var2_2, var1_1.getTop());
            }
lbl17: // 4 sources:
            this.deleteFromAEL(var1_1);
        } else {
            if (var1_1.windDelta != 0) throw new IllegalStateException("DoMaxima error");
            if (var1_1.outIdx >= 0) {
                this.addOutPt(var1_1, var1_1.getTop());
                var1_1.outIdx = -1;
            }
            this.deleteFromAEL(var1_1);
            if (var2_2.outIdx >= 0) {
                this.addOutPt(var2_2, var1_1.getTop());
                var2_2.outIdx = -1;
            }
        }
        this.deleteFromAEL(var2_2);
    }

    private void doSimplePolygons() {
        for (int i2 = 0; i2 < this.polyOuts.size(); ++i2) {
            Path.OutPt outPt;
            Path.OutRec outRec = this.polyOuts.get(i2);
            Path.OutPt outPt2 = outRec.getPoints();
            if (outPt2 == null || outRec.isOpen) continue;
            do {
                outPt = outPt2.next;
                while (outPt != outRec.getPoints()) {
                    Object object = outPt;
                    if (outPt2.getPt().equals(outPt.getPt())) {
                        object = outPt;
                        if (!outPt.next.equals(outPt2)) {
                            object = outPt;
                            if (!outPt.prev.equals(outPt2)) {
                                Path.OutPt outPt3;
                                object = outPt2.prev;
                                outPt2.prev = outPt3 = outPt.prev;
                                outPt3.next = outPt2;
                                outPt.prev = object;
                                object.next = outPt;
                                outRec.setPoints(outPt2);
                                object = this.createOutRec();
                                object.setPoints(outPt);
                                this.updateOutPtIdxs((Path.OutRec)object);
                                if (DefaultClipper.poly2ContainsPoly1(object.getPoints(), outRec.getPoints())) {
                                    object.isHole = outRec.isHole ^ true;
                                    object.firstLeft = outRec;
                                    if (this.usingPolyTree) {
                                        this.fixupFirstLefts2((Path.OutRec)object, outRec);
                                    }
                                } else if (DefaultClipper.poly2ContainsPoly1(outRec.getPoints(), object.getPoints())) {
                                    object.isHole = outRec.isHole;
                                    outRec.isHole = object.isHole ^ true;
                                    object.firstLeft = outRec.firstLeft;
                                    outRec.firstLeft = object;
                                    if (this.usingPolyTree) {
                                        this.fixupFirstLefts2(outRec, (Path.OutRec)object);
                                    }
                                } else {
                                    object.isHole = outRec.isHole;
                                    object.firstLeft = outRec.firstLeft;
                                    if (this.usingPolyTree) {
                                        this.fixupFirstLefts1(outRec, (Path.OutRec)object);
                                    }
                                }
                                object = outPt2;
                            }
                        }
                    }
                    outPt = object.next;
                }
                outPt2 = outPt = outPt2.next;
            } while (outPt != outRec.getPoints());
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    private boolean executeInternal() {
        block20 : {
            block18 : {
                block19 : {
                    block17 : {
                        block16 : {
                            this.reset();
                            var11_1 = this.currentLM;
                            var3_3 = 0;
                            if (var11_1 != null) break block16;
                            do {
                                this.joins.clear();
                                this.ghostJoins.clear();
                                return false;
                                break;
                            } while (true);
                        }
                        try {
                            var5_4 = this.popScanbeam();
                            do lbl-1000: // 3 sources:
                            {
                                this.insertLocalMinimaIntoAEL(var5_4);
                                this.processHorizontals();
                                this.ghostJoins.clear();
                                if (this.scanbeam == null) break block17;
                                if (!this.processIntersections(var7_5 = this.popScanbeam())) ** continue;
                                this.processEdgesAtTopOfScanbeam(var7_5);
                                var5_4 = var7_5;
                                if (this.scanbeam != null) ** GOTO lbl-1000
                                var5_4 = var7_5;
                            } while (this.currentLM != null);
                            break block17;
lbl25: // 2 sources:
                            var4_8 = this.polyOuts.size();
                            var2_7 = true;
                            if (var1_6 >= var4_8) ** GOTO lbl-1000
                            var11_1 = this.polyOuts.get(var1_6);
                            if (var11_1.pts == null || var11_1.isOpen) break block18;
                            var9_9 = var11_1.isHole;
                            var10_10 = this.reverseSolution;
                            if (var11_1.area() <= 0.0) break block19;
                        }
                        catch (Throwable var11_2) {
                            this.joins.clear();
                            this.ghostJoins.clear();
                            throw var11_2;
                        }
lbl33: // 1 sources:
                        if ((var9_9 ^ var10_10) == var2_7) {
                            var11_1.getPoints().reversePolyPtLinks();
                            break block18;
                        }
                        break block18;
lbl-1000: // 1 sources:
                        {
                            this.joinCommonEdges();
                            var1_6 = var3_3;
lbl40: // 2 sources:
                            if (var1_6 < this.polyOuts.size()) {
                                var11_1 = this.polyOuts.get(var1_6);
                                if (var11_1.getPoints() != null) {
                                    if (var11_1.isOpen) {
                                        this.fixupOutPolyline((Path.OutRec)var11_1);
                                    } else {
                                        this.fixupOutPolygon((Path.OutRec)var11_1);
                                    }
                                }
                                break block20;
                            }
                            if (this.strictlySimple) {
                                this.doSimplePolygons();
                            }
                            this.joins.clear();
                            this.ghostJoins.clear();
                            return true;
                        }
                    }
                    var1_6 = 0;
                    ** GOTO lbl25
                }
                var2_7 = false;
                ** GOTO lbl33
            }
            ++var1_6;
            ** GOTO lbl25
        }
        ++var1_6;
        ** GOTO lbl40
    }

    private void fixupFirstLefts1(Path.OutRec outRec, Path.OutRec outRec2) {
        for (int i2 = 0; i2 < this.polyOuts.size(); ++i2) {
            Path.OutRec outRec3 = this.polyOuts.get(i2);
            if (outRec3.getPoints() == null || outRec3.firstLeft == null || !DefaultClipper.parseFirstLeft(outRec3.firstLeft).equals(outRec) || !DefaultClipper.poly2ContainsPoly1(outRec3.getPoints(), outRec2.getPoints())) continue;
            outRec3.firstLeft = outRec2;
        }
    }

    private void fixupFirstLefts2(Path.OutRec outRec, Path.OutRec outRec2) {
        for (Path.OutRec outRec3 : this.polyOuts) {
            if (outRec3.firstLeft != outRec) continue;
            outRec3.firstLeft = outRec2;
        }
    }

    private boolean fixupIntersectionOrder() {
        Collections.sort(this.intersectList, this.intersectNodeComparer);
        this.copyAELToSEL();
        int n2 = this.intersectList.size();
        for (int i2 = 0; i2 < n2; ++i2) {
            if (!this.EdgesAdjacent(this.intersectList.get(i2))) {
                int n3;
                for (n3 = i2 + 1; n3 < n2 && !this.EdgesAdjacent(this.intersectList.get(n3)); ++n3) {
                }
                if (n3 == n2) {
                    return false;
                }
                IntersectNode intersectNode = this.intersectList.get(i2);
                this.intersectList.set(i2, this.intersectList.get(n3));
                this.intersectList.set(n3, intersectNode);
            }
            this.swapPositionsInSEL(this.intersectList.get((int)i2).edge1, this.intersectList.get((int)i2).Edge2);
        }
        return true;
    }

    private void fixupOutPolygon(Path.OutRec outRec) {
        outRec.bottomPt = null;
        Path.OutPt outPt = outRec.getPoints();
        boolean bl2 = this.preserveCollinear || this.strictlySimple;
        block0 : do {
            Path.OutPt outPt2 = null;
            while (outPt.prev != outPt && outPt.prev != outPt.next) {
                if (!outPt.getPt().equals(outPt.next.getPt()) && !outPt.getPt().equals(outPt.prev.getPt()) && (!Point.slopesEqual(outPt.prev.getPt(), outPt.getPt(), outPt.next.getPt(), this.useFullRange) || bl2 && Point.isPt2BetweenPt1AndPt3(outPt.prev.getPt(), outPt.getPt(), outPt.next.getPt()))) {
                    if (outPt == outPt2) {
                        outRec.setPoints(outPt);
                        return;
                    }
                    Path.OutPt outPt3 = outPt2;
                    if (outPt2 == null) {
                        outPt3 = outPt;
                    }
                    outPt = outPt.next;
                    outPt2 = outPt3;
                    continue;
                }
                outPt.prev.next = outPt.next;
                outPt.next.prev = outPt.prev;
                outPt = outPt.prev;
                continue block0;
            }
            break;
        } while (true);
        outRec.setPoints(null);
    }

    private void fixupOutPolyline(Path.OutRec outRec) {
        Path.OutPt outPt = outRec.pts;
        Path.OutPt outPt2 = outPt.prev;
        while (outPt != outPt2) {
            Path.OutPt outPt3;
            outPt = outPt3 = outPt.next;
            if (!outPt3.pt.equals(outPt3.prev.pt)) continue;
            Path.OutPt outPt4 = outPt2;
            if (outPt3 == outPt2) {
                outPt4 = outPt3.prev;
            }
            outPt = outPt3.prev;
            outPt.next = outPt3.next;
            outPt3.next.prev = outPt;
            outPt2 = outPt4;
        }
        if (outPt == outPt.prev) {
            outRec.pts = null;
        }
    }

    private static void getHorzDirection(Edge edge, Clipper.Direction[] arrdirection, long[] arrl, long[] arrl2) {
        if (edge.getBot().getX() < edge.getTop().getX()) {
            arrl[0] = edge.getBot().getX();
            arrl2[0] = edge.getTop().getX();
            arrdirection[0] = Clipper.Direction.LEFT_TO_RIGHT;
            return;
        }
        arrl[0] = edge.getTop().getX();
        arrl2[0] = edge.getBot().getX();
        arrdirection[0] = Clipper.Direction.RIGHT_TO_LEFT;
    }

    private Path.OutRec getOutRec(int n2) {
        Path.OutRec outRec;
        List<Path.OutRec> list = this.polyOuts;
        while ((outRec = list.get(n2)) != this.polyOuts.get(outRec.Idx)) {
            list = this.polyOuts;
            n2 = outRec.Idx;
        }
        return outRec;
    }

    private static boolean getOverlap(long l2, long l3, long l4, long l5, long[] arrl, long[] arrl2) {
        boolean bl2 = false;
        if (l2 < l3) {
            if (l4 < l5) {
                arrl[0] = Math.max(l2, l4);
                arrl2[0] = Math.min(l3, l5);
            } else {
                arrl[0] = Math.max(l2, l5);
                arrl2[0] = Math.min(l3, l4);
            }
        } else if (l4 < l5) {
            arrl[0] = Math.max(l3, l4);
            arrl2[0] = Math.min(l2, l5);
        } else {
            arrl[0] = Math.max(l3, l5);
            arrl2[0] = Math.min(l2, l4);
        }
        if (arrl[0] < arrl2[0]) {
            bl2 = true;
        }
        return bl2;
    }

    /*
     * Enabled aggressive block sorting
     */
    private void insertEdgeIntoAEL(Edge edge, Edge object) {
        block8 : {
            block7 : {
                block6 : {
                    LOGGER.entering(DefaultClipper.class.getName(), "insertEdgeIntoAEL");
                    if (this.activeEdges != null) break block6;
                    edge.prevInAEL = null;
                    edge.nextInAEL = null;
                    object = LOGGER;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("Edge ");
                    stringBuilder.append(edge.outIdx);
                    stringBuilder.append(" -> ");
                    stringBuilder.append((Object)null);
                    object.finest(stringBuilder.toString());
                    break block7;
                }
                if (object != null || !Edge.doesE2InsertBeforeE1(this.activeEdges, edge)) break block8;
                edge.prevInAEL = null;
                edge.nextInAEL = this.activeEdges;
                object = LOGGER;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Edge ");
                stringBuilder.append(edge.outIdx);
                stringBuilder.append(" -> ");
                stringBuilder.append(edge.nextInAEL.outIdx);
                object.finest(stringBuilder.toString());
                this.activeEdges.prevInAEL = edge;
            }
            this.activeEdges = edge;
            return;
        }
        LOGGER.finest("activeEdges unchanged");
        Object object2 = object;
        if (object == null) {
            object2 = this.activeEdges;
        }
        while (object2.nextInAEL != null && !Edge.doesE2InsertBeforeE1(object2.nextInAEL, edge)) {
            object2 = object2.nextInAEL;
        }
        edge.nextInAEL = object2.nextInAEL;
        if (object2.nextInAEL != null) {
            object2.nextInAEL.prevInAEL = edge;
        }
        edge.prevInAEL = object2;
        object2.nextInAEL = edge;
    }

    /*
     * Enabled aggressive block sorting
     */
    private void insertLocalMinimaIntoAEL(long l2) {
        LOGGER.entering(DefaultClipper.class.getName(), "insertLocalMinimaIntoAEL");
        while (this.currentLM != null && this.currentLM.y == l2) {
            Edge edge = this.currentLM.leftBound;
            Edge edge2 = this.currentLM.rightBound;
            this.popLocalMinima();
            Object object = null;
            Object object2 = null;
            if (edge == null) {
                this.insertEdgeIntoAEL(edge2, null);
                this.updateWindingCount(edge2);
                if (edge2.isContributing(this.clipFillType, this.subjFillType, this.clipType)) {
                    object2 = this.addOutPt(edge2, edge2.getBot());
                }
            } else {
                if (edge2 == null) {
                    this.insertEdgeIntoAEL(edge, null);
                    this.updateWindingCount(edge);
                    object2 = object;
                    if (edge.isContributing(this.clipFillType, this.subjFillType, this.clipType)) {
                        object2 = this.addOutPt(edge, edge.getBot());
                    }
                } else {
                    this.insertEdgeIntoAEL(edge, null);
                    this.insertEdgeIntoAEL(edge2, edge);
                    this.updateWindingCount(edge);
                    edge2.windCnt = edge.windCnt;
                    edge2.windCnt2 = edge.windCnt2;
                    object2 = object;
                    if (edge.isContributing(this.clipFillType, this.subjFillType, this.clipType)) {
                        object2 = this.addLocalMinPoly(edge, edge2, edge.getBot());
                    }
                }
                this.insertScanbeam(edge.getTop().getY());
            }
            if (edge2 != null) {
                if (edge2.isHorizontal()) {
                    this.addEdgeToSEL(edge2);
                } else {
                    this.insertScanbeam(edge2.getTop().getY());
                }
            }
            if (edge == null || edge2 == null) continue;
            if (object2 != null && edge2.isHorizontal() && this.ghostJoins.size() > 0 && edge2.windDelta != 0) {
                for (int i2 = 0; i2 < this.ghostJoins.size(); ++i2) {
                    object = this.ghostJoins.get(i2);
                    if (!this.doHorzSegmentsOverlap(object.outPt1.getPt().getX(), object.getOffPt().getX(), edge2.getBot().getX(), edge2.getTop().getX())) continue;
                    this.addJoin(object.outPt1, (Path.OutPt)object2, object.getOffPt());
                }
            }
            if (edge.outIdx >= 0 && edge.prevInAEL != null && edge.prevInAEL.getCurrent().getX() == edge.getBot().getX() && edge.prevInAEL.outIdx >= 0 && Edge.slopesEqual(edge.prevInAEL, edge, this.useFullRange) && edge.windDelta != 0 && edge.prevInAEL.windDelta != 0) {
                this.addJoin((Path.OutPt)object2, this.addOutPt(edge.prevInAEL, edge.getBot()), edge.getTop());
            }
            if (edge.nextInAEL == edge2) continue;
            if (edge2.outIdx >= 0 && edge2.prevInAEL.outIdx >= 0 && Edge.slopesEqual(edge2.prevInAEL, edge2, this.useFullRange) && edge2.windDelta != 0 && edge2.prevInAEL.windDelta != 0) {
                this.addJoin((Path.OutPt)object2, this.addOutPt(edge2.prevInAEL, edge2.getBot()), edge2.getTop());
            }
            if ((object2 = edge.nextInAEL) == null) continue;
            while (object2 != edge2) {
                this.intersectEdges(edge2, (Edge)object2, edge.getCurrent());
                object2 = object2.nextInAEL;
            }
        }
    }

    private void insertScanbeam(long l2) {
        if (this.scanbeam == null) {
            this.scanbeam = new ClipperBase.Scanbeam();
            this.scanbeam.next = null;
            this.scanbeam.y = l2;
            return;
        }
        if (l2 > this.scanbeam.y) {
            ClipperBase.Scanbeam scanbeam = new ClipperBase.Scanbeam();
            scanbeam.y = l2;
            scanbeam.next = this.scanbeam;
            this.scanbeam = scanbeam;
            return;
        }
        ClipperBase.Scanbeam scanbeam = this.scanbeam;
        while (scanbeam.next != null && l2 <= scanbeam.next.y) {
            scanbeam = scanbeam.next;
        }
        if (l2 == scanbeam.y) {
            return;
        }
        ClipperBase.Scanbeam scanbeam2 = new ClipperBase.Scanbeam();
        scanbeam2.y = l2;
        scanbeam2.next = scanbeam.next;
        scanbeam.next = scanbeam2;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void intersectEdges(Edge var1_1, Edge var2_2, Point.LongPoint var3_3) {
        block60 : {
            block61 : {
                block59 : {
                    block57 : {
                        block58 : {
                            block51 : {
                                block56 : {
                                    block55 : {
                                        block53 : {
                                            block54 : {
                                                block52 : {
                                                    DefaultClipper.LOGGER.entering(DefaultClipper.class.getName(), "insersectEdges");
                                                    var4_4 = var1_1.outIdx;
                                                    var5_5 = 0;
                                                    var6_6 = var4_4 >= 0 ? 1 : 0;
                                                    var7_7 = var2_2.outIdx >= 0 ? 1 : 0;
                                                    this.setZ(var3_3, var1_1, var2_2);
                                                    if (var1_1.windDelta == 0 || var2_2.windDelta == 0) break block51;
                                                    if (var1_1.polyTyp == var2_2.polyTyp) {
                                                        if (var1_1.isEvenOddFillType(this.clipFillType, this.subjFillType)) {
                                                            var4_4 = var1_1.windCnt;
                                                            var1_1.windCnt = var2_2.windCnt;
                                                        } else {
                                                            var4_4 = var1_1.windCnt + var2_2.windDelta == 0 ? - var1_1.windCnt : var1_1.windCnt + var2_2.windDelta;
                                                            var1_1.windCnt = var4_4;
                                                            var4_4 = var2_2.windCnt - var1_1.windDelta == 0 ? - var2_2.windCnt : var2_2.windCnt - var1_1.windDelta;
                                                        }
                                                        var2_2.windCnt = var4_4;
                                                    } else {
                                                        var4_4 = var2_2.isEvenOddFillType(this.clipFillType, this.subjFillType) == false ? var1_1.windCnt2 + var2_2.windDelta : (var1_1.windCnt2 == 0 ? 1 : 0);
                                                        var1_1.windCnt2 = var4_4;
                                                        if (!var1_1.isEvenOddFillType(this.clipFillType, this.subjFillType)) {
                                                            var4_4 = var2_2.windCnt2 - var1_1.windDelta;
                                                        } else {
                                                            var4_4 = var5_5;
                                                            if (var2_2.windCnt2 == 0) {
                                                                var4_4 = 1;
                                                            }
                                                        }
                                                        var2_2.windCnt2 = var4_4;
                                                    }
                                                    if (var1_1.polyTyp == Clipper.PolyType.SUBJECT) {
                                                        var8_8 = this.subjFillType;
                                                        var9_9 = this.clipFillType;
                                                    } else {
                                                        var8_8 = this.clipFillType;
                                                        var9_9 = this.subjFillType;
                                                    }
                                                    if (var2_2.polyTyp == Clipper.PolyType.SUBJECT) {
                                                        var10_10 = this.subjFillType;
                                                        var11_11 = this.clipFillType;
                                                    } else {
                                                        var10_10 = this.clipFillType;
                                                        var11_11 = this.subjFillType;
                                                    }
                                                    switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[var8_8.ordinal()]) {
                                                        default: {
                                                            var4_4 = Math.abs(var1_1.windCnt);
                                                            ** break;
                                                        }
                                                        case 2: {
                                                            var4_4 = - var1_1.windCnt;
                                                            ** break;
                                                        }
                                                        case 1: 
                                                    }
                                                    var4_4 = var1_1.windCnt;
lbl48: // 3 sources:
                                                    switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[var10_10.ordinal()]) {
                                                        default: {
                                                            var5_5 = Math.abs(var2_2.windCnt);
                                                            ** break;
                                                        }
                                                        case 2: {
                                                            var5_5 = - var2_2.windCnt;
                                                            ** break;
                                                        }
                                                        case 1: 
                                                    }
                                                    var5_5 = var2_2.windCnt;
lbl57: // 3 sources:
                                                    if (var6_6 == 0 || var7_7 == 0) break block52;
                                                    if (var4_4 != 0 && var4_4 != 1 || var5_5 != 0 && var5_5 != 1 || var1_1.polyTyp != var2_2.polyTyp && this.clipType != Clipper.ClipType.XOR) {
                                                        this.addLocalMaxPoly(var1_1, var2_2, var3_3);
                                                        return;
                                                    }
                                                    this.addOutPt(var1_1, var3_3);
                                                    break block53;
                                                }
                                                if (var6_6 == 0) break block54;
                                                if (var5_5 != 0) {
                                                    if (var5_5 != 1) return;
                                                }
                                                this.addOutPt(var1_1, var3_3);
                                                break block55;
                                            }
                                            if (var7_7 == 0) break block56;
                                            if (var4_4 != 0) {
                                                if (var4_4 != 1) return;
                                            }
                                        }
                                        this.addOutPt(var2_2, var3_3);
                                    }
                                    Edge.swapSides(var1_1, var2_2);
                                    Edge.swapPolyIndexes(var1_1, var2_2);
                                    return;
                                }
                                if (var4_4 != 0) {
                                    if (var4_4 != 1) return;
                                }
                                if (var5_5 != 0) {
                                    if (var5_5 != 1) return;
                                }
                                switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[var9_9.ordinal()]) {
                                    default: {
                                        var6_6 = Math.abs(var1_1.windCnt2);
                                        ** break;
                                    }
                                    case 2: {
                                        var6_6 = - var1_1.windCnt2;
                                        ** break;
                                    }
                                    case 1: 
                                }
                                var6_6 = var1_1.windCnt2;
lbl93: // 3 sources:
                                switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$PolyFillType[var11_11.ordinal()]) {
                                    default: {
                                        var7_7 = Math.abs(var2_2.windCnt2);
                                        ** break;
                                    }
                                    case 2: {
                                        var7_7 = - var2_2.windCnt2;
                                        ** break;
                                    }
                                    case 1: 
                                }
                                var7_7 = var2_2.windCnt2;
lbl102: // 3 sources:
                                if (var1_1.polyTyp == var2_2.polyTyp) {
                                    if (var4_4 == 1 && var5_5 == 1) {
                                        switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$ClipType[this.clipType.ordinal()]) {
                                            case 4: {
                                                ** break;
                                            }
                                            default: {
                                                return;
                                            }
                                            case 3: {
                                                if (var1_1.polyTyp == Clipper.PolyType.CLIP && var6_6 > 0 && var7_7 > 0) ** break;
                                                if (var1_1.polyTyp != Clipper.PolyType.SUBJECT) return;
                                                if (var6_6 > 0) return;
                                                if (var7_7 > 0) return;
                                                ** break;
                                            }
                                            case 2: {
                                                if (var6_6 > 0) return;
                                                if (var7_7 > 0) return;
                                                ** break;
                                            }
                                            case 1: {
                                                if (var6_6 <= 0) return;
                                                if (var7_7 <= 0) return;
                                                ** break;
                                            }
                                        }
                                    }
                                } else lbl-1000: // 6 sources:
                                {
                                    this.addLocalMinPoly(var1_1, var2_2, var3_3);
                                    return;
                                }
                                Edge.swapSides(var1_1, var2_2);
                                return;
                            }
                            if (var1_1.windDelta == 0 && var2_2.windDelta == 0) {
                                return;
                            }
                            if (var1_1.polyTyp != var2_2.polyTyp || var1_1.windDelta == var2_2.windDelta || this.clipType != Clipper.ClipType.UNION) break block57;
                            if (var1_1.windDelta != 0) break block58;
                            if (var7_7 == 0) return;
                            this.addOutPt(var1_1, var3_3);
                            if (var6_6 == 0) return;
                            break block59;
                        }
                        if (var6_6 == 0) return;
                        this.addOutPt(var2_2, var3_3);
                        if (var7_7 == 0) return;
                        break block60;
                    }
                    if (var1_1.polyTyp == var2_2.polyTyp) return;
                    if (var1_1.windDelta != 0 || Math.abs(var2_2.windCnt) != 1 || this.clipType == Clipper.ClipType.UNION && var2_2.windCnt2 != 0) break block61;
                    this.addOutPt(var1_1, var3_3);
                    if (var6_6 == 0) return;
                }
                var1_1.outIdx = -1;
                return;
            }
            if (var2_2.windDelta != 0) return;
            if (Math.abs(var1_1.windCnt) != 1) return;
            if (this.clipType == Clipper.ClipType.UNION) {
                if (var1_1.windCnt2 != 0) return;
            }
            this.addOutPt(var2_2, var3_3);
            if (var7_7 == 0) return;
        }
        var2_2.outIdx = -1;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void intersectPoint(Edge var1_1, Edge var2_2, Point.LongPoint[] var3_3) {
        block6 : {
            block7 : {
                var12_4 = new Point.LongPoint();
                var3_3[0] = var12_4;
                if (var1_1.deltaX == var2_2.deltaX) {
                    var12_4.setY(var1_1.getCurrent().getY());
                    var12_4.setX(Edge.topX(var1_1, var12_4.getY()));
                    return;
                }
                if (var1_1.getDelta().getX() != 0L) break block6;
                var12_4.setX(var1_1.getBot().getX());
                if (!var2_2.isHorizontal()) break block7;
                var3_3 = var2_2.getBot();
                ** GOTO lbl22
            }
            var4_6 = (double)var2_2.getBot().getY() - (double)var2_2.getBot().getX() / var2_2.deltaX;
            var6_8 = var12_4.getX();
            var8_10 = var2_2.deltaX;
            ** GOTO lbl27
        }
        if (var2_2.getDelta().getX() == 0L) {
            var12_4.setX(var2_2.getBot().getX());
            if (var1_1.isHorizontal()) {
                var3_3 = var1_1.getBot();
lbl22: // 2 sources:
                var10_5 = var3_3.getY();
            } else {
                var4_6 = (double)var1_1.getBot().getY() - (double)var1_1.getBot().getX() / var1_1.deltaX;
                var6_8 = var12_4.getX();
                var8_10 = var1_1.deltaX;
lbl27: // 2 sources:
                var10_5 = Math.round(var6_8 / var8_10 + var4_6);
            }
            var12_4.setY(var10_5);
        } else {
            var4_7 = (double)var1_1.getBot().getX() - (double)var1_1.getBot().getY() * var1_1.deltaX;
            var6_9 = (double)var2_2.getBot().getX() - (double)var2_2.getBot().getY() * var2_2.deltaX;
            var8_11 = (var6_9 - var4_7) / (var1_1.deltaX - var2_2.deltaX);
            var12_4.setY(Math.round(var8_11));
            var10_5 = Math.abs(var1_1.deltaX) < Math.abs(var2_2.deltaX) ? Math.round(var1_1.deltaX * var8_11 + var4_7) : Math.round(var2_2.deltaX * var8_11 + var6_9);
            var12_4.setX(var10_5);
        }
        if (var12_4.getY() < var1_1.getTop().getY() || var12_4.getY() < var2_2.getTop().getY()) {
            var3_3 = var1_1.getTop().getY() > var2_2.getTop().getY() ? var1_1.getTop() : var2_2.getTop();
            var12_4.setY(var3_3.getY());
            var10_5 = Math.abs(var1_1.deltaX) < Math.abs(var2_2.deltaX) ? Edge.topX(var1_1, var12_4.getY()) : Edge.topX(var2_2, var12_4.getY());
            var12_4.setX(var10_5);
        }
        if (var12_4.getY() <= var1_1.getCurrent().getY()) return;
        var12_4.setY(var1_1.getCurrent().getY());
        var10_5 = Math.abs(var1_1.deltaX) > Math.abs(var2_2.deltaX) ? Edge.topX(var2_2, var12_4.getY()) : Edge.topX(var1_1, var12_4.getY());
        var12_4.setX(var10_5);
    }

    private static boolean isParam1RightOfParam2(Path.OutRec outRec, Path.OutRec outRec2) {
        Path.OutRec outRec3;
        do {
            if ((outRec3 = outRec.firstLeft) == outRec2) {
                return true;
            }
            outRec = outRec3;
        } while (outRec3 != null);
        return false;
    }

    private static int isPointInPolygon(Point.LongPoint object, Path.OutPt outPt) {
        long l2 = object.getX();
        long l3 = object.getY();
        long l4 = outPt.getPt().getX();
        long l5 = outPt.getPt().getY();
        int n2 = 0;
        object = outPt;
        do {
            boolean bl2;
            long l6;
            long l7;
            long l8;
            long l9;
            block16 : {
                block17 : {
                    object = object.next;
                    l9 = object.getPt().getX();
                    l8 = object.getPt().getY();
                    l7 = l8 LCMP l3;
                    if (l7 != false) break block16;
                    l6 = l9 LCMP l2;
                    if (l6 == false) break block17;
                    if (l5 != l3) break block16;
                    l6 = l6 > 0 ? (long)1 : (long)0;
                    bl2 = l4 < l2;
                    if (l6 != bl2) break block16;
                }
                return -1;
            }
            l6 = l5 < l3 ? (long)1 : (long)0;
            bl2 = l7 < 0;
            if (l6 != bl2) {
                if (l4 >= l2) {
                    if (l9 > l2) {
                        n2 = 1 - n2;
                    } else {
                        l6 = (long)((double)(l4 - l2) * (double)(l8 - l3) - (double)(l9 - l2) * (double)(l5 - l3) DCMPL 0.0);
                        if (l6 == false) {
                            return -1;
                        }
                        l6 = l6 > 0 ? (long)1 : (long)0;
                        bl2 = l8 > l5;
                        if (l6 == bl2) {
                            n2 = 1 - n2;
                        }
                    }
                } else {
                    long l10 = l2;
                    if (l9 > l10) {
                        l6 = (long)((double)(l4 - l10) * (double)(l8 - l3) - (double)(l9 - l10) * (double)(l5 - l3) DCMPL 0.0);
                        if (l6 == false) {
                            return -1;
                        }
                        l6 = l6 > 0 ? (long)1 : (long)0;
                        bl2 = l8 > l5;
                        if (l6 == bl2) {
                            n2 = 1 - n2;
                        }
                    }
                }
            }
            if (outPt == object) {
                return n2;
            }
            l4 = l9;
            l5 = l8;
        } while (true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void joinCommonEdges() {
        var1_1 = 0;
        while (var1_1 < this.joins.size()) {
            block13 : {
                block19 : {
                    block18 : {
                        block17 : {
                            block15 : {
                                block16 : {
                                    block14 : {
                                        var10_10 = this.joins.get(var1_1);
                                        var8_8 = this.getOutRec(var10_10.outPt1.idx);
                                        var9_9 = this.getOutRec(var10_10.outPt2.idx);
                                        if (var8_8.getPoints() == null || var9_9.getPoints() == null || var8_8.isOpen || var9_9.isOpen) break block13;
                                        if (var8_8 == var9_9) ** GOTO lbl-1000
                                        if (DefaultClipper.isParam1RightOfParam2(var8_8, var9_9)) {
                                            var7_7 = var9_9;
                                        } else if (DefaultClipper.isParam1RightOfParam2(var9_9, var8_8)) lbl-1000: // 2 sources:
                                        {
                                            var7_7 = var8_8;
                                        } else {
                                            var7_7 = Path.OutPt.getLowerMostRec(var8_8, var9_9);
                                        }
                                        if (!this.joinPoints(var10_10, var8_8, var9_9)) break block13;
                                        if (var8_8 != var9_9) break block14;
                                        var8_8.setPoints(var10_10.outPt1);
                                        var8_8.bottomPt = null;
                                        var7_7 = this.createOutRec();
                                        var7_7.setPoints(var10_10.outPt2);
                                        this.updateOutPtIdxs((Path.OutRec)var7_7);
                                        var5_5 = this.usingPolyTree;
                                        var4_4 = 1;
                                        var3_3 = 1;
                                        if (!var5_5) break block15;
                                        break block16;
                                    }
                                    var9_9.setPoints(null);
                                    var9_9.bottomPt = null;
                                    var9_9.Idx = var8_8.Idx;
                                    var8_8.isHole = var7_7.isHole;
                                    if (var7_7 == var9_9) {
                                        var8_8.firstLeft = var9_9.firstLeft;
                                    }
                                    var9_9.firstLeft = var8_8;
                                    if (this.usingPolyTree) {
                                        this.fixupFirstLefts2(var9_9, var8_8);
                                    }
                                    break block13;
                                }
                                for (var2_2 = 0; var2_2 < this.polyOuts.size() - 1; ++var2_2) {
                                    var9_9 = this.polyOuts.get(var2_2);
                                    if (var9_9.getPoints() == null || DefaultClipper.parseFirstLeft(var9_9.firstLeft) != var8_8 || var9_9.isHole == var8_8.isHole || !DefaultClipper.poly2ContainsPoly1(var9_9.getPoints(), var10_10.outPt2)) continue;
                                    var9_9.firstLeft = var7_7;
                                }
                            }
                            if (!DefaultClipper.poly2ContainsPoly1(var7_7.getPoints(), var8_8.getPoints())) break block17;
                            var7_7.isHole = var8_8.isHole ^ true;
                            var7_7.firstLeft = var8_8;
                            if (this.usingPolyTree) {
                                this.fixupFirstLefts2((Path.OutRec)var7_7, var8_8);
                            }
                            var5_5 = var7_7.isHole;
                            var6_6 = this.reverseSolution;
                            var2_2 = var7_7.area() > 0.0 ? var3_3 : 0;
                            if ((var5_5 ^ var6_6) != var2_2) break block13;
                            var7_7 = var7_7.getPoints();
                            break block18;
                        }
                        if (!DefaultClipper.poly2ContainsPoly1(var8_8.getPoints(), var7_7.getPoints())) break block19;
                        var7_7.isHole = var8_8.isHole;
                        var8_8.isHole = var7_7.isHole ^ true;
                        var7_7.firstLeft = var8_8.firstLeft;
                        var8_8.firstLeft = var7_7;
                        if (this.usingPolyTree) {
                            this.fixupFirstLefts2(var8_8, (Path.OutRec)var7_7);
                        }
                        var5_5 = var8_8.isHole;
                        var6_6 = this.reverseSolution;
                        var2_2 = var8_8.area() > 0.0 ? var4_4 : 0;
                        if ((var5_5 ^ var6_6) != var2_2) break block13;
                        var7_7 = var8_8.getPoints();
                    }
                    var7_7.reversePolyPtLinks();
                    break block13;
                }
                var7_7.isHole = var8_8.isHole;
                var7_7.firstLeft = var8_8.firstLeft;
                if (this.usingPolyTree) {
                    this.fixupFirstLefts1(var8_8, (Path.OutRec)var7_7);
                }
            }
            ++var1_1;
        }
    }

    private static boolean joinHorz(Path.OutPt outPt, Path.OutPt outPt2, Path.OutPt object, Path.OutPt object2, Point.LongPoint object3, boolean bl2) {
        Clipper.Direction direction;
        boolean bl3;
        block25 : {
            block26 : {
                Object object4;
                block24 : {
                    block22 : {
                        block23 : {
                            block21 : {
                                direction = outPt.getPt().getX() > outPt2.getPt().getX() ? Clipper.Direction.RIGHT_TO_LEFT : Clipper.Direction.LEFT_TO_RIGHT;
                                object4 = object.getPt().getX() > object2.getPt().getX() ? Clipper.Direction.RIGHT_TO_LEFT : Clipper.Direction.LEFT_TO_RIGHT;
                                bl3 = false;
                                if (direction == object4) {
                                    return false;
                                }
                                object2 = outPt;
                                if (direction != Clipper.Direction.LEFT_TO_RIGHT) break block21;
                                while (outPt.next.getPt().getX() <= object3.getX() && outPt.next.getPt().getX() >= outPt.getPt().getX() && outPt.next.getPt().getY() == object3.getY()) {
                                    outPt = outPt.next;
                                }
                                outPt2 = outPt;
                                if (bl2) {
                                    outPt2 = outPt;
                                    if (outPt.getPt().getX() != object3.getX()) {
                                        outPt2 = outPt.next;
                                    }
                                }
                                outPt = object2 = outPt2.duplicate(bl2 ^ true);
                                if (object2.getPt().equals(object3)) break block22;
                                object2.setPt((Point.LongPoint)object3);
                                outPt2 = object2.duplicate(bl2 ^ true);
                                outPt = object2;
                                break block23;
                            }
                            while (object2.next.getPt().getX() >= object3.getX() && object2.next.getPt().getX() <= object2.getPt().getX() && object2.next.getPt().getY() == object3.getY()) {
                                object2 = object2.next;
                            }
                            outPt2 = object2;
                            if (!bl2) {
                                outPt2 = object2;
                                if (object2.getPt().getX() != object3.getX()) {
                                    outPt2 = object2.next;
                                }
                            }
                            outPt = object2 = outPt2.duplicate(bl2);
                            if (object2.getPt().equals(object3)) break block22;
                            object2.setPt((Point.LongPoint)object3);
                            outPt2 = object2.duplicate(bl2);
                            outPt = object2;
                        }
                        object2 = outPt2;
                        outPt2 = outPt;
                        outPt = object2;
                    }
                    object2 = object;
                    if (object4 != Clipper.Direction.LEFT_TO_RIGHT) break block24;
                    while (object.next.getPt().getX() <= object3.getX() && object.next.getPt().getX() >= object.getPt().getX() && object.next.getPt().getY() == object3.getY()) {
                        object = object.next;
                    }
                    object2 = object;
                    if (bl2) {
                        object2 = object;
                        if (object.getPt().getX() != object3.getX()) {
                            object2 = object.next;
                        }
                    }
                    object4 = object2.duplicate(bl2 ^ true);
                    object = object4;
                    if (object4.getPt().equals(object3)) break block25;
                    object4.setPt((Point.LongPoint)object3);
                    object2 = object4.duplicate(bl2 ^ true);
                    object = object4;
                    break block26;
                }
                while (object2.next.getPt().getX() >= object3.getX() && object2.next.getPt().getX() <= object2.getPt().getX() && object2.next.getPt().getY() == object3.getY()) {
                    object2 = object2.next;
                }
                object = object2;
                if (!bl2) {
                    object = object2;
                    if (object2.getPt().getX() != object3.getX()) {
                        object = object2.next;
                    }
                }
                object4 = object.duplicate(bl2);
                object2 = object;
                object = object4;
                if (object4.getPt().equals(object3)) break block25;
                object4.setPt((Point.LongPoint)object3);
                object2 = object4.duplicate(bl2);
                object = object4;
            }
            object3 = object;
            object = object2;
            object2 = object3;
        }
        if (direction == Clipper.Direction.LEFT_TO_RIGHT) {
            bl3 = true;
        }
        if (bl3 == bl2) {
            outPt2.prev = object2;
            object2.next = outPt2;
            outPt.next = object;
            object.prev = outPt;
            return true;
        }
        outPt2.next = object2;
        object2.prev = outPt2;
        outPt.prev = object;
        object.next = outPt;
        return true;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private boolean joinPoints(Path.Join var1_1, Path.OutRec var2_2, Path.OutRec var3_3) {
        block26 : {
            block28 : {
                block30 : {
                    block29 : {
                        block27 : {
                            block25 : {
                                block24 : {
                                    var13_25 = var1_1.outPt1;
                                    var12_26 = var1_1.outPt2;
                                    var6_27 = var1_1.outPt1.getPt().getY();
                                    var8_28 = var1_1.getOffPt().getY();
                                    var10_29 = true;
                                    var4_30 = var6_27 == var8_28;
                                    if (!var4_30) break block24;
                                    if (!var1_1.getOffPt().equals(var1_1.outPt1.getPt())) break block25;
                                    if (!var1_1.getOffPt().equals(var1_1.outPt2.getPt())) break block24;
                                    if (var2_2 /* !! */  != var3_24) {
                                        return false;
                                    }
                                    var2_3 = var1_1.outPt1;
                                    while ((var2_5 = var2_4.next) != var13_25 && var2_5.getPt().equals(var1_1.getOffPt())) {
                                    }
                                    var4_30 = var2_5.getPt().getY() > var1_1.getOffPt().getY();
                                    var2_6 = var1_1.outPt2;
                                    while ((var2_8 = var2_7.next) != var12_26 && var2_8.getPt().equals(var1_1.getOffPt())) {
                                    }
                                    var5_31 = var2_8.getPt().getY() > var1_1.getOffPt().getY();
                                    if (var4_30 == var5_31) {
                                        return false;
                                    }
                                    if (!var4_30) ** GOTO lbl-1000
                                    ** GOTO lbl-1000
                                }
                                if (!var4_30) break block26;
                            }
                            var3_24 = var13_25;
                            while (var3_24.prev.getPt().getY() == var3_24.getPt().getY() && var3_24.prev != var13_25 && var3_24.prev != var12_26) {
                                var3_24 = var3_24.prev;
                            }
                            var11_33 = var13_25;
                            while (var11_33.next.getPt().getY() == var11_33.getPt().getY() && var11_33.next != var3_24 && var11_33.next != var12_26) {
                                var11_33 = var11_33.next;
                            }
                            if (var11_33.next == var3_24) return false;
                            if (var11_33.next == var12_26) {
                                return false;
                            }
                            var13_25 = var12_26;
                            while (var13_25.prev.getPt().getY() == var13_25.getPt().getY() && var13_25.prev != var12_26 && var13_25.prev != var11_33) {
                                var13_25 = var13_25.prev;
                            }
                            while (var12_26.next.getPt().getY() == var12_26.getPt().getY() && var12_26.next != var13_25 && var12_26.next != var3_24) {
                                var12_26 = var12_26.next;
                            }
                            if (var12_26.next == var13_25) return false;
                            if (var12_26.next == var3_24) {
                                return false;
                            }
                            var2_13 = new long[1];
                            var14_35 = new long[1];
                            if (!DefaultClipper.getOverlap(var3_24.getPt().getX(), var11_33.getPt().getX(), var13_25.getPt().getX(), var12_26.getPt().getX(), var2_13, var14_35)) {
                                return false;
                            }
                            var6_27 = var2_13[0];
                            var8_28 = var14_35[0];
                            if (var3_24.getPt().getX() < var6_27 || var3_24.getPt().getX() > var8_28) break block27;
                            var2_14 = var14_36 = new Point.LongPoint(var3_24.getPt());
                            if (var3_24.getPt().getX() <= var11_33.getPt().getX()) ** GOTO lbl-1000
                            var2_15 = var14_36;
                            break block28;
                        }
                        if (var13_25.getPt().getX() < var6_27 || var13_25.getPt().getX() > var8_28) break block29;
                        var2_18 = var14_37 = new Point.LongPoint(var13_25.getPt());
                        if (var13_25.getPt().getX() <= var12_26.getPt().getX()) ** GOTO lbl-1000
                        var2_19 = var14_37;
                        break block28;
                    }
                    if (var11_33.getPt().getX() < var6_27 || var11_33.getPt().getX() > var8_28) break block30;
                    var2_20 = var14_38 = new Point.LongPoint(var11_33.getPt());
                    if (var11_33.getPt().getX() <= var3_24.getPt().getX()) ** GOTO lbl-1000
                    var2_21 = var14_38;
                    break block28;
                }
                var2_22 = var14_39 = new Point.LongPoint(var12_26.getPt());
                if (var12_26.getPt().getX() > var13_25.getPt().getX()) {
                    var2_23 = var14_39;
                } else lbl-1000: // 4 sources:
                {
                    var10_29 = false;
                }
            }
            var1_1.outPt1 = var3_24;
            var1_1.outPt2 = var13_25;
            return DefaultClipper.joinHorz(var3_24, var11_33, var13_25, var12_26, (Point.LongPoint)var2_17, var10_29);
        }
        var11_34 = var13_25.next;
        while (var11_34.getPt().equals(var13_25.getPt()) && var11_34 != var13_25) {
            var11_34 = var11_34.next;
        }
        var4_30 = var11_34.getPt().getY() > var13_25.getPt().getY() || !Point.slopesEqual(var13_25.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange);
        var14_40 = var11_34;
        if (var4_30) {
            var11_34 = var13_25.prev;
            while (var11_34.getPt().equals(var13_25.getPt()) && var11_34 != var13_25) {
                var11_34 = var11_34.prev;
            }
            if (var11_34.getPt().getY() > var13_25.getPt().getY()) return false;
            var14_41 = var11_34;
            if (!Point.slopesEqual(var13_25.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange)) {
                return false;
            }
        }
        var11_34 = var12_26.next;
        while (var11_34.getPt().equals(var12_26.getPt()) && var11_34 != var12_26) {
            var11_34 = var11_34.next;
        }
        var5_32 = var11_34.getPt().getY() > var12_26.getPt().getY() || !Point.slopesEqual(var12_26.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange);
        var15_43 = var11_34;
        if (var5_32) {
            var11_34 = var12_26.prev;
            while (var11_34.getPt().equals(var12_26.getPt()) && var11_34 != var12_26) {
                var11_34 = var11_34.prev;
            }
            if (var11_34.getPt().getY() > var12_26.getPt().getY()) return false;
            var15_43 = var11_34;
            if (!Point.slopesEqual(var12_26.getPt(), var11_34.getPt(), var1_1.getOffPt(), this.useFullRange)) {
                return false;
            }
        }
        if (var14_42 == var13_25) return false;
        if (var15_43 == var12_26) return false;
        if (var14_42 == var15_43) return false;
        if (var2_2 /* !! */  == var3_24 && var4_30 == var5_32) {
            return false;
        }
        if (var4_30) lbl-1000: // 2 sources:
        {
            var2_10 = var13_25.duplicate(false);
            var3_24 = var12_26.duplicate(true);
            var13_25.prev = var12_26;
            var12_26.next = var13_25;
            var2_10.next = var3_24;
            var3_24.prev = var2_10;
        } else lbl-1000: // 2 sources:
        {
            var2_12 = var13_25.duplicate(true);
            var3_24 = var12_26.duplicate(false);
            var13_25.next = var12_26;
            var12_26.prev = var13_25;
            var2_12.prev = var3_24;
            var3_24.next = var2_12;
        }
        var1_1.outPt1 = var13_25;
        var1_1.outPt2 = var2_11;
        return true;
    }

    private static Paths minkowski(Path path, Path path2, boolean bl2, boolean bl3) {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    public static Paths minkowskiDiff(Path arrayList, Path object) {
        arrayList = DefaultClipper.minkowski(arrayList, (Path)object, false, true);
        object = new DefaultClipper();
        object.addPaths((Paths)arrayList, Clipper.PolyType.SUBJECT, true);
        object.execute(Clipper.ClipType.UNION, (Paths)arrayList, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO);
        return arrayList;
    }

    public static Paths minkowskiSum(Path arrayList, Path object, boolean bl2) {
        arrayList = DefaultClipper.minkowski(arrayList, (Path)object, true, bl2);
        object = new DefaultClipper();
        object.addPaths((Paths)arrayList, Clipper.PolyType.SUBJECT, true);
        object.execute(Clipper.ClipType.UNION, (Paths)arrayList, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO);
        return arrayList;
    }

    public static Paths minkowskiSum(Path path, Paths paths, boolean bl2) {
        Paths paths2 = new Paths();
        DefaultClipper defaultClipper = new DefaultClipper();
        for (int i2 = 0; i2 < paths.size(); ++i2) {
            defaultClipper.addPaths(DefaultClipper.minkowski(path, (Path)paths.get(i2), true, bl2), Clipper.PolyType.SUBJECT, true);
            if (!bl2) continue;
            defaultClipper.addPath(((Path)paths.get(i2)).TranslatePath((Point.LongPoint)path.get(0)), Clipper.PolyType.CLIP, true);
        }
        defaultClipper.execute(Clipper.ClipType.UNION, paths2, Clipper.PolyFillType.NON_ZERO, Clipper.PolyFillType.NON_ZERO);
        return paths2;
    }

    private static boolean poly2ContainsPoly1(Path.OutPt outPt, Path.OutPt outPt2) {
        Path.OutPt outPt3;
        Path.OutPt outPt4 = outPt;
        do {
            int n2;
            if ((n2 = DefaultClipper.isPointInPolygon(outPt4.getPt(), outPt2)) >= 0) {
                if (n2 > 0) {
                    return true;
                }
                return false;
            }
            outPt4 = outPt3 = outPt4.next;
        } while (outPt3 != outPt);
        return true;
    }

    private long popScanbeam() {
        LOGGER.entering(DefaultClipper.class.getName(), "popBeam");
        long l2 = this.scanbeam.y;
        this.scanbeam = this.scanbeam.next;
        return l2;
    }

    /*
     * Enabled aggressive block sorting
     */
    private void processEdgesAtTopOfScanbeam(long l2) {
        Object object;
        Object object2;
        Object object3;
        LOGGER.entering(DefaultClipper.class.getName(), "processEdgesAtTopOfScanbeam");
        block0 : do {
            object = this.activeEdges;
            while (object != null) {
                boolean bl2;
                double d2 = l2;
                boolean bl3 = bl2 = object.isMaxima(d2);
                if (bl2) {
                    object2 = object.getMaximaPair();
                    bl3 = object2 == null || !object2.isHorizontal();
                }
                if (bl3) {
                    if (this.strictlySimple) {
                        this.InsertMaxima(object.getTop().getX());
                    }
                    object2 = object.prevInAEL;
                    this.doMaxima((Edge)object);
                    if (object2 == null) continue block0;
                    object = object2.nextInAEL;
                    continue;
                }
                if (object.isIntermediate(d2) && object.nextInLML.isHorizontal()) {
                    object2 = new Edge[]{object};
                    this.updateEdgeIntoAEL((Edge[])object2);
                    object = object2[0];
                    if (object.outIdx >= 0) {
                        this.addOutPt((Edge)object, object.getBot());
                    }
                    this.addEdgeToSEL((Edge)object);
                } else {
                    object.getCurrent().setX(Edge.topX((Edge)object, l2));
                    object.getCurrent().setY(l2);
                }
                if (this.strictlySimple) {
                    object2 = object.prevInAEL;
                    if (object.outIdx >= 0 && object.windDelta != 0 && object2 != null && object2.outIdx >= 0 && object2.getCurrent().getX() == object.getCurrent().getX() && object2.windDelta != 0) {
                        object3 = new Point.LongPoint(object.getCurrent());
                        this.setZ((Point.LongPoint)object3, (Edge)object2, (Edge)object);
                        this.addJoin(this.addOutPt((Edge)object2, (Point.LongPoint)object3), this.addOutPt((Edge)object, (Point.LongPoint)object3), (Point.LongPoint)object3);
                    }
                }
                object = object.nextInAEL;
            }
            break;
        } while (true);
        this.processHorizontals();
        this.maxima = null;
        object = this.activeEdges;
        do {
            block15 : {
                Edge edge;
                block17 : {
                    block16 : {
                        if (object == null) {
                            LOGGER.exiting(DefaultClipper.class.getName(), "processEdgesAtTopOfScanbeam");
                            return;
                        }
                        object3 = object;
                        if (!object.isIntermediate(l2)) break block15;
                        object2 = object.outIdx >= 0 ? this.addOutPt((Edge)object, object.getTop()) : null;
                        object3 = new Edge[]{object};
                        this.updateEdgeIntoAEL((Edge[])object3);
                        edge = object3[0];
                        object3 = edge.prevInAEL;
                        object = edge.nextInAEL;
                        if (object3 == null || object3.getCurrent().getX() != edge.getBot().getX() || object3.getCurrent().getY() != edge.getBot().getY() || object2 == null || object3.outIdx < 0 || object3.getCurrent().getY() <= object3.getTop().getY() || !Edge.slopesEqual(edge, (Edge)object3, this.useFullRange) || edge.windDelta == 0 || object3.windDelta == 0) break block16;
                        object = this.addOutPt((Edge)object3, edge.getBot());
                        break block17;
                    }
                    object3 = edge;
                    if (object == null) break block15;
                    object3 = edge;
                    if (object.getCurrent().getX() != edge.getBot().getX()) break block15;
                    object3 = edge;
                    if (object.getCurrent().getY() != edge.getBot().getY()) break block15;
                    object3 = edge;
                    if (object2 == null) break block15;
                    object3 = edge;
                    if (object.outIdx < 0) break block15;
                    object3 = edge;
                    if (object.getCurrent().getY() <= object.getTop().getY()) break block15;
                    object3 = edge;
                    if (!Edge.slopesEqual(edge, (Edge)object, this.useFullRange)) break block15;
                    object3 = edge;
                    if (edge.windDelta == 0) break block15;
                    object3 = edge;
                    if (object.windDelta == 0) break block15;
                    object = this.addOutPt((Edge)object, edge.getBot());
                }
                this.addJoin((Path.OutPt)object2, (Path.OutPt)object, edge.getTop());
                object3 = edge;
            }
            object = object3.nextInAEL;
        } while (true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void processHorizontal(Edge var1_1) {
        block42 : {
            block44 : {
                block43 : {
                    DefaultClipper.LOGGER.entering(DefaultClipper.class.getName(), "isHorizontal");
                    var17_2 = new Clipper.Direction[1];
                    var21_3 = new long[1];
                    var22_4 = new long[1];
                    var2_5 = var1_1.outIdx >= 0 && this.polyOuts.get((int)var1_1.outIdx).isOpen != false;
                    DefaultClipper.getHorzDirection((Edge)var1_1, (Clipper.Direction[])var17_2, var21_3, var22_4);
                    var13_6 = var1_1;
                    while (var13_6.nextInLML != null && var13_6.nextInLML.isHorizontal()) {
                        var13_6 = var13_6.nextInLML;
                    }
                    var12_7 = var13_6.nextInLML;
                    var19_29 = null;
                    var14_30 = var12_7 == null ? var13_6.getMaximaPair() : null;
                    var15_31 = this.maxima;
                    var12_8 = var15_31;
                    if (var15_31 == null) break block42;
                    var16_32 = var15_31;
                    if (var17_2[0] != Clipper.Direction.LEFT_TO_RIGHT) break block43;
                    while (var15_31 != null && var15_31.X <= var1_1.getBot().getX()) {
                        var15_31 = var15_31.Next;
                    }
                    var12_9 = var15_31;
                    if (var15_31 == null) break block42;
                    var12_10 = var15_31;
                    if (var15_31.X < var13_6.getBot().getX()) break block42;
                    break block44;
                }
                while (var16_32.Next != null && var16_32.Next.X < var1_1.getBot().getX()) {
                    var16_32 = var16_32.Next;
                }
                var12_11 = var16_32;
                if (var16_32.X > var13_6.getTop().getX()) break block42;
            }
            var12_13 = null;
        }
        var16_32 = var14_30;
        var14_30 = var13_6;
        var15_31 = var1_1;
        var1_1 = var12_14;
        do {
            block41 : {
                var3_33 = var15_31 == var14_30;
                var18_38 = var15_31.getNextInAEL(var17_2[0]);
                var12_16 = var17_2;
                var13_6 = var16_32;
                var16_32 = var18_38;
                while (var16_32 != null) {
                    var17_2 = var1_1;
                    var18_38 = var12_17;
                    if (var1_1 == null) ** GOTO lbl76
                    if (var12_17[0] != Clipper.Direction.LEFT_TO_RIGHT) {
                        var18_38 = var12_17;
                        var12_18 = var1_1;
                        do {
                            var17_2 = var12_19;
                            var1_1 = var18_38;
                            if (var12_19 != null) {
                                var17_2 = var12_19;
                                var1_1 = var18_38;
                                if (var12_19.X > var16_32.getCurrent().getX()) {
                                    if (var15_31.outIdx >= 0 && !var2_5) {
                                        this.addOutPt((Edge)var15_31, new Point.LongPoint(var12_19.X, var15_31.getBot().getY()));
                                    }
                                    var12_20 = var12_19.Prev;
                                    continue;
                                }
                            }
                            break;
                        } while (true);
                    } else {
                        do {
                            var17_2 = var1_1;
                            var18_38 = var12_17;
                            if (var1_1 != null) {
                                var17_2 = var1_1;
                                var18_38 = var12_17;
                                if (var1_1.X < var16_32.getCurrent().getX()) {
                                    if (var15_31.outIdx >= 0 && !var2_5) {
                                        this.addOutPt((Edge)var15_31, new Point.LongPoint(var1_1.X, var15_31.getBot().getY()));
                                    }
                                    var1_1 = var1_1.Next;
                                    continue;
                                } else {
                                }
                            } else {
                            }
                            break;
                        } while (true);
lbl76: // 5 sources:
                        var1_1 = var18_38;
                    }
                    var12_22 /* !! */  = var17_2;
                    if (var1_1[0] == Clipper.Direction.LEFT_TO_RIGHT && var16_32.getCurrent().getX() > var22_4[0] || var1_1[0] == Clipper.Direction.RIGHT_TO_LEFT && var16_32.getCurrent().getX() < var21_3[0] || var16_32.getCurrent().getX() == var15_31.getTop().getX() && var15_31.nextInLML != null && var16_32.deltaX < var15_31.nextInLML.deltaX) {
                        var16_32 = var1_1;
                        break block41;
                    }
                    if (var15_31.outIdx >= 0 && !var2_5) {
                        var19_29 = this.addOutPt((Edge)var15_31, var16_32.getCurrent());
                        var17_2 = this.sortedEdges;
                        while (var17_2 != null) {
                            if (var17_2.outIdx >= 0) {
                                var4_34 = var15_31.getBot().getX();
                                var6_35 = var15_31.getTop().getX();
                                var8_36 = var17_2.getBot().getX();
                                var10_37 = var17_2.getTop().getX();
                                var18_38 = var17_2;
                                if (this.doHorzSegmentsOverlap(var4_34, var6_35, var8_36, var10_37)) {
                                    this.addJoin(this.GetLastOutPt((Edge)var18_38), var19_29, var18_38.getTop());
                                }
                            }
                            var17_2 = var17_2.nextInSEL;
                        }
                        var17_2 = var14_30;
                        this.addGhostJoin(var19_29, var15_31.getBot());
                        var14_30 = var13_6;
                        var13_6 = var17_2;
                    } else {
                        var17_2 = var13_6;
                        var13_6 = var14_30;
                        var14_30 = var17_2;
                    }
                    if (var16_32 == var14_30 && var3_33) {
                        if (var15_31.outIdx >= 0) {
                            this.addLocalMaxPoly((Edge)var15_31, (Edge)var14_30, var15_31.getTop());
                        }
                        this.deleteFromAEL((Edge)var15_31);
                        this.deleteFromAEL((Edge)var14_30);
                        return;
                    }
                    if (var1_1[0] == Clipper.Direction.LEFT_TO_RIGHT) {
                        this.intersectEdges((Edge)var15_31, (Edge)var16_32, new Point.LongPoint(var16_32.getCurrent().getX(), var15_31.getCurrent().getY()));
                    } else {
                        this.intersectEdges((Edge)var16_32, (Edge)var15_31, new Point.LongPoint(var16_32.getCurrent().getX(), var15_31.getCurrent().getY()));
                    }
                    var20_39 = var16_32.getNextInAEL((Clipper.Direction)var1_1[0]);
                    this.swapPositionsInAEL((Edge)var15_31, (Edge)var16_32);
                    var17_2 = var14_30;
                    var18_38 = var1_1;
                    var1_1 = var12_22 /* !! */ ;
                    var16_32 = var20_39;
                    var14_30 = var13_6;
                    var13_6 = var17_2;
                    var12_23 = var18_38;
                }
                var16_32 = var12_17;
                var12_24 = var1_1;
            }
            if (var15_31.nextInLML == null || !var15_31.nextInLML.isHorizontal()) break;
            var1_1 = new Edge[]{var15_31};
            this.updateEdgeIntoAEL((Edge[])var1_1);
            var15_31 = var1_1[0];
            if (var15_31.outIdx >= 0) {
                this.addOutPt((Edge)var15_31, var15_31.getBot());
            }
            DefaultClipper.getHorzDirection((Edge)var15_31, (Clipper.Direction[])var16_32, var21_3, var22_4);
            var17_2 = var16_32;
            var1_1 = var12_25;
            var16_32 = var13_6;
        } while (true);
        if (var15_31.outIdx >= 0 && var19_29 == null) {
            var12_26 = this.GetLastOutPt((Edge)var15_31);
            var1_1 = this.sortedEdges;
            while (var1_1 != null) {
                if (var1_1.outIdx >= 0 && this.doHorzSegmentsOverlap(var15_31.getBot().getX(), var15_31.getTop().getX(), var1_1.getBot().getX(), var1_1.getTop().getX())) {
                    this.addJoin(this.GetLastOutPt((Edge)var1_1), var12_26, var1_1.getTop());
                }
                var1_1 = var1_1.nextInSEL;
            }
            this.addGhostJoin(var12_26, var15_31.getTop());
        }
        if (var15_31.nextInLML != null) {
            if (var15_31.outIdx < 0) {
                var1_1 = new Edge[]{var15_31};
                this.updateEdgeIntoAEL((Edge[])var1_1);
                var1_1 = var1_1[0];
                return;
            }
            var12_28 = this.addOutPt((Edge)var15_31, var15_31.getTop());
            var1_1 = new Edge[]{var15_31};
            this.updateEdgeIntoAEL((Edge[])var1_1);
            var13_6 = var1_1[0];
            if (var13_6.windDelta == 0) {
                return;
            }
            var1_1 = var13_6.prevInAEL;
            var14_30 = var13_6.nextInAEL;
            if (var1_1 != null && var1_1.getCurrent().getX() == var13_6.getBot().getX() && var1_1.getCurrent().getY() == var13_6.getBot().getY() && var1_1.windDelta != 0 && var1_1.outIdx >= 0 && var1_1.getCurrent().getY() > var1_1.getTop().getY() && Edge.slopesEqual((Edge)var13_6, (Edge)var1_1, this.useFullRange)) {
                var1_1 = this.addOutPt((Edge)var1_1, var13_6.getBot());
            } else {
                if (var14_30 == null) return;
                if (var14_30.getCurrent().getX() != var13_6.getBot().getX()) return;
                if (var14_30.getCurrent().getY() != var13_6.getBot().getY()) return;
                if (var14_30.windDelta == 0) return;
                if (var14_30.outIdx < 0) return;
                if (var14_30.getCurrent().getY() <= var14_30.getTop().getY()) return;
                if (Edge.slopesEqual((Edge)var13_6, (Edge)var14_30, this.useFullRange) == false) return;
                var1_1 = this.addOutPt((Edge)var14_30, var13_6.getBot());
            }
            this.addJoin(var12_28, (Path.OutPt)var1_1, var13_6.getTop());
            return;
        }
        if (var15_31.outIdx >= 0) {
            this.addOutPt((Edge)var15_31, var15_31.getTop());
        }
        this.deleteFromAEL((Edge)var15_31);
    }

    private void processHorizontals() {
        Edge edge;
        LOGGER.entering(DefaultClipper.class.getName(), "processHorizontals");
        while ((edge = this.sortedEdges) != null) {
            this.deleteFromSEL(edge);
            this.processHorizontal(edge);
        }
    }

    private void processIntersectList() {
        for (int i2 = 0; i2 < this.intersectList.size(); ++i2) {
            IntersectNode intersectNode = this.intersectList.get(i2);
            this.intersectEdges(intersectNode.edge1, intersectNode.Edge2, intersectNode.getPt());
            this.swapPositionsInAEL(intersectNode.edge1, intersectNode.Edge2);
        }
        this.intersectList.clear();
    }

    private boolean processIntersections(long l2) {
        block5 : {
            LOGGER.entering(DefaultClipper.class.getName(), "processIntersections");
            if (this.activeEdges == null) {
                return true;
            }
            try {
                this.buildIntersectList(l2);
                if (this.intersectList.size() != 0) break block5;
                return true;
            }
            catch (Exception exception) {
                this.sortedEdges = null;
                this.intersectList.clear();
                throw new IllegalStateException("ProcessIntersections error", exception);
            }
        }
        if (this.intersectList.size() == 1 || this.fixupIntersectionOrder()) {
            this.processIntersectList();
            this.sortedEdges = null;
            return true;
        }
        return false;
    }

    private void setHoleState(Edge edge, Path.OutRec outRec) {
        edge = edge.prevInAEL;
        boolean bl2 = false;
        while (edge != null) {
            boolean bl3 = bl2;
            if (edge.outIdx >= 0) {
                bl3 = bl2;
                if (edge.windDelta != 0) {
                    bl3 = bl2 ^= true;
                    if (outRec.firstLeft == null) {
                        outRec.firstLeft = this.polyOuts.get(edge.outIdx);
                        bl3 = bl2;
                    }
                }
            }
            edge = edge.prevInAEL;
            bl2 = bl3;
        }
        if (bl2) {
            outRec.isHole = true;
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    private void setZ(Point.LongPoint longPoint, Edge object, Edge edge) {
        block4 : {
            block9 : {
                block6 : {
                    block8 : {
                        block7 : {
                            block5 : {
                                if (longPoint.getZ() != 0L) break block4;
                                if (this.zFillFunction == null) {
                                    return;
                                }
                                if (!longPoint.equals(object.getBot())) break block5;
                                object = object.getBot();
                                break block6;
                            }
                            if (!longPoint.equals(object.getTop())) break block7;
                            object = object.getTop();
                            break block6;
                        }
                        if (!longPoint.equals(edge.getBot())) break block8;
                        object = edge.getBot();
                        break block6;
                    }
                    if (!longPoint.equals(edge.getTop())) break block9;
                    object = edge.getTop();
                }
                longPoint.setZ(object.getZ());
                return;
            }
            this.zFillFunction.zFill(object.getBot(), object.getTop(), edge.getBot(), edge.getTop(), longPoint);
        }
    }

    public static Paths simplifyPolygon(Path path) {
        return DefaultClipper.simplifyPolygon(path, Clipper.PolyFillType.EVEN_ODD);
    }

    public static Paths simplifyPolygon(Path path, Clipper.PolyFillType polyFillType) {
        Paths paths = new Paths();
        DefaultClipper defaultClipper = new DefaultClipper(2);
        defaultClipper.addPath(path, Clipper.PolyType.SUBJECT, true);
        defaultClipper.execute(Clipper.ClipType.UNION, paths, polyFillType, polyFillType);
        return paths;
    }

    public static Paths simplifyPolygons(Paths paths) {
        return DefaultClipper.simplifyPolygons(paths, Clipper.PolyFillType.EVEN_ODD);
    }

    public static Paths simplifyPolygons(Paths paths, Clipper.PolyFillType polyFillType) {
        Paths paths2 = new Paths();
        DefaultClipper defaultClipper = new DefaultClipper(2);
        defaultClipper.addPaths(paths, Clipper.PolyType.SUBJECT, true);
        defaultClipper.execute(Clipper.ClipType.UNION, paths2, polyFillType, polyFillType);
        return paths2;
    }

    private void swapPositionsInAEL(Edge edge, Edge edge2) {
        LOGGER.entering(DefaultClipper.class.getName(), "swapPositionsInAEL");
        if (edge.nextInAEL != edge.prevInAEL) {
            if (edge2.nextInAEL == edge2.prevInAEL) {
                return;
            }
            if (edge.nextInAEL == edge2) {
                Edge edge3;
                Edge edge4 = edge2.nextInAEL;
                if (edge4 != null) {
                    edge4.prevInAEL = edge;
                }
                if ((edge3 = edge.prevInAEL) != null) {
                    edge3.nextInAEL = edge2;
                }
                edge2.prevInAEL = edge3;
                edge2.nextInAEL = edge;
                edge.prevInAEL = edge2;
                edge.nextInAEL = edge4;
            } else if (edge2.nextInAEL == edge) {
                Edge edge5;
                Edge edge6 = edge.nextInAEL;
                if (edge6 != null) {
                    edge6.prevInAEL = edge2;
                }
                if ((edge5 = edge2.prevInAEL) != null) {
                    edge5.nextInAEL = edge;
                }
                edge.prevInAEL = edge5;
                edge.nextInAEL = edge2;
                edge2.prevInAEL = edge;
                edge2.nextInAEL = edge6;
            } else {
                Edge edge7 = edge.nextInAEL;
                Edge edge8 = edge.prevInAEL;
                edge.nextInAEL = edge2.nextInAEL;
                if (edge.nextInAEL != null) {
                    edge.nextInAEL.prevInAEL = edge;
                }
                edge.prevInAEL = edge2.prevInAEL;
                if (edge.prevInAEL != null) {
                    edge.prevInAEL.nextInAEL = edge;
                }
                edge2.nextInAEL = edge7;
                if (edge2.nextInAEL != null) {
                    edge2.nextInAEL.prevInAEL = edge2;
                }
                edge2.prevInAEL = edge8;
                if (edge2.prevInAEL != null) {
                    edge2.prevInAEL.nextInAEL = edge2;
                }
            }
            if (edge.prevInAEL == null) {
                this.activeEdges = edge;
            } else if (edge2.prevInAEL == null) {
                this.activeEdges = edge2;
            }
            LOGGER.exiting(DefaultClipper.class.getName(), "swapPositionsInAEL");
        }
    }

    private void swapPositionsInSEL(Edge edge, Edge edge2) {
        if (edge.nextInSEL == null && edge.prevInSEL == null) {
            return;
        }
        if (edge2.nextInSEL == null && edge2.prevInSEL == null) {
            return;
        }
        if (edge.nextInSEL == edge2) {
            Edge edge3;
            Edge edge4 = edge2.nextInSEL;
            if (edge4 != null) {
                edge4.prevInSEL = edge;
            }
            if ((edge3 = edge.prevInSEL) != null) {
                edge3.nextInSEL = edge2;
            }
            edge2.prevInSEL = edge3;
            edge2.nextInSEL = edge;
            edge.prevInSEL = edge2;
            edge.nextInSEL = edge4;
        } else if (edge2.nextInSEL == edge) {
            Edge edge5;
            Edge edge6 = edge.nextInSEL;
            if (edge6 != null) {
                edge6.prevInSEL = edge2;
            }
            if ((edge5 = edge2.prevInSEL) != null) {
                edge5.nextInSEL = edge;
            }
            edge.prevInSEL = edge5;
            edge.nextInSEL = edge2;
            edge2.prevInSEL = edge;
            edge2.nextInSEL = edge6;
        } else {
            Edge edge7 = edge.nextInSEL;
            Edge edge8 = edge.prevInSEL;
            edge.nextInSEL = edge2.nextInSEL;
            if (edge.nextInSEL != null) {
                edge.nextInSEL.prevInSEL = edge;
            }
            edge.prevInSEL = edge2.prevInSEL;
            if (edge.prevInSEL != null) {
                edge.prevInSEL.nextInSEL = edge;
            }
            edge2.nextInSEL = edge7;
            if (edge2.nextInSEL != null) {
                edge2.nextInSEL.prevInSEL = edge2;
            }
            edge2.prevInSEL = edge8;
            if (edge2.prevInSEL != null) {
                edge2.prevInSEL.nextInSEL = edge2;
            }
        }
        if (edge.prevInSEL == null) {
            this.sortedEdges = edge;
            return;
        }
        if (edge2.prevInSEL == null) {
            this.sortedEdges = edge2;
        }
    }

    private void updateEdgeIntoAEL(Edge[] arredge) {
        Edge edge = arredge[0];
        if (edge.nextInLML != null) {
            Edge edge2 = edge.prevInAEL;
            Edge edge3 = edge.nextInAEL;
            edge.nextInLML.outIdx = edge.outIdx;
            if (edge2 != null) {
                edge2.nextInAEL = edge.nextInLML;
            } else {
                this.activeEdges = edge.nextInLML;
            }
            if (edge3 != null) {
                edge3.prevInAEL = edge.nextInLML;
            }
            edge.nextInLML.side = edge.side;
            edge.nextInLML.windDelta = edge.windDelta;
            edge.nextInLML.windCnt = edge.windCnt;
            edge.nextInLML.windCnt2 = edge.windCnt2;
            arredge[0] = edge = edge.nextInLML;
            edge.setCurrent(edge.getBot());
            edge.prevInAEL = edge2;
            edge.nextInAEL = edge3;
            if (!edge.isHorizontal()) {
                this.insertScanbeam(edge.getTop().getY());
            }
            return;
        }
        throw new IllegalStateException("UpdateEdgeIntoAEL: invalid call");
    }

    private void updateOutPtIdxs(Path.OutRec outRec) {
        Path.OutPt outPt;
        Path.OutPt outPt2 = outRec.getPoints();
        do {
            outPt2.idx = outRec.Idx;
            outPt2 = outPt = outPt2.prev;
        } while (outPt != outRec.getPoints());
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void updateWindingCount(Edge var1_1) {
        block15 : {
            block17 : {
                block19 : {
                    block20 : {
                        block21 : {
                            block18 : {
                                block16 : {
                                    block14 : {
                                        DefaultClipper.LOGGER.entering(DefaultClipper.class.getName(), "updateWindingCount");
                                        var4_2 = var1_1.prevInAEL;
                                        while (var4_2 != null && (var4_2.polyTyp != var1_1.polyTyp || var4_2.windDelta == 0)) {
                                            var4_2 = var4_2.prevInAEL;
                                        }
                                        if (var4_2 != null) break block14;
                                        var2_3 = var1_1.windDelta == 0 ? 1 : var1_1.windDelta;
                                        var1_1.windCnt = var2_3;
                                        var1_1.windCnt2 = 0;
                                        var4_2 = this.activeEdges;
                                        break block15;
                                    }
                                    if (var1_1.windDelta != 0 || this.clipType == Clipper.ClipType.UNION) break block16;
                                    var1_1.windCnt = 1;
                                    break block17;
                                }
                                if (!var1_1.isEvenOddFillType(this.clipFillType, this.subjFillType)) break block18;
                                if (var1_1.windDelta == 0) {
                                    var5_5 = var4_2.prevInAEL;
                                    var2_3 = 1;
                                    while (var5_5 != null) {
                                        var3_4 = var2_3;
                                        if (var5_5.polyTyp == var4_2.polyTyp) {
                                            var3_4 = var2_3;
                                            if (var5_5.windDelta != 0) {
                                                var3_4 = var2_3 ^ 1;
                                            }
                                        }
                                        var5_5 = var5_5.prevInAEL;
                                        var2_3 = var3_4;
                                    }
                                    var2_3 ^= 1;
                                } else {
                                    var2_3 = var1_1.windDelta;
                                }
                                break block19;
                            }
                            if (var4_2.windCnt * var4_2.windDelta >= 0) break block20;
                            if (Math.abs(var4_2.windCnt) <= 1) break block21;
                            if (var4_2.windDelta * var1_1.windDelta >= 0) ** GOTO lbl-1000
                            ** GOTO lbl-1000
                        }
                        var2_3 = var1_1.windDelta == 0 ? 1 : var1_1.windDelta;
                        break block19;
                    }
                    if (var1_1.windDelta == 0) {
                        var2_3 = var4_2.windCnt < 0 ? var4_2.windCnt - 1 : var4_2.windCnt + 1;
                    } else if (var4_2.windDelta * var1_1.windDelta < 0) lbl-1000: // 2 sources:
                    {
                        var2_3 = var4_2.windCnt;
                    } else lbl-1000: // 2 sources:
                    {
                        var2_3 = var4_2.windCnt + var1_1.windDelta;
                    }
                }
                var1_1.windCnt = var2_3;
            }
            var1_1.windCnt2 = var4_2.windCnt2;
            var4_2 = var4_2.nextInAEL;
        }
        var5_5 = var4_2;
        if (!var1_1.isEvenOddAltFillType(this.clipFillType, this.subjFillType)) {
            while (var5_5 != var1_1) {
                var1_1.windCnt2 += var5_5.windDelta;
                var5_5 = var5_5.nextInAEL;
            }
            return;
        }
        while (var4_2 != var1_1) {
            if (var4_2.windDelta != 0) {
                var2_3 = var1_1.windCnt2 == 0 ? 1 : 0;
                var1_1.windCnt2 = var2_3;
            }
            var4_2 = var4_2.nextInAEL;
        }
    }

    @Override
    public boolean execute(Clipper.ClipType clipType, Paths paths) {
        return this.execute(clipType, paths, Clipper.PolyFillType.EVEN_ODD);
    }

    public boolean execute(Clipper.ClipType clipType, Paths paths, Clipper.PolyFillType polyFillType) {
        return this.execute(clipType, paths, polyFillType, polyFillType);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public boolean execute(Clipper.ClipType clipType, Paths paths, Clipper.PolyFillType polyFillType, Clipper.PolyFillType polyFillType2) {
        synchronized (this) {
            if (this.hasOpenPaths) {
                throw new IllegalStateException("Error: PolyTree struct is needed for open path clipping.");
            }
            paths.clear();
            this.subjFillType = polyFillType;
            this.clipFillType = polyFillType2;
            this.clipType = clipType;
            this.usingPolyTree = false;
            try {
                boolean bl2 = this.executeInternal();
                if (bl2) {
                    this.buildResult(paths);
                }
                return bl2;
            }
            finally {
                this.polyOuts.clear();
            }
        }
    }

    @Override
    public boolean execute(Clipper.ClipType clipType, PolyTree polyTree) {
        return this.execute(clipType, polyTree, Clipper.PolyFillType.EVEN_ODD);
    }

    public boolean execute(Clipper.ClipType clipType, PolyTree polyTree, Clipper.PolyFillType polyFillType) {
        return this.execute(clipType, polyTree, polyFillType, polyFillType);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public boolean execute(Clipper.ClipType clipType, PolyTree polyTree, Clipper.PolyFillType polyFillType, Clipper.PolyFillType polyFillType2) {
        synchronized (this) {
            this.subjFillType = polyFillType;
            this.clipFillType = polyFillType2;
            this.clipType = clipType;
            this.usingPolyTree = true;
            try {
                boolean bl2 = this.executeInternal();
                if (bl2) {
                    this.buildResult2(polyTree);
                }
                return bl2;
            }
            finally {
                this.polyOuts.clear();
            }
        }
    }

    @Override
    protected void reset() {
        super.reset();
        this.scanbeam = null;
        this.maxima = null;
        this.activeEdges = null;
        this.sortedEdges = null;
        ClipperBase.LocalMinima localMinima = this.minimaList;
        while (localMinima != null) {
            this.insertScanbeam(localMinima.y);
            localMinima = localMinima.next;
        }
    }

    private class IntersectNode {
        Edge Edge2;
        Edge edge1;
        private Point.LongPoint pt;

        private IntersectNode() {
        }

        public Point.LongPoint getPt() {
            return this.pt;
        }

        public void setPt(Point.LongPoint longPoint) {
            this.pt = longPoint;
        }
    }

}

