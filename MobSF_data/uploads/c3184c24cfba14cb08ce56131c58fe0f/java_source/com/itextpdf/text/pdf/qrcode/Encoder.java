/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.qrcode;

import com.itextpdf.text.pdf.qrcode.BitVector;
import com.itextpdf.text.pdf.qrcode.BlockPair;
import com.itextpdf.text.pdf.qrcode.ByteArray;
import com.itextpdf.text.pdf.qrcode.ByteMatrix;
import com.itextpdf.text.pdf.qrcode.CharacterSetECI;
import com.itextpdf.text.pdf.qrcode.EncodeHintType;
import com.itextpdf.text.pdf.qrcode.ErrorCorrectionLevel;
import com.itextpdf.text.pdf.qrcode.GF256;
import com.itextpdf.text.pdf.qrcode.MaskUtil;
import com.itextpdf.text.pdf.qrcode.MatrixUtil;
import com.itextpdf.text.pdf.qrcode.Mode;
import com.itextpdf.text.pdf.qrcode.QRCode;
import com.itextpdf.text.pdf.qrcode.ReedSolomonEncoder;
import com.itextpdf.text.pdf.qrcode.Version;
import com.itextpdf.text.pdf.qrcode.WriterException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Map;

public final class Encoder {
    private static final int[] ALPHANUMERIC_TABLE = new int[]{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 36, -1, -1, -1, 37, 38, -1, -1, -1, -1, 39, 40, -1, 41, 42, 43, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, -1, -1, -1, -1, -1};
    static final String DEFAULT_BYTE_MODE_ENCODING = "ISO-8859-1";

    private Encoder() {
    }

    static void append8BitBytes(String arrby, BitVector bitVector, String string2) {
        try {
            arrby = arrby.getBytes(string2);
        }
        catch (UnsupportedEncodingException unsupportedEncodingException) {
            throw new WriterException(unsupportedEncodingException.toString());
        }
        for (int i2 = 0; i2 < arrby.length; ++i2) {
            bitVector.appendBits(arrby[i2], 8);
        }
        return;
    }

    static void appendAlphanumericBytes(String string2, BitVector bitVector) {
        int n2 = string2.length();
        int n3 = 0;
        while (n3 < n2) {
            int n4 = Encoder.getAlphanumericCode(string2.charAt(n3));
            if (n4 != -1) {
                int n5 = n3 + 1;
                if (n5 < n2) {
                    if ((n5 = Encoder.getAlphanumericCode(string2.charAt(n5))) != -1) {
                        bitVector.appendBits(n4 * 45 + n5, 11);
                        n3 += 2;
                        continue;
                    }
                    throw new WriterException();
                }
                bitVector.appendBits(n4, 6);
                n3 = n5;
                continue;
            }
            throw new WriterException();
        }
    }

    static void appendBytes(String charSequence, Mode mode, BitVector bitVector, String string2) {
        if (mode.equals(Mode.NUMERIC)) {
            Encoder.appendNumericBytes((String)charSequence, bitVector);
            return;
        }
        if (mode.equals(Mode.ALPHANUMERIC)) {
            Encoder.appendAlphanumericBytes((String)charSequence, bitVector);
            return;
        }
        if (mode.equals(Mode.BYTE)) {
            Encoder.append8BitBytes((String)charSequence, bitVector, string2);
            return;
        }
        if (mode.equals(Mode.KANJI)) {
            Encoder.appendKanjiBytes((String)charSequence, bitVector);
            return;
        }
        charSequence = new StringBuilder();
        charSequence.append("Invalid mode: ");
        charSequence.append(mode);
        throw new WriterException(charSequence.toString());
    }

    private static void appendECI(CharacterSetECI characterSetECI, BitVector bitVector) {
        bitVector.appendBits(Mode.ECI.getBits(), 4);
        bitVector.appendBits(characterSetECI.getValue(), 8);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    static void appendKanjiBytes(String var0, BitVector var1_2) {
        try {}
        catch (UnsupportedEncodingException var0_1) {
            throw new WriterException(var0_1.toString());
        }
        var0 = var0.getBytes("Shift_JIS");
        var4_3 = var0.length;
        var2_4 = 0;
        while (var2_4 < var4_3) {
            var5_6 = (var0[var2_4] & 255) << 8 | var0[var2_4 + 1] & 255;
            var3_5 = 33088;
            if (var5_6 >= 33088 && var5_6 <= 40956) ** GOTO lbl14
            if (var5_6 >= 57408 && var5_6 <= 60351) {
                var3_5 = 49472;
lbl14: // 2 sources:
                var3_5 = var5_6 - var3_5;
            } else {
                var3_5 = -1;
            }
            if (var3_5 == -1) throw new WriterException("Invalid byte sequence");
            var1_2.appendBits((var3_5 >> 8) * 192 + (var3_5 & 255), 13);
            var2_4 += 2;
        }
    }

    static void appendLengthInfo(int n2, int n3, Mode object, BitVector bitVector) {
        int n4 = (1 << (n3 = object.getCharacterCountBits(Version.getVersionForNumber(n3)))) - 1;
        if (n2 <= n4) {
            bitVector.appendBits(n2, n3);
            return;
        }
        object = new StringBuilder();
        object.append(n2);
        object.append("is bigger than");
        object.append(n4);
        throw new WriterException(object.toString());
    }

    static void appendModeInfo(Mode mode, BitVector bitVector) {
        bitVector.appendBits(mode.getBits(), 4);
    }

    static void appendNumericBytes(String string2, BitVector bitVector) {
        int n2 = string2.length();
        int n3 = 0;
        while (n3 < n2) {
            int n4 = string2.charAt(n3) - 48;
            int n5 = n3 + 2;
            if (n5 < n2) {
                bitVector.appendBits(n4 * 100 + (string2.charAt(n3 + 1) - 48) * 10 + (string2.charAt(n5) - 48), 10);
                n3 += 3;
                continue;
            }
            if (++n3 < n2) {
                bitVector.appendBits(n4 * 10 + (string2.charAt(n3) - 48), 7);
                n3 = n5;
                continue;
            }
            bitVector.appendBits(n4, 4);
        }
    }

    private static int calculateMaskPenalty(ByteMatrix byteMatrix) {
        return MaskUtil.applyMaskPenaltyRule1(byteMatrix) + 0 + MaskUtil.applyMaskPenaltyRule2(byteMatrix) + MaskUtil.applyMaskPenaltyRule3(byteMatrix) + MaskUtil.applyMaskPenaltyRule4(byteMatrix);
    }

    private static int chooseMaskPattern(BitVector bitVector, ErrorCorrectionLevel errorCorrectionLevel, int n2, ByteMatrix byteMatrix) {
        int n3 = Integer.MAX_VALUE;
        int n4 = -1;
        for (int i2 = 0; i2 < 8; ++i2) {
            MatrixUtil.buildMatrix(bitVector, errorCorrectionLevel, n2, i2, byteMatrix);
            int n5 = Encoder.calculateMaskPenalty(byteMatrix);
            int n6 = n3;
            if (n5 < n3) {
                n4 = i2;
                n6 = n5;
            }
            n3 = n6;
        }
        return n4;
    }

    public static Mode chooseMode(String string2) {
        return Encoder.chooseMode(string2, null);
    }

    public static Mode chooseMode(String string2, String string3) {
        if ("Shift_JIS".equals(string3)) {
            if (Encoder.isOnlyDoubleByteKanji(string2)) {
                return Mode.KANJI;
            }
            return Mode.BYTE;
        }
        boolean bl2 = false;
        boolean bl3 = false;
        for (int i2 = 0; i2 < string2.length(); ++i2) {
            char c2 = string2.charAt(i2);
            if (c2 >= '0' && c2 <= '9') {
                bl3 = true;
                continue;
            }
            if (Encoder.getAlphanumericCode(c2) != -1) {
                bl2 = true;
                continue;
            }
            return Mode.BYTE;
        }
        if (bl2) {
            return Mode.ALPHANUMERIC;
        }
        if (bl3) {
            return Mode.NUMERIC;
        }
        return Mode.BYTE;
    }

    public static void encode(String string2, ErrorCorrectionLevel errorCorrectionLevel, QRCode qRCode) {
        Encoder.encode(string2, errorCorrectionLevel, null, qRCode);
    }

    public static void encode(String object, ErrorCorrectionLevel object2, Map<EncodeHintType, Object> object3, QRCode qRCode) {
        object3 = object3 == null ? null : (String)object3.get(EncodeHintType.CHARACTER_SET);
        Object object4 = object3;
        if (object3 == null) {
            object4 = DEFAULT_BYTE_MODE_ENCODING;
        }
        object3 = Encoder.chooseMode((String)object, (String)object4);
        BitVector bitVector = new BitVector();
        Encoder.appendBytes((String)object, (Mode)object3, bitVector, (String)object4);
        Encoder.initQRCode(bitVector.sizeInBytes(), (ErrorCorrectionLevel)object2, (Mode)object3, qRCode);
        object2 = new BitVector();
        if (object3 == Mode.BYTE && !DEFAULT_BYTE_MODE_ENCODING.equals(object4) && (object4 = CharacterSetECI.getCharacterSetECIByName((String)object4)) != null) {
            Encoder.appendECI((CharacterSetECI)object4, (BitVector)object2);
        }
        Encoder.appendModeInfo((Mode)object3, (BitVector)object2);
        int n2 = object3.equals(Mode.BYTE) ? bitVector.sizeInBytes() : object.length();
        Encoder.appendLengthInfo(n2, qRCode.getVersion(), (Mode)object3, (BitVector)object2);
        object2.appendBitVector(bitVector);
        Encoder.terminateBits(qRCode.getNumDataBytes(), (BitVector)object2);
        object = new BitVector();
        Encoder.interleaveWithECBytes((BitVector)object2, qRCode.getNumTotalBytes(), qRCode.getNumDataBytes(), qRCode.getNumRSBlocks(), (BitVector)object);
        object2 = new ByteMatrix(qRCode.getMatrixWidth(), qRCode.getMatrixWidth());
        qRCode.setMaskPattern(Encoder.chooseMaskPattern((BitVector)object, qRCode.getECLevel(), qRCode.getVersion(), (ByteMatrix)object2));
        MatrixUtil.buildMatrix((BitVector)object, qRCode.getECLevel(), qRCode.getVersion(), qRCode.getMaskPattern(), (ByteMatrix)object2);
        qRCode.setMatrix((ByteMatrix)object2);
        if (qRCode.isValid()) {
            return;
        }
        object = new StringBuilder();
        object.append("Invalid QR code: ");
        object.append(qRCode.toString());
        throw new WriterException(object.toString());
    }

    static ByteArray generateECBytes(ByteArray byteArray, int n2) {
        int n3;
        int n4 = byteArray.size();
        int[] arrn = new int[n4 + n2];
        int n5 = 0;
        for (n3 = 0; n3 < n4; ++n3) {
            arrn[n3] = byteArray.at(n3);
        }
        new ReedSolomonEncoder(GF256.QR_CODE_FIELD).encode(arrn, n2);
        byteArray = new ByteArray(n2);
        for (n3 = n5; n3 < n2; ++n3) {
            byteArray.set(n3, arrn[n4 + n3]);
        }
        return byteArray;
    }

    static int getAlphanumericCode(int n2) {
        if (n2 < ALPHANUMERIC_TABLE.length) {
            return ALPHANUMERIC_TABLE[n2];
        }
        return -1;
    }

    static void getNumDataBytesAndNumECBytesForBlockID(int n2, int n3, int n4, int n5, int[] arrn, int[] arrn2) {
        if (n5 < n4) {
            int n6 = n2 % n4;
            int n7 = n4 - n6;
            int n8 = n2 / n4;
            int n9 = (n3 /= n4) + 1;
            int n10 = n8 - n3;
            if (n10 == (n8 = n8 + 1 - n9)) {
                if (n4 == n7 + n6) {
                    if (n2 == (n3 + n10) * n7 + (n9 + n8) * n6) {
                        if (n5 < n7) {
                            arrn[0] = n3;
                            arrn2[0] = n10;
                            return;
                        }
                        arrn[0] = n9;
                        arrn2[0] = n8;
                        return;
                    }
                    throw new WriterException("Total bytes mismatch");
                }
                throw new WriterException("RS blocks mismatch");
            }
            throw new WriterException("EC bytes mismatch");
        }
        throw new WriterException("Block ID too large");
    }

    private static void initQRCode(int n2, ErrorCorrectionLevel errorCorrectionLevel, Mode object, QRCode qRCode) {
        qRCode.setECLevel(errorCorrectionLevel);
        qRCode.setMode((Mode)object);
        for (int i2 = 1; i2 <= 40; ++i2) {
            object = Version.getVersionForNumber(i2);
            int n3 = object.getTotalCodewords();
            Version.ECBlocks eCBlocks = object.getECBlocksForLevel(errorCorrectionLevel);
            int n4 = eCBlocks.getTotalECCodewords();
            int n5 = eCBlocks.getNumBlocks();
            int n6 = n3 - n4;
            if (n6 < n2 + 3) continue;
            qRCode.setVersion(i2);
            qRCode.setNumTotalBytes(n3);
            qRCode.setNumDataBytes(n6);
            qRCode.setNumRSBlocks(n5);
            qRCode.setNumECBytes(n4);
            qRCode.setMatrixWidth(object.getDimensionForVersion());
            return;
        }
        throw new WriterException("Cannot find proper rs block info (input data too big?)");
    }

    static void interleaveWithECBytes(BitVector object, int n2, int n3, int n4, BitVector bitVector) {
        if (object.sizeInBytes() == n3) {
            ArrayList<BlockPair> arrayList = new ArrayList<BlockPair>(n4);
            int n5 = 0;
            int n6 = 0;
            int n7 = 0;
            for (int i2 = 0; i2 < n4; ++i2) {
                int[] arrn = new int[1];
                Object object2 = new int[1];
                Encoder.getNumDataBytesAndNumECBytesForBlockID(n2, n3, n4, i2, arrn, (int[])object2);
                ByteArray byteArray = new ByteArray();
                byteArray.set(object.getArray(), n5, arrn[0]);
                object2 = Encoder.generateECBytes(byteArray, object2[0]);
                arrayList.add(new BlockPair(byteArray, (ByteArray)object2));
                n6 = Math.max(n6, byteArray.size());
                n7 = Math.max(n7, object2.size());
                n5 += arrn[0];
            }
            if (n3 == n5) {
                for (n3 = 0; n3 < n6; ++n3) {
                    for (n4 = 0; n4 < arrayList.size(); ++n4) {
                        object = ((BlockPair)arrayList.get(n4)).getDataBytes();
                        if (n3 >= object.size()) continue;
                        bitVector.appendBits(object.at(n3), 8);
                    }
                }
                for (n3 = 0; n3 < n7; ++n3) {
                    for (n4 = 0; n4 < arrayList.size(); ++n4) {
                        object = ((BlockPair)arrayList.get(n4)).getErrorCorrectionBytes();
                        if (n3 >= object.size()) continue;
                        bitVector.appendBits(object.at(n3), 8);
                    }
                }
                if (n2 == bitVector.sizeInBytes()) {
                    return;
                }
                object = new StringBuilder();
                object.append("Interleaving error: ");
                object.append(n2);
                object.append(" and ");
                object.append(bitVector.sizeInBytes());
                object.append(" differ.");
                throw new WriterException(object.toString());
            }
            throw new WriterException("Data bytes does not match offset");
        }
        throw new WriterException("Number of bits and data bytes does not match");
    }

    private static boolean isOnlyDoubleByteKanji(String arrby) {
        try {
            arrby = arrby.getBytes("Shift_JIS");
        }
        catch (UnsupportedEncodingException unsupportedEncodingException) {
            return false;
        }
        int n2 = arrby.length;
        if (n2 % 2 != 0) {
            return false;
        }
        for (int i2 = 0; i2 < n2; i2 += 2) {
            int n3 = arrby[i2] & 255;
            if (n3 >= 129 && n3 <= 159) continue;
            if (n3 >= 224) {
                if (n3 <= 235) continue;
                return false;
            }
            return false;
        }
        return true;
    }

    /*
     * Enabled aggressive block sorting
     */
    static void terminateBits(int n2, BitVector bitVector) {
        int n3;
        int n4 = n2 << 3;
        if (bitVector.size() > n4) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("data bits cannot fit in the QR Code");
            stringBuilder.append(bitVector.size());
            stringBuilder.append(" > ");
            stringBuilder.append(n4);
            throw new WriterException(stringBuilder.toString());
        }
        int n5 = 0;
        for (n3 = 0; n3 < 4 && bitVector.size() < n4; ++n3) {
            bitVector.appendBit(0);
        }
        int n6 = bitVector.size() % 8;
        if (n6 > 0) {
            for (n3 = 0; n3 < 8 - n6; ++n3) {
                bitVector.appendBit(0);
            }
        }
        if (bitVector.size() % 8 != 0) {
            throw new WriterException("Number of bits is not a multiple of 8");
        }
        n6 = bitVector.sizeInBytes();
        for (n3 = n5; n3 < n2 - n6; ++n3) {
            n5 = n3 % 2 == 0 ? 236 : 17;
            bitVector.appendBits(n5, 8);
        }
        if (bitVector.size() == n4) {
            return;
        }
        throw new WriterException("Bits size does not equal capacity");
    }
}

