/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.fonts.cmaps.CMapByteCid;
import com.itextpdf.text.pdf.fonts.cmaps.CMapCache;
import com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni;
import com.itextpdf.text.pdf.fonts.cmaps.CMapParserEx;
import com.itextpdf.text.pdf.fonts.cmaps.CMapSequence;
import com.itextpdf.text.pdf.fonts.cmaps.CMapToUnicode;
import com.itextpdf.text.pdf.fonts.cmaps.CidLocation;
import com.itextpdf.text.pdf.fonts.cmaps.CidLocationFromByte;
import com.itextpdf.text.pdf.fonts.cmaps.IdentityToUnicode;
import java.io.IOException;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class CMapAwareDocumentFont
extends DocumentFont {
    private CMapByteCid byteCid;
    private CMapCidUni cidUni;
    private char[] cidbyte2uni;
    private PdfDictionary fontDic;
    private int spaceWidth;
    private CMapToUnicode toUnicodeCmap;
    private Map<Integer, Integer> uni2cid;

    public CMapAwareDocumentFont(PRIndirectReference pRIndirectReference) {
        super(pRIndirectReference);
        this.fontDic = (PdfDictionary)PdfReader.getPdfObjectRelease(pRIndirectReference);
        this.initFont();
    }

    public CMapAwareDocumentFont(PdfDictionary pdfDictionary) {
        super(pdfDictionary);
        this.fontDic = pdfDictionary;
        this.initFont();
    }

    private int computeAverageWidth() {
        int n2;
        int n3 = 0;
        int n4 = 0;
        int n5 = 0;
        for (n2 = 0; n2 < this.widths.length; ++n2) {
            int n6 = n4;
            int n7 = n5;
            if (this.widths[n2] != 0) {
                n7 = n5 + this.widths[n2];
                n6 = n4 + 1;
            }
            n4 = n6;
            n5 = n7;
        }
        n2 = n3;
        if (n4 != 0) {
            n2 = n5 / n4;
        }
        return n2;
    }

    private String decodeSingleCID(byte[] arrby, int n2, int n3) {
        if (this.toUnicodeCmap != null) {
            int n4 = n2 + n3;
            if (n4 <= arrby.length) {
                String string2 = this.toUnicodeCmap.lookup(arrby, n2, n3);
                if (string2 != null) {
                    return string2;
                }
                if (n3 != 1 || this.cidbyte2uni == null) {
                    return null;
                }
            } else {
                throw new ArrayIndexOutOfBoundsException(MessageLocalization.getComposedMessage("invalid.index.1", n4));
            }
        }
        if (n3 == 1) {
            if (this.cidbyte2uni == null) {
                return "";
            }
            return new String(this.cidbyte2uni, arrby[n2] & 255, 1);
        }
        throw new Error("Multi-byte glyphs not implemented yet");
    }

    private void initFont() {
        this.processToUnicode();
        try {
            this.processUni2Byte();
            this.spaceWidth = super.getWidth(32);
            if (this.spaceWidth == 0) {
                this.spaceWidth = this.computeAverageWidth();
            }
            if (this.cjkEncoding != null) {
                this.byteCid = CMapCache.getCachedCMapByteCid(this.cjkEncoding);
                this.cidUni = CMapCache.getCachedCMapCidUni(this.uniMap);
            }
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void processToUnicode() {
        var1_1 = PdfReader.getPdfObjectRelease(this.fontDic.get(PdfName.TOUNICODE));
        if (!(var1_1 instanceof PRStream)) ** GOTO lbl9
        try {
            var1_1 = new CidLocationFromByte(PdfReader.getStreamBytes((PRStream)var1_1));
            this.toUnicodeCmap = new CMapToUnicode();
            CMapParserEx.parseCid("", this.toUnicodeCmap, (CidLocation)var1_1);
            var1_1 = this.toUnicodeCmap.createReverseMapping();
            ** break block8
lbl9: // 1 sources:
            if (this.isType0 == false) return;
            var1_1 = this.fontDic.getAsName(PdfName.ENCODING);
            if (var1_1 == null) {
                return;
            }
            if (!PdfName.decodeName(var1_1.toString()).equals("Identity-H")) {
                return;
            }
            var1_1 = ((PdfDictionary)PdfReader.getPdfObjectRelease(((PdfArray)PdfReader.getPdfObjectRelease(this.fontDic.get(PdfName.DESCENDANTFONTS))).getPdfObject(0))).getAsDict(PdfName.CIDSYSTEMINFO);
            if (var1_1 == null) {
                return;
            }
            if ((var1_1 = var1_1.getAsString(PdfName.ORDERING)) == null) {
                return;
            }
            if ((var1_1 = IdentityToUnicode.GetMapFromOrdering(var1_1.toUnicodeString())) == null) {
                return;
            }
            this.toUnicodeCmap = var1_1;
            var1_1 = this.toUnicodeCmap.createReverseMapping();
        }
        catch (IOException var1_2) {}
lbl-1000: // 2 sources:
        {
            
            this.uni2cid = var1_1;
            return;
        }
        this.toUnicodeCmap = null;
        this.uni2cid = null;
    }

    private void processUni2Byte() {
        int n2;
        Object object = this.getByte2Uni();
        Object object2 = object.toOrderedKeys();
        if (((int[])object2).length == 0) {
            return;
        }
        this.cidbyte2uni = new char[256];
        int n3 = 0;
        for (n2 = 0; n2 < ((int[])object2).length; ++n2) {
            int n4 = object2[n2];
            this.cidbyte2uni[n4] = (char)object.get(n4);
        }
        if (this.toUnicodeCmap != null) {
            object = this.toUnicodeCmap.createDirectMapping().entrySet().iterator();
            while (object.hasNext()) {
                object2 = (Map.Entry)object.next();
                if ((Integer)object2.getKey() >= 256) continue;
                this.cidbyte2uni[((Integer)object2.getKey()).intValue()] = (char)((Integer)object2.getValue()).intValue();
            }
        }
        if ((object = this.getDiffmap()) != null) {
            object2 = object.toOrderedKeys();
            for (n2 = n3; n2 < ((int[])object2).length; ++n2) {
                n3 = object.get((int)object2[n2]);
                if (n3 >= 256) continue;
                this.cidbyte2uni[n3] = (char)object2[n2];
            }
        }
    }

    public String decode(byte[] object, int n2, int n3) {
        StringBuilder stringBuilder;
        stringBuilder = new StringBuilder();
        if (this.toUnicodeCmap == null && this.byteCid != null) {
            object = new CMapSequence((byte[])object, n2, n3);
            object = this.byteCid.decodeSequence((CMapSequence)object);
            for (n2 = 0; n2 < object.length(); ++n2) {
                n3 = this.cidUni.lookup(object.charAt(n2));
                if (n3 <= 0) continue;
                stringBuilder.append(Utilities.convertFromUtf32(n3));
            }
        } else {
            int n4;
            int n5 = n2;
            while (n5 < (n4 = n2 + n3)) {
                String string2 = this.decodeSingleCID((byte[])object, n5, 1);
                int n6 = n5;
                String string3 = string2;
                if (string2 == null) {
                    n6 = n5;
                    string3 = string2;
                    if (n5 < n4 - 1) {
                        string3 = this.decodeSingleCID((byte[])object, n5, 2);
                        n6 = n5 + 1;
                    }
                }
                if (string3 != null) {
                    stringBuilder.append(string3);
                }
                n5 = n6 + 1;
            }
        }
        return stringBuilder.toString();
    }

    public String encode(byte[] arrby, int n2, int n3) {
        return this.decode(arrby, n2, n3);
    }

    @Override
    public int getWidth(int n2) {
        if (n2 == 32) {
            if (this.spaceWidth != 0) {
                return this.spaceWidth;
            }
            return this.defaultWidth;
        }
        return super.getWidth(n2);
    }
}

