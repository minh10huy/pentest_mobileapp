/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.text.Version;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.UnsupportedPdfException;
import com.itextpdf.text.pdf.FilterHandlers;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.codec.PngWriter;
import com.itextpdf.text.pdf.codec.TiffWriter;
import java.io.ByteArrayOutputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;

public class PdfImageObject {
    private int bpc;
    private PdfDictionary colorSpaceDic;
    private PdfDictionary dictionary;
    private int height;
    private byte[] icc;
    private byte[] imageBytes;
    private byte[] palette;
    private int pngBitDepth;
    private int pngColorType = -1;
    private ImageBytesType streamContentType = null;
    private int stride;
    private int width;

    public PdfImageObject(PRStream pRStream) {
        this(pRStream, PdfReader.getStreamBytesRaw(pRStream), null);
    }

    public PdfImageObject(PRStream pRStream, PdfDictionary pdfDictionary) {
        this(pRStream, PdfReader.getStreamBytesRaw(pRStream), pdfDictionary);
    }

    /*
     * Enabled aggressive block sorting
     */
    protected PdfImageObject(PdfDictionary object, byte[] arrby, PdfDictionary object2) {
        void var2_6;
        TrackingFilter trackingFilter;
        this.dictionary = object;
        this.colorSpaceDic = trackingFilter;
        trackingFilter = new TrackingFilter();
        HashMap<PdfName, FilterHandlers.FilterHandler> hashMap = new HashMap<PdfName, FilterHandlers.FilterHandler>(FilterHandlers.getDefaultFilterHandlers());
        hashMap.put(PdfName.JBIG2DECODE, trackingFilter);
        hashMap.put(PdfName.DCTDECODE, trackingFilter);
        hashMap.put(PdfName.JPXDECODE, trackingFilter);
        this.imageBytes = PdfReader.decodeBytes((byte[])var2_6, object, hashMap);
        if (trackingFilter.lastFilterName != null) {
            void var1_3;
            if (PdfName.JBIG2DECODE.equals(trackingFilter.lastFilterName)) {
                ImageBytesType imageBytesType = ImageBytesType.JBIG2;
            } else if (PdfName.DCTDECODE.equals(trackingFilter.lastFilterName)) {
                ImageBytesType imageBytesType = ImageBytesType.JPG;
            } else {
                if (!PdfName.JPXDECODE.equals(trackingFilter.lastFilterName)) return;
                ImageBytesType imageBytesType = ImageBytesType.JP2;
            }
            this.streamContentType = var1_3;
            return;
        }
        this.decodeImageBytes();
    }

    /*
     * Enabled aggressive block sorting
     */
    private void decodeImageBytes() {
        Object object;
        void var3_6;
        void var3_11;
        ImageBytesType imageBytesType = this.streamContentType;
        int n2 = 0;
        if (imageBytesType != null) {
            throw new IllegalStateException(MessageLocalization.getComposedMessage("Decoding.can't.happen.on.this.type.of.stream.(.1.)", new Object[]{this.streamContentType}));
        }
        this.pngColorType = -1;
        PdfObject pdfObject = this.dictionary.getAsArray(PdfName.DECODE);
        this.width = this.dictionary.getAsNumber(PdfName.WIDTH).intValue();
        this.height = this.dictionary.getAsNumber(PdfName.HEIGHT).intValue();
        this.pngBitDepth = this.bpc = this.dictionary.getAsNumber(PdfName.BITSPERCOMPONENT).intValue();
        Object object2 = this.dictionary.getDirectObject(PdfName.COLORSPACE);
        PdfObject pdfObject2 = object2;
        if (object2 instanceof PdfName) {
            PdfObject pdfObject3 = object2;
            if (this.colorSpaceDic != null) {
                object = this.colorSpaceDic.getDirectObject((PdfName)object2);
                PdfObject pdfObject4 = object2;
                if (object != null) {
                    byte[] arrby = object;
                }
            }
        }
        this.palette = null;
        this.icc = null;
        this.stride = 0;
        this.findColorspace((PdfObject)var3_6, true);
        object2 = new ByteArrayOutputStream();
        if (this.pngColorType < 0) {
            if (this.bpc != 8) {
                throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("the.color.depth.1.is.not.supported", this.bpc));
            }
            if (!PdfName.DEVICECMYK.equals(var3_6)) {
                if (!(var3_6 instanceof PdfArray)) {
                    throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("the.color.space.1.is.not.supported", var3_6));
                }
                object = (PdfArray)var3_6;
                pdfObject = object.getDirectObject(0);
                if (!PdfName.ICCBASED.equals(pdfObject)) {
                    throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("the.color.space.1.is.not.supported", var3_6));
                }
                PRStream pRStream = (PRStream)object.getDirectObject(1);
                n2 = pRStream.getAsNumber(PdfName.N).intValue();
                if (n2 != 4) {
                    throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("N.value.1.is.not.supported", n2));
                }
                this.icc = PdfReader.getStreamBytes(pRStream);
            }
            this.stride = this.width * 4;
            TiffWriter tiffWriter = new TiffWriter();
            tiffWriter.addField(new TiffWriter.FieldShort(277, 4));
            tiffWriter.addField(new TiffWriter.FieldShort(258, new int[]{8, 8, 8, 8}));
            tiffWriter.addField(new TiffWriter.FieldShort(262, 5));
            tiffWriter.addField(new TiffWriter.FieldLong(256, this.width));
            tiffWriter.addField(new TiffWriter.FieldLong(257, this.height));
            tiffWriter.addField(new TiffWriter.FieldShort(259, 5));
            tiffWriter.addField(new TiffWriter.FieldShort(317, 2));
            tiffWriter.addField(new TiffWriter.FieldLong(278, this.height));
            tiffWriter.addField(new TiffWriter.FieldRational(282, new int[]{300, 1}));
            tiffWriter.addField(new TiffWriter.FieldRational(283, new int[]{300, 1}));
            tiffWriter.addField(new TiffWriter.FieldShort(296, 2));
            tiffWriter.addField(new TiffWriter.FieldAscii(305, Version.getInstance().getVersion()));
            object = new ByteArrayOutputStream();
            TiffWriter.compressLZW((OutputStream)object, 2, this.imageBytes, this.height, 4, this.stride);
            object = object.toByteArray();
            tiffWriter.addField(new TiffWriter.FieldImage((byte[])object));
            tiffWriter.addField(new TiffWriter.FieldLong(279, ((Object)object).length));
            if (this.icc != null) {
                tiffWriter.addField(new TiffWriter.FieldUndefined(34675, this.icc));
            }
            tiffWriter.writeFile((OutputStream)object2);
            ImageBytesType imageBytesType2 = ImageBytesType.CCITT;
        } else {
            PngWriter pngWriter = new PngWriter((OutputStream)object2);
            if (pdfObject != null && this.pngBitDepth == 1 && pdfObject.getAsNumber(0).intValue() == 1 && pdfObject.getAsNumber(1).intValue() == 0) {
                int n3 = this.imageBytes.length;
                while (n2 < n3) {
                    object = this.imageBytes;
                    object[n2] = (byte)(object[n2] ^ 255);
                    ++n2;
                }
            }
            pngWriter.writeHeader(this.width, this.height, this.pngBitDepth, this.pngColorType);
            if (this.icc != null) {
                pngWriter.writeIccProfile(this.icc);
            }
            if (this.palette != null) {
                pngWriter.writePalette(this.palette);
            }
            pngWriter.writeData(this.imageBytes, this.stride);
            pngWriter.writeEnd();
            ImageBytesType imageBytesType3 = ImageBytesType.PNG;
        }
        this.streamContentType = var3_11;
        this.imageBytes = object2.toByteArray();
    }

    /*
     * Enabled aggressive block sorting
     */
    private void findColorspace(PdfObject object, boolean bl2) {
        block22 : {
            block21 : {
                block20 : {
                    PdfObject pdfObject;
                    block19 : {
                        block17 : {
                            block18 : {
                                block15 : {
                                    block16 : {
                                        if (object == null && this.bpc == 1 || PdfName.DEVICEGRAY.equals(object)) break block15;
                                        if (!PdfName.DEVICERGB.equals(object)) break block16;
                                        if (this.bpc != 8 && this.bpc != 16) return;
                                        break block17;
                                    }
                                    if (!(object instanceof PdfArray)) return;
                                    pdfObject = (object = (PdfArray)object).getDirectObject(0);
                                    if (!PdfName.CALGRAY.equals(pdfObject)) break block18;
                                }
                                this.stride = (this.width * this.bpc + 7) / 8;
                                this.pngColorType = 0;
                                return;
                            }
                            if (!PdfName.CALRGB.equals(pdfObject)) break block19;
                            if (this.bpc != 8 && this.bpc != 16) return;
                        }
                        this.stride = (this.width * this.bpc * 3 + 7) / 8;
                        this.pngColorType = 2;
                        return;
                    }
                    if (PdfName.ICCBASED.equals(pdfObject)) {
                        int n2 = (object = (PRStream)object.getDirectObject(1)).getAsNumber(PdfName.N).intValue();
                        if (n2 == 1) {
                            this.stride = (this.width * this.bpc + 7) / 8;
                            this.pngColorType = 0;
                        } else {
                            if (n2 != 3) return;
                            this.stride = (this.width * this.bpc * 3 + 7) / 8;
                            this.pngColorType = 2;
                        }
                        this.icc = PdfReader.getStreamBytes((PRStream)object);
                        return;
                    }
                    if (!bl2 || !PdfName.INDEXED.equals(pdfObject)) return;
                    this.findColorspace(object.getDirectObject(1), false);
                    if (this.pngColorType != 2) return;
                    if (!((object = object.getDirectObject(3)) instanceof PdfString)) break block20;
                    object = ((PdfString)object).getBytes();
                    break block21;
                }
                if (!(object instanceof PRStream)) break block22;
                object = PdfReader.getStreamBytes((PRStream)object);
            }
            this.palette = object;
        }
        this.stride = (this.width * this.bpc + 7) / 8;
        this.pngColorType = 3;
    }

    public PdfObject get(PdfName pdfName) {
        return this.dictionary.get(pdfName);
    }

    public PdfDictionary getDictionary() {
        return this.dictionary;
    }

    public String getFileType() {
        return this.streamContentType.getFileExtension();
    }

    public byte[] getImageAsBytes() {
        return this.imageBytes;
    }

    public ImageBytesType getImageBytesType() {
        return this.streamContentType;
    }

    public static enum ImageBytesType {
        PNG("png"),
        JPG("jpg"),
        JP2("jp2"),
        CCITT("tif"),
        JBIG2("jbig2");
        
        private final String fileExtension;

        private ImageBytesType(String string3) {
            this.fileExtension = string3;
        }

        public String getFileExtension() {
            return this.fileExtension;
        }
    }

    private static class TrackingFilter
    implements FilterHandlers.FilterHandler {
        public PdfName lastFilterName = null;

        private TrackingFilter() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            this.lastFilterName = pdfName;
            return arrby;
        }
    }

}

