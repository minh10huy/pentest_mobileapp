/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNameTree;
import com.itextpdf.text.pdf.PdfNull;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.xml.XMLUtil;
import com.itextpdf.text.xml.simpleparser.IanaEncodings;
import com.itextpdf.text.xml.simpleparser.SimpleXMLDocHandler;
import com.itextpdf.text.xml.simpleparser.SimpleXMLParser;
import java.io.BufferedWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Reader;
import java.io.Writer;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

public final class SimpleNamedDestination
implements SimpleXMLDocHandler {
    private HashMap<String, String> xmlLast;
    private HashMap<String, String> xmlNames;

    private SimpleNamedDestination() {
    }

    static PdfArray createDestinationArray(String object, PdfWriter object2) {
        PdfArray pdfArray = new PdfArray();
        StringTokenizer stringTokenizer = new StringTokenizer((String)object);
        pdfArray.add(object2.getPageReference(Integer.parseInt(stringTokenizer.nextToken())));
        if (!stringTokenizer.hasMoreTokens()) {
            pdfArray.add(PdfName.XYZ);
            pdfArray.add(new float[]{0.0f, 10000.0f, 0.0f});
            return pdfArray;
        }
        object = object2 = stringTokenizer.nextToken();
        if (object2.startsWith("/")) {
            object = object2.substring(1);
        }
        pdfArray.add(new PdfName((String)object));
        for (int i2 = 0; i2 < 4 && stringTokenizer.hasMoreTokens(); ++i2) {
            object = stringTokenizer.nextToken();
            if (object.equals("null")) {
                pdfArray.add(PdfNull.PDFNULL);
                continue;
            }
            pdfArray.add(new PdfNumber((String)object));
        }
        return pdfArray;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public static String escapeBinaryString(String var0) {
        var4_1 = new StringBuffer();
        var5_2 = var0.toCharArray();
        var3_3 = var5_2.length;
        var2_4 = 0;
        while (var2_4 < var3_3) {
            block3 : {
                var1_5 = var5_2[var2_4];
                if (var1_5 >= ' ') break block3;
                var4_1.append('\\');
                var0 = new StringBuilder();
                var0.append("00");
                var0.append(Integer.toOctalString(var1_5));
                var0 = var0.toString();
                var0 = var0.substring(var0.length() - 3);
                ** GOTO lbl18
            }
            if (var1_5 == '\\') {
                var0 = "\\\\";
lbl18: // 2 sources:
                var4_1.append((String)var0);
            } else {
                var4_1.append(var1_5);
            }
            ++var2_4;
        }
        return var4_1.toString();
    }

    public static void exportToXML(HashMap<String, String> hashMap, OutputStream outputStream, String string2, boolean bl2) {
        SimpleNamedDestination.exportToXML(hashMap, new BufferedWriter(new OutputStreamWriter(outputStream, IanaEncodings.getJavaEncoding(string2))), string2, bl2);
    }

    public static void exportToXML(HashMap<String, String> object, Writer writer, String string2, boolean bl2) {
        writer.write("<?xml version=\"1.0\" encoding=\"");
        writer.write(XMLUtil.escapeXML(string2, bl2));
        writer.write("\"?>\n<Destination>\n");
        for (Map.Entry entry : object.entrySet()) {
            string2 = (String)entry.getKey();
            String object2 = (String)entry.getValue();
            writer.write("  <Name Page=\"");
            writer.write(XMLUtil.escapeXML(object2, bl2));
            writer.write("\">");
            writer.write(XMLUtil.escapeXML(SimpleNamedDestination.escapeBinaryString(string2), bl2));
            writer.write("</Name>\n");
        }
        writer.write("</Destination>\n");
        writer.flush();
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static HashMap<String, String> getNamedDestination(PdfReader hashMap, boolean bl2) {
        int n2;
        IntHashtable intHashtable = new IntHashtable();
        int n3 = hashMap.getNumberOfPages();
        for (n2 = 1; n2 <= n3; ++n2) {
            intHashtable.put(hashMap.getPageOrigRef(n2).getNumber(), n2);
        }
        hashMap = bl2 ? hashMap.getNamedDestinationFromNames() : hashMap.getNamedDestinationFromStrings();
        HashMap<String, String> hashMap2 = new HashMap<String, String>(hashMap.size());
        for (Map.Entry entry : hashMap.entrySet()) {
            PdfArray pdfArray = (PdfArray)entry.getValue();
            StringBuffer stringBuffer = new StringBuffer();
            stringBuffer.append(intHashtable.get(pdfArray.getAsIndirectObject(0).getNumber()));
            stringBuffer.append(' ');
            stringBuffer.append(pdfArray.getPdfObject(1).toString().substring(1));
            n2 = 2;
            do {
                if (n2 >= pdfArray.size()) break;
                stringBuffer.append(' ');
                stringBuffer.append(pdfArray.getPdfObject(n2).toString());
                ++n2;
            } while (true);
            try {
                hashMap2.put((String)entry.getKey(), stringBuffer.toString());
            }
            catch (Exception exception) {}
        }
        return hashMap2;
    }

    public static HashMap<String, String> importFromXML(InputStream inputStream) {
        SimpleNamedDestination simpleNamedDestination = new SimpleNamedDestination();
        SimpleXMLParser.parse((SimpleXMLDocHandler)simpleNamedDestination, inputStream);
        return simpleNamedDestination.xmlNames;
    }

    public static HashMap<String, String> importFromXML(Reader reader) {
        SimpleNamedDestination simpleNamedDestination = new SimpleNamedDestination();
        SimpleXMLParser.parse((SimpleXMLDocHandler)simpleNamedDestination, reader);
        return simpleNamedDestination.xmlNames;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static PdfDictionary outputNamedDestinationAsNames(HashMap<String, String> object, PdfWriter pdfWriter) {
        PdfDictionary pdfDictionary = new PdfDictionary();
        for (Object object2 : object.entrySet()) {
            try {
                String string2 = (String)object2.getKey();
                object2 = SimpleNamedDestination.createDestinationArray((String)object2.getValue(), pdfWriter);
                pdfDictionary.put(new PdfName(string2), (PdfObject)object2);
            }
            catch (Exception exception) {}
        }
        return pdfDictionary;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public static PdfDictionary outputNamedDestinationAsStrings(HashMap<String, String> object, PdfWriter pdfWriter) {
        HashMap hashMap = new HashMap(object.size());
        for (Map.Entry entry : object.entrySet()) {
            try {
                PdfArray pdfArray = SimpleNamedDestination.createDestinationArray((String)entry.getValue(), pdfWriter);
                hashMap.put(entry.getKey(), pdfWriter.addToBody(pdfArray).getIndirectReference());
            }
            catch (Exception exception) {}
        }
        return PdfNameTree.writeTree(hashMap, pdfWriter);
    }

    public static String unEscapeBinaryString(String arrc) {
        StringBuffer stringBuffer = new StringBuffer();
        arrc = arrc.toCharArray();
        int n2 = arrc.length;
        int n3 = 0;
        while (n3 < n2) {
            char c2 = arrc[n3];
            int n4 = n3++;
            char c3 = c2;
            if (c2 == '\\') {
                if (n3 >= n2) {
                    stringBuffer.append('\\');
                    break;
                }
                c2 = arrc[n3];
                n4 = n3;
                c3 = c2;
                if (c2 >= '0') {
                    n4 = n3;
                    c3 = c2;
                    if (c2 <= '7') {
                        char c4;
                        n4 = c2 - 48;
                        int n5 = n3 + 1;
                        for (n3 = 0; n3 < 2 && n5 < n2 && (c4 = arrc[n5]) >= '0' && c4 <= '7'; ++n5, ++n3) {
                            n4 = n4 * 8 + c4 - 48;
                        }
                        n3 = n5 - 1;
                        c3 = (char)n4;
                        n4 = n3;
                    }
                }
            }
            stringBuffer.append(c3);
            n3 = n4 + 1;
        }
        return stringBuffer.toString();
    }

    @Override
    public void endDocument() {
    }

    @Override
    public void endElement(String string2) {
        if (string2.equals("Destination")) {
            if (this.xmlLast == null && this.xmlNames != null) {
                return;
            }
            throw new RuntimeException(MessageLocalization.getComposedMessage("destination.end.tag.out.of.place", new Object[0]));
        }
        if (string2.equals("Name")) {
            if (this.xmlLast != null && this.xmlNames != null) {
                if (this.xmlLast.containsKey("Page")) {
                    this.xmlNames.put(SimpleNamedDestination.unEscapeBinaryString(this.xmlLast.get("Name")), this.xmlLast.get("Page"));
                    this.xmlLast = null;
                    return;
                }
                throw new RuntimeException(MessageLocalization.getComposedMessage("page.attribute.missing", new Object[0]));
            }
            throw new RuntimeException(MessageLocalization.getComposedMessage("name.end.tag.out.of.place", new Object[0]));
        }
        throw new RuntimeException(MessageLocalization.getComposedMessage("invalid.end.tag.1", string2));
    }

    @Override
    public void startDocument() {
    }

    @Override
    public void startElement(String string2, Map<String, String> map) {
        if (this.xmlNames == null) {
            if (string2.equals("Destination")) {
                this.xmlNames = new HashMap();
                return;
            }
            throw new RuntimeException(MessageLocalization.getComposedMessage("root.element.is.not.destination", new Object[0]));
        }
        if (string2.equals("Name")) {
            if (this.xmlLast == null) {
                this.xmlLast = new HashMap<String, String>(map);
                this.xmlLast.put("Name", "");
                return;
            }
            throw new RuntimeException(MessageLocalization.getComposedMessage("nested.tags.are.not.allowed", new Object[0]));
        }
        throw new RuntimeException(MessageLocalization.getComposedMessage("tag.1.not.allowed", string2));
    }

    @Override
    public void text(String string2) {
        if (this.xmlLast == null) {
            return;
        }
        String string3 = this.xmlLast.get("Name");
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(string3);
        stringBuilder.append(string2);
        string2 = stringBuilder.toString();
        this.xmlLast.put("Name", string2);
    }
}

