/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.awt.geom.AffineTransform;
import com.itextpdf.text.AccessibleElementId;
import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.CMYKColor;
import com.itextpdf.text.pdf.ExtendedColor;
import com.itextpdf.text.pdf.GrayColor;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfBorderArray;
import com.itextpdf.text.pdf.PdfBorderDictionary;
import com.itextpdf.text.pdf.PdfColor;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfDestination;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfFileSpecification;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfOCG;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfRectangle;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfTemplate;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Set;

public class PdfAnnotation
extends PdfDictionary
implements IAccessibleElement {
    public static final PdfName AA_BLUR;
    public static final PdfName AA_DOWN;
    public static final PdfName AA_ENTER;
    public static final PdfName AA_EXIT;
    public static final PdfName AA_FOCUS;
    public static final PdfName AA_JS_CHANGE;
    public static final PdfName AA_JS_FORMAT;
    public static final PdfName AA_JS_KEY;
    public static final PdfName AA_JS_OTHER_CHANGE;
    public static final PdfName AA_UP;
    public static final PdfName APPEARANCE_DOWN;
    public static final PdfName APPEARANCE_NORMAL;
    public static final PdfName APPEARANCE_ROLLOVER;
    public static final int FLAGS_HIDDEN = 2;
    public static final int FLAGS_INVISIBLE = 1;
    public static final int FLAGS_LOCKED = 128;
    public static final int FLAGS_LOCKEDCONTENTS = 512;
    public static final int FLAGS_NOROTATE = 16;
    public static final int FLAGS_NOVIEW = 32;
    public static final int FLAGS_NOZOOM = 8;
    public static final int FLAGS_PRINT = 4;
    public static final int FLAGS_READONLY = 64;
    public static final int FLAGS_TOGGLENOVIEW = 256;
    public static final PdfName HIGHLIGHT_INVERT;
    public static final PdfName HIGHLIGHT_NONE;
    public static final PdfName HIGHLIGHT_OUTLINE;
    public static final PdfName HIGHLIGHT_PUSH;
    public static final PdfName HIGHLIGHT_TOGGLE;
    public static final int MARKUP_HIGHLIGHT = 0;
    public static final int MARKUP_SQUIGGLY = 3;
    public static final int MARKUP_STRIKEOUT = 2;
    public static final int MARKUP_UNDERLINE = 1;
    protected HashMap<PdfName, PdfObject> accessibleAttributes = null;
    protected boolean annotation = true;
    protected boolean form = false;
    private AccessibleElementId id = null;
    private int placeInPage = -1;
    protected PdfIndirectReference reference;
    protected PdfName role = null;
    protected HashSet<PdfTemplate> templates;
    protected boolean used = false;
    protected PdfWriter writer;

    static {
        HIGHLIGHT_NONE = PdfName.N;
        HIGHLIGHT_INVERT = PdfName.I;
        HIGHLIGHT_OUTLINE = PdfName.O;
        HIGHLIGHT_PUSH = PdfName.P;
        HIGHLIGHT_TOGGLE = PdfName.T;
        APPEARANCE_NORMAL = PdfName.N;
        APPEARANCE_ROLLOVER = PdfName.R;
        APPEARANCE_DOWN = PdfName.D;
        AA_ENTER = PdfName.E;
        AA_EXIT = PdfName.X;
        AA_DOWN = PdfName.D;
        AA_UP = PdfName.U;
        AA_FOCUS = PdfName.FO;
        AA_BLUR = PdfName.BL;
        AA_JS_KEY = PdfName.K;
        AA_JS_FORMAT = PdfName.F;
        AA_JS_CHANGE = PdfName.V;
        AA_JS_OTHER_CHANGE = PdfName.C;
    }

    public PdfAnnotation(PdfWriter pdfWriter, float f2, float f3, float f4, float f5, PdfAction pdfAction) {
        this.writer = pdfWriter;
        this.put(PdfName.SUBTYPE, PdfName.LINK);
        this.put(PdfName.RECT, new PdfRectangle(f2, f3, f4, f5));
        this.put(PdfName.A, pdfAction);
        this.put(PdfName.BORDER, new PdfBorderArray(0.0f, 0.0f, 0.0f));
        this.put(PdfName.C, new PdfColor(0, 0, 255));
    }

    public PdfAnnotation(PdfWriter pdfWriter, float f2, float f3, float f4, float f5, PdfString pdfString, PdfString pdfString2) {
        this.writer = pdfWriter;
        this.put(PdfName.SUBTYPE, PdfName.TEXT);
        this.put(PdfName.T, pdfString);
        this.put(PdfName.RECT, new PdfRectangle(f2, f3, f4, f5));
        this.put(PdfName.CONTENTS, pdfString2);
    }

    public PdfAnnotation(PdfWriter pdfWriter, Rectangle rectangle) {
        this.writer = pdfWriter;
        if (rectangle != null) {
            this.put(PdfName.RECT, new PdfRectangle(rectangle));
        }
    }

    public static PdfAnnotation createFileAttachment(PdfWriter object, Rectangle rectangle, String string2, PdfFileSpecification pdfFileSpecification) {
        object = object.createAnnotation(rectangle, PdfName.FILEATTACHMENT);
        if (string2 != null) {
            object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        }
        object.put(PdfName.FS, pdfFileSpecification.getReference());
        return object;
    }

    public static PdfAnnotation createFileAttachment(PdfWriter pdfWriter, Rectangle rectangle, String string2, byte[] arrby, String string3, String string4) {
        return PdfAnnotation.createFileAttachment(pdfWriter, rectangle, string2, PdfFileSpecification.fileEmbedded(pdfWriter, string3, string4, arrby));
    }

    public static PdfAnnotation createFreeText(PdfWriter object, Rectangle rectangle, String string2, PdfContentByte pdfContentByte) {
        object = object.createAnnotation(rectangle, PdfName.FREETEXT);
        object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        object.setDefaultAppearanceString(pdfContentByte);
        return object;
    }

    public static PdfAnnotation createInk(PdfWriter object, Rectangle object2, String object3, float[][] arrf) {
        object = object.createAnnotation((Rectangle)object2, PdfName.INK);
        object.put(PdfName.CONTENTS, new PdfString((String)object3, "UnicodeBig"));
        object2 = new PdfArray();
        for (int i2 = 0; i2 < arrf.length; ++i2) {
            object3 = new PdfArray();
            float[] arrf2 = arrf[i2];
            for (int i3 = 0; i3 < arrf2.length; ++i3) {
                object3.add(new PdfNumber(arrf2[i3]));
            }
            object2.add((PdfObject)object3);
        }
        object.put(PdfName.INKLIST, (PdfObject)object2);
        return object;
    }

    public static PdfAnnotation createLine(PdfWriter object, Rectangle object2, String string2, float f2, float f3, float f4, float f5) {
        object = object.createAnnotation((Rectangle)object2, PdfName.LINE);
        object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        object2 = new PdfArray(new PdfNumber(f2));
        object2.add(new PdfNumber(f3));
        object2.add(new PdfNumber(f4));
        object2.add(new PdfNumber(f5));
        object.put(PdfName.L, (PdfObject)object2);
        return object;
    }

    protected static PdfAnnotation createLink(PdfWriter object, Rectangle rectangle, PdfName pdfName) {
        object = object.createAnnotation(rectangle, PdfName.LINK);
        if (!pdfName.equals(HIGHLIGHT_INVERT)) {
            object.put(PdfName.H, pdfName);
        }
        return object;
    }

    public static PdfAnnotation createLink(PdfWriter object, Rectangle object2, PdfName pdfObject, int n2, PdfDestination pdfDestination) {
        object2 = PdfAnnotation.createLink((PdfWriter)object, (Rectangle)object2, (PdfName)pdfObject);
        object = object.getPageReference(n2);
        pdfObject = new PdfDestination(pdfDestination);
        pdfObject.addPage((PdfIndirectReference)object);
        object2.put(PdfName.DEST, pdfObject);
        return object2;
    }

    public static PdfAnnotation createLink(PdfWriter object, Rectangle rectangle, PdfName pdfName, PdfAction pdfAction) {
        object = PdfAnnotation.createLink((PdfWriter)object, rectangle, pdfName);
        object.putEx(PdfName.A, pdfAction);
        return object;
    }

    public static PdfAnnotation createLink(PdfWriter object, Rectangle rectangle, PdfName pdfName, String string2) {
        object = PdfAnnotation.createLink((PdfWriter)object, rectangle, pdfName);
        object.put(PdfName.DEST, new PdfString(string2, "UnicodeBig"));
        return object;
    }

    public static PdfAnnotation createMarkup(PdfWriter object, Rectangle object2, String string2, int n2, float[] arrf) {
        PdfName pdfName = PdfName.HIGHLIGHT;
        switch (n2) {
            default: {
                break;
            }
            case 3: {
                pdfName = PdfName.SQUIGGLY;
                break;
            }
            case 2: {
                pdfName = PdfName.STRIKEOUT;
                break;
            }
            case 1: {
                pdfName = PdfName.UNDERLINE;
            }
        }
        object = object.createAnnotation((Rectangle)object2, pdfName);
        object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        object2 = new PdfArray();
        for (n2 = 0; n2 < arrf.length; ++n2) {
            object2.add(new PdfNumber(arrf[n2]));
        }
        object.put(PdfName.QUADPOINTS, (PdfObject)object2);
        return object;
    }

    /*
     * Enabled aggressive block sorting
     */
    public static PdfAnnotation createPolygonPolyline(PdfWriter object, Rectangle rectangle, String string2, boolean bl2, PdfArray pdfArray) {
        PdfName pdfName = bl2 ? PdfName.POLYGON : PdfName.POLYLINE;
        object = object.createAnnotation(rectangle, pdfName);
        object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        object.put(PdfName.VERTICES, new PdfArray(pdfArray));
        return object;
    }

    public static PdfAnnotation createPopup(PdfWriter object, Rectangle rectangle, String string2, boolean bl2) {
        object = object.createAnnotation(rectangle, PdfName.POPUP);
        if (string2 != null) {
            object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        }
        if (bl2) {
            object.put(PdfName.OPEN, PdfBoolean.PDFTRUE);
        }
        return object;
    }

    public static PdfAnnotation createScreen(PdfWriter object, Rectangle object2, String object3, PdfFileSpecification pdfFileSpecification, String string2, boolean bl2) {
        object2 = object.createAnnotation((Rectangle)object2, PdfName.SCREEN);
        object2.put(PdfName.F, new PdfNumber(4));
        object2.put(PdfName.TYPE, PdfName.ANNOT);
        object2.setPage();
        object = object.addToBody(PdfAction.rendition((String)object3, pdfFileSpecification, string2, object2.getIndirectReference())).getIndirectReference();
        if (bl2) {
            object3 = new PdfDictionary();
            object3.put(new PdfName("PV"), (PdfObject)object);
            object2.put(PdfName.AA, (PdfObject)object3);
        }
        object2.put(PdfName.A, (PdfObject)object);
        return object2;
    }

    /*
     * Enabled aggressive block sorting
     */
    public static PdfAnnotation createSquareCircle(PdfWriter object, Rectangle rectangle, String string2, boolean bl2) {
        PdfName pdfName = bl2 ? PdfName.SQUARE : PdfName.CIRCLE;
        object = object.createAnnotation(rectangle, pdfName);
        object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        return object;
    }

    public static PdfAnnotation createStamp(PdfWriter object, Rectangle rectangle, String string2, String string3) {
        object = object.createAnnotation(rectangle, PdfName.STAMP);
        object.put(PdfName.CONTENTS, new PdfString(string2, "UnicodeBig"));
        object.put(PdfName.NAME, new PdfName(string3));
        return object;
    }

    public static PdfAnnotation createText(PdfWriter object, Rectangle rectangle, String string2, String string3, boolean bl2, String string4) {
        object = object.createAnnotation(rectangle, PdfName.TEXT);
        if (string2 != null) {
            object.put(PdfName.T, new PdfString(string2, "UnicodeBig"));
        }
        if (string3 != null) {
            object.put(PdfName.CONTENTS, new PdfString(string3, "UnicodeBig"));
        }
        if (bl2) {
            object.put(PdfName.OPEN, PdfBoolean.PDFTRUE);
        }
        if (string4 != null) {
            object.put(PdfName.NAME, new PdfName(string4));
        }
        return object;
    }

    /*
     * Enabled aggressive block sorting
     */
    public static PdfArray getMKColor(BaseColor object) {
        PdfArray pdfArray = new PdfArray();
        switch (ExtendedColor.getType((BaseColor)object)) {
            default: {
                pdfArray.add(new PdfNumber((float)object.getRed() / 255.0f));
                pdfArray.add(new PdfNumber((float)object.getGreen() / 255.0f));
                object = new PdfNumber((float)object.getBlue() / 255.0f);
                break;
            }
            case 3: 
            case 4: 
            case 5: {
                throw new RuntimeException(MessageLocalization.getComposedMessage("separations.patterns.and.shadings.are.not.allowed.in.mk.dictionary", new Object[0]));
            }
            case 2: {
                object = (CMYKColor)object;
                pdfArray.add(new PdfNumber(object.getCyan()));
                pdfArray.add(new PdfNumber(object.getMagenta()));
                pdfArray.add(new PdfNumber(object.getYellow()));
                object = new PdfNumber(object.getBlack());
                break;
            }
            case 1: {
                object = new PdfNumber(((GrayColor)object).getGray());
            }
        }
        pdfArray.add((PdfObject)object);
        return pdfArray;
    }

    public void applyCTM(AffineTransform affineTransform) {
        PdfArray pdfArray = this.getAsArray(PdfName.RECT);
        if (pdfArray != null) {
            pdfArray = pdfArray.size() == 4 ? new PdfRectangle(pdfArray.getAsNumber(0).floatValue(), pdfArray.getAsNumber(1).floatValue(), pdfArray.getAsNumber(2).floatValue(), pdfArray.getAsNumber(3).floatValue()) : new PdfRectangle(pdfArray.getAsNumber(0).floatValue(), pdfArray.getAsNumber(1).floatValue());
            this.put(PdfName.RECT, pdfArray.transform(affineTransform));
        }
    }

    @Override
    public PdfObject getAccessibleAttribute(PdfName pdfName) {
        if (this.accessibleAttributes != null) {
            return this.accessibleAttributes.get(pdfName);
        }
        return null;
    }

    @Override
    public HashMap<PdfName, PdfObject> getAccessibleAttributes() {
        return this.accessibleAttributes;
    }

    @Override
    public AccessibleElementId getId() {
        if (this.id == null) {
            this.id = new AccessibleElementId();
        }
        return this.id;
    }

    public PdfIndirectReference getIndirectReference() {
        if (this.reference == null) {
            this.reference = this.writer.getPdfIndirectReference();
        }
        return this.reference;
    }

    PdfDictionary getMK() {
        PdfDictionary pdfDictionary;
        PdfDictionary pdfDictionary2 = pdfDictionary = (PdfDictionary)this.get(PdfName.MK);
        if (pdfDictionary == null) {
            pdfDictionary2 = new PdfDictionary();
            this.put(PdfName.MK, pdfDictionary2);
        }
        return pdfDictionary2;
    }

    public int getPlaceInPage() {
        return this.placeInPage;
    }

    @Override
    public PdfName getRole() {
        return this.role;
    }

    public HashSet<PdfTemplate> getTemplates() {
        return this.templates;
    }

    public boolean isAnnotation() {
        return this.annotation;
    }

    public boolean isForm() {
        return this.form;
    }

    @Override
    public boolean isInline() {
        return false;
    }

    public boolean isUsed() {
        return this.used;
    }

    @Override
    public void setAccessibleAttribute(PdfName pdfName, PdfObject pdfObject) {
        if (this.accessibleAttributes == null) {
            this.accessibleAttributes = new HashMap();
        }
        this.accessibleAttributes.put(pdfName, pdfObject);
    }

    public void setAction(PdfAction pdfAction) {
        this.put(PdfName.A, pdfAction);
    }

    public void setAdditionalActions(PdfName pdfName, PdfAction pdfAction) {
        PdfObject pdfObject = this.get(PdfName.AA);
        pdfObject = pdfObject != null && pdfObject.isDictionary() ? (PdfDictionary)pdfObject : new PdfDictionary();
        pdfObject.put(pdfName, pdfAction);
        this.put(PdfName.AA, pdfObject);
    }

    public void setAppearance(PdfName pdfName, PdfTemplate pdfTemplate) {
        PdfDictionary pdfDictionary;
        PdfDictionary pdfDictionary2 = pdfDictionary = (PdfDictionary)this.get(PdfName.AP);
        if (pdfDictionary == null) {
            pdfDictionary2 = new PdfDictionary();
        }
        pdfDictionary2.put(pdfName, pdfTemplate.getIndirectReference());
        this.put(PdfName.AP, pdfDictionary2);
        if (!this.form) {
            return;
        }
        if (this.templates == null) {
            this.templates = new HashSet();
        }
        this.templates.add(pdfTemplate);
    }

    public void setAppearance(PdfName pdfName, String string2, PdfTemplate pdfTemplate) {
        PdfObject pdfObject = (PdfDictionary)this.get(PdfName.AP);
        PdfDictionary pdfDictionary = pdfObject;
        if (pdfObject == null) {
            pdfDictionary = new PdfDictionary();
        }
        pdfObject = (pdfObject = pdfDictionary.get(pdfName)) != null && pdfObject.isDictionary() ? (PdfDictionary)pdfObject : new PdfDictionary();
        pdfObject.put(new PdfName(string2), pdfTemplate.getIndirectReference());
        pdfDictionary.put(pdfName, pdfObject);
        this.put(PdfName.AP, pdfDictionary);
        if (!this.form) {
            return;
        }
        if (this.templates == null) {
            this.templates = new HashSet();
        }
        this.templates.add(pdfTemplate);
    }

    public void setAppearanceState(String string2) {
        if (string2 == null) {
            this.remove(PdfName.AS);
            return;
        }
        this.put(PdfName.AS, new PdfName(string2));
    }

    public void setBorder(PdfBorderArray pdfBorderArray) {
        this.put(PdfName.BORDER, pdfBorderArray);
    }

    public void setBorderStyle(PdfBorderDictionary pdfBorderDictionary) {
        this.put(PdfName.BS, pdfBorderDictionary);
    }

    public void setColor(BaseColor baseColor) {
        this.put(PdfName.C, new PdfColor(baseColor));
    }

    public void setDefaultAppearanceString(PdfContentByte arrby) {
        arrby = arrby.getInternalBuffer().toByteArray();
        int n2 = arrby.length;
        for (int i2 = 0; i2 < n2; ++i2) {
            if (arrby[i2] != 10) continue;
            arrby[i2] = 32;
        }
        this.put(PdfName.DA, new PdfString(arrby));
    }

    public void setFlags(int n2) {
        if (n2 == 0) {
            this.remove(PdfName.F);
            return;
        }
        this.put(PdfName.F, new PdfNumber(n2));
    }

    public void setHighlighting(PdfName pdfName) {
        if (pdfName.equals(HIGHLIGHT_INVERT)) {
            this.remove(PdfName.H);
            return;
        }
        this.put(PdfName.H, pdfName);
    }

    @Override
    public void setId(AccessibleElementId accessibleElementId) {
        this.id = accessibleElementId;
    }

    public void setLayer(PdfOCG pdfOCG) {
        this.put(PdfName.OC, pdfOCG.getRef());
    }

    public void setMKAlternateCaption(String string2) {
        this.getMK().put(PdfName.AC, new PdfString(string2, "UnicodeBig"));
    }

    public void setMKAlternateIcon(PdfTemplate pdfTemplate) {
        this.getMK().put(PdfName.IX, pdfTemplate.getIndirectReference());
    }

    public void setMKBackgroundColor(BaseColor baseColor) {
        if (baseColor == null) {
            this.getMK().remove(PdfName.BG);
            return;
        }
        this.getMK().put(PdfName.BG, PdfAnnotation.getMKColor(baseColor));
    }

    public void setMKBorderColor(BaseColor baseColor) {
        if (baseColor == null) {
            this.getMK().remove(PdfName.BC);
            return;
        }
        this.getMK().put(PdfName.BC, PdfAnnotation.getMKColor(baseColor));
    }

    public void setMKIconFit(PdfName pdfObject, PdfName pdfName, float f2, float f3, boolean bl2) {
        PdfDictionary pdfDictionary = new PdfDictionary();
        if (!pdfObject.equals(PdfName.A)) {
            pdfDictionary.put(PdfName.SW, pdfObject);
        }
        if (!pdfName.equals(PdfName.P)) {
            pdfDictionary.put(PdfName.S, pdfName);
        }
        if (f2 != 0.5f || f3 != 0.5f) {
            pdfObject = new PdfArray(new PdfNumber(f2));
            pdfObject.add(new PdfNumber(f3));
            pdfDictionary.put(PdfName.A, pdfObject);
        }
        if (bl2) {
            pdfDictionary.put(PdfName.FB, PdfBoolean.PDFTRUE);
        }
        this.getMK().put(PdfName.IF, pdfDictionary);
    }

    public void setMKNormalCaption(String string2) {
        this.getMK().put(PdfName.CA, new PdfString(string2, "UnicodeBig"));
    }

    public void setMKNormalIcon(PdfTemplate pdfTemplate) {
        this.getMK().put(PdfName.I, pdfTemplate.getIndirectReference());
    }

    public void setMKRolloverCaption(String string2) {
        this.getMK().put(PdfName.RC, new PdfString(string2, "UnicodeBig"));
    }

    public void setMKRolloverIcon(PdfTemplate pdfTemplate) {
        this.getMK().put(PdfName.RI, pdfTemplate.getIndirectReference());
    }

    public void setMKRotation(int n2) {
        this.getMK().put(PdfName.R, new PdfNumber(n2));
    }

    public void setMKTextPosition(int n2) {
        this.getMK().put(PdfName.TP, new PdfNumber(n2));
    }

    public void setName(String string2) {
        this.put(PdfName.NM, new PdfString(string2));
    }

    public void setPage() {
        this.put(PdfName.P, this.writer.getCurrentPage());
    }

    public void setPage(int n2) {
        this.put(PdfName.P, this.writer.getPageReference(n2));
    }

    public void setPlaceInPage(int n2) {
        this.placeInPage = n2;
    }

    public void setPopup(PdfAnnotation pdfAnnotation) {
        this.put(PdfName.POPUP, pdfAnnotation.getIndirectReference());
        pdfAnnotation.put(PdfName.PARENT, this.getIndirectReference());
    }

    @Override
    public void setRole(PdfName pdfName) {
        this.role = pdfName;
    }

    public void setRotate(int n2) {
        this.put(PdfName.ROTATE, new PdfNumber(n2));
    }

    public void setTitle(String string2) {
        if (string2 == null) {
            this.remove(PdfName.T);
            return;
        }
        this.put(PdfName.T, new PdfString(string2, "UnicodeBig"));
    }

    public void setUsed() {
        this.used = true;
    }

    @Override
    public void toPdf(PdfWriter pdfWriter, OutputStream outputStream) {
        PdfWriter.checkPdfIsoConformance(pdfWriter, 13, this);
        super.toPdf(pdfWriter, outputStream);
    }

    public static class PdfImportedLink {
        PdfArray destination;
        float llx;
        float lly;
        int newPage;
        HashMap<PdfName, PdfObject> parameters;
        PdfArray rect;
        float urx;
        float ury;

        /*
         * Enabled force condition propagation
         * Lifted jumps to return sites
         */
        PdfImportedLink(PdfDictionary pdfObject) {
            block3 : {
                this.parameters = new HashMap();
                this.destination = null;
                this.newPage = 0;
                this.parameters.putAll(pdfObject.hashMap);
                try {
                    this.destination = (PdfArray)this.parameters.remove(PdfName.DEST);
                    if (this.destination == null) break block3;
                }
                catch (ClassCastException classCastException) {
                    throw new IllegalArgumentException(MessageLocalization.getComposedMessage("you.have.to.consolidate.the.named.destinations.of.your.reader", new Object[0]));
                }
                this.destination = new PdfArray(this.destination);
            }
            pdfObject = (PdfArray)this.parameters.remove(PdfName.RECT);
            this.llx = pdfObject.getAsNumber(0).floatValue();
            this.lly = pdfObject.getAsNumber(1).floatValue();
            this.urx = pdfObject.getAsNumber(2).floatValue();
            this.ury = pdfObject.getAsNumber(3).floatValue();
            this.rect = new PdfArray((PdfArray)pdfObject);
        }

        private void appendDictionary(StringBuffer stringBuffer, HashMap<PdfName, PdfObject> object) {
            stringBuffer.append(" <<");
            for (Map.Entry entry : object.entrySet()) {
                stringBuffer.append(entry.getKey());
                stringBuffer.append(":");
                if (entry.getValue() instanceof PdfDictionary) {
                    this.appendDictionary(stringBuffer, ((PdfDictionary)entry.getValue()).hashMap);
                } else {
                    stringBuffer.append(entry.getValue());
                }
                stringBuffer.append(" ");
            }
            stringBuffer.append(">> ");
        }

        public PdfAnnotation createAnnotation(PdfWriter object) {
            PdfAnnotation pdfAnnotation = object.createAnnotation(new Rectangle(this.llx, this.lly, this.urx, this.ury), null);
            if (this.newPage != 0) {
                object = object.getPageReference(this.newPage);
                this.destination.set(0, (PdfObject)object);
            }
            if (this.destination != null) {
                pdfAnnotation.put(PdfName.DEST, this.destination);
            }
            pdfAnnotation.hashMap.putAll(this.parameters);
            return pdfAnnotation;
        }

        public int getDestinationPage() {
            if (!this.isInternal()) {
                return 0;
            }
            PRIndirectReference pRIndirectReference = (PRIndirectReference)this.destination.getAsIndirectObject(0);
            PdfReader pdfReader = pRIndirectReference.getReader();
            for (int i2 = 1; i2 <= pdfReader.getNumberOfPages(); ++i2) {
                PRIndirectReference pRIndirectReference2 = pdfReader.getPageOrigRef(i2);
                if (pRIndirectReference2.getGeneration() != pRIndirectReference.getGeneration() || pRIndirectReference2.getNumber() != pRIndirectReference.getNumber()) continue;
                return i2;
            }
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("page.not.found", new Object[0]));
        }

        public Map<PdfName, PdfObject> getParameters() {
            return new HashMap<PdfName, PdfObject>(this.parameters);
        }

        public PdfArray getRect() {
            return new PdfArray(this.rect);
        }

        public boolean isInternal() {
            if (this.destination != null) {
                return true;
            }
            return false;
        }

        public void setDestinationPage(int n2) {
            if (this.isInternal()) {
                this.newPage = n2;
                return;
            }
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("cannot.change.destination.of.external.link", new Object[0]));
        }

        public String toString() {
            StringBuffer stringBuffer = new StringBuffer("Imported link: location [");
            stringBuffer.append(this.llx);
            stringBuffer.append(' ');
            stringBuffer.append(this.lly);
            stringBuffer.append(' ');
            stringBuffer.append(this.urx);
            stringBuffer.append(' ');
            stringBuffer.append(this.ury);
            stringBuffer.append("] destination ");
            stringBuffer.append(this.destination);
            stringBuffer.append(" parameters ");
            stringBuffer.append(this.parameters);
            if (this.parameters != null) {
                this.appendDictionary(stringBuffer, this.parameters);
            }
            return stringBuffer.toString();
        }

        public void transformDestination(float f2, float f3, float f4, float f5, float f6, float f7) {
            if (this.isInternal()) {
                if (this.destination.getAsName(1).equals(PdfName.XYZ)) {
                    float f8 = this.destination.getAsNumber(2).floatValue();
                    float f9 = this.destination.getAsNumber(3).floatValue();
                    this.destination.set(2, new PdfNumber(f2 * f8 + f4 * f9 + f6));
                    this.destination.set(3, new PdfNumber(f8 * f3 + f9 * f5 + f7));
                }
                return;
            }
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("cannot.change.destination.of.external.link", new Object[0]));
        }

        public void transformRect(float f2, float f3, float f4, float f5, float f6, float f7) {
            float f8 = this.llx;
            float f9 = this.lly;
            float f10 = this.llx;
            float f11 = this.lly;
            this.llx = f8 * f2 + f9 * f4 + f6;
            this.lly = f10 * f3 + f11 * f5 + f7;
            f8 = this.urx;
            f9 = this.ury;
            f10 = this.urx;
            f11 = this.ury;
            this.urx = f8 * f2 + f9 * f4 + f6;
            this.ury = f10 * f3 + f11 * f5 + f7;
        }
    }

}

