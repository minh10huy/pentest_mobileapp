/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BadPdfFormatException;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfCopy;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNull;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfStructureTreeRoot;
import com.itextpdf.text.pdf.RefKey;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class PdfStructTreeController {
    private PdfIndirectReference nullReference = null;
    private PdfDictionary parentTree;
    protected PdfReader reader;
    private PdfDictionary roleMap = null;
    private PdfDictionary sourceClassMap = null;
    private PdfDictionary sourceRoleMap = null;
    private PdfDictionary structTreeRoot;
    private PdfStructureTreeRoot structureTreeRoot;
    private PdfCopy writer;

    protected PdfStructTreeController(PdfReader pdfReader, PdfCopy pdfCopy) {
        if (pdfCopy.isTagged()) {
            this.writer = pdfCopy;
            this.structureTreeRoot = pdfCopy.getStructureTreeRoot();
            this.structureTreeRoot.put(PdfName.PARENTTREE, new PdfDictionary(PdfName.STRUCTELEM));
            this.setReader(pdfReader);
            return;
        }
        throw new BadPdfFormatException(MessageLocalization.getComposedMessage("no.structtreeroot.found", new Object[0]));
    }

    private void addKid(PdfObject pdfObject) {
        if (!pdfObject.isIndirect()) {
            return;
        }
        RefKey refKey = new RefKey((PRIndirectReference)(pdfObject = (PRIndirectReference)pdfObject));
        if (!this.writer.indirects.containsKey(refKey)) {
            this.writer.copyIndirect((PRIndirectReference)pdfObject, true, false);
        }
        pdfObject = this.writer.indirects.get(refKey).getRef();
        if (this.writer.updateRootKids) {
            this.addKid(this.structureTreeRoot, pdfObject);
            this.writer.structureTreeRootKidsForReaderImported(this.reader);
        }
    }

    public static boolean checkTagged(PdfReader object) {
        if ((object = PdfStructTreeController.getDirectObject(object.getCatalog().get(PdfName.STRUCTTREEROOT))) != null) {
            if (!object.isDictionary()) {
                return false;
            }
            if ((object = PdfStructTreeController.getDirectObject(((PdfDictionary)object).get(PdfName.PARENTTREE))) != null) {
                if (!object.isDictionary()) {
                    return false;
                }
                return true;
            }
        }
        return false;
    }

    public static boolean compareObjects(PdfObject pdfObject, PdfObject pdfObject2) {
        block24 : {
            boolean bl2;
            block25 : {
                block26 : {
                    pdfObject2 = PdfStructTreeController.getDirectObject(pdfObject2);
                    boolean bl3 = false;
                    boolean bl4 = false;
                    boolean bl5 = false;
                    if (pdfObject2 == null) {
                        return false;
                    }
                    if (pdfObject.type() != pdfObject2.type()) {
                        return false;
                    }
                    if (pdfObject.isBoolean()) {
                        if (pdfObject == pdfObject2) {
                            return true;
                        }
                        boolean bl6 = bl5;
                        if (pdfObject2 instanceof PdfBoolean) {
                            bl6 = bl5;
                            if (((PdfBoolean)pdfObject).booleanValue() == ((PdfBoolean)pdfObject2).booleanValue()) {
                                bl6 = true;
                            }
                        }
                        return bl6;
                    }
                    if (pdfObject.isName()) {
                        return pdfObject.equals(pdfObject2);
                    }
                    if (pdfObject.isNumber()) {
                        if (pdfObject == pdfObject2) {
                            return true;
                        }
                        boolean bl7 = bl3;
                        if (pdfObject2 instanceof PdfNumber) {
                            bl7 = bl3;
                            if (((PdfNumber)pdfObject).doubleValue() == ((PdfNumber)pdfObject2).doubleValue()) {
                                bl7 = true;
                            }
                        }
                        return bl7;
                    }
                    if (pdfObject.isNull()) {
                        if (pdfObject == pdfObject2) {
                            return true;
                        }
                        if (pdfObject2 instanceof PdfNull) {
                            return true;
                        }
                        return false;
                    }
                    if (!pdfObject.isString()) break block24;
                    if (pdfObject == pdfObject2) {
                        return true;
                    }
                    bl2 = bl4;
                    if (!(pdfObject2 instanceof PdfString)) break block25;
                    pdfObject2 = (PdfString)pdfObject2;
                    if (pdfObject2.value == null && ((PdfString)pdfObject).value == null) break block26;
                    pdfObject = (PdfString)pdfObject;
                    bl2 = bl4;
                    if (pdfObject.value == null) break block25;
                    bl2 = bl4;
                    if (!pdfObject.value.equals(pdfObject2.value)) break block25;
                }
                bl2 = true;
            }
            return bl2;
        }
        if (pdfObject.isArray()) {
            pdfObject = (PdfArray)pdfObject;
            pdfObject2 = (PdfArray)pdfObject2;
            if (pdfObject.size() != pdfObject2.size()) {
                return false;
            }
            for (int i2 = 0; i2 < pdfObject.size(); ++i2) {
                if (PdfStructTreeController.compareObjects(pdfObject.getPdfObject(i2), pdfObject2.getPdfObject(i2))) continue;
                return false;
            }
            return true;
        }
        if (pdfObject.isDictionary()) {
            pdfObject = (PdfDictionary)pdfObject;
            pdfObject2 = (PdfDictionary)pdfObject2;
            if (pdfObject.size() != pdfObject2.size()) {
                return false;
            }
            for (PdfName pdfName : pdfObject.hashMap.keySet()) {
                if (PdfStructTreeController.compareObjects(pdfObject.get(pdfName), pdfObject2.get(pdfName))) continue;
                return false;
            }
            return true;
        }
        return false;
    }

    private returnType copyPageMarks(PdfDictionary pdfObject, PdfNumber pdfNumber, int n2) {
        PdfObject pdfObject2 = (PdfArray)PdfStructTreeController.getDirectObject(pdfObject.get(PdfName.NUMS));
        if (pdfObject2 == null) {
            if ((pdfObject = (PdfArray)PdfStructTreeController.getDirectObject(pdfObject.get(PdfName.KIDS))) == null) {
                return returnType.NOTFOUND;
            }
            int n3 = pdfObject.size() / 2;
            int n4 = 0;
            block5 : do {
                int n5 = n3 + n4;
                pdfObject2 = (PdfDictionary)PdfStructTreeController.getDirectObject(pdfObject.getPdfObject(n5));
                switch (.$SwitchMap$com$itextpdf$text$pdf$PdfStructTreeController$returnType[this.copyPageMarks((PdfDictionary)pdfObject2, pdfNumber, n2).ordinal()]) {
                    default: {
                        return returnType.NOTFOUND;
                    }
                    case 3: {
                        if (n5 == 0) {
                            return returnType.BELOW;
                        }
                        if (n3 == 0) {
                            return returnType.NOTFOUND;
                        }
                        n3 /= 2;
                        continue block5;
                    }
                    case 2: {
                        n3 = n4 = n3 / 2;
                        if (n4 == 0) {
                            n3 = 1;
                        }
                        if (n3 + n5 == pdfObject.size()) {
                            return returnType.ABOVE;
                        }
                        n4 = n5;
                        continue block5;
                    }
                    case 1: 
                }
                break;
            } while (true);
            return returnType.FOUND;
        }
        if (pdfObject2.size() == 0) {
            return returnType.NOTFOUND;
        }
        return this.findAndCopyMarks((PdfArray)pdfObject2, pdfNumber.intValue(), n2);
    }

    private returnType findAndCopyMarks(PdfArray pdfObject, int n2, int n3) {
        if (pdfObject.getAsNumber(0).intValue() > n2) {
            return returnType.BELOW;
        }
        if (pdfObject.getAsNumber(pdfObject.size() - 2).intValue() < n2) {
            return returnType.ABOVE;
        }
        int n4 = pdfObject.size() / 4;
        int n5 = 0;
        do {
            int n6;
            int n7;
            int n8;
            block18 : {
                block21 : {
                    block20 : {
                        PdfObject pdfObject2;
                        block19 : {
                            if ((n6 = pdfObject.getAsNumber(n8 = (n7 = n5 + n4) * 2).intValue()) != n2) break block18;
                            pdfObject = pdfObject2 = pdfObject.getPdfObject(n8 + 1);
                            while (pdfObject.isIndirect()) {
                                pdfObject = PdfReader.getPdfObjectRelease(pdfObject);
                            }
                            if (!pdfObject.isArray()) break block19;
                            pdfObject2 = null;
                            Iterator<PdfObject> iterator = ((PdfArray)pdfObject).iterator();
                            pdfObject = pdfObject2;
                            while (iterator.hasNext()) {
                                pdfObject2 = iterator.next();
                                if (pdfObject2.isNull()) {
                                    if (this.nullReference == null) {
                                        this.nullReference = this.writer.addToBody(new PdfNull()).getIndirectReference();
                                    }
                                    this.structureTreeRoot.setPageMark(n3, this.nullReference);
                                    continue;
                                }
                                PdfObject pdfObject3 = this.writer.copyObject(pdfObject2, true, false);
                                pdfObject2 = pdfObject;
                                if (pdfObject == null) {
                                    pdfObject2 = pdfObject3;
                                }
                                this.structureTreeRoot.setPageMark(n3, (PdfIndirectReference)pdfObject3);
                                pdfObject = pdfObject2;
                            }
                            this.attachStructTreeRootKids(pdfObject);
                            break block20;
                        }
                        if (!pdfObject.isDictionary()) break block21;
                        if (PdfStructTreeController.getKDict((PdfDictionary)pdfObject) == null) {
                            return returnType.NOTFOUND;
                        }
                        pdfObject = this.writer.copyObject(pdfObject2, true, false);
                        this.structureTreeRoot.setAnnotationMark(n3, (PdfIndirectReference)pdfObject);
                    }
                    return returnType.FOUND;
                }
                return returnType.NOTFOUND;
            }
            if (n6 < n2) {
                if (n4 == 0) {
                    return returnType.NOTFOUND;
                }
                n8 = n4;
                if (n4 != 1) {
                    n8 = n4 / 2;
                }
                if (n8 + n7 == pdfObject.size()) {
                    return returnType.NOTFOUND;
                }
                n5 = n7;
                n4 = n8;
                continue;
            }
            if (n7 == 0) {
                return returnType.BELOW;
            }
            if (n4 == 0) {
                return returnType.NOTFOUND;
            }
            n4 /= 2;
        } while (true);
    }

    /*
     * Enabled aggressive block sorting
     */
    private static PdfArray getDirectArray(PdfArray pdfArray) {
        PdfArray pdfArray2 = new PdfArray();
        int n2 = 0;
        while (n2 < pdfArray.size()) {
            PdfObject pdfObject = PdfStructTreeController.getDirectObject(pdfArray.getPdfObject(n2));
            if (pdfObject != null) {
                PdfObject pdfObject2;
                if (pdfObject.isArray()) {
                    pdfObject2 = PdfStructTreeController.getDirectArray((PdfArray)pdfObject);
                } else {
                    pdfObject2 = pdfObject;
                    if (pdfObject.isDictionary()) {
                        pdfObject2 = PdfStructTreeController.getDirectDict((PdfDictionary)pdfObject);
                    }
                }
                pdfArray2.add(pdfObject2);
            }
            ++n2;
        }
        return pdfArray2;
    }

    /*
     * Enabled aggressive block sorting
     */
    private static PdfDictionary getDirectDict(PdfDictionary entry) {
        PdfDictionary pdfDictionary = new PdfDictionary();
        Iterator<Map.Entry<PdfName, PdfObject>> iterator = entry.hashMap.entrySet().iterator();
        while (iterator.hasNext()) {
            entry = iterator.next();
            PdfObject pdfObject = PdfStructTreeController.getDirectObject(entry.getValue());
            if (pdfObject == null) continue;
            if (pdfObject.isArray()) {
                entry = entry.getKey();
                pdfObject = PdfStructTreeController.getDirectArray((PdfArray)pdfObject);
            } else if (pdfObject.isDictionary()) {
                entry = (PdfName)entry.getKey();
                pdfObject = PdfStructTreeController.getDirectDict((PdfDictionary)pdfObject);
            } else {
                entry = (PdfName)entry.getKey();
            }
            pdfDictionary.put((PdfName)((Object)entry), pdfObject);
        }
        return pdfDictionary;
    }

    public static PdfObject getDirectObject(PdfObject pdfObject) {
        PdfObject pdfObject2 = pdfObject;
        if (pdfObject == null) {
            return null;
        }
        while (pdfObject2.isIndirect()) {
            pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject2);
        }
        return pdfObject2;
    }

    static PdfDictionary getKDict(PdfDictionary pdfObject) {
        PdfDictionary pdfDictionary = pdfObject.getAsDict(PdfName.K);
        if (pdfDictionary != null) {
            if (PdfName.OBJR.equals(pdfDictionary.getAsName(PdfName.TYPE))) {
                return pdfDictionary;
            }
        } else {
            if ((pdfObject = pdfObject.getAsArray(PdfName.K)) == null) {
                return null;
            }
            for (int i2 = 0; i2 < pdfObject.size(); ++i2) {
                pdfDictionary = pdfObject.getAsDict(i2);
                if (pdfDictionary == null || !PdfName.OBJR.equals(pdfDictionary.getAsName(PdfName.TYPE))) continue;
                return pdfDictionary;
            }
        }
        return null;
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void addClass(PdfObject pdfObject) {
        pdfObject = PdfStructTreeController.getDirectObject(pdfObject);
        boolean bl2 = pdfObject.isDictionary();
        if (bl2) {
            if ((pdfObject = ((PdfDictionary)pdfObject).get(PdfName.C)) == null) {
                return;
            }
            if (pdfObject.isArray()) {
                pdfObject = (PdfArray)pdfObject;
                for (int i2 = 0; i2 < pdfObject.size(); ++i2) {
                    this.addClass(pdfObject.getPdfObject(i2));
                }
                return;
            } else {
                if (!pdfObject.isName()) return;
                {
                    this.addClass(pdfObject);
                    return;
                }
            }
        }
        if (!pdfObject.isName()) return;
        PdfName pdfName = (PdfName)pdfObject;
        if (this.sourceClassMap == null) {
            pdfObject = PdfStructTreeController.getDirectObject(this.structTreeRoot.get(PdfName.CLASSMAP));
            if (pdfObject == null) {
                return;
            }
            if (!pdfObject.isDictionary()) {
                return;
            }
            this.sourceClassMap = (PdfDictionary)pdfObject;
        }
        if ((pdfObject = PdfStructTreeController.getDirectObject(this.sourceClassMap.get(pdfName))) == null) {
            return;
        }
        PdfObject pdfObject2 = this.structureTreeRoot.getMappedClass(pdfName);
        if (pdfObject2 != null) {
            if (!PdfStructTreeController.compareObjects(pdfObject2, pdfObject)) throw new BadPdfFormatException(MessageLocalization.getComposedMessage("conflict.in.classmap", pdfName));
            return;
        }
        if (pdfObject.isDictionary()) {
            pdfObject2 = this.structureTreeRoot;
            pdfObject = PdfStructTreeController.getDirectDict((PdfDictionary)pdfObject);
        } else {
            if (!pdfObject.isArray()) return;
            pdfObject2 = this.structureTreeRoot;
            pdfObject = PdfStructTreeController.getDirectArray((PdfArray)pdfObject);
        }
        pdfObject2.mapClass(pdfName, pdfObject);
    }

    protected void addKid(PdfDictionary pdfDictionary, PdfObject pdfObject) {
        PdfArray pdfArray;
        PdfObject pdfObject2 = pdfDictionary.get(PdfName.K);
        if (pdfObject2 instanceof PdfArray) {
            pdfArray = (PdfArray)pdfObject2;
        } else {
            pdfArray = new PdfArray();
            if (pdfObject2 != null) {
                pdfArray.add(pdfObject2);
            }
        }
        pdfArray.add(pdfObject);
        pdfDictionary.put(PdfName.K, pdfArray);
    }

    /*
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    protected void addRole(PdfName pdfName) {
        if (pdfName == null) {
            return;
        }
        Object object = this.writer.getStandardStructElems().iterator();
        while (object.hasNext()) {
            if (!object.next().equals(pdfName)) continue;
            return;
        }
        if (this.sourceRoleMap == null) {
            object = PdfStructTreeController.getDirectObject(this.structTreeRoot.get(PdfName.ROLEMAP));
            if (object == null) return;
            if (!object.isDictionary()) {
                return;
            }
            this.sourceRoleMap = (PdfDictionary)object;
        }
        if ((object = this.sourceRoleMap.get(pdfName)) == null) return;
        if (!object.isName()) {
            return;
        }
        if (this.roleMap == null) {
            this.roleMap = new PdfDictionary();
            this.structureTreeRoot.put(PdfName.ROLEMAP, this.roleMap);
        } else {
            PdfObject pdfObject = this.roleMap.get(pdfName);
            if (pdfObject != null) {
                if (!pdfObject.equals(object)) throw new BadPdfFormatException(MessageLocalization.getComposedMessage("conflict.in.rolemap", pdfName));
                return;
            }
        }
        this.roleMap.put(pdfName, (PdfObject)object);
    }

    protected void attachStructTreeRootKids(PdfObject object) {
        PdfObject pdfObject = this.structTreeRoot.get(PdfName.K);
        if (pdfObject != null && (pdfObject.isArray() || pdfObject.isIndirect())) {
            if (pdfObject.isIndirect()) {
                this.addKid(pdfObject);
                return;
            }
            object = ((PdfArray)pdfObject).iterator();
            while (object.hasNext()) {
                this.addKid((PdfObject)object.next());
            }
        } else {
            this.addKid(this.structureTreeRoot, (PdfObject)object);
        }
    }

    public void copyStructTreeForPage(PdfNumber pdfNumber, int n2) {
        if (this.copyPageMarks(this.parentTree, pdfNumber, n2) != returnType.NOTFOUND) {
            return;
        }
        throw new BadPdfFormatException(MessageLocalization.getComposedMessage("invalid.structparent", new Object[0]));
    }

    protected void setReader(PdfReader object) {
        this.reader = object;
        if ((object = PdfStructTreeController.getDirectObject(object.getCatalog().get(PdfName.STRUCTTREEROOT))) != null && object.isDictionary()) {
            this.structTreeRoot = (PdfDictionary)object;
            object = PdfStructTreeController.getDirectObject(this.structTreeRoot.get(PdfName.PARENTTREE));
            if (object != null && object.isDictionary()) {
                this.parentTree = (PdfDictionary)object;
                this.sourceRoleMap = null;
                this.sourceClassMap = null;
                this.nullReference = null;
                return;
            }
            throw new BadPdfFormatException(MessageLocalization.getComposedMessage("the.document.does.not.contain.parenttree", new Object[0]));
        }
        throw new BadPdfFormatException(MessageLocalization.getComposedMessage("no.structtreeroot.found", new Object[0]));
    }

    public static enum returnType {
        BELOW,
        FOUND,
        ABOVE,
        NOTFOUND;
        

        private returnType() {
        }
    }

}

