/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.io.StreamUtil;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.fonts.cmaps.CMapCache;
import com.itextpdf.text.pdf.fonts.cmaps.CMapCidByte;
import com.itextpdf.text.pdf.fonts.cmaps.CMapCidUni;
import com.itextpdf.text.pdf.fonts.cmaps.CMapUniCid;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.StringTokenizer;

class CJKFont
extends BaseFont {
    private static final int BRACKET = 1;
    static final String CJK_ENCODING = "UnicodeBigUnmarked";
    private static final int FIRST = 0;
    public static final String RESOURCE_PATH_CMAP = "com/itextpdf/text/pdf/fonts/cmaps/";
    private static final int SERIAL = 2;
    private static final int V1Y = 880;
    private static final HashMap<String, HashMap<String, Object>> allFonts;
    static Properties cjkEncodings;
    static Properties cjkFonts;
    private static boolean propertiesLoaded;
    private static final HashMap<String, Set<String>> registryNames;
    private String CMap;
    private CMapCidByte cidByte;
    private boolean cidDirect = false;
    private CMapCidUni cidUni;
    private HashMap<String, Object> fontDesc;
    private String fontName;
    private IntHashtable hMetrics;
    private String style = "";
    private CMapUniCid uniCid;
    private String uniMap;
    private IntHashtable vMetrics;

    static {
        cjkFonts = new Properties();
        cjkEncodings = new Properties();
        allFonts = new HashMap();
        propertiesLoaded = false;
        registryNames = new HashMap();
    }

    CJKFont(String string2, String string3, boolean bl2) {
        CJKFont.loadProperties();
        this.fontType = 2;
        String string4 = CJKFont.getBaseName(string2);
        if (CJKFont.isCJKFont(string4, string3)) {
            String string5 = string2;
            if (string4.length() < string2.length()) {
                this.style = string2.substring(string4.length());
                string5 = string4;
            }
            this.fontName = string5;
            this.encoding = CJK_ENCODING;
            this.vertical = string3.endsWith("V");
            this.CMap = string3;
            if (string3.equals("Identity-H") || string3.equals("Identity-V")) {
                this.cidDirect = true;
            }
            this.loadCMaps();
            return;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("font.1.with.2.encoding.is.not.a.cjk.font", string2, string3));
    }

    public static String GetCompatibleFont(String string2) {
        CJKFont.loadProperties();
        for (Map.Entry<String, Set<String>> entry : registryNames.entrySet()) {
            if (!entry.getValue().contains(string2)) continue;
            entry = entry.getKey();
            for (Map.Entry<String, HashMap<String, Object>> entry2 : allFonts.entrySet()) {
                if (!entry.equals(entry2.getValue().get("Registry"))) continue;
                return entry2.getKey();
            }
        }
        return null;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    static String convertToHCIDMetrics(int[] var0, IntHashtable var1_1) {
        if (var0.length == 0) {
            return null;
        }
        var3_2 = 0;
        var5_3 = 0;
        var4_4 = 0;
        do {
            var2_5 = var3_2;
            if (var3_2 >= var0.length) return null;
            var4_4 = var0[var3_2];
            var5_3 = var1_1.get(var4_4);
            if (var5_3 != 0) {
                var2_5 = var3_2 + 1;
                if (var5_3 == 0) {
                    return null;
                }
                break;
            }
            ++var3_2;
        } while (true);
        var9_6 = new StringBuilder();
        var9_6.append('[');
        var9_6.append(var4_4);
        var3_2 = 0;
        var6_7 = var4_4;
        for (var4_4 = var2_5; var4_4 < var0.length; ++var4_4) {
            block23 : {
                block24 : {
                    block22 : {
                        var8_9 = var0[var4_4];
                        var7_8 = var1_1.get(var8_9);
                        if (var7_8 != 0) break block22;
                        var2_5 = var3_2;
                        break block23;
                    }
                    switch (var3_2) {
                        default: {
                            var2_5 = var3_2;
                            break block24;
                        }
                        case 2: {
                            if (var8_9 != var6_7 + 1) ** GOTO lbl38
                            var2_5 = var3_2;
                            if (var7_8 == var5_3) break block24;
lbl38: // 2 sources:
                            var9_6.append(' ');
                            var9_6.append(var6_7);
                            var9_6.append(' ');
                            var9_6.append(var5_3);
                            var9_6.append(' ');
                            ** GOTO lbl58
                        }
                        case 1: {
                            var2_5 = var6_7 + 1;
                            if (var8_9 == var2_5 && var7_8 == var5_3) {
                                var9_6.append(']');
                                var9_6.append(var6_7);
                                ** break;
                            }
                            if (var8_9 == var2_5) {
                                var9_6.append(' ');
                                var9_6.append(var5_3);
                                var2_5 = var3_2;
                            } else {
                                var9_6.append(' ');
                                var9_6.append(var5_3);
                                var9_6.append(']');
lbl58: // 2 sources:
                                var9_6.append(var8_9);
                                var2_5 = 0;
                            }
                            break block24;
                        }
                        case 0: 
                    }
                    var2_5 = var6_7 + 1;
                    if (var8_9 == var2_5 && var7_8 == var5_3) lbl-1000: // 2 sources:
                    {
                        var2_5 = 2;
                    } else if (var8_9 == var2_5) {
                        var9_6.append('[');
                        var9_6.append(var5_3);
                        var2_5 = 1;
                    } else {
                        var9_6.append('[');
                        var9_6.append(var5_3);
                        var9_6.append(']');
                        var9_6.append(var8_9);
                        var2_5 = var3_2;
                    }
                }
                var6_7 = var8_9;
                var5_3 = var7_8;
            }
            var3_2 = var2_5;
        }
        switch (var3_2) {
            default: {
                return var9_6.toString();
            }
            case 2: {
                var9_6.append(' ');
                var9_6.append(var6_7);
                var9_6.append(' ');
                var9_6.append(var5_3);
                var9_6.append(']');
                return var9_6.toString();
            }
            case 1: {
                var9_6.append(' ');
                ** break;
            }
            case 0: 
        }
        var9_6.append('[');
lbl97: // 2 sources:
        var9_6.append(var5_3);
        var9_6.append("]]");
        return var9_6.toString();
    }

    static String convertToVCIDMetrics(int[] arrn, IntHashtable intHashtable, IntHashtable intHashtable2) {
        int n2;
        if (arrn.length == 0) {
            return null;
        }
        int n3 = 0;
        int n4 = 0;
        int n5 = 0;
        int n6 = 0;
        do {
            n2 = n3;
            if (n3 >= arrn.length) break;
            n6 = arrn[n3];
            n4 = intHashtable.get(n6);
            if (n4 != 0) {
                n2 = n3 + 1;
                break;
            }
            n5 = intHashtable2.get(n6);
            ++n3;
        } while (true);
        if (n4 == 0) {
            return null;
        }
        n3 = n5;
        if (n5 == 0) {
            n3 = 1000;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append('[');
        stringBuilder.append(n6);
        n5 = 0;
        int n7 = n4;
        n4 = n2;
        do {
            n2 = arrn.length;
            int n8 = 2;
            if (n4 >= n2) break;
            int n9 = arrn[n4];
            int n10 = intHashtable.get(n9);
            if (n10 == 0) {
                n2 = n3;
            } else {
                n2 = intHashtable2.get(n6);
                if (n2 == 0) {
                    n2 = 1000;
                }
                if (n5 != 0) {
                    if (n5 == 2 && (n9 != n6 + 1 || n10 != n7 || n2 != n3)) {
                        stringBuilder.append(' ');
                        stringBuilder.append(n6);
                        stringBuilder.append(' ');
                        stringBuilder.append(- n7);
                        stringBuilder.append(' ');
                        stringBuilder.append(n3 / 2);
                        stringBuilder.append(' ');
                        stringBuilder.append(880);
                        stringBuilder.append(' ');
                        stringBuilder.append(n9);
                        n5 = 0;
                    }
                } else if (n9 == n6 + 1 && n10 == n7 && n2 == n3) {
                    n5 = n8;
                } else {
                    stringBuilder.append(' ');
                    stringBuilder.append(n6);
                    stringBuilder.append(' ');
                    stringBuilder.append(- n7);
                    stringBuilder.append(' ');
                    stringBuilder.append(n3 / 2);
                    stringBuilder.append(' ');
                    stringBuilder.append(880);
                    stringBuilder.append(' ');
                    stringBuilder.append(n9);
                }
                n6 = n9;
                n7 = n10;
            }
            ++n4;
            n3 = n2;
        } while (true);
        stringBuilder.append(' ');
        stringBuilder.append(n6);
        stringBuilder.append(' ');
        stringBuilder.append(- n7);
        stringBuilder.append(' ');
        stringBuilder.append(n3 / 2);
        stringBuilder.append(' ');
        stringBuilder.append(880);
        stringBuilder.append(" ]");
        return stringBuilder.toString();
    }

    static IntHashtable createMetric(String object) {
        IntHashtable intHashtable = new IntHashtable();
        object = new StringTokenizer((String)object);
        while (object.hasMoreTokens()) {
            intHashtable.put(Integer.parseInt(object.nextToken()), Integer.parseInt(object.nextToken()));
        }
        return intHashtable;
    }

    private float getBBox(int n2) {
        StringTokenizer stringTokenizer = new StringTokenizer((String)this.fontDesc.get("FontBBox"), " []\r\n\t\f");
        String string2 = stringTokenizer.nextToken();
        for (int i2 = 0; i2 < n2; ++i2) {
            string2 = stringTokenizer.nextToken();
        }
        return Integer.parseInt(string2);
    }

    /*
     * Enabled aggressive block sorting
     */
    private PdfDictionary getCIDFont(PdfIndirectReference object, IntHashtable object2) {
        void var1_6;
        Object object3;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        pdfDictionary.put(PdfName.SUBTYPE, PdfName.CIDFONTTYPE0);
        PdfObject pdfObject = PdfName.BASEFONT;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(this.fontName);
        stringBuilder.append(this.style);
        pdfDictionary.put((PdfName)pdfObject, new PdfName(stringBuilder.toString()));
        pdfDictionary.put(PdfName.FONTDESCRIPTOR, (PdfObject)object);
        int[] arrn = object3.toOrderedKeys();
        object3 = CJKFont.convertToHCIDMetrics(arrn, this.hMetrics);
        if (object3 != null) {
            pdfDictionary.put(PdfName.W, new PdfLiteral((String)object3));
        }
        if (this.vertical) {
            String string2 = CJKFont.convertToVCIDMetrics(arrn, this.vMetrics, this.hMetrics);
            if (string2 != null) {
                pdfDictionary.put(PdfName.W2, new PdfLiteral(string2));
            }
        } else {
            pdfDictionary.put(PdfName.DW, new PdfNumber(1000));
        }
        pdfObject = new PdfDictionary();
        if (this.cidDirect) {
            pdfObject.put(PdfName.REGISTRY, new PdfString(this.cidUni.getRegistry(), null));
            pdfObject.put(PdfName.ORDERING, new PdfString(this.cidUni.getOrdering(), null));
            object3 = PdfName.SUPPLEMENT;
            PdfNumber pdfNumber = new PdfNumber(this.cidUni.getSupplement());
        } else {
            pdfObject.put(PdfName.REGISTRY, new PdfString(this.cidByte.getRegistry(), null));
            pdfObject.put(PdfName.ORDERING, new PdfString(this.cidByte.getOrdering(), null));
            object3 = PdfName.SUPPLEMENT;
            PdfNumber pdfNumber = new PdfNumber(this.cidByte.getSupplement());
        }
        pdfObject.put((PdfName)object3, (PdfObject)var1_6);
        pdfDictionary.put(PdfName.CIDSYSTEMINFO, pdfObject);
        return pdfDictionary;
    }

    private float getDescNumber(String string2) {
        return Integer.parseInt((String)this.fontDesc.get(string2));
    }

    private PdfDictionary getFontBaseType(PdfIndirectReference pdfIndirectReference) {
        CharSequence charSequence;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        pdfDictionary.put(PdfName.SUBTYPE, PdfName.TYPE0);
        CharSequence charSequence2 = charSequence = this.fontName;
        if (this.style.length() > 0) {
            charSequence2 = new StringBuilder();
            charSequence2.append((String)charSequence);
            charSequence2.append("-");
            charSequence2.append(this.style.substring(1));
            charSequence2 = charSequence2.toString();
        }
        charSequence = new StringBuilder();
        charSequence.append((String)charSequence2);
        charSequence.append("-");
        charSequence.append(this.CMap);
        charSequence2 = charSequence.toString();
        pdfDictionary.put(PdfName.BASEFONT, new PdfName((String)charSequence2));
        pdfDictionary.put(PdfName.ENCODING, new PdfName(this.CMap));
        pdfDictionary.put(PdfName.DESCENDANTFONTS, new PdfArray(pdfIndirectReference));
        return pdfDictionary;
    }

    private PdfDictionary getFontDescriptor() {
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONTDESCRIPTOR);
        pdfDictionary.put(PdfName.ASCENT, new PdfLiteral((String)this.fontDesc.get("Ascent")));
        pdfDictionary.put(PdfName.CAPHEIGHT, new PdfLiteral((String)this.fontDesc.get("CapHeight")));
        pdfDictionary.put(PdfName.DESCENT, new PdfLiteral((String)this.fontDesc.get("Descent")));
        pdfDictionary.put(PdfName.FLAGS, new PdfLiteral((String)this.fontDesc.get("Flags")));
        pdfDictionary.put(PdfName.FONTBBOX, new PdfLiteral((String)this.fontDesc.get("FontBBox")));
        PdfObject pdfObject = PdfName.FONTNAME;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(this.fontName);
        stringBuilder.append(this.style);
        pdfDictionary.put((PdfName)pdfObject, new PdfName(stringBuilder.toString()));
        pdfDictionary.put(PdfName.ITALICANGLE, new PdfLiteral((String)this.fontDesc.get("ItalicAngle")));
        pdfDictionary.put(PdfName.STEMV, new PdfLiteral((String)this.fontDesc.get("StemV")));
        pdfObject = new PdfDictionary();
        pdfObject.put(PdfName.PANOSE, new PdfString((String)this.fontDesc.get("Panose"), null));
        pdfDictionary.put(PdfName.STYLE, pdfObject);
        return pdfDictionary;
    }

    public static boolean isCJKFont(String object, String string2) {
        CJKFont.loadProperties();
        boolean bl2 = registryNames.containsKey("fonts");
        boolean bl3 = false;
        if (!bl2) {
            return false;
        }
        if (!registryNames.get("fonts").contains(object)) {
            return false;
        }
        if (!string2.equals("Identity-H")) {
            if (string2.equals("Identity-V")) {
                return true;
            }
            object = (String)allFonts.get(object).get("Registry");
            object = registryNames.get(object);
            bl2 = bl3;
            if (object != null) {
                bl2 = bl3;
                if (object.contains(string2)) {
                    bl2 = true;
                }
            }
            return bl2;
        }
        return true;
    }

    private void loadCMaps() {
        try {
            this.fontDesc = allFonts.get(this.fontName);
            this.hMetrics = (IntHashtable)this.fontDesc.get("W");
            this.vMetrics = (IntHashtable)this.fontDesc.get("W2");
            Object object = (String)this.fontDesc.get("Registry");
            this.uniMap = "";
            Object object2 = registryNames;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append((String)object);
            stringBuilder.append("_Uni");
            object = object2.get(stringBuilder.toString()).iterator();
            while (object.hasNext()) {
                this.uniMap = object2 = (String)object.next();
                if ((!object2.endsWith("V") || !this.vertical) && (object2.endsWith("V") || this.vertical)) continue;
            }
            if (this.cidDirect) {
                this.cidUni = CMapCache.getCachedCMapCidUni(this.uniMap);
                return;
            }
            this.uniCid = CMapCache.getCachedCMapUniCid(this.uniMap);
            this.cidByte = CMapCache.getCachedCMapCidByte(this.CMap);
            return;
        }
        catch (Exception exception) {
            throw new DocumentException(exception);
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private static void loadProperties() {
        if (propertiesLoaded) {
            return;
        }
        HashMap<String, HashMap<String, Object>> hashMap = allFonts;
        synchronized (hashMap) {
            if (propertiesLoaded) {
                return;
            }
            try {
                CJKFont.loadRegistry();
                for (String string2 : registryNames.get("fonts")) {
                    allFonts.put(string2, CJKFont.readFontProperties(string2));
                }
            }
            catch (Exception exception) {}
            propertiesLoaded = true;
            return;
        }
    }

    private static void loadRegistry() {
        InputStream inputStream = StreamUtil.getResourceStream("com/itextpdf/text/pdf/fonts/cmaps/cjk_registry.properties");
        Properties properties = new Properties();
        properties.load(inputStream);
        inputStream.close();
        for (String string2 : properties.keySet()) {
            String[] arrstring = properties.getProperty(string2).split(" ");
            HashSet<String> hashSet = new HashSet<String>();
            for (String string3 : arrstring) {
                if (string3.length() <= 0) continue;
                hashSet.add(string3);
            }
            registryNames.put(string2, hashSet);
        }
    }

    private static HashMap<String, Object> readFontProperties(String object) {
        Object object2 = new StringBuilder();
        object2.append((String)object);
        object2.append(".properties");
        object = object2.toString();
        object2 = new StringBuilder();
        object2.append(RESOURCE_PATH_CMAP);
        object2.append((String)object);
        object2 = StreamUtil.getResourceStream(object2.toString());
        object = new Properties();
        object.load((InputStream)object2);
        object2.close();
        object2 = CJKFont.createMetric(object.getProperty("W"));
        object.remove("W");
        IntHashtable intHashtable = CJKFont.createMetric(object.getProperty("W2"));
        object.remove("W2");
        HashMap<String, Object> hashMap = new HashMap<String, Object>();
        Enumeration enumeration = object.keys();
        while (enumeration.hasMoreElements()) {
            String string2 = (String)enumeration.nextElement();
            hashMap.put(string2, object.getProperty(string2));
        }
        hashMap.put("W", object2);
        hashMap.put("W2", intHashtable);
        return hashMap;
    }

    @Override
    public boolean charExists(int n2) {
        if (this.cidDirect) {
            return true;
        }
        if (this.cidByte.lookup(this.uniCid.lookup(n2)).length > 0) {
            return true;
        }
        return false;
    }

    @Override
    byte[] convertToBytes(int n2) {
        if (this.cidDirect) {
            return super.convertToBytes(n2);
        }
        return this.cidByte.lookup(this.uniCid.lookup(n2));
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    @Override
    public byte[] convertToBytes(String arrby) {
        ByteArrayOutputStream byteArrayOutputStream;
        if (this.cidDirect) {
            return super.convertToBytes((String)arrby);
        }
        try {
            int n2 = arrby.length();
            if (n2 == 1) {
                return this.convertToBytes(arrby.charAt(0));
            }
            byteArrayOutputStream = new ByteArrayOutputStream();
            for (int i2 = 0; i2 < arrby.length(); ++i2) {
                if (Utilities.isSurrogatePair((String)arrby, i2)) {
                    n2 = Utilities.convertToUtf32((String)arrby, i2);
                    ++i2;
                } else {
                    n2 = arrby.charAt(i2);
                }
                byteArrayOutputStream.write(this.convertToBytes(n2));
            }
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
        return byteArrayOutputStream.toByteArray();
    }

    @Override
    public String[][] getAllNameEntries() {
        return new String[][]{{"4", "", "", "", this.fontName}};
    }

    @Override
    public int[] getCharBBox(int n2) {
        return null;
    }

    @Override
    public int getCidCode(int n2) {
        if (this.cidDirect) {
            return n2;
        }
        return this.uniCid.lookup(n2);
    }

    @Override
    public String[][] getFamilyFontName() {
        return this.getFullFontName();
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    @Override
    public float getFontDescriptor(int var1_1, float var2_2) {
        switch (var1_1) {
            default: {
                return 0.0f;
            }
            case 12: {
                var3_3 = this.getBBox(2) - this.getBBox(0);
                return var2_2 * var3_3 / 1000.0f;
            }
            case 11: {
                return 0.0f;
            }
            case 8: {
                var1_1 = 3;
                ** GOTO lbl17
            }
            case 7: {
                var3_3 = this.getBBox(2);
                return var2_2 * var3_3 / 1000.0f;
            }
            case 6: {
                var1_1 = 1;
lbl17: // 2 sources:
                var3_3 = this.getBBox(var1_1);
                return var2_2 * var3_3 / 1000.0f;
            }
            case 5: {
                var3_3 = this.getBBox(0);
                return var2_2 * var3_3 / 1000.0f;
            }
            case 4: {
                return this.getDescNumber("ItalicAngle");
            }
            case 3: 
            case 10: {
                return this.getDescNumber("Descent") * var2_2 / 1000.0f;
            }
            case 2: {
                return this.getDescNumber("CapHeight") * var2_2 / 1000.0f;
            }
            case 1: 
            case 9: 
        }
        return this.getDescNumber("Ascent") * var2_2 / 1000.0f;
    }

    @Override
    public String[][] getFullFontName() {
        return new String[][]{{"", "", "", this.fontName}};
    }

    @Override
    public PdfStream getFullFontStream() {
        return null;
    }

    @Override
    public int getKerning(int n2, int n3) {
        return 0;
    }

    @Override
    public String getPostscriptFontName() {
        return this.fontName;
    }

    @Override
    protected int[] getRawCharBBox(int n2, String string2) {
        return null;
    }

    @Override
    int getRawWidth(int n2, String string2) {
        return 0;
    }

    String getUniMap() {
        return this.uniMap;
    }

    @Override
    public int getUnicodeEquivalent(int n2) {
        int n3 = n2;
        if (this.cidDirect) {
            if (n2 == 32767) {
                return 10;
            }
            n3 = this.cidUni.lookup(n2);
        }
        return n3;
    }

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public int getWidth(int n2) {
        int n3 = n2;
        if (!this.cidDirect) {
            n3 = this.uniCid.lookup(n2);
        }
        IntHashtable intHashtable = this.vertical ? this.vMetrics : this.hMetrics;
        n2 = intHashtable.get(n3);
        if (n2 <= 0) {
            return 1000;
        }
        return n2;
    }

    @Override
    public int getWidth(String string2) {
        boolean bl2 = this.cidDirect;
        int n2 = 0;
        int n3 = 0;
        if (bl2) {
            int n4 = 0;
            do {
                n2 = n4;
                if (n3 < string2.length()) {
                    n4 += this.getWidth(string2.charAt(n3));
                    ++n3;
                    continue;
                }
                break;
            } while (true);
        } else {
            int n5 = 0;
            n3 = n2;
            do {
                n2 = n5;
                if (n3 >= string2.length()) break;
                if (Utilities.isSurrogatePair(string2, n3)) {
                    n2 = Utilities.convertToUtf32(string2, n3);
                    ++n3;
                } else {
                    n2 = string2.charAt(n3);
                }
                n5 += this.getWidth(n2);
                ++n3;
            } while (true);
        }
        return n2;
    }

    @Override
    public boolean hasKernPairs() {
        return false;
    }

    public boolean isIdentity() {
        return this.cidDirect;
    }

    @Override
    public boolean setCharAdvance(int n2, int n3) {
        return false;
    }

    @Override
    public boolean setKerning(int n2, int n3, int n4) {
        return false;
    }

    @Override
    public void setPostscriptFontName(String string2) {
        this.fontName = string2;
    }

    @Override
    void writeFont(PdfWriter pdfWriter, PdfIndirectReference pdfIndirectReference, Object[] object) {
        Object object2 = (IntHashtable)object[0];
        object = this.getFontDescriptor();
        object = object != null ? pdfWriter.addToBody((PdfObject)object).getIndirectReference() : null;
        if ((object2 = this.getCIDFont((PdfIndirectReference)object, (IntHashtable)object2)) != null) {
            object = pdfWriter.addToBody((PdfObject)object2).getIndirectReference();
        }
        pdfWriter.addToBody((PdfObject)this.getFontBaseType((PdfIndirectReference)object), pdfIndirectReference);
    }
}

