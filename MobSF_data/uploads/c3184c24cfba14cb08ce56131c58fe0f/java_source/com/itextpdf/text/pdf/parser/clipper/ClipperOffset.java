/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Clipper;
import com.itextpdf.text.pdf.parser.clipper.DefaultClipper;
import com.itextpdf.text.pdf.parser.clipper.LongRect;
import com.itextpdf.text.pdf.parser.clipper.Path;
import com.itextpdf.text.pdf.parser.clipper.Paths;
import com.itextpdf.text.pdf.parser.clipper.Point;
import com.itextpdf.text.pdf.parser.clipper.PolyNode;
import com.itextpdf.text.pdf.parser.clipper.PolyTree;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;

public class ClipperOffset {
    private static final double DEFAULT_ARC_TOLERANCE = 0.25;
    private static final double TOLERANCE = 1.0E-20;
    private static final double TWO_PI = 6.283185307179586;
    private final double arcTolerance;
    private double cos;
    private double delta;
    private Path destPoly;
    private Paths destPolys;
    private double inA;
    private Point.LongPoint lowest;
    private double miterLim;
    private final double miterLimit;
    private final List<Point.DoublePoint> normals;
    private final PolyNode polyNodes;
    private double sin;
    private Path srcPoly;
    private double stepsPerRad;

    public ClipperOffset() {
        this(2.0, 0.25);
    }

    public ClipperOffset(double d2) {
        this(d2, 0.25);
    }

    public ClipperOffset(double d2, double d3) {
        this.miterLimit = d2;
        this.arcTolerance = d3;
        this.lowest = new Point.LongPoint();
        this.lowest.setX(-1L);
        this.polyNodes = new PolyNode();
        this.normals = new ArrayList<Point.DoublePoint>();
    }

    private void doMiter(int n2, int n3, double d2) {
        d2 = this.delta / d2;
        this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n2)).getX() + (this.normals.get(n3).getX() + this.normals.get(n2).getX()) * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(n2)).getY() + (this.normals.get(n3).getY() + this.normals.get(n2).getY()) * d2)));
    }

    /*
     * Enabled aggressive block sorting
     */
    private void doOffset(double d2) {
        this.destPolys = new Paths();
        this.delta = d2;
        boolean bl2 = ClipperOffset.nearZero(d2);
        int n2 = 0;
        if (bl2) {
            do {
                if (n2 >= this.polyNodes.getChildCount()) {
                    return;
                }
                PolyNode polyNode = this.polyNodes.getChilds().get(n2);
                if (polyNode.getEndType() == Clipper.EndType.CLOSED_POLYGON) {
                    this.destPolys.add(polyNode.getPolygon());
                }
                ++n2;
            } while (true);
        }
        this.miterLim = this.miterLimit > 2.0 ? 2.0 / (this.miterLimit * this.miterLimit) : 0.5;
        double d3 = this.arcTolerance;
        double d4 = 0.0;
        double d5 = 0.25;
        if (d3 > 0.0) {
            d5 = this.arcTolerance > Math.abs(d2) * 0.25 ? 0.25 * Math.abs(d2) : this.arcTolerance;
        }
        d5 = 3.141592653589793 / Math.acos(1.0 - d5 / Math.abs(d2));
        d3 = 6.283185307179586 / d5;
        this.sin = Math.sin(d3);
        this.cos = Math.cos(d3);
        this.stepsPerRad = d5 / 6.283185307179586;
        double d6 = d2 DCMPG 0.0;
        if (d6 < 0) {
            this.sin = - this.sin;
        }
        n2 = 0;
        while (n2 < this.polyNodes.getChildCount()) {
            block41 : {
                block38 : {
                    block37 : {
                        int n3;
                        int n4;
                        double d7;
                        block40 : {
                            int n5;
                            List<Point.LongPoint> list;
                            int n6;
                            Object object;
                            Object object2;
                            block39 : {
                                object = this.polyNodes.getChilds().get(n2);
                                this.srcPoly = object.getPolygon();
                                n6 = this.srcPoly.size();
                                if (n6 == 0 || d6 <= 0 && (n6 < 3 || object.getEndType() != Clipper.EndType.CLOSED_POLYGON)) break block38;
                                this.destPoly = new Path();
                                n4 = 1;
                                if (n6 != 1) break block39;
                                if (object.getJoinType() == Clipper.JoinType.ROUND) {
                                    d3 = 1.0;
                                    do {
                                        d7 = d4;
                                        if ((double)n4 <= d5) {
                                            this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() + d3 * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() + d7 * d2)));
                                            double d8 = this.cos;
                                            double d9 = this.sin;
                                            d4 = this.sin;
                                            d4 = d7 * this.cos + d3 * d4;
                                            ++n4;
                                            d3 = d8 * d3 - d9 * d7;
                                            continue;
                                        }
                                        break block37;
                                        break;
                                    } while (true);
                                }
                                break block40;
                            }
                            n4 = n2;
                            d4 = d5;
                            this.normals.clear();
                            n2 = 0;
                            while (n2 < (n3 = n6 - 1)) {
                                List<Point.DoublePoint> list2 = this.normals;
                                object2 = (Point.LongPoint)this.srcPoly.get(n2);
                                list = this.srcPoly;
                                list2.add(Point.getUnitNormal((Point.LongPoint)object2, (Point.LongPoint)list.get(++n2)));
                            }
                            if (object.getEndType() != Clipper.EndType.CLOSED_LINE && object.getEndType() != Clipper.EndType.CLOSED_POLYGON) {
                                this.normals.add(new Point.DoublePoint(this.normals.get(n6 - 2)));
                            } else {
                                this.normals.add(Point.getUnitNormal((Point.LongPoint)this.srcPoly.get(n3), (Point.LongPoint)this.srcPoly.get(0)));
                            }
                            if (object.getEndType() == Clipper.EndType.CLOSED_POLYGON) {
                                n5 = 0;
                                do {
                                    n2 = n4;
                                    d5 = d4;
                                    if (n5 < n6) {
                                        Clipper.JoinType joinType = object.getJoinType();
                                        this.offsetPoint(n5, new int[]{n3}, joinType);
                                        ++n5;
                                        continue;
                                    }
                                    break block37;
                                    break;
                                } while (true);
                            }
                            if (object.getEndType() == Clipper.EndType.CLOSED_LINE) {
                                int[] arrn = new int[]{n3};
                                for (n2 = 0; n2 < n6; ++n2) {
                                    this.offsetPoint(n2, arrn, object.getJoinType());
                                }
                                this.destPolys.add(this.destPoly);
                                this.destPoly = new Path();
                                object2 = this.normals.get(n3);
                                for (n2 = n3; n2 > 0; --n2) {
                                    list = this.normals;
                                    List<Point.DoublePoint> list3 = this.normals;
                                    n5 = n2 - 1;
                                    list.set(n2, (Point.LongPoint)((Object)new Point.DoublePoint(- list3.get(n5).getX(), - this.normals.get(n5).getY())));
                                }
                                this.normals.set(0, new Point.DoublePoint(- object2.getX(), - object2.getY(), 0.0));
                                arrn[0] = 0;
                                do {
                                    n2 = n4;
                                    d5 = d4;
                                    if (n3 >= 0) {
                                        this.offsetPoint(n3, arrn, object.getJoinType());
                                        --n3;
                                        continue;
                                    }
                                    break block37;
                                    break;
                                } while (true);
                            }
                            int[] arrn = new int[1];
                            for (n2 = 1; n2 < n3; ++n2) {
                                this.offsetPoint(n2, arrn, object.getJoinType());
                            }
                            if (object.getEndType() == Clipper.EndType.OPEN_BUTT) {
                                object2 = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n3)).getX() + this.normals.get(n3).getX() * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(n3)).getY() + this.normals.get(n3).getY() * d2), 0L);
                                this.destPoly.add(object2);
                                object2 = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n3)).getX() - this.normals.get(n3).getX() * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(n3)).getY() - this.normals.get(n3).getY() * d2), 0L);
                                this.destPoly.add(object2);
                            } else {
                                arrn[0] = n6 - 2;
                                this.inA = 0.0;
                                this.normals.set(n3, new Point.DoublePoint(- this.normals.get(n3).getX(), - this.normals.get(n3).getY()));
                                if (object.getEndType() == Clipper.EndType.OPEN_SQUARE) {
                                    this.doSquare(n3, arrn[0], true);
                                } else {
                                    this.doRound(n3, arrn[0]);
                                }
                            }
                            for (n2 = n3; n2 > 0; --n2) {
                                object2 = this.normals;
                                list = this.normals;
                                n5 = n2 - 1;
                                object2.set(n2, new Point.DoublePoint(- ((Point.DoublePoint)((Object)list.get(n5))).getX(), - this.normals.get(n5).getY()));
                            }
                            this.normals.set(0, new Point.DoublePoint(- this.normals.get(1).getX(), - this.normals.get(1).getY()));
                            arrn[0] = n3;
                            for (n2 = arrn[0] - 1; n2 > 0; --n2) {
                                this.offsetPoint(n2, arrn, object.getJoinType());
                            }
                            if (object.getEndType() == Clipper.EndType.OPEN_BUTT) {
                                object = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() - this.normals.get(0).getX() * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() - this.normals.get(0).getY() * d2));
                                this.destPoly.add(object);
                                object = new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() + this.normals.get(0).getX() * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() + this.normals.get(0).getY() * d2));
                                this.destPoly.add(object);
                            } else {
                                arrn[0] = 1;
                                this.inA = 0.0;
                                if (object.getEndType() == Clipper.EndType.OPEN_SQUARE) {
                                    this.doSquare(0, 1, true);
                                } else {
                                    this.doRound(0, 1);
                                }
                            }
                            d3 = 0.0;
                            this.destPolys.add(this.destPoly);
                            n2 = n4;
                            d5 = d4;
                            break block41;
                        }
                        n4 = n2;
                        d4 = d5;
                        n3 = 0;
                        d7 = -1.0;
                        d3 = -1.0;
                        do {
                            n2 = n4;
                            d5 = d4;
                            if (n3 >= 4) break;
                            this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getX() + d7 * d2), Math.round((double)((Point.LongPoint)this.srcPoly.get(0)).getY() + d3 * d2)));
                            if (d7 < 0.0) {
                                d5 = 1.0;
                            } else if (d3 < 0.0) {
                                d3 = 1.0;
                                d5 = d7;
                            } else {
                                d5 = -1.0;
                            }
                            ++n3;
                            d7 = d5;
                        } while (true);
                    }
                    this.destPolys.add(this.destPoly);
                    d4 = 0.0;
                }
                d3 = d4;
            }
            d4 = d3;
            ++n2;
        }
    }

    private void doRound(int n2, int n3) {
        double d2 = Math.atan2(this.inA, this.normals.get(n3).getX() * this.normals.get(n2).getX() + this.normals.get(n3).getY() * this.normals.get(n2).getY());
        int n4 = Math.max((int)Math.round(this.stepsPerRad * Math.abs(d2)), 1);
        double d3 = this.normals.get(n3).getX();
        d2 = this.normals.get(n3).getY();
        for (n3 = 0; n3 < n4; ++n3) {
            this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n2)).getX() + this.delta * d3), Math.round((double)((Point.LongPoint)this.srcPoly.get(n2)).getY() + this.delta * d2)));
            double d4 = this.cos;
            double d5 = this.sin;
            double d6 = this.sin;
            d6 = d2 * this.cos + d3 * d6;
            d3 = d4 * d3 - d5 * d2;
            d2 = d6;
        }
        this.destPoly.add(new Point.LongPoint(Math.round((double)((Point.LongPoint)this.srcPoly.get(n2)).getX() + this.normals.get(n2).getX() * this.delta), Math.round((double)((Point.LongPoint)this.srcPoly.get(n2)).getY() + this.normals.get(n2).getY() * this.delta)));
    }

    private void doSquare(int n2, int n3, boolean bl2) {
        double d2 = this.normals.get(n3).getX();
        double d3 = this.normals.get(n3).getY();
        double d4 = this.normals.get(n2).getX();
        double d5 = this.normals.get(n2).getY();
        double d6 = ((Point.LongPoint)this.srcPoly.get(n2)).getX();
        double d7 = ((Point.LongPoint)this.srcPoly.get(n2)).getY();
        double d8 = Math.tan(Math.atan2(this.inA, d2 * d4 + d3 * d5) / 4.0);
        Path path = this.destPoly;
        double d9 = this.delta;
        double d10 = 0.0;
        double d11 = bl2 ? d3 * d8 : 0.0;
        long l2 = Math.round(d9 * (d2 - d11) + d6);
        d9 = this.delta;
        d11 = bl2 ? d2 * d8 : 0.0;
        path.add(new Point.LongPoint(l2, Math.round(d9 * (d3 + d11) + d7), 0L));
        path = this.destPoly;
        d3 = this.delta;
        d11 = bl2 ? d5 * d8 : 0.0;
        l2 = Math.round(d6 + d3 * (d4 + d11));
        d6 = this.delta;
        d11 = d10;
        if (bl2) {
            d11 = d4 * d8;
        }
        path.add(new Point.LongPoint(l2, Math.round(d7 + d6 * (d5 - d11)), 0L));
    }

    /*
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void fixOrientations() {
        long l2 = this.lowest.getX();
        int n2 = 0;
        int n3 = 0;
        int n4 = n2;
        if (l2 >= 0L) {
            n4 = n2;
            if (!this.polyNodes.childs.get((int)this.lowest.getX()).getPolygon().orientation()) {
                n4 = n3;
                while (n4 < this.polyNodes.getChildCount()) {
                    PolyNode polyNode = this.polyNodes.childs.get(n4);
                    if (polyNode.getEndType() == Clipper.EndType.CLOSED_POLYGON || polyNode.getEndType() == Clipper.EndType.CLOSED_LINE && polyNode.getPolygon().orientation()) {
                        Collections.reverse(polyNode.getPolygon());
                    }
                    ++n4;
                }
                return;
            }
        }
        while (n4 < this.polyNodes.getChildCount()) {
            PolyNode polyNode = this.polyNodes.childs.get(n4);
            if (polyNode.getEndType() == Clipper.EndType.CLOSED_LINE && !polyNode.getPolygon().orientation()) {
                Collections.reverse(polyNode.getPolygon());
            }
            ++n4;
        }
    }

    private static boolean nearZero(double d2) {
        if (d2 > -1.0E-20 && d2 < 1.0E-20) {
            return true;
        }
        return false;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void offsetPoint(int var1_1, int[] var2_2, Clipper.JoinType var3_3) {
        block14 : {
            block15 : {
                block13 : {
                    var17_4 = var2_2[0];
                    var12_5 = this.normals.get(var17_4).getX();
                    var8_6 = this.normals.get(var17_4).getY();
                    var6_7 = this.normals.get(var1_1).getY();
                    var10_8 = this.normals.get(var1_1).getX();
                    var20_9 = ((Point.LongPoint)this.srcPoly.get(var1_1)).getX();
                    var18_10 = ((Point.LongPoint)this.srcPoly.get(var1_1)).getY();
                    this.inA = var12_5 * var6_7 - var10_8 * var8_6;
                    var14_11 = Math.abs(this.inA * this.delta);
                    var4_12 = 1.0;
                    if (var14_11 >= 1.0) break block13;
                    if (var12_5 * var10_8 + var6_7 * var8_6 > 0.0) {
                        this.destPoly.add(new Point.LongPoint(Math.round((double)var20_9 + var12_5 * this.delta), Math.round((double)var18_10 + var8_6 * this.delta), 0L));
                        return;
                    }
                    break block14;
                }
                if (this.inA > 1.0) break block15;
                var14_11 = this.inA;
                var4_12 = -1.0;
                if (var14_11 >= -1.0) break block14;
            }
            this.inA = var4_12;
        }
        if (this.inA * this.delta < 0.0) {
            var3_3 = this.destPoly;
            var4_12 = var20_9;
            var20_9 = Math.round(var12_5 * this.delta + var4_12);
            var12_5 = var18_10;
            var3_3.add(new Point.LongPoint(var20_9, Math.round(var8_6 * this.delta + var12_5)));
            this.destPoly.add(this.srcPoly.get(var1_1));
            this.destPoly.add(new Point.LongPoint(Math.round(var4_12 + var10_8 * this.delta), Math.round(var12_5 + var6_7 * this.delta)));
        } else {
            var16_13 = var1_1;
            switch (.$SwitchMap$com$itextpdf$text$pdf$parser$clipper$Clipper$JoinType[var3_3.ordinal()]) {
                default: {
                    ** break;
                }
                case 3: {
                    this.doRound(var16_13, var17_4);
                    ** break;
                }
                case 1: {
                    var4_12 = var10_8 * var12_5 + 1.0 + var6_7 * var8_6;
                    if (var4_12 >= this.miterLim) {
                        this.doMiter(var16_13, var17_4, var4_12);
                        ** break;
                    }
                }
                case 2: 
            }
            this.doSquare(var16_13, var17_4, false);
            ** break;
        }
lbl48: // 5 sources:
        var2_2[0] = var1_1;
    }

    /*
     * Enabled aggressive block sorting
     */
    public void addPath(Path object, Clipper.JoinType enum_, Clipper.EndType endType) {
        block20 : {
            block19 : {
                PolyNode polyNode;
                int n2;
                block18 : {
                    int n3;
                    int n4;
                    int n5;
                    block15 : {
                        block14 : {
                            n2 = object.size() - 1;
                            if (n2 < 0) {
                                return;
                            }
                            polyNode = new PolyNode();
                            polyNode.setJoinType((Clipper.JoinType)enum_);
                            polyNode.setEndType(endType);
                            enum_ = Clipper.EndType.CLOSED_LINE;
                            n3 = 0;
                            n4 = n2;
                            if (endType == enum_) break block14;
                            n5 = n2;
                            if (endType != Clipper.EndType.CLOSED_POLYGON) break block15;
                            n4 = n2;
                        }
                        do {
                            n5 = n4;
                            if (n4 <= 0) break;
                            n5 = n4;
                            if (object.get(0) != object.get(n4)) break;
                            --n4;
                        } while (true);
                    }
                    polyNode.getPolygon().add(object.get(0));
                    n2 = 0;
                    for (n4 = 1; n4 <= n5; ++n4) {
                        int n6;
                        int n7;
                        block16 : {
                            block17 : {
                                n7 = n3;
                                n6 = n2;
                                if (polyNode.getPolygon().get(n3) == object.get(n4)) break block16;
                                ++n3;
                                polyNode.getPolygon().add(object.get(n4));
                                if (((Point.LongPoint)object.get(n4)).getY() > ((Point.LongPoint)polyNode.getPolygon().get(n2)).getY()) break block17;
                                n7 = n3;
                                n6 = n2;
                                if (((Point.LongPoint)object.get(n4)).getY() != ((Point.LongPoint)polyNode.getPolygon().get(n2)).getY()) break block16;
                                n7 = n3;
                                n6 = n2;
                                if (((Point.LongPoint)object.get(n4)).getX() >= ((Point.LongPoint)polyNode.getPolygon().get(n2)).getX()) break block16;
                            }
                            n6 = n3;
                            n7 = n3;
                        }
                        n3 = n7;
                        n2 = n6;
                    }
                    if (endType == Clipper.EndType.CLOSED_POLYGON && n3 < 2) {
                        return;
                    }
                    this.polyNodes.addChild(polyNode);
                    if (endType != Clipper.EndType.CLOSED_POLYGON) {
                        return;
                    }
                    if (this.lowest.getX() >= 0L) break block18;
                    object = new Point.LongPoint(this.polyNodes.getChildCount() - 1, n2);
                    break block19;
                }
                object = (Point.LongPoint)this.polyNodes.getChilds().get((int)this.lowest.getX()).getPolygon().get((int)this.lowest.getY());
                if (((Point.LongPoint)polyNode.getPolygon().get(n2)).getY() <= object.getY() && (((Point.LongPoint)polyNode.getPolygon().get(n2)).getY() != object.getY() || ((Point.LongPoint)polyNode.getPolygon().get(n2)).getX() >= object.getX())) break block20;
                object = new Point.LongPoint(this.polyNodes.getChildCount() - 1, n2);
            }
            this.lowest = object;
            return;
        }
    }

    public void addPaths(Paths object, Clipper.JoinType joinType, Clipper.EndType endType) {
        object = object.iterator();
        while (object.hasNext()) {
            this.addPath((Path)object.next(), joinType, endType);
        }
    }

    public void clear() {
        this.polyNodes.getChilds().clear();
        this.lowest.setX(-1L);
    }

    public void execute(Paths paths, double d2) {
        paths.clear();
        this.fixOrientations();
        this.doOffset(d2);
        DefaultClipper defaultClipper = new DefaultClipper(1);
        defaultClipper.addPaths(this.destPolys, Clipper.PolyType.SUBJECT, true);
        if (d2 > 0.0) {
            defaultClipper.execute(Clipper.ClipType.UNION, paths, Clipper.PolyFillType.POSITIVE, Clipper.PolyFillType.POSITIVE);
            return;
        }
        LongRect longRect = this.destPolys.getBounds();
        Path path = new Path(4);
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.top - 10L, 0L));
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.top - 10L, 0L));
        defaultClipper.addPath(path, Clipper.PolyType.SUBJECT, true);
        defaultClipper.execute(Clipper.ClipType.UNION, paths, Clipper.PolyFillType.NEGATIVE, Clipper.PolyFillType.NEGATIVE);
        if (paths.size() > 0) {
            paths.remove(0);
        }
    }

    public void execute(PolyTree polyTree, double d2) {
        polyTree.Clear();
        this.fixOrientations();
        this.doOffset(d2);
        Object object = new DefaultClipper(1);
        object.addPaths(this.destPolys, Clipper.PolyType.SUBJECT, true);
        if (d2 > 0.0) {
            object.execute(Clipper.ClipType.UNION, polyTree, Clipper.PolyFillType.POSITIVE, Clipper.PolyFillType.POSITIVE);
            return;
        }
        LongRect longRect = this.destPolys.getBounds();
        Path path = new Path(4);
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.bottom + 10L, 0L));
        path.add(new Point.LongPoint(longRect.right + 10L, longRect.top - 10L, 0L));
        path.add(new Point.LongPoint(longRect.left - 10L, longRect.top - 10L, 0L));
        object.addPath(path, Clipper.PolyType.SUBJECT, true);
        object.execute(Clipper.ClipType.UNION, polyTree, Clipper.PolyFillType.NEGATIVE, Clipper.PolyFillType.NEGATIVE);
        if (polyTree.getChildCount() == 1 && polyTree.getChilds().get(0).getChildCount() > 0) {
            object = polyTree.getChilds().get(0);
            polyTree.getChilds().set(0, object.getChilds().get(0));
            polyTree.getChilds().get(0).setParent(polyTree);
            for (int i2 = 1; i2 < object.getChildCount(); ++i2) {
                polyTree.addChild(object.getChilds().get(i2));
            }
        } else {
            polyTree.Clear();
        }
    }

}

