/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Clipper;
import com.itextpdf.text.pdf.parser.clipper.Edge;
import com.itextpdf.text.pdf.parser.clipper.Path;
import com.itextpdf.text.pdf.parser.clipper.Paths;
import com.itextpdf.text.pdf.parser.clipper.Point;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;

public abstract class ClipperBase
implements Clipper {
    private static final long HI_RANGE = 0x3FFFFFFFFFFFFFFFL;
    private static final Logger LOGGER = Logger.getLogger(Clipper.class.getName());
    private static final long LOW_RANGE = 0x3FFFFFFFL;
    protected LocalMinima currentLM;
    private final List<List<Edge>> edges;
    protected boolean hasOpenPaths;
    protected LocalMinima minimaList;
    protected final boolean preserveCollinear;
    protected boolean useFullRange;

    protected ClipperBase(boolean bl2) {
        this.preserveCollinear = bl2;
        this.minimaList = null;
        this.currentLM = null;
        this.hasOpenPaths = false;
        this.edges = new ArrayList<List<Edge>>();
    }

    private void disposeLocalMinimaList() {
        while (this.minimaList != null) {
            LocalMinima localMinima = this.minimaList.next;
            this.minimaList = null;
            this.minimaList = localMinima;
        }
        this.currentLM = null;
    }

    private static void initEdge(Edge edge, Edge edge2, Edge edge3, Point.LongPoint longPoint) {
        edge.next = edge2;
        edge.prev = edge3;
        edge.setCurrent(new Point.LongPoint(longPoint));
        edge.outIdx = -1;
    }

    private static void initEdge2(Edge edge, Clipper.PolyType polyType) {
        if (edge.getCurrent().getY() >= edge.next.getCurrent().getY()) {
            edge.setBot(new Point.LongPoint(edge.getCurrent()));
            edge.setTop(new Point.LongPoint(edge.next.getCurrent()));
        } else {
            edge.setTop(new Point.LongPoint(edge.getCurrent()));
            edge.setBot(new Point.LongPoint(edge.next.getCurrent()));
        }
        edge.updateDeltaX();
        edge.polyTyp = polyType;
    }

    /*
     * Enabled aggressive block sorting
     */
    private void insertLocalMinima(LocalMinima localMinima) {
        block4 : {
            block3 : {
                if (this.minimaList == null) break block3;
                if (localMinima.y < this.minimaList.y) break block4;
                localMinima.next = this.minimaList;
            }
            this.minimaList = localMinima;
            return;
        }
        LocalMinima localMinima2 = this.minimaList;
        while (localMinima2.next != null && localMinima.y < localMinima2.next.y) {
            localMinima2 = localMinima2.next;
        }
        localMinima.next = localMinima2.next;
        localMinima2.next = localMinima;
    }

    protected static Path.OutRec parseFirstLeft(Path.OutRec outRec) {
        while (outRec != null && outRec.getPoints() == null) {
            outRec = outRec.firstLeft;
        }
        return outRec;
    }

    private Edge processBound(Edge edge, boolean bl2) {
        Edge edge2;
        Edge edge3;
        block31 : {
            block32 : {
                if (edge.outIdx == -2) {
                    Object object;
                    Edge edge4;
                    if (bl2) {
                        edge4 = edge;
                        do {
                            object = edge4;
                            if (edge4.getTop().getY() != edge4.next.getBot().getY()) break;
                            edge4 = edge4.next;
                        } while (true);
                        do {
                            edge4 = object;
                            if (object != edge) {
                                edge4 = object;
                                if (object.deltaX == -3.4E38) {
                                    object = object.prev;
                                    continue;
                                }
                            }
                            break;
                        } while (true);
                    } else {
                        edge4 = edge;
                        do {
                            object = edge4;
                            if (edge4.getTop().getY() != edge4.prev.getBot().getY()) break;
                            edge4 = edge4.prev;
                        } while (true);
                        do {
                            edge4 = object;
                            if (object == edge) break;
                            edge4 = object;
                            if (object.deltaX != -3.4E38) break;
                            object = object.next;
                        } while (true);
                    }
                    if (edge4 == edge) {
                        if (bl2) {
                            return edge4.next;
                        }
                        return edge4.prev;
                    }
                    edge = bl2 ? edge.next : edge.prev;
                    object = new LocalMinima();
                    object.next = null;
                    object.y = edge.getBot().getY();
                    object.leftBound = null;
                    object.rightBound = edge;
                    edge.windDelta = 0;
                    edge = this.processBound(edge, bl2);
                    this.insertLocalMinima((LocalMinima)object);
                    return edge;
                }
                if (edge.deltaX == -3.4E38) {
                    edge3 = bl2 ? edge.prev : edge.next;
                    if (edge3.deltaX == -3.4E38 ? edge3.getBot().getX() != edge.getBot().getX() && edge3.getTop().getX() != edge.getBot().getX() : edge3.getBot().getX() != edge.getBot().getX()) {
                        edge.reverseHorizontal();
                    }
                }
                if (bl2) {
                    edge3 = edge;
                    while (edge3.getTop().getY() == edge3.next.getBot().getY() && edge3.next.outIdx != -2) {
                        edge3 = edge3.next;
                    }
                    Edge edge5 = edge3;
                    if (edge3.deltaX == -3.4E38) {
                        edge5 = edge3;
                        if (edge3.next.outIdx != -2) {
                            Edge edge6 = edge3;
                            while (edge6.prev.deltaX == -3.4E38) {
                                edge6 = edge6.prev;
                            }
                            edge5 = edge3;
                            if (edge6.prev.getTop().getX() > edge3.next.getTop().getX()) {
                                edge5 = edge6.prev;
                            }
                        }
                    }
                    edge3 = edge;
                    while (edge3 != edge5) {
                        edge3.nextInLML = edge3.next;
                        if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.prev.getTop().getX()) {
                            edge3.reverseHorizontal();
                        }
                        edge3 = edge3.next;
                    }
                    if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.prev.getTop().getX()) {
                        edge3.reverseHorizontal();
                    }
                    return edge5.next;
                }
                edge3 = edge;
                while (edge3.getTop().getY() == edge3.prev.getBot().getY() && edge3.prev.outIdx != -2) {
                    edge3 = edge3.prev;
                }
                edge2 = edge3;
                if (edge3.deltaX != -3.4E38) break block31;
                edge2 = edge3;
                if (edge3.prev.outIdx == -2) break block31;
                Edge edge7 = edge3;
                while (edge7.next.deltaX == -3.4E38) {
                    edge7 = edge7.next;
                }
                if (edge7.next.getTop().getX() == edge3.prev.getTop().getX()) break block32;
                edge2 = edge3;
                if (edge7.next.getTop().getX() <= edge3.prev.getTop().getX()) break block31;
            }
            edge2 = edge7.next;
        }
        edge3 = edge;
        while (edge3 != edge2) {
            edge3.nextInLML = edge3.prev;
            if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.next.getTop().getX()) {
                edge3.reverseHorizontal();
            }
            edge3 = edge3.prev;
        }
        if (edge3.deltaX == -3.4E38 && edge3 != edge && edge3.getBot().getX() != edge3.next.getTop().getX()) {
            edge3.reverseHorizontal();
        }
        return edge2.prev;
    }

    private static boolean rangeTest(Point.LongPoint longPoint, boolean bl2) {
        if (bl2) {
            if (longPoint.getX() <= 0x3FFFFFFFFFFFFFFFL && longPoint.getY() <= 0x3FFFFFFFFFFFFFFFL && - longPoint.getX() <= 0x3FFFFFFFFFFFFFFFL && - longPoint.getY() <= 0x3FFFFFFFFFFFFFFFL) {
                return bl2;
            }
            throw new IllegalStateException("Coordinate outside allowed range");
        }
        if (longPoint.getX() <= 0x3FFFFFFFL && longPoint.getY() <= 0x3FFFFFFFL && - longPoint.getX() <= 0x3FFFFFFFL && - longPoint.getY() <= 0x3FFFFFFFL) {
            return bl2;
        }
        return ClipperBase.rangeTest(longPoint, true);
    }

    private static Edge removeEdge(Edge edge) {
        edge.prev.next = edge.next;
        edge.next.prev = edge.prev;
        Edge edge2 = edge.next;
        edge.prev = null;
        return edge2;
    }

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public boolean addPath(Path object, Clipper.PolyType object2, boolean bl2) {
        int n2;
        int n3;
        Edge edge;
        Object object3;
        void var1_3;
        ArrayList<Edge> arrayList;
        void var2_17;
        Edge edge2;
        void var3_23;
        block36 : {
            Edge edge3;
            if (var3_23 == false && var2_17 == Clipper.PolyType.CLIP) {
                throw new IllegalStateException("AddPath: Open paths must be subject.");
            }
            n3 = n2 = object.size() - 1;
            if (var3_23 != false) {
                do {
                    n3 = n2;
                    if (n2 <= 0) break;
                    n3 = n2;
                    if (!((Point.LongPoint)object.get(n2)).equals(object.get(0))) break;
                    --n2;
                } while (true);
            }
            while (n3 > 0 && ((Point.LongPoint)object.get(n3)).equals(object.get(n3 - 1))) {
                --n3;
            }
            if (var3_23 != false && n3 < 2 || var3_23 == false && n3 < 1) {
                return false;
            }
            arrayList = new ArrayList<Edge>(n3 + 1);
            for (n2 = 0; n2 <= n3; ++n2) {
                arrayList.add(new Edge());
            }
            ((Edge)arrayList.get(1)).setCurrent(new Point.LongPoint((Point.LongPoint)object.get(1)));
            this.useFullRange = ClipperBase.rangeTest((Point.LongPoint)object.get(0), this.useFullRange);
            this.useFullRange = ClipperBase.rangeTest((Point.LongPoint)object.get(n3), this.useFullRange);
            ClipperBase.initEdge((Edge)arrayList.get(0), (Edge)arrayList.get(1), (Edge)arrayList.get(n3), (Point.LongPoint)object.get(0));
            edge = (Edge)arrayList.get(n3);
            edge2 = (Edge)arrayList.get(0);
            n2 = n3 - 1;
            ClipperBase.initEdge(edge, edge2, (Edge)arrayList.get(n2), (Point.LongPoint)object.get(n3));
            for (n3 = n2; n3 >= 1; --n3) {
                this.useFullRange = ClipperBase.rangeTest((Point.LongPoint)object.get(n3), this.useFullRange);
                ClipperBase.initEdge((Edge)arrayList.get(n3), (Edge)arrayList.get(n3 + 1), (Edge)arrayList.get(n3 - 1), (Point.LongPoint)object.get(n3));
            }
            edge2 = edge3 = (edge = (Edge)arrayList.get(0));
            do {
                block39 : {
                    block38 : {
                        block37 : {
                            if (!edge.getCurrent().equals(edge.next.getCurrent()) || var3_23 == false && edge.next.equals(var1_3)) break block37;
                            if (edge == edge.next) break block36;
                            edge2 = var1_3;
                            if (edge == var1_3) {
                                edge2 = edge.next;
                            }
                            edge = ClipperBase.removeEdge(edge);
                            Edge edge4 = edge2;
                            break block38;
                        }
                        if (edge.prev == edge.next) break block36;
                        if (var3_23 == false || !Point.slopesEqual(edge.prev.getCurrent(), edge.getCurrent(), edge.next.getCurrent(), this.useFullRange) || this.isPreserveCollinear() && Point.isPt2BetweenPt1AndPt3(edge.prev.getCurrent(), edge.getCurrent(), edge.next.getCurrent())) break block39;
                        edge2 = var1_3;
                        if (edge == var1_3) {
                            edge2 = edge.next;
                        }
                        edge = ClipperBase.removeEdge((Edge)edge).prev;
                        Edge edge5 = edge2;
                    }
                    object3 = edge;
                    edge2 = edge;
                    edge = object3;
                    continue;
                }
                object3 = edge.next;
                edge = object3;
                if (object3 == edge2) break block36;
                edge = object3;
                if (var3_23 != false) continue;
                edge = object3;
                if (object3.next == var1_3) break;
            } while (true);
            edge = object3;
        }
        if (var3_23 == false && edge == edge.next || var3_23 != false && edge.prev == edge.next) {
            return false;
        }
        if (var3_23 == false) {
            this.hasOpenPaths = true;
            var1_3.prev.outIdx = -2;
        }
        edge2 = var1_3;
        n3 = 1;
        do {
            ClipperBase.initEdge2(edge2, (Clipper.PolyType)var2_17);
            edge = edge2.next;
            n2 = n3;
            if (n3 != 0) {
                n2 = n3;
                if (edge.getCurrent().getY() != var1_3.getCurrent().getY()) {
                    n2 = 0;
                }
            }
            edge2 = edge;
            n3 = n2;
        } while (edge != var1_3);
        if (n2 == 0) {
            this.edges.add(arrayList);
            Edge edge6 = edge;
            if (edge.prev.getBot().equals(edge.prev.getTop())) {
                Edge edge7 = edge.next;
            }
        } else {
            if (var3_23 != false) {
                return false;
            }
            edge.prev.outIdx = -2;
            LocalMinima localMinima = new LocalMinima();
            localMinima.next = null;
            localMinima.y = edge.getBot().getY();
            localMinima.leftBound = null;
            localMinima.rightBound = edge;
            localMinima.rightBound.side = Edge.Side.RIGHT;
            localMinima.rightBound.windDelta = 0;
            do {
                if (edge.getBot().getX() != edge.prev.getTop().getX()) {
                    edge.reverseHorizontal();
                }
                if (edge.next.outIdx == -2) {
                    this.insertLocalMinima(localMinima);
                    this.edges.add(arrayList);
                    return true;
                }
                edge.nextInLML = edge.next;
                edge = edge.next;
            } while (true);
        }
        edge2 = null;
        void var1_11;
        Edge edge8;
        while ((edge8 = var1_11.findNextLocMin()) != edge2) {
            Edge edge9;
            void var2_22;
            boolean bl3;
            edge = edge2;
            if (edge2 == null) {
                edge = edge8;
            }
            object3 = new LocalMinima();
            object3.next = null;
            object3.y = edge8.getBot().getY();
            if (edge8.deltaX < edge8.prev.deltaX) {
                object3.leftBound = edge8.prev;
                object3.rightBound = edge8;
                bl3 = false;
            } else {
                object3.leftBound = edge8;
                object3.rightBound = edge8.prev;
                bl3 = true;
            }
            object3.leftBound.side = Edge.Side.LEFT;
            object3.rightBound.side = Edge.Side.RIGHT;
            object3.leftBound.windDelta = var3_23 == false ? 0 : (object3.leftBound.next == object3.rightBound ? -1 : 1);
            object3.rightBound.windDelta = - object3.leftBound.windDelta;
            Edge edge10 = edge9 = this.processBound(object3.leftBound, bl3);
            if (edge9.outIdx == -2) {
                Edge edge11 = this.processBound(edge9, bl3);
            }
            Edge edge12 = edge2 = this.processBound(object3.rightBound, bl3 ^ true);
            if (edge2.outIdx == -2) {
                Edge edge13 = this.processBound(edge2, bl3 ^ true);
            }
            if (object3.leftBound.outIdx == -2) {
                object3.leftBound = null;
            } else if (object3.rightBound.outIdx == -2) {
                object3.rightBound = null;
            }
            this.insertLocalMinima((LocalMinima)object3);
            edge2 = edge;
            if (bl3) continue;
            void var1_16 = var2_22;
            edge2 = edge;
        }
        return true;
    }

    @Override
    public boolean addPaths(Paths paths, Clipper.PolyType polyType, boolean bl2) {
        boolean bl3 = false;
        for (int i2 = 0; i2 < paths.size(); ++i2) {
            if (!this.addPath((Path)paths.get(i2), polyType, bl2)) continue;
            bl3 = true;
        }
        return bl3;
    }

    @Override
    public void clear() {
        this.disposeLocalMinimaList();
        this.edges.clear();
        this.useFullRange = false;
        this.hasOpenPaths = false;
    }

    public boolean isPreserveCollinear() {
        return this.preserveCollinear;
    }

    protected void popLocalMinima() {
        LOGGER.entering(ClipperBase.class.getName(), "popLocalMinima");
        if (this.currentLM == null) {
            return;
        }
        this.currentLM = this.currentLM.next;
    }

    protected void reset() {
        this.currentLM = this.minimaList;
        if (this.currentLM == null) {
            return;
        }
        LocalMinima localMinima = this.minimaList;
        while (localMinima != null) {
            Edge edge = localMinima.leftBound;
            if (edge != null) {
                edge.setCurrent(new Point.LongPoint(edge.getBot()));
                edge.side = Edge.Side.LEFT;
                edge.outIdx = -1;
            }
            if ((edge = localMinima.rightBound) != null) {
                edge.setCurrent(new Point.LongPoint(edge.getBot()));
                edge.side = Edge.Side.RIGHT;
                edge.outIdx = -1;
            }
            localMinima = localMinima.next;
        }
    }

    protected class LocalMinima {
        Edge leftBound;
        LocalMinima next;
        Edge rightBound;
        long y;

        protected LocalMinima() {
        }
    }

    protected class Scanbeam {
        Scanbeam next;
        long y;

        protected Scanbeam() {
        }
    }

}

