/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import java.util.Arrays;
import java.util.Iterator;
import java.util.NoSuchElementException;

public class LongHashtable
implements Cloneable {
    private transient int count;
    private float loadFactor;
    private transient Entry[] table;
    private int threshold;

    public LongHashtable() {
        this(150, 0.75f);
    }

    public LongHashtable(int n2) {
        this(n2, 0.75f);
    }

    public LongHashtable(int n2, float f2) {
        if (n2 >= 0) {
            if (f2 > 0.0f) {
                int n3 = n2;
                if (n2 == 0) {
                    n3 = 1;
                }
                this.loadFactor = f2;
                this.table = new Entry[n3];
                this.threshold = (int)((float)n3 * f2);
                return;
            }
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("illegal.load.1", String.valueOf(f2)));
        }
        throw new IllegalArgumentException(MessageLocalization.getComposedMessage("illegal.capacity.1", n2));
    }

    public void clear() {
        Entry[] arrentry = this.table;
        int n2 = arrentry.length;
        while (--n2 >= 0) {
            arrentry[n2] = null;
        }
        this.count = 0;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public Object clone() {
        try {
            var4_1 = (LongHashtable)super.clone();
            var4_1.table = new Entry[this.table.length];
            var1_2 = this.table.length;
        }
        catch (CloneNotSupportedException var3_5) {
            throw new InternalError();
        }
        do lbl-1000: // 2 sources:
        {
            var2_3 = var1_2 - 1;
            if (var1_2 <= 0) return var4_1;
            var5_6 = var4_1.table;
            var3_4 = this.table[var2_3] != null ? (Entry)this.table[var2_3].clone() : null;
            break;
        } while (true);
        {
            var5_6[var2_3] = var3_4;
            var1_2 = var2_3;
            ** while (true)
        }
    }

    public boolean contains(long l2) {
        Entry[] arrentry = this.table;
        int n2 = arrentry.length;
        do {
            int n3 = n2 - 1;
            if (n2 <= 0) break;
            Entry entry = arrentry[n3];
            while (entry != null) {
                if (entry.value == l2) {
                    return true;
                }
                entry = entry.next;
            }
            n2 = n3;
        } while (true);
        return false;
    }

    public boolean containsKey(long l2) {
        Object object = this.table;
        int n2 = (int)(l2 >>> 32 ^ l2);
        object = object[(Integer.MAX_VALUE & n2) % ((Entry[])object).length];
        while (object != null) {
            if (object.hash == n2 && object.key == l2) {
                return true;
            }
            object = object.next;
        }
        return false;
    }

    public boolean containsValue(long l2) {
        return this.contains(l2);
    }

    public long get(long l2) {
        Object object = this.table;
        int n2 = (int)(l2 >>> 32 ^ l2);
        object = object[(Integer.MAX_VALUE & n2) % ((Entry[])object).length];
        while (object != null) {
            if (object.hash == n2 && object.key == l2) {
                return object.value;
            }
            object = object.next;
        }
        return 0L;
    }

    public Iterator<Entry> getEntryIterator() {
        return new LongHashtableIterator(this.table);
    }

    public long[] getKeys() {
        long[] arrl = new long[this.count];
        int n2 = this.table.length;
        int n3 = 0;
        Entry entry = null;
        do {
            int n4 = n2;
            Entry entry2 = entry;
            if (entry == null) {
                do {
                    n4 = n2 - 1;
                    if (n2 <= 0) break;
                    entry = entry2 = this.table[n4];
                    if (entry2 != null) break;
                    n2 = n4;
                    entry = entry2;
                } while (true);
                entry2 = entry;
            }
            if (entry2 == null) {
                return arrl;
            }
            entry = entry2.next;
            arrl[n3] = entry2.key;
            ++n3;
            n2 = n4;
        } while (true);
    }

    public long getOneKey() {
        Entry entry;
        if (this.count == 0) {
            return 0L;
        }
        int n2 = this.table.length;
        Entry entry2 = null;
        do {
            int n3 = n2 - 1;
            entry = entry2;
            if (n2 <= 0) break;
            entry = entry2 = this.table[n3];
            if (entry2 != null) break;
            n2 = n3;
        } while (true);
        if (entry == null) {
            return 0L;
        }
        return entry.key;
    }

    public boolean isEmpty() {
        if (this.count == 0) {
            return true;
        }
        return false;
    }

    public long put(long l2, long l3) {
        Entry[] arrentry = this.table;
        int n2 = (int)(l2 >>> 32 ^ l2);
        int n3 = Integer.MAX_VALUE & n2;
        int n4 = n3 % arrentry.length;
        Object object = arrentry[n4];
        while (object != null) {
            if (object.hash == n2 && object.key == l2) {
                l2 = object.value;
                object.value = l3;
                return l2;
            }
            object = object.next;
        }
        object = arrentry;
        if (this.count >= this.threshold) {
            this.rehash();
            object = this.table;
            n4 = n3 % ((Entry[])object).length;
        }
        object[n4] = new Entry(n2, l2, l3, object[n4]);
        ++this.count;
        return 0L;
    }

    protected void rehash() {
        int n2 = this.table.length;
        Entry[] arrentry = this.table;
        int n3 = n2 * 2 + 1;
        Entry[] arrentry2 = new Entry[n3];
        this.threshold = (int)((float)n3 * this.loadFactor);
        this.table = arrentry2;
        do {
            int n4 = n2 - 1;
            if (n2 <= 0) break;
            Entry entry = arrentry[n4];
            while (entry != null) {
                Entry entry2 = entry.next;
                n2 = (entry.hash & Integer.MAX_VALUE) % n3;
                entry.next = arrentry2[n2];
                arrentry2[n2] = entry;
                entry = entry2;
            }
            n2 = n4;
        } while (true);
    }

    public long remove(long l2) {
        Entry[] arrentry = this.table;
        int n2 = (int)(l2 >>> 32 ^ l2);
        int n3 = (Integer.MAX_VALUE & n2) % arrentry.length;
        Entry entry = arrentry[n3];
        Entry entry2 = null;
        do {
            Entry entry3 = entry2;
            entry2 = entry;
            if (entry2 == null) break;
            if (entry2.hash == n2 && entry2.key == l2) {
                if (entry3 != null) {
                    entry3.next = entry2.next;
                } else {
                    arrentry[n3] = entry2.next;
                }
                --this.count;
                l2 = entry2.value;
                entry2.value = 0L;
                return l2;
            }
            entry = entry2.next;
        } while (true);
        return 0L;
    }

    public int size() {
        return this.count;
    }

    public long[] toOrderedKeys() {
        long[] arrl = this.getKeys();
        Arrays.sort(arrl);
        return arrl;
    }

    static class Entry {
        int hash;
        long key;
        Entry next;
        long value;

        protected Entry(int n2, long l2, long l3, Entry entry) {
            this.hash = n2;
            this.key = l2;
            this.value = l3;
            this.next = entry;
        }

        protected Object clone() {
            long l2;
            int n2;
            Entry entry;
            long l3;
            n2 = this.hash;
            l2 = this.key;
            l3 = this.value;
            entry = this.next != null ? (Entry)this.next.clone() : null;
            return new Entry(n2, l2, l3, entry);
        }

        public long getKey() {
            return this.key;
        }

        public long getValue() {
            return this.value;
        }
    }

    static class LongHashtableIterator
    implements Iterator<Entry> {
        Entry entry;
        int index;
        Entry[] table;

        LongHashtableIterator(Entry[] arrentry) {
            this.table = arrentry;
            this.index = arrentry.length;
        }

        @Override
        public boolean hasNext() {
            block2 : {
                Entry entry;
                if (this.entry != null) {
                    return true;
                }
                do {
                    int n2 = this.index;
                    this.index = n2 - 1;
                    if (n2 <= 0) break block2;
                    this.entry = entry = this.table[this.index];
                } while (entry == null);
                return true;
            }
            return false;
        }

        @Override
        public Entry next() {
            Entry entry;
            if (this.entry == null) {
                do {
                    int n2 = this.index;
                    this.index = n2 - 1;
                    if (n2 <= 0) break;
                    this.entry = entry = this.table[this.index];
                } while (entry == null);
            }
            if (this.entry != null) {
                entry = this.entry;
                this.entry = entry.next;
                return entry;
            }
            throw new NoSuchElementException(MessageLocalization.getComposedMessage("inthashtableiterator", new Object[0]));
        }

        @Override
        public void remove() {
            throw new UnsupportedOperationException(MessageLocalization.getComposedMessage("remove.not.supported", new Object[0]));
        }
    }

}

