/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocWriter;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Image;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.FdfReader;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfAcroForm;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfDestination;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfFileSpecification;
import com.itextpdf.text.pdf.PdfFormField;
import com.itextpdf.text.pdf.PdfImportedPage;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLayer;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfSignatureAppearance;
import com.itextpdf.text.pdf.PdfStamperImp;
import com.itextpdf.text.pdf.PdfTransition;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.XmlSignatureAppearance;
import com.itextpdf.text.pdf.collection.PdfCollection;
import com.itextpdf.text.pdf.interfaces.PdfEncryptionSettings;
import com.itextpdf.text.pdf.interfaces.PdfViewerPreferences;
import com.itextpdf.text.pdf.security.LtvVerification;
import com.itextpdf.text.xml.xmp.XmpWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.cert.Certificate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class PdfStamper
implements PdfEncryptionSettings,
PdfViewerPreferences {
    protected boolean hasSignature;
    private Map<String, String> moreInfo;
    protected PdfSignatureAppearance sigApp;
    protected XmlSignatureAppearance sigXmlApp;
    protected PdfStamperImp stamper;
    private LtvVerification verification;

    protected PdfStamper() {
    }

    public PdfStamper(PdfReader pdfReader, OutputStream outputStream) {
        this.stamper = new PdfStamperImp(pdfReader, outputStream, '\u0000', false);
    }

    public PdfStamper(PdfReader pdfReader, OutputStream outputStream, char c2) {
        this.stamper = new PdfStamperImp(pdfReader, outputStream, c2, false);
    }

    public PdfStamper(PdfReader pdfReader, OutputStream outputStream, char c2, boolean bl2) {
        this.stamper = new PdfStamperImp(pdfReader, outputStream, c2, bl2);
    }

    public static PdfStamper createSignature(PdfReader pdfReader, OutputStream outputStream, char c2) {
        return PdfStamper.createSignature(pdfReader, outputStream, c2, null, false);
    }

    public static PdfStamper createSignature(PdfReader pdfReader, OutputStream outputStream, char c2, File file) {
        return PdfStamper.createSignature(pdfReader, outputStream, c2, file, false);
    }

    public static PdfStamper createSignature(PdfReader object, OutputStream outputStream, char c2, File object2, boolean bl2) {
        if (object2 == null) {
            ByteBuffer byteBuffer = new ByteBuffer();
            object2 = new PdfStamper((PdfReader)object, byteBuffer, c2, bl2);
            object2.sigApp = new PdfSignatureAppearance(object2.stamper);
            object2.sigApp.setSigout(byteBuffer);
        } else {
            File file = object2;
            if (object2.isDirectory()) {
                file = File.createTempFile("pdf", ".pdf", (File)object2);
            }
            object2 = new PdfStamper((PdfReader)object, new FileOutputStream(file), c2, bl2);
            object2.sigApp = new PdfSignatureAppearance(object2.stamper);
            object2.sigApp.setTempFile(file);
        }
        object2.sigApp.setOriginalout(outputStream);
        object2.sigApp.setStamper((PdfStamper)object2);
        object2.hasSignature = true;
        object = object.getCatalog();
        object = (PdfDictionary)PdfReader.getPdfObject(object.get(PdfName.ACROFORM), (PdfObject)object);
        if (object != null) {
            object.remove(PdfName.NEEDAPPEARANCES);
            object2.stamper.markUsed((PdfObject)object);
        }
        return object2;
    }

    public static PdfStamper createXmlSignature(PdfReader pdfViewerPreferences, OutputStream outputStream) {
        pdfViewerPreferences = new PdfStamper((PdfReader)pdfViewerPreferences, outputStream);
        pdfViewerPreferences.sigXmlApp = new XmlSignatureAppearance(pdfViewerPreferences.stamper);
        pdfViewerPreferences.sigXmlApp.setStamper((PdfStamper)pdfViewerPreferences);
        return pdfViewerPreferences;
    }

    public void addAnnotation(PdfAnnotation pdfAnnotation, int n2) {
        this.stamper.addAnnotation(pdfAnnotation, n2);
    }

    public void addComments(FdfReader fdfReader) {
        this.stamper.addComments(fdfReader);
    }

    public void addFileAttachment(String string2, PdfFileSpecification pdfFileSpecification) {
        this.stamper.addFileAttachment(string2, pdfFileSpecification);
    }

    public void addFileAttachment(String string2, byte[] arrby, String string3, String string4) {
        this.addFileAttachment(string2, PdfFileSpecification.fileEmbedded(this.stamper, string3, string4, arrby));
    }

    public void addJavaScript(String string2) {
        this.stamper.addJavaScript(string2, PdfEncodings.isPdfDocEncoding(string2) ^ true);
    }

    public void addJavaScript(String string2, String string3) {
        this.stamper.addJavaScript(string2, PdfAction.javaScript(string3, this.stamper, PdfEncodings.isPdfDocEncoding(string3) ^ true));
    }

    public boolean addNamedDestination(String string2, int n2, PdfDestination pdfDestination) {
        HashMap<Object, PdfObject> hashMap = this.stamper.getNamedDestinations();
        if (this.getReader().getNamedDestination().containsKey(string2)) {
            return false;
        }
        pdfDestination = new PdfDestination(pdfDestination);
        pdfDestination.addPage(this.getReader().getPageOrigRef(n2));
        hashMap.put(string2, new PdfArray(pdfDestination));
        return true;
    }

    public PdfFormField addSignature(String string2, int n2, float f2, float f3, float f4, float f5) {
        PdfAcroForm pdfAcroForm = this.stamper.getAcroForm();
        PdfFormField pdfFormField = PdfFormField.createSignature(this.stamper);
        pdfAcroForm.setSignatureParams(pdfFormField, string2, f2, f3, f4, f5);
        pdfAcroForm.drawSignatureAppearences(pdfFormField, f2, f3, f4, f5);
        this.addAnnotation(pdfFormField, n2);
        return pdfFormField;
    }

    @Override
    public void addViewerPreference(PdfName pdfName, PdfObject pdfObject) {
        this.stamper.addViewerPreference(pdfName, pdfObject);
    }

    public void close() {
        if (this.stamper.closed) {
            return;
        }
        if (!this.hasSignature) {
            this.mergeVerification();
            this.stamper.close(this.moreInfo);
            return;
        }
        throw new DocumentException("Signature defined. Must be closed in PdfSignatureAppearance.");
    }

    public void createXmpMetadata() {
        this.stamper.createXmpMetadata();
    }

    public void flush() {
        try {
            this.stamper.alterContents();
            this.stamper.pagesToContent.clear();
            return;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public AcroFields getAcroFields() {
        return this.stamper.getAcroFields();
    }

    public PdfImportedPage getImportedPage(PdfReader pdfReader, int n2) {
        return this.stamper.getImportedPage(pdfReader, n2);
    }

    public LtvVerification getLtvVerification() {
        if (this.verification == null) {
            this.verification = new LtvVerification(this);
        }
        return this.verification;
    }

    public Map<String, String> getMoreInfo() {
        return this.moreInfo;
    }

    public PdfContentByte getOverContent(int n2) {
        return this.stamper.getOverContent(n2);
    }

    public Map<String, PdfLayer> getPdfLayers() {
        return this.stamper.getPdfLayers();
    }

    public PdfReader getReader() {
        return this.stamper.reader;
    }

    public PdfSignatureAppearance getSignatureAppearance() {
        return this.sigApp;
    }

    public PdfContentByte getUnderContent(int n2) {
        return this.stamper.getUnderContent(n2);
    }

    public PdfWriter getWriter() {
        return this.stamper;
    }

    public XmlSignatureAppearance getXmlSignatureAppearance() {
        return this.sigXmlApp;
    }

    public XmpWriter getXmpWriter() {
        return this.stamper.getXmpWriter();
    }

    public void insertPage(int n2, Rectangle rectangle) {
        this.stamper.insertPage(n2, rectangle);
    }

    public boolean isFullCompression() {
        return this.stamper.isFullCompression();
    }

    public boolean isRotateContents() {
        return this.stamper.isRotateContents();
    }

    public void makePackage(PdfName pdfName) {
        PdfCollection pdfCollection = new PdfCollection(0);
        pdfCollection.put(PdfName.VIEW, pdfName);
        this.stamper.makePackage(pdfCollection);
    }

    public void makePackage(PdfCollection pdfCollection) {
        this.stamper.makePackage(pdfCollection);
    }

    public void markUsed(PdfObject pdfObject) {
        this.stamper.markUsed(pdfObject);
    }

    void mergeVerification() {
        if (this.verification == null) {
            return;
        }
        this.verification.merge();
    }

    public boolean partialFormFlattening(String string2) {
        return this.stamper.partialFormFlattening(string2);
    }

    public void replacePage(PdfReader pdfReader, int n2, int n3) {
        this.stamper.replacePage(pdfReader, n2, n3);
    }

    public void setAnnotationFlattening(boolean bl2) {
        this.stamper.setFlatAnnotations(bl2);
    }

    public void setDuration(int n2, int n3) {
        this.stamper.setDuration(n2, n3);
    }

    public void setEncryption(int n2, String string2, String string3, int n3) {
        this.setEncryption(DocWriter.getISOBytes(string2), DocWriter.getISOBytes(string3), n3, n2);
    }

    public void setEncryption(boolean bl2, String string2, String string3, int n2) {
        this.setEncryption(DocWriter.getISOBytes(string2), DocWriter.getISOBytes(string3), n2, bl2);
    }

    @Override
    public void setEncryption(byte[] arrby, byte[] arrby2, int n2, int n3) {
        if (!this.stamper.isAppend()) {
            if (!this.stamper.isContentWritten()) {
                this.stamper.setEncryption(arrby, arrby2, n2, n3);
                return;
            }
            throw new DocumentException(MessageLocalization.getComposedMessage("content.was.already.written.to.the.output", new Object[0]));
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("append.mode.does.not.support.changing.the.encryption.status", new Object[0]));
    }

    public void setEncryption(byte[] arrby, byte[] arrby2, int n2, boolean bl2) {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    @Override
    public void setEncryption(Certificate[] arrcertificate, int[] arrn, int n2) {
        if (!this.stamper.isAppend()) {
            if (!this.stamper.isContentWritten()) {
                this.stamper.setEncryption(arrcertificate, arrn, n2);
                return;
            }
            throw new DocumentException(MessageLocalization.getComposedMessage("content.was.already.written.to.the.output", new Object[0]));
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("append.mode.does.not.support.changing.the.encryption.status", new Object[0]));
    }

    public void setFormFlattening(boolean bl2) {
        this.stamper.setFormFlattening(bl2);
    }

    public void setFreeTextFlattening(boolean bl2) {
        this.stamper.setFreeTextFlattening(bl2);
    }

    public void setFullCompression() {
        if (this.stamper.isAppend()) {
            return;
        }
        this.stamper.fullCompression = true;
        this.stamper.setAtLeastPdfVersion('5');
    }

    public void setMoreInfo(Map<String, String> map) {
        this.moreInfo = map;
    }

    public void setOutlines(List<HashMap<String, Object>> list) {
        this.stamper.setOutlines(list);
    }

    public void setPageAction(PdfName pdfName, PdfAction pdfAction, int n2) {
        this.stamper.setPageAction(pdfName, pdfAction, n2);
    }

    public void setRotateContents(boolean bl2) {
        this.stamper.setRotateContents(bl2);
    }

    public void setThumbnail(Image image, int n2) {
        this.stamper.setThumbnail(image, n2);
    }

    public void setTransition(PdfTransition pdfTransition, int n2) {
        this.stamper.setTransition(pdfTransition, n2);
    }

    @Override
    public void setViewerPreferences(int n2) {
        this.stamper.setViewerPreferences(n2);
    }

    public void setXmpMetadata(byte[] arrby) {
        this.stamper.setXmpMetadata(arrby);
    }
}

