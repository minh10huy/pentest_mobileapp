/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.spongycastle.cert.ocsp.BasicOCSPResp
 *  org.spongycastle.cms.SignerInformationVerifier
 *  org.spongycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder
 *  org.spongycastle.operator.ContentVerifierProvider
 *  org.spongycastle.operator.jcajce.JcaContentVerifierProviderBuilder
 *  org.spongycastle.tsp.TimeStampToken
 */
package com.itextpdf.text.pdf.security;

import com.itextpdf.text.pdf.security.VerificationException;
import java.io.Serializable;
import java.security.KeyStore;
import java.security.PublicKey;
import java.security.cert.CRL;
import java.security.cert.Certificate;
import java.security.cert.CertificateParsingException;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import org.spongycastle.cert.ocsp.BasicOCSPResp;
import org.spongycastle.cms.SignerInformationVerifier;
import org.spongycastle.cms.jcajce.JcaSimpleSignerInfoVerifierBuilder;
import org.spongycastle.operator.ContentVerifierProvider;
import org.spongycastle.operator.jcajce.JcaContentVerifierProviderBuilder;
import org.spongycastle.tsp.TimeStampToken;

public class CertificateVerification {
    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public static String verifyCertificate(X509Certificate x509Certificate, Collection<CRL> iterator, Calendar iterator2) {
        Object object = iterator2;
        if (iterator2 == null) {
            object = new GregorianCalendar();
        }
        if (x509Certificate.hasUnsupportedCriticalExtension()) {
            for (String string2 : x509Certificate.getCriticalExtensionOIDs()) {
                if ("2.5.29.15".equals(string2) && x509Certificate.getKeyUsage()[0]) continue;
                if (!"2.5.29.37".equals(string2)) return "Has unsupported critical extension";
                boolean bl2 = x509Certificate.getExtendedKeyUsage().contains("1.3.6.1.5.5.7.3.8");
                if (!bl2) return "Has unsupported critical extension";
            }
        }
        try {
            x509Certificate.checkValidity(object.getTime());
            if (iterator == null) return null;
            iterator = iterator.iterator();
        }
        catch (Exception exception) {
            return exception.getMessage();
        }
        do {
            if (!iterator.hasNext()) return null;
        } while (!((CRL)iterator.next()).isRevoked(x509Certificate));
        return "Certificate revoked";
        catch (CertificateParsingException certificateParsingException) {
            return "Has unsupported critical extension";
        }
    }

    public static List<VerificationException> verifyCertificates(Certificate[] arrcertificate, KeyStore keyStore, Calendar calendar) {
        return CertificateVerification.verifyCertificates(arrcertificate, keyStore, null, calendar);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static List<VerificationException> verifyCertificates(Certificate[] arrcertificate, KeyStore keyStore, Collection<CRL> collection, Calendar serializable) {
        ArrayList<VerificationException> arrayList = new ArrayList<VerificationException>();
        Serializable serializable2 = serializable;
        if (serializable == null) {
            serializable2 = new GregorianCalendar();
        }
        block6 : for (int n2 = 0; n2 < arrcertificate.length; ++n2) {
            Object object;
            block15 : {
                serializable = (X509Certificate)arrcertificate[n2];
                object = CertificateVerification.verifyCertificate((X509Certificate)serializable, collection, (Calendar)serializable2);
                if (object != null) {
                    arrayList.add(new VerificationException((Certificate)serializable, (String)object));
                }
                try {
                    object = keyStore.aliases();
                }
                catch (Exception exception) {
                    break block15;
                }
                do {
                    boolean bl2;
                    if (!(bl2 = object.hasMoreElements())) break;
                    try {
                        Object object2 = (String)object.nextElement();
                        if (!keyStore.isCertificateEntry((String)object2) || CertificateVerification.verifyCertificate((X509Certificate)(object2 = (X509Certificate)keyStore.getCertificate((String)object2)), collection, (Calendar)serializable2) != null) continue;
                        serializable.verify(object2.getPublicKey());
                        return arrayList;
                    }
                    catch (Exception exception) {
                        continue;
                    }
                    break;
                } while (true);
            }
            int n3 = 0;
            do {
                block17 : {
                    block16 : {
                        if (n3 >= arrcertificate.length) break block16;
                        if (n3 == n2) break block17;
                        object = (X509Certificate)arrcertificate[n3];
                        try {
                            serializable.verify(object.getPublicKey());
                        }
                        catch (Exception exception) {}
                    }
                    if (n3 != arrcertificate.length) continue block6;
                    arrayList.add(new VerificationException((Certificate)serializable, "Cannot be verified against the KeyStore or the certificate chain"));
                    continue block6;
                }
                ++n3;
            } while (true);
        }
        if (arrayList.size() == 0) {
            arrayList.add(new VerificationException(null, "Invalid state. Possible circular certificate chain"));
        }
        return arrayList;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static boolean verifyOcspCertificates(BasicOCSPResp basicOCSPResp, KeyStore keyStore, String enumeration) {
        boolean bl2;
        Object object = enumeration;
        if (enumeration == null) {
            object = "BC";
        }
        try {
            enumeration = keyStore.aliases();
        }
        catch (Exception exception) {
            return false;
        }
        while (bl2 = enumeration.hasMoreElements()) {
            try {
                Object object2 = enumeration.nextElement();
                if (!keyStore.isCertificateEntry((String)object2)) continue;
                object2 = (X509Certificate)keyStore.getCertificate((String)object2);
                bl2 = basicOCSPResp.isSignatureValid(new JcaContentVerifierProviderBuilder().setProvider((String)object).build(object2.getPublicKey()));
                if (!bl2) continue;
                return true;
            }
            catch (Exception exception) {
            }
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static boolean verifyTimestampCertificates(TimeStampToken timeStampToken, KeyStore keyStore, String enumeration) {
        boolean bl2;
        Object object = enumeration;
        if (enumeration == null) {
            object = "BC";
        }
        try {
            enumeration = keyStore.aliases();
        }
        catch (Exception exception) {
            return false;
        }
        while (bl2 = enumeration.hasMoreElements()) {
            try {
                Object object2 = enumeration.nextElement();
                if (!keyStore.isCertificateEntry((String)object2)) continue;
                object2 = (X509Certificate)keyStore.getCertificate((String)object2);
                timeStampToken.isSignatureValid(new JcaSimpleSignerInfoVerifierBuilder().setProvider((String)object).build((X509Certificate)object2));
                return true;
            }
            catch (Exception exception) {
            }
        }
        return false;
    }
}

