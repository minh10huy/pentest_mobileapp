/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.fonts.otf;

import com.itextpdf.text.log.Logger;
import com.itextpdf.text.pdf.Glyph;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.fonts.otf.FontReadingException;
import com.itextpdf.text.pdf.fonts.otf.OpenTypeFontTableReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class GlyphSubstitutionTableReader
extends OpenTypeFontTableReader {
    private final Map<Integer, Character> glyphToCharacterMap;
    private final int[] glyphWidthsByIndex;
    private Map<Integer, List<Integer>> rawLigatureSubstitutionMap;

    public GlyphSubstitutionTableReader(RandomAccessFileOrArray randomAccessFileOrArray, int n2, Map<Integer, Character> map, int[] arrn) {
        super(randomAccessFileOrArray, n2);
        this.glyphWidthsByIndex = arrn;
        this.glyphToCharacterMap = map;
    }

    /*
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private String getTextFromGlyph(int n2, Map<Integer, Character> object) {
        StringBuilder stringBuilder = new StringBuilder(1);
        List<Integer> list = (Character)object.get(n2);
        if (list != null) {
            stringBuilder.append(list.charValue());
            return stringBuilder.toString();
        }
        list = this.rawLigatureSubstitutionMap.get(n2);
        if (list != null && !list.isEmpty()) {
            list = list.iterator();
            while (list.hasNext()) {
                stringBuilder.append(this.getTextFromGlyph((Integer)list.next(), (Map<Integer, Character>)object));
            }
            return stringBuilder.toString();
        }
        object = new StringBuilder();
        object.append("No corresponding character or simple glyphs found for GlyphID=");
        object.append(n2);
        throw new FontReadingException(object.toString());
    }

    private void readLigatureSetTable(int n2, int n3) {
        this.rf.seek(n2);
        int n4 = this.rf.readShort();
        Iterator<Integer> iterator = LOG;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("ligatureCount=");
        stringBuilder.append(n4);
        iterator.debug(stringBuilder.toString());
        iterator = new ArrayList(n4);
        for (int i2 = 0; i2 < n4; ++i2) {
            iterator.add(Integer.valueOf(this.rf.readShort()));
        }
        iterator = iterator.iterator();
        while (iterator.hasNext()) {
            this.readLigatureTable((Integer)iterator.next() + n2, n3);
        }
    }

    private void readLigatureSubstitutionSubtable(int n2) {
        this.rf.seek(n2);
        int n3 = this.rf.readShort();
        Object object = LOG;
        List<Integer> list = new StringBuilder();
        list.append("substFormat=");
        list.append(n3);
        object.debug(list.toString());
        if (n3 == 1) {
            int n4 = this.rf.readShort();
            object = LOG;
            list = new StringBuilder();
            list.append("coverage=");
            list.append(n4);
            object.debug(list.toString());
            int n5 = this.rf.readShort();
            object = new ArrayList(n5);
            int n6 = 0;
            for (n3 = 0; n3 < n5; ++n3) {
                object.add(Integer.valueOf(this.rf.readShort()));
            }
            list = this.readCoverageFormat(n4 + n2);
            if (n5 == list.size()) {
                for (n3 = n6; n3 < n5; ++n3) {
                    n6 = (Integer)list.get(n3);
                    n4 = (Integer)object.get(n3);
                    Logger logger = LOG;
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("ligatureOffset=");
                    stringBuilder.append(n4);
                    logger.debug(stringBuilder.toString());
                    this.readLigatureSetTable(n4 + n2, n6);
                }
                return;
            }
            throw new IllegalArgumentException("According to the OpenTypeFont specifications, the coverage count should be equal to the no. of LigatureSetTables");
        }
        throw new IllegalArgumentException("The expected SubstFormat is 1");
    }

    private void readLigatureTable(int n2, int n3) {
        this.rf.seek(n2);
        short s2 = this.rf.readShort();
        Object object = LOG;
        List<Integer> list = new StringBuilder();
        list.append("ligGlyph=");
        list.append((int)s2);
        object.debug(list.toString());
        short s3 = this.rf.readShort();
        object = new ArrayList();
        object.add(n3);
        for (n2 = 0; n2 < s3 - 1; ++n2) {
            object.add(Integer.valueOf(this.rf.readShort()));
        }
        list = LOG;
        Object object2 = new StringBuilder();
        object2.append("glyphIdList=");
        object2.append(object);
        list.debug(object2.toString());
        list = this.rawLigatureSubstitutionMap.put(Integer.valueOf(s2), (List<Integer>)object);
        if (list != null) {
            object2 = LOG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("!!!!!!!!!!glyphId=");
            stringBuilder.append(s2);
            stringBuilder.append(",\npreviousValue=");
            stringBuilder.append(list);
            stringBuilder.append(",\ncurrentVal=");
            stringBuilder.append(object);
            object2.warn(stringBuilder.toString());
        }
    }

    private void readSingleSubstitutionSubtable(int n2) {
        Object object;
        int n3;
        block6 : {
            block5 : {
                Object object2;
                block4 : {
                    this.rf.seek(n2);
                    n3 = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("substFormat=");
                    object2.append(n3);
                    object.debug(object2.toString());
                    if (n3 != 1) break block4;
                    short s2 = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("coverage=");
                    object2.append(s2);
                    object.debug(object2.toString());
                    n3 = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("deltaGlyphID=");
                    object2.append(n3);
                    object.debug(object2.toString());
                    object = this.readCoverageFormat(n2 + s2).iterator();
                    while (object.hasNext()) {
                        n2 = (Integer)object.next();
                        this.rawLigatureSubstitutionMap.put(n2 + n3, Arrays.asList(n2));
                    }
                    break block5;
                }
                if (n3 == 2) {
                    short s3 = this.rf.readShort();
                    object = LOG;
                    object2 = new StringBuilder();
                    object2.append("coverage=");
                    object2.append(s3);
                    object.debug(object2.toString());
                    int n4 = this.rf.readUnsignedShort();
                    object = new int[n4];
                    for (n3 = 0; n3 < n4; ++n3) {
                        object[n3] = this.rf.readUnsignedShort();
                    }
                    object2 = this.readCoverageFormat(n2 + s3);
                    for (n2 = 0; n2 < n4; ++n2) {
                        this.rawLigatureSubstitutionMap.put((int)object[n2], Arrays.asList((Integer)object2.get(n2)));
                    }
                }
                break block6;
            }
            return;
        }
        object = new StringBuilder();
        object.append("Bad substFormat: ");
        object.append(n3);
        throw new IllegalArgumentException(object.toString());
    }

    public Map<String, Glyph> getGlyphSubstitutionMap() {
        LinkedHashMap<String, Glyph> linkedHashMap = new LinkedHashMap<String, Glyph>();
        for (Integer n2 : this.rawLigatureSubstitutionMap.keySet()) {
            Object object = this.rawLigatureSubstitutionMap.get(n2);
            StringBuilder stringBuilder = new StringBuilder(object.size());
            object = object.iterator();
            while (object.hasNext()) {
                stringBuilder.append(this.getTextFromGlyph((Integer)object.next(), this.glyphToCharacterMap));
            }
            Glyph object2 = new Glyph(n2, this.glyphWidthsByIndex[n2], stringBuilder.toString());
            linkedHashMap.put(object2.chars, object2);
        }
        return Collections.unmodifiableMap(linkedHashMap);
    }

    public void read() {
        this.rawLigatureSubstitutionMap = new LinkedHashMap<Integer, List<Integer>>();
        this.startReadingTable();
    }

    @Override
    protected void readSubTable(int n2, int n3) {
        if (n2 == 1) {
            this.readSingleSubstitutionSubtable(n3);
            return;
        }
        if (n2 == 4) {
            this.readLigatureSubstitutionSubtable(n3);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("LookupType ");
        stringBuilder.append(n2);
        stringBuilder.append(" is not yet handled for ");
        stringBuilder.append(GlyphSubstitutionTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }
}

