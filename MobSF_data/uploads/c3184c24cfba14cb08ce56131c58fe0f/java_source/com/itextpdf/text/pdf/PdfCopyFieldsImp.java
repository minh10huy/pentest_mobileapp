/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocListener;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.BadPasswordException;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfCopy;
import com.itextpdf.text.pdf.PdfCopyFields;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfDocument;
import com.itextpdf.text.pdf.PdfFormField;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfPages;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

@Deprecated
class PdfCopyFieldsImp
extends PdfWriter {
    protected static final HashMap<PdfName, Integer> fieldKeys;
    private static final PdfName iTextTag;
    protected static final HashMap<PdfName, Integer> widgetKeys;
    private static final Integer zero;
    protected Counter COUNTER = CounterFactory.getCounter(PdfCopyFields.class);
    private ArrayList<String> calculationOrder = new ArrayList();
    private ArrayList<Object> calculationOrderRefs;
    boolean closing = false;
    HashMap<String, Object> fieldTree = new HashMap();
    ArrayList<AcroFields> fields = new ArrayList();
    RandomAccessFileOrArray file;
    PdfDictionary form;
    private boolean hasSignature;
    private HashSet<Object> mergedRadioButtons = new HashSet();
    Document nd;
    private boolean needAppearances = false;
    ArrayList<PdfDictionary> pageDics = new ArrayList();
    ArrayList<PdfIndirectReference> pageRefs = new ArrayList();
    HashMap<PdfReader, IntHashtable> pages2intrefs = new HashMap();
    ArrayList<PdfReader> readers = new ArrayList();
    HashMap<PdfReader, IntHashtable> readers2intrefs = new HashMap();
    PdfDictionary resources = new PdfDictionary();
    private HashMap<PdfArray, ArrayList<Integer>> tabOrder;
    HashMap<PdfReader, IntHashtable> visited = new HashMap();

    static {
        iTextTag = new PdfName("_iTextTag_");
        zero = 0;
        widgetKeys = new HashMap();
        fieldKeys = new HashMap();
        Integer n2 = 1;
        widgetKeys.put(PdfName.SUBTYPE, n2);
        widgetKeys.put(PdfName.CONTENTS, n2);
        widgetKeys.put(PdfName.RECT, n2);
        widgetKeys.put(PdfName.NM, n2);
        widgetKeys.put(PdfName.M, n2);
        widgetKeys.put(PdfName.F, n2);
        widgetKeys.put(PdfName.BS, n2);
        widgetKeys.put(PdfName.BORDER, n2);
        widgetKeys.put(PdfName.AP, n2);
        widgetKeys.put(PdfName.AS, n2);
        widgetKeys.put(PdfName.C, n2);
        widgetKeys.put(PdfName.A, n2);
        widgetKeys.put(PdfName.STRUCTPARENT, n2);
        widgetKeys.put(PdfName.OC, n2);
        widgetKeys.put(PdfName.H, n2);
        widgetKeys.put(PdfName.MK, n2);
        widgetKeys.put(PdfName.DA, n2);
        widgetKeys.put(PdfName.Q, n2);
        widgetKeys.put(PdfName.P, n2);
        fieldKeys.put(PdfName.AA, n2);
        fieldKeys.put(PdfName.FT, n2);
        fieldKeys.put(PdfName.TU, n2);
        fieldKeys.put(PdfName.TM, n2);
        fieldKeys.put(PdfName.FF, n2);
        fieldKeys.put(PdfName.V, n2);
        fieldKeys.put(PdfName.DV, n2);
        fieldKeys.put(PdfName.DS, n2);
        fieldKeys.put(PdfName.RV, n2);
        fieldKeys.put(PdfName.OPT, n2);
        fieldKeys.put(PdfName.MAXLEN, n2);
        fieldKeys.put(PdfName.TI, n2);
        fieldKeys.put(PdfName.I, n2);
        fieldKeys.put(PdfName.LOCK, n2);
        fieldKeys.put(PdfName.SV, n2);
    }

    PdfCopyFieldsImp(OutputStream outputStream) {
        this(outputStream, '\u0000');
    }

    PdfCopyFieldsImp(OutputStream outputStream, char c2) {
        super(new PdfDocument(), outputStream);
        this.pdf.addWriter(this);
        if (c2 != '\u0000') {
            super.setPdfVersion(c2);
        }
        this.nd = new Document();
        this.nd.addDocListener(this.pdf);
    }

    private void adjustTabOrder(PdfArray pdfArray, PdfIndirectReference pdfIndirectReference, PdfNumber serializable) {
        int n2;
        int n3;
        int n4 = serializable.intValue();
        serializable = this.tabOrder.get(pdfArray);
        if (serializable == null) {
            serializable = new ArrayList();
            int n5 = pdfArray.size();
            for (n2 = 0; n2 < n5 - 1; ++n2) {
                serializable.add(zero);
            }
            serializable.add(n4);
            this.tabOrder.put(pdfArray, (ArrayList<Integer>)serializable);
            pdfArray.add(pdfIndirectReference);
            return;
        }
        int n6 = n2 = serializable.size() - 1;
        do {
            n3 = n2;
            if (n6 < 0) break;
            if ((Integer)serializable.get(n6) <= n4) {
                n2 = n6 + 1;
                serializable.add(n2, n4);
                pdfArray.add(n2, pdfIndirectReference);
                n3 = -2;
                break;
            }
            --n6;
        } while (true);
        if (n3 != -2) {
            serializable.add(0, n4);
            pdfArray.add(0, pdfIndirectReference);
        }
    }

    private static String getCOName(PdfReader object, PRIndirectReference object2) {
        object = "";
        while (object2 != null && (object2 = PdfReader.getPdfObject((PdfObject)object2)) != null && object2.type() == 6) {
            PdfObject pdfObject = (PdfDictionary)object2;
            PdfString pdfString = pdfObject.getAsString(PdfName.T);
            object2 = object;
            if (pdfString != null) {
                object2 = new StringBuilder();
                object2.append(pdfString.toUnicodeString());
                object2.append(".");
                object2.append((String)object);
                object2 = object2.toString();
            }
            pdfObject = (PRIndirectReference)pdfObject.get(PdfName.PARENT);
            object = object2;
            object2 = pdfObject;
        }
        object2 = object;
        if (object.endsWith(".")) {
            object2 = object.substring(0, object.length() - 1);
        }
        return object2;
    }

    void addDocument(PdfReader pdfReader) {
        block5 : {
            block8 : {
                block7 : {
                    block6 : {
                        if (!pdfReader.isOpenedWithFullPermissions()) break block5;
                        this.openDoc();
                        if (!this.readers2intrefs.containsKey(pdfReader)) break block6;
                        pdfReader = new PdfReader(pdfReader);
                        break block7;
                    }
                    if (pdfReader.isTampered()) break block8;
                    pdfReader.consolidateNamedDestinations();
                    pdfReader.setTampered(true);
                }
                pdfReader.shuffleSubsetNames();
                this.readers2intrefs.put(pdfReader, new IntHashtable());
                this.readers.add(pdfReader);
                int n2 = pdfReader.getNumberOfPages();
                Object object = new IntHashtable();
                for (int i2 = 1; i2 <= n2; ++i2) {
                    object.put(pdfReader.getPageOrigRef(i2).getNumber(), 1);
                    pdfReader.releasePage(i2);
                }
                this.pages2intrefs.put(pdfReader, (IntHashtable)object);
                this.visited.put(pdfReader, new IntHashtable());
                object = pdfReader.getAcroFields();
                if (object.isGenerateAppearances() ^ true) {
                    this.needAppearances = true;
                }
                this.fields.add((AcroFields)object);
                this.updateCalculationOrder(pdfReader);
                return;
            }
            throw new DocumentException(MessageLocalization.getComposedMessage("the.document.was.reused", new Object[0]));
        }
        throw new BadPasswordException(MessageLocalization.getComposedMessage("pdfreader.not.opened.with.owner.password", new Object[0]));
    }

    void addDocument(PdfReader pdfReader, List<Integer> list) {
        if (!this.readers2intrefs.containsKey(pdfReader) && pdfReader.isTampered()) {
            throw new DocumentException(MessageLocalization.getComposedMessage("the.document.was.reused", new Object[0]));
        }
        pdfReader = new PdfReader(pdfReader);
        pdfReader.selectPages(list);
        if (pdfReader.getNumberOfPages() == 0) {
            return;
        }
        pdfReader.setTampered(false);
        this.addDocument(pdfReader);
    }

    void addPageOffsetToField(Map<String, AcroFields.Item> object, int n2) {
        if (n2 == 0) {
            return;
        }
        for (AcroFields.Item item : object.values()) {
            for (int i2 = 0; i2 < item.size(); ++i2) {
                item.forcePage(i2, item.getPage(i2) + n2);
            }
        }
    }

    protected PdfArray branchForm(HashMap<String, Object> object, PdfIndirectReference pdfIndirectReference, String string2) {
        PdfArray pdfArray = new PdfArray();
        Iterator<Map.Entry<String, Object>> iterator = object.entrySet().iterator();
        do {
            object = pdfIndirectReference;
            if (!iterator.hasNext()) break;
            Object object2 = iterator.next();
            Object object3 = object2.getKey();
            Object object4 = object2.getValue();
            object2 = this.getPdfIndirectReference();
            PdfDictionary pdfDictionary = new PdfDictionary();
            if (object != null) {
                pdfDictionary.put(PdfName.PARENT, (PdfObject)object);
            }
            pdfDictionary.put(PdfName.T, new PdfString((String)object3, "UnicodeBig"));
            object = new StringBuilder();
            object.append(string2);
            object.append(".");
            object.append((String)object3);
            object = object.toString();
            int n2 = this.calculationOrder.indexOf(object);
            if (n2 >= 0) {
                this.calculationOrderRefs.set(n2, object2);
            }
            if (object4 instanceof HashMap) {
                pdfDictionary.put(PdfName.KIDS, this.branchForm((HashMap)object4, (PdfIndirectReference)object2, (String)object));
                pdfArray.add((PdfObject)object2);
                this.addToBody((PdfObject)pdfDictionary, (PdfIndirectReference)object2);
                continue;
            }
            object4 = (ArrayList)object4;
            pdfDictionary.mergeDifferent((PdfDictionary)object4.get(0));
            if (object4.size() == 3) {
                pdfDictionary.mergeDifferent((PdfDictionary)object4.get(2));
                n2 = (Integer)object4.get(1);
                object4 = this.pageDics.get(n2 - 1);
                object = object3 = object4.getAsArray(PdfName.ANNOTS);
                if (object3 == null) {
                    object = new PdfArray();
                    object4.put(PdfName.ANNOTS, (PdfObject)object);
                }
                object3 = (PdfNumber)pdfDictionary.get(iTextTag);
                pdfDictionary.remove(iTextTag);
                this.adjustTabOrder((PdfArray)object, (PdfIndirectReference)object2, (PdfNumber)object3);
            } else {
                PdfDictionary pdfDictionary2 = (PdfDictionary)object4.get(0);
                PdfName pdfName = pdfDictionary2.getAsName(PdfName.V);
                PdfArray pdfArray2 = new PdfArray();
                for (n2 = 1; n2 < object4.size(); n2 += 2) {
                    PdfObject pdfObject;
                    int n3 = (Integer)object4.get(n2);
                    PdfObject pdfObject2 = this.pageDics.get(n3 - 1);
                    object = object3 = pdfObject2.getAsArray(PdfName.ANNOTS);
                    if (object3 == null) {
                        object = new PdfArray();
                        pdfObject2.put(PdfName.ANNOTS, (PdfObject)object);
                    }
                    object3 = new PdfDictionary();
                    object3.merge((PdfDictionary)object4.get(n2 + 1));
                    object3.put(PdfName.PARENT, (PdfObject)object2);
                    pdfObject2 = (PdfNumber)object3.get(iTextTag);
                    object3.remove(iTextTag);
                    if (PdfCopy.isCheckButton(pdfDictionary2)) {
                        pdfObject = object3.getAsName(PdfName.AS);
                        if (pdfName != null && pdfObject != null) {
                            object3.put(PdfName.AS, pdfName);
                        }
                    } else if (PdfCopy.isRadioButton(pdfDictionary2)) {
                        pdfObject = object3.getAsName(PdfName.AS);
                        if (pdfName != null && pdfObject != null && !pdfObject.equals(this.getOffStateName((PdfDictionary)object3))) {
                            if (!this.mergedRadioButtons.contains(object4)) {
                                this.mergedRadioButtons.add(object4);
                                object3.put(PdfName.AS, pdfName);
                            } else {
                                object3.put(PdfName.AS, this.getOffStateName((PdfDictionary)object3));
                            }
                        }
                    }
                    pdfObject = this.addToBody((PdfObject)object3).getIndirectReference();
                    this.adjustTabOrder((PdfArray)object, (PdfIndirectReference)pdfObject, (PdfNumber)pdfObject2);
                    pdfArray2.add(pdfObject);
                    this.propagate((PdfObject)object3, null, false);
                }
                pdfDictionary.put(PdfName.KIDS, pdfArray2);
            }
            pdfArray.add((PdfObject)object2);
            this.addToBody((PdfObject)pdfDictionary, (PdfIndirectReference)object2);
            this.propagate(pdfDictionary, null, false);
        } while (true);
        return pdfArray;
    }

    @Override
    public void close() {
        if (this.closing) {
            super.close();
            return;
        }
        this.closing = true;
        try {
            this.closeIt();
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void closeIt() {
        Object object2;
        Object object3;
        int[] arrn;
        Object object;
        int n2;
        int n3;
        for (n2 = 0; n2 < this.readers.size(); ++n2) {
            this.readers.get(n2).removeFields();
        }
        n2 = 0;
        do {
            int n4 = this.readers.size();
            if (n2 >= n4) break;
            object = this.readers.get(n2);
            for (n3 = 1; n3 <= object.getNumberOfPages(); ++n3) {
                this.pageRefs.add(this.getNewReference(object.getPageOrigRef(n3)));
                this.pageDics.add(object.getPageN(n3));
            }
            ++n2;
        } while (true);
        this.mergeFields();
        this.createAcroForms();
        for (n2 = 0; n2 < this.readers.size(); ++n2) {
            object = this.readers.get(n2);
            for (n3 = 1; n3 <= object.getNumberOfPages(); ++n3) {
                object3 = object.getPageN(n3);
                object2 = this.getNewReference(object.getPageOrigRef(n3));
                arrn = this.root.addPageRef((PdfIndirectReference)object2);
                object3.put(PdfName.PARENT, (PdfObject)arrn);
                this.propagate((PdfObject)object3, (PdfIndirectReference)object2, false);
            }
        }
        object = this.readers2intrefs.entrySet().iterator();
        do {
            if (!object.hasNext()) {
                this.pdf.close();
                return;
            }
            object2 = (Map.Entry)object.next();
            object3 = (PdfReader)object2.getKey();
            try {
                this.file = object3.getSafeFile();
                this.file.reOpen();
                object2 = (IntHashtable)object2.getValue();
                arrn = object2.toOrderedKeys();
            }
            catch (Throwable throwable2) {
                try {
                    this.file.close();
                }
                catch (Exception exception) {
                    throw throwable2;
                }
                throw throwable2;
            }
            for (n2 = 0; n2 < arrn.length; ++n2) {
                this.addToBody(PdfReader.getPdfObjectRelease(new PRIndirectReference((PdfReader)object3, arrn[n2])), object2.get(arrn[n2]));
            }
            try {
                this.file.close();
            }
            catch (Exception exception) {
            }
        } while (true);
    }

    protected void createAcroForms() {
        if (this.fieldTree.isEmpty()) {
            return;
        }
        this.form = new PdfDictionary();
        this.form.put(PdfName.DR, this.resources);
        PdfObject pdfObject = this.resources;
        int n2 = 0;
        this.propagate(pdfObject, null, false);
        if (this.needAppearances) {
            this.form.put(PdfName.NEEDAPPEARANCES, PdfBoolean.PDFTRUE);
        }
        this.form.put(PdfName.DA, new PdfString("/Helv 0 Tf 0 g "));
        this.tabOrder = new HashMap();
        this.calculationOrderRefs = new ArrayList<String>(this.calculationOrder);
        this.form.put(PdfName.FIELDS, this.branchForm(this.fieldTree, null, ""));
        if (this.hasSignature) {
            this.form.put(PdfName.SIGFLAGS, new PdfNumber(3));
        }
        pdfObject = new PdfArray();
        while (n2 < this.calculationOrderRefs.size()) {
            Object object = this.calculationOrderRefs.get(n2);
            if (object instanceof PdfIndirectReference) {
                pdfObject.add((PdfIndirectReference)object);
            }
            ++n2;
        }
        if (pdfObject.size() > 0) {
            this.form.put(PdfName.CO, pdfObject);
        }
    }

    void createWidgets(ArrayList<Object> arrayList, AcroFields.Item item) {
        for (int i2 = 0; i2 < item.size(); ++i2) {
            arrayList.add(item.getPage(i2));
            PdfDictionary pdfDictionary = item.getMerged(i2);
            PdfObject pdfObject = pdfDictionary.get(PdfName.DR);
            if (pdfObject != null) {
                PdfFormField.mergeResources(this.resources, (PdfDictionary)PdfReader.getPdfObject(pdfObject));
            }
            pdfObject = new PdfDictionary();
            for (PdfName pdfName : pdfDictionary.getKeys()) {
                if (!widgetKeys.containsKey(pdfName)) continue;
                pdfObject.put(pdfName, pdfDictionary.get(pdfName));
            }
            pdfObject.put(iTextTag, new PdfNumber(item.getTabOrder(i2) + 1));
            arrayList.add(pdfObject);
        }
    }

    @Override
    protected PdfDictionary getCatalog(PdfIndirectReference pdfObject) {
        try {
            pdfObject = this.pdf.getCatalog((PdfIndirectReference)pdfObject);
            if (this.form != null) {
                PdfIndirectReference pdfIndirectReference = this.addToBody(this.form).getIndirectReference();
                pdfObject.put(PdfName.ACROFORM, pdfIndirectReference);
            }
            return pdfObject;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    @Override
    protected Counter getCounter() {
        return this.COUNTER;
    }

    @Override
    protected int getNewObjectNumber(PdfReader object, int n2, int n3) {
        int n4;
        object = this.readers2intrefs.get(object);
        n3 = n4 = object.get(n2);
        if (n4 == 0) {
            n3 = this.getIndirectReferenceNumber();
            object.put(n2, n3);
        }
        return n3;
    }

    protected PdfIndirectReference getNewReference(PRIndirectReference pRIndirectReference) {
        return new PdfIndirectReference(0, this.getNewObjectNumber(pRIndirectReference.getReader(), pRIndirectReference.getNumber(), 0));
    }

    protected PdfName getOffStateName(PdfDictionary pdfDictionary) {
        return PdfName.Off;
    }

    @Override
    public PdfIndirectReference getPageReference(int n2) {
        return this.pageRefs.get(n2 - 1);
    }

    @Override
    RandomAccessFileOrArray getReaderFile(PdfReader pdfReader) {
        return this.file;
    }

    protected boolean isPage(PRIndirectReference pRIndirectReference) {
        IntHashtable intHashtable = this.pages2intrefs.get(pRIndirectReference.getReader());
        if (intHashtable != null) {
            return intHashtable.containsKey(pRIndirectReference.getNumber());
        }
        return false;
    }

    protected boolean isVisited(PRIndirectReference pRIndirectReference) {
        IntHashtable intHashtable = this.visited.get(pRIndirectReference.getReader());
        if (intHashtable != null) {
            return intHashtable.containsKey(pRIndirectReference.getNumber());
        }
        return false;
    }

    protected boolean isVisited(PdfReader pdfReader, int n2, int n3) {
        return this.readers2intrefs.get(pdfReader).containsKey(n2);
    }

    /*
     * Enabled aggressive block sorting
     */
    void mergeField(String cloneable, AcroFields.Item item) {
        Object object;
        Serializable serializable = this.fieldTree;
        Serializable serializable2 = new StringTokenizer((String)((Object)cloneable), ".");
        cloneable = serializable;
        if (!serializable2.hasMoreTokens()) {
            return;
        }
        do {
            object = serializable2.nextToken();
            serializable = cloneable.get(object);
            if (!serializable2.hasMoreTokens()) break;
            if (serializable == null) {
                serializable = new HashMap();
                cloneable.put(object, serializable);
                cloneable = serializable;
            } else {
                if (!(serializable instanceof HashMap)) {
                    return;
                }
                cloneable = serializable;
            }
            cloneable = (HashMap)cloneable;
        } while (true);
        if (serializable instanceof HashMap) {
            return;
        }
        int n2 = 0;
        serializable2 = item.getMerged(0);
        if (serializable == null) {
            serializable = new PdfDictionary();
            if (PdfName.SIG.equals(serializable2.get(PdfName.FT))) {
                this.hasSignature = true;
            }
            Iterator<PdfName> iterator = serializable2.getKeys().iterator();
            do {
                if (!iterator.hasNext()) {
                    serializable2 = new ArrayList<Object>();
                    serializable2.add(serializable);
                    this.createWidgets((ArrayList<Object>)serializable2, item);
                    cloneable.put(object, serializable2);
                    return;
                }
                PdfName pdfName = iterator.next();
                if (!fieldKeys.containsKey(pdfName)) continue;
                serializable.put(pdfName, serializable2.get(pdfName));
            } while (true);
        }
        cloneable = (ArrayList)serializable;
        object = (PdfDictionary)cloneable.get(0);
        serializable = (PdfName)object.get(PdfName.FT);
        PdfName pdfName = (PdfName)serializable2.get(PdfName.FT);
        if (serializable != null) {
            if (!serializable.equals(pdfName)) {
                return;
            }
            int n3 = (object = object.get(PdfName.FF)) != null && object.isNumber() ? ((PdfNumber)object).intValue() : 0;
            serializable2 = serializable2.get(PdfName.FF);
            int n4 = n2;
            if (serializable2 != null) {
                n4 = n2;
                if (serializable2.isNumber()) {
                    n4 = ((PdfNumber)serializable2).intValue();
                }
            }
            if (serializable.equals(PdfName.BTN)) {
                if (((n4 = n3 ^ n4) & 65536) != 0) {
                    return;
                }
                if ((n3 & 65536) == 0 && (32768 & n4) != 0) {
                    return;
                }
            } else if (serializable.equals(PdfName.CH) && ((n3 ^ n4) & 131072) != 0) {
                return;
            }
            this.createWidgets((ArrayList<Object>)cloneable, item);
        }
    }

    void mergeFields() {
        int n2 = 0;
        for (int i2 = 0; i2 < this.fields.size(); ++i2) {
            Map<String, AcroFields.Item> map = this.fields.get(i2).getFields();
            this.addPageOffsetToField(map, n2);
            this.mergeWithMaster(map);
            n2 += this.readers.get(i2).getNumberOfPages();
        }
    }

    void mergeWithMaster(Map<String, AcroFields.Item> object) {
        for (Map.Entry entry : object.entrySet()) {
            this.mergeField((String)entry.getKey(), (AcroFields.Item)entry.getValue());
        }
    }

    public void openDoc() {
        if (!this.nd.isOpen()) {
            this.nd.open();
        }
    }

    void propagate(PdfObject object, PdfIndirectReference object2, boolean bl2) {
        if (object == null) {
            return;
        }
        if (object instanceof PdfIndirectReference) {
            return;
        }
        int n2 = object.type();
        if (n2 != 10) {
            switch (n2) {
                default: {
                    return;
                }
                case 6: 
                case 7: {
                    object = (PdfDictionary)((Object)object);
                    for (PdfName pdfIndirectReference : object.getKeys()) {
                        if (bl2 && (pdfIndirectReference.equals(PdfName.PARENT) || pdfIndirectReference.equals(PdfName.KIDS))) continue;
                        PdfObject pdfObject = object.get(pdfIndirectReference);
                        if (pdfObject != null && pdfObject.isIndirect()) {
                            PRIndirectReference pRIndirectReference = (PRIndirectReference)pdfObject;
                            if (this.setVisited(pRIndirectReference) || this.isPage(pRIndirectReference)) continue;
                            PdfIndirectReference pdfIndirectReference2 = this.getNewReference(pRIndirectReference);
                            this.propagate(PdfReader.getPdfObjectRelease(pRIndirectReference), pdfIndirectReference2, bl2);
                            continue;
                        }
                        this.propagate(pdfObject, null, bl2);
                    }
                    break;
                }
                case 5: {
                    object = ((PdfArray)((Object)object)).listIterator();
                    while (object.hasNext()) {
                        object2 = object.next();
                        if (object2 != null && object2.isIndirect()) {
                            if (this.isVisited((PRIndirectReference)(object2 = (PRIndirectReference)object2)) || this.isPage((PRIndirectReference)object2)) continue;
                            PdfIndirectReference pdfIndirectReference = this.getNewReference((PRIndirectReference)object2);
                            this.propagate(PdfReader.getPdfObjectRelease((PdfObject)object2), pdfIndirectReference, bl2);
                            continue;
                        }
                        this.propagate((PdfObject)object2, null, bl2);
                    }
                    break block0;
                }
            }
            return;
        }
        throw new RuntimeException(MessageLocalization.getComposedMessage("reference.pointing.to.reference", new Object[0]));
    }

    protected boolean setVisited(PRIndirectReference pRIndirectReference) {
        boolean bl2;
        IntHashtable intHashtable = this.visited.get(pRIndirectReference.getReader());
        boolean bl3 = bl2 = false;
        if (intHashtable != null) {
            bl3 = bl2;
            if (intHashtable.put(pRIndirectReference.getNumber(), 1) != 0) {
                bl3 = true;
            }
        }
        return bl3;
    }

    protected void updateCalculationOrder(PdfReader pdfReader) {
        PdfObject pdfObject = pdfReader.getCatalog().getAsDict(PdfName.ACROFORM);
        if (pdfObject == null) {
            return;
        }
        if ((pdfObject = pdfObject.getAsArray(PdfName.CO)) != null) {
            if (pdfObject.size() == 0) {
                return;
            }
            AcroFields acroFields = pdfReader.getAcroFields();
            for (int i2 = 0; i2 < pdfObject.size(); ++i2) {
                Object object = pdfObject.getPdfObject(i2);
                if (object == null || !object.isIndirect() || acroFields.getFieldItem((String)(object = PdfCopyFieldsImp.getCOName(pdfReader, (PRIndirectReference)object))) == null) continue;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(".");
                stringBuilder.append((String)object);
                object = stringBuilder.toString();
                if (this.calculationOrder.contains(object)) continue;
                this.calculationOrder.add((String)object);
            }
        }
    }
}

