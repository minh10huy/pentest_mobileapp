/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.spongycastle.cert.X509CertificateHolder
 *  org.spongycastle.cms.CMSEnvelopedData
 *  org.spongycastle.cms.Recipient
 *  org.spongycastle.cms.RecipientId
 *  org.spongycastle.cms.RecipientInformation
 *  org.spongycastle.cms.RecipientInformationStore
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocWriter;
import com.itextpdf.text.Document;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.PageSize;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.BadPasswordException;
import com.itextpdf.text.exceptions.InvalidPdfException;
import com.itextpdf.text.exceptions.UnsupportedPdfException;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.io.WindowRandomAccessSource;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.log.Level;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.FilterHandlers;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.LZWDecoder;
import com.itextpdf.text.pdf.LongHashtable;
import com.itextpdf.text.pdf.PRAcroForm;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfEncryption;
import com.itextpdf.text.pdf.PdfEncryptor;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNameTree;
import com.itextpdf.text.pdf.PdfNull;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReaderInstance;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.SequenceList;
import com.itextpdf.text.pdf.interfaces.PdfViewerPreferences;
import com.itextpdf.text.pdf.internal.PdfViewerPreferencesImp;
import com.itextpdf.text.pdf.security.ExternalDecryptionProcess;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.net.URL;
import java.security.Key;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.zip.InflaterInputStream;
import org.spongycastle.cert.X509CertificateHolder;
import org.spongycastle.cms.CMSEnvelopedData;
import org.spongycastle.cms.Recipient;
import org.spongycastle.cms.RecipientId;
import org.spongycastle.cms.RecipientInformation;
import org.spongycastle.cms.RecipientInformationStore;

public class PdfReader
implements PdfViewerPreferences {
    protected static Counter COUNTER;
    private static final Logger LOGGER;
    public static boolean debugmode = false;
    static final byte[] endobj;
    static final byte[] endstream;
    static final PdfName[] pageInhCandidates;
    public static boolean unethicalreading = false;
    protected PRAcroForm acroForm = null;
    protected boolean acroFormParsed;
    private boolean appendable;
    protected PdfDictionary catalog;
    protected Certificate certificate;
    protected Key certificateKey;
    protected String certificateKeyProvider;
    protected boolean consolidateNamedDestinations;
    private PRIndirectReference cryptoRef;
    protected PdfEncryption decrypt;
    protected boolean encrypted;
    private boolean encryptionError;
    protected long eofPos;
    protected ExternalDecryptionProcess externalDecryptionProcess;
    private long fileLength;
    protected int freeXref;
    private boolean hybridXref;
    protected long lastXref;
    private int lastXrefPartial;
    protected boolean newXrefType;
    private int objGen;
    private int objNum;
    protected HashMap<Integer, IntHashtable> objStmMark;
    protected LongHashtable objStmToOffset;
    private boolean ownerPasswordUsed;
    protected long pValue;
    protected PageRefs pageRefs;
    private boolean partial;
    protected byte[] password;
    protected char pdfVersion;
    protected int rValue;
    private int readDepth;
    protected boolean rebuilt;
    protected boolean remoteToLocalNamedDestinations;
    PdfDictionary rootPages;
    protected boolean sharedStreams;
    protected ArrayList<PdfString> strings;
    protected boolean tampered;
    protected PRTokeniser tokens;
    protected PdfDictionary trailer;
    private final PdfViewerPreferencesImp viewerPreferences;
    protected long[] xref;
    protected ArrayList<PdfObject> xrefObj;

    static {
        LOGGER = LoggerFactory.getLogger(PdfReader.class);
        pageInhCandidates = new PdfName[]{PdfName.MEDIABOX, PdfName.ROTATE, PdfName.RESOURCES, PdfName.CROPBOX};
        endstream = PdfEncodings.convertToBytes("endstream", null);
        endobj = PdfEncodings.convertToBytes("endobj", null);
        COUNTER = CounterFactory.getCounter(PdfReader.class);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private PdfReader(RandomAccessSource randomAccessSource, boolean bl2, byte[] arrby, Certificate certificate, Key key, String string2, ExternalDecryptionProcess externalDecryptionProcess, boolean bl3) {
        this.acroFormParsed = false;
        this.encrypted = false;
        this.rebuilt = false;
        this.tampered = false;
        this.password = null;
        this.certificateKey = null;
        this.certificate = null;
        this.certificateKeyProvider = null;
        this.externalDecryptionProcess = null;
        this.strings = new ArrayList();
        this.sharedStreams = true;
        this.consolidateNamedDestinations = false;
        this.remoteToLocalNamedDestinations = false;
        this.lastXrefPartial = -1;
        this.viewerPreferences = new PdfViewerPreferencesImp();
        this.readDepth = 0;
        this.certificate = certificate;
        this.certificateKey = key;
        this.certificateKeyProvider = string2;
        this.externalDecryptionProcess = externalDecryptionProcess;
        this.password = arrby;
        this.partial = bl2;
        try {
            this.tokens = PdfReader.getOffsetTokeniser(randomAccessSource);
            if (bl2) {
                this.readPdfPartial();
            } else {
                this.readPdf();
            }
            this.getCounter().read(this.fileLength);
            return;
        }
        catch (IOException iOException) {
            if (bl3) {
                randomAccessSource.close();
            }
            throw iOException;
        }
    }

    public PdfReader(PdfReader pdfReader) {
        int n2 = 0;
        this.acroFormParsed = false;
        this.encrypted = false;
        this.rebuilt = false;
        this.tampered = false;
        this.password = null;
        this.certificateKey = null;
        this.certificate = null;
        this.certificateKeyProvider = null;
        this.externalDecryptionProcess = null;
        this.strings = new ArrayList();
        this.sharedStreams = true;
        this.consolidateNamedDestinations = false;
        this.remoteToLocalNamedDestinations = false;
        this.lastXrefPartial = -1;
        this.viewerPreferences = new PdfViewerPreferencesImp();
        this.readDepth = 0;
        this.appendable = pdfReader.appendable;
        this.consolidateNamedDestinations = pdfReader.consolidateNamedDestinations;
        this.encrypted = pdfReader.encrypted;
        this.rebuilt = pdfReader.rebuilt;
        this.sharedStreams = pdfReader.sharedStreams;
        this.tampered = pdfReader.tampered;
        this.password = pdfReader.password;
        this.pdfVersion = pdfReader.pdfVersion;
        this.eofPos = pdfReader.eofPos;
        this.freeXref = pdfReader.freeXref;
        this.lastXref = pdfReader.lastXref;
        this.newXrefType = pdfReader.newXrefType;
        this.tokens = new PRTokeniser(pdfReader.tokens.getSafeFile());
        if (pdfReader.decrypt != null) {
            this.decrypt = new PdfEncryption(pdfReader.decrypt);
        }
        this.pValue = pdfReader.pValue;
        this.rValue = pdfReader.rValue;
        this.xrefObj = new ArrayList<PdfObject>(pdfReader.xrefObj);
        while (n2 < pdfReader.xrefObj.size()) {
            this.xrefObj.set(n2, PdfReader.duplicatePdfObject(pdfReader.xrefObj.get(n2), this));
            ++n2;
        }
        this.pageRefs = new PageRefs(pdfReader.pageRefs, this);
        this.trailer = (PdfDictionary)PdfReader.duplicatePdfObject(pdfReader.trailer, this);
        this.catalog = this.trailer.getAsDict(PdfName.ROOT);
        this.rootPages = this.catalog.getAsDict(PdfName.PAGES);
        this.fileLength = pdfReader.fileLength;
        this.partial = pdfReader.partial;
        this.hybridXref = pdfReader.hybridXref;
        this.objStmToOffset = pdfReader.objStmToOffset;
        this.xref = pdfReader.xref;
        this.cryptoRef = (PRIndirectReference)PdfReader.duplicatePdfObject(pdfReader.cryptoRef, this);
        this.ownerPasswordUsed = pdfReader.ownerPasswordUsed;
    }

    public PdfReader(RandomAccessFileOrArray randomAccessFileOrArray, byte[] arrby) {
        this(randomAccessFileOrArray, arrby, true);
    }

    public PdfReader(RandomAccessFileOrArray randomAccessFileOrArray, byte[] arrby, boolean bl2) {
        this(randomAccessFileOrArray.getByteSource(), bl2, arrby, null, null, null, null, false);
    }

    public PdfReader(InputStream inputStream) {
        this(inputStream, null);
    }

    public PdfReader(InputStream inputStream, Certificate certificate, ExternalDecryptionProcess externalDecryptionProcess) {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createSource(inputStream), false, null, certificate, null, null, externalDecryptionProcess, true);
    }

    public PdfReader(InputStream inputStream, byte[] arrby) {
        this(new RandomAccessSourceFactory().createSource(inputStream), false, arrby, null, null, null, null, false);
    }

    public PdfReader(String string2) {
        this(string2, (byte[])null);
    }

    public PdfReader(String string2, Certificate certificate, ExternalDecryptionProcess externalDecryptionProcess) {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2), false, null, certificate, null, null, externalDecryptionProcess, true);
    }

    public PdfReader(String string2, Certificate certificate, Key key, String string3) {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2), false, null, certificate, key, string3, null, true);
    }

    public PdfReader(String string2, byte[] arrby) {
        this(string2, arrby, false);
    }

    public PdfReader(String string2, byte[] arrby, boolean bl2) {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2), bl2, arrby, null, null, null, null, true);
    }

    public PdfReader(URL uRL) {
        this(uRL, null);
    }

    public PdfReader(URL uRL, byte[] arrby) {
        this(new RandomAccessSourceFactory().createSource(uRL), false, arrby, null, null, null, null, true);
    }

    public PdfReader(byte[] arrby) {
        this(arrby, null);
    }

    public PdfReader(byte[] arrby, Certificate certificate, ExternalDecryptionProcess externalDecryptionProcess) {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createSource(arrby), false, null, certificate, null, null, externalDecryptionProcess, true);
    }

    public PdfReader(byte[] arrby, byte[] arrby2) {
        this(new RandomAccessSourceFactory().createSource(arrby), false, arrby2, null, null, null, null, true);
    }

    /*
     * Enabled aggressive block sorting
     */
    public static byte[] ASCII85Decode(byte[] arrby) {
        ByteArrayOutputStream byteArrayOutputStream;
        int n2;
        block11 : {
            int[] arrn;
            block9 : {
                block10 : {
                    byteArrayOutputStream = new ByteArrayOutputStream();
                    arrn = new int[5];
                    int n3 = 0;
                    n2 = 0;
                    while (n3 < arrby.length) {
                        int n4 = arrby[n3] & 255;
                        if (n4 == 126) {
                            if (n2 != 2) break block9;
                            break block10;
                        }
                        if (!PRTokeniser.isWhitespace(n4)) {
                            if (n4 == 122 && n2 == 0) {
                                byteArrayOutputStream.write(0);
                                byteArrayOutputStream.write(0);
                                byteArrayOutputStream.write(0);
                                byteArrayOutputStream.write(0);
                            } else {
                                if (n4 < 33) throw new RuntimeException(MessageLocalization.getComposedMessage("illegal.character.in.ascii85decode", new Object[0]));
                                if (n4 > 117) throw new RuntimeException(MessageLocalization.getComposedMessage("illegal.character.in.ascii85decode", new Object[0]));
                                arrn[n2] = n4 - 33;
                                n2 = n4 = n2 + 1;
                                if (n4 == 5) {
                                    n4 = 0;
                                    for (n2 = 0; n2 < 5; ++n2) {
                                        n4 = n4 * 85 + arrn[n2];
                                    }
                                    byteArrayOutputStream.write((byte)(n4 >> 24));
                                    byteArrayOutputStream.write((byte)(n4 >> 16));
                                    byteArrayOutputStream.write((byte)(n4 >> 8));
                                    byteArrayOutputStream.write((byte)n4);
                                    n2 = 0;
                                }
                            }
                        }
                        ++n3;
                    }
                    return byteArrayOutputStream.toByteArray();
                }
                n2 = arrn[0] * 85 * 85 * 85 * 85 + arrn[1] * 85 * 85 * 85 + 614125 + 7225 + 85 >> 24;
                break block11;
            }
            if (n2 == 3) {
                n2 = arrn[0] * 85 * 85 * 85 * 85 + arrn[1] * 85 * 85 * 85 + arrn[2] * 85 * 85 + 7225 + 85;
                byteArrayOutputStream.write((byte)(n2 >> 24));
                n2 >>= 16;
            } else {
                if (n2 != 4) return byteArrayOutputStream.toByteArray();
                n2 = arrn[0] * 85 * 85 * 85 * 85 + arrn[1] * 85 * 85 * 85 + arrn[2] * 85 * 85 + arrn[3] * 85 + 85;
                byteArrayOutputStream.write((byte)(n2 >> 24));
                byteArrayOutputStream.write((byte)(n2 >> 16));
                n2 >>= 8;
            }
        }
        byteArrayOutputStream.write((byte)n2);
        return byteArrayOutputStream.toByteArray();
    }

    public static byte[] ASCIIHexDecode(byte[] arrby) {
        int n2;
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        boolean bl2 = true;
        int n3 = 0;
        for (int i2 = 0; i2 < arrby.length && (n2 = arrby[i2] & 255) != 62; ++i2) {
            if (PRTokeniser.isWhitespace(n2)) continue;
            if ((n2 = PRTokeniser.getHex(n2)) != -1) {
                if (bl2) {
                    n3 = n2;
                } else {
                    byteArrayOutputStream.write((byte)((n3 << 4) + n2));
                }
                bl2 ^= true;
                continue;
            }
            throw new RuntimeException(MessageLocalization.getComposedMessage("illegal.character.in.asciihexdecode", new Object[0]));
        }
        if (!bl2) {
            byteArrayOutputStream.write((byte)(n3 << 4));
        }
        return byteArrayOutputStream.toByteArray();
    }

    public static byte[] FlateDecode(byte[] arrby) {
        byte[] arrby2 = PdfReader.FlateDecode(arrby, true);
        if (arrby2 == null) {
            return PdfReader.FlateDecode(arrby, false);
        }
        return arrby2;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static byte[] FlateDecode(byte[] object, boolean bl2) {
        byte[] arrby = new byte[](new ByteArrayInputStream((byte[])object));
        object = new ByteArrayOutputStream();
        int n2 = bl2 ? 4092 : 1;
        byte[] arrby2 = new byte[n2];
        try {
            do {
                if ((n2 = arrby.read(arrby2)) < 0) {
                    arrby.close();
                    object.close();
                    return object.toByteArray();
                }
                object.write(arrby2, 0, n2);
            } while (true);
        }
        catch (Exception exception) {}
        if (!bl2) return object.toByteArray();
        return null;
    }

    public static byte[] LZWDecode(byte[] arrby) {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        new LZWDecoder().decode(arrby, byteArrayOutputStream);
        return byteArrayOutputStream.toByteArray();
    }

    /*
     * Enabled aggressive block sorting
     */
    private void checkPRStreamLength(PRStream pRStream) {
        long l2;
        long l3 = this.tokens.length();
        long l4 = pRStream.getOffset();
        Object object = PdfReader.getPdfObjectRelease(pRStream.get(PdfName.LENGTH));
        int n2 = 1;
        if (object != null && object.type() == 2) {
            l2 = ((PdfNumber)object).intValue();
            long l5 = l2 + l4;
            if (l5 <= l3 - 20L) {
                this.tokens.seek(l5);
                object = this.tokens.readString(20);
                if (object.startsWith("\nendstream") || object.startsWith("\r\nendstream") || object.startsWith("\rendstream") || object.startsWith("endstream")) {
                    n2 = 0;
                }
            }
        } else {
            l2 = 0L;
        }
        l3 = l2;
        if (n2 != 0) {
            block11 : {
                block12 : {
                    object = new byte[16];
                    this.tokens.seek(l4);
                    do {
                        l3 = this.tokens.getFilePointer();
                        if (!this.tokens.readLineSegment((byte[])object, false)) {
                            l4 = l3;
                            break block11;
                        }
                        if (PdfReader.equalsn((byte[])object, endstream)) break block12;
                    } while (!PdfReader.equalsn((byte[])object, endobj));
                    object = this.tokens;
                    l2 = l3 - 16L;
                    object.seek(l2);
                    n2 = this.tokens.readString(16).indexOf("endstream");
                    if (n2 >= 0) {
                        l3 = l2 + (long)n2;
                    }
                }
                l2 = l3 - l4;
                l4 = l3;
            }
            this.tokens.seek(l4 - 2L);
            l3 = l2;
            if (this.tokens.read() == 13) {
                l3 = l2 - 1L;
            }
            this.tokens.seek(l4 - 1L);
            l2 = l3;
            if (this.tokens.read() == 10) {
                l2 = l3 - 1L;
            }
            l3 = l2;
            if (l2 < 0L) {
                l3 = 0L;
            }
        }
        pRStream.setLength((int)l3);
    }

    private boolean convertNamedDestination(PdfObject object, HashMap<Object, PdfObject> hashMap) {
        PdfObject pdfObject;
        PdfObject pdfObject2 = PdfReader.getPdfObject((PdfObject)object);
        int n2 = this.lastXrefPartial;
        this.releaseLastXrefPartial();
        if (pdfObject2 != null && pdfObject2.isDictionary() && (pdfObject = PdfReader.getPdfObject(((PdfDictionary)pdfObject2).get(PdfName.A))) != null) {
            int n3 = this.lastXrefPartial;
            this.releaseLastXrefPartial();
            PdfDictionary pdfDictionary = (PdfDictionary)pdfObject;
            object = (PdfName)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.S));
            if (PdfName.GOTOR.equals(object) && (object = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.D))) != null) {
                if (!object.isName()) {
                    object = object.isString() ? object.toString() : null;
                }
                if ((PdfArray)hashMap.get(object) != null) {
                    pdfDictionary.remove(PdfName.F);
                    pdfDictionary.remove(PdfName.NEWWINDOW);
                    pdfDictionary.put(PdfName.S, PdfName.GOTO);
                    this.setXrefPartialObject(n3, pdfObject);
                    this.setXrefPartialObject(n2, pdfObject2);
                    return true;
                }
            }
        }
        return false;
    }

    public static byte[] decodeBytes(byte[] arrby, PdfDictionary pdfDictionary) {
        return PdfReader.decodeBytes(arrby, pdfDictionary, FilterHandlers.getDefaultFilterHandlers());
    }

    public static byte[] decodeBytes(byte[] arrby, PdfDictionary pdfDictionary, Map<PdfName, FilterHandlers.FilterHandler> map) {
        Serializable serializable;
        ArrayList<Serializable> arrayList;
        ArrayList<Object> arrayList2;
        Serializable serializable2;
        block21 : {
            block20 : {
                serializable2 = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.FILTER));
                serializable = new ArrayList<PdfObject>();
                arrayList2 = serializable;
                if (serializable2 != null) {
                    if (serializable2.isName()) {
                        serializable.add(serializable2);
                        arrayList2 = serializable;
                    } else {
                        arrayList2 = serializable;
                        if (serializable2.isArray()) {
                            arrayList2 = ((PdfArray)serializable2).getArrayList();
                        }
                    }
                }
                arrayList = new ArrayList<Serializable>();
                serializable = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.DECODEPARMS));
                if (serializable == null) break block20;
                serializable2 = serializable;
                if (serializable.isDictionary()) break block21;
                serializable2 = serializable;
                if (serializable.isArray()) break block21;
            }
            serializable2 = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.DP));
        }
        serializable = arrayList;
        if (serializable2 != null) {
            if (serializable2.isDictionary()) {
                arrayList.add(serializable2);
                serializable = arrayList;
            } else {
                serializable = arrayList;
                if (serializable2.isArray()) {
                    serializable = ((PdfArray)serializable2).getArrayList();
                }
            }
        }
        for (int i2 = 0; i2 < arrayList2.size(); ++i2) {
            PdfName pdfName = (PdfName)arrayList2.get(i2);
            FilterHandlers.FilterHandler filterHandler = map.get(pdfName);
            if (filterHandler != null) {
                int n2 = serializable.size();
                arrayList = null;
                serializable2 = arrayList;
                if (i2 < n2) {
                    PdfObject pdfObject = PdfReader.getPdfObject((PdfObject)serializable.get(i2));
                    if (pdfObject instanceof PdfDictionary) {
                        serializable2 = (PdfDictionary)pdfObject;
                    } else {
                        serializable2 = arrayList;
                        if (pdfObject != null) {
                            serializable2 = arrayList;
                            if (!(pdfObject instanceof PdfNull)) {
                                if (pdfObject instanceof PdfLiteral && Arrays.equals("null".getBytes(), ((PdfLiteral)pdfObject).getBytes())) {
                                    serializable2 = arrayList;
                                } else {
                                    throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("the.decode.parameter.type.1.is.not.supported", pdfObject.getClass().toString()));
                                }
                            }
                        }
                    }
                }
                arrby = filterHandler.decode(arrby, pdfName, (PdfObject)serializable2, pdfDictionary);
                continue;
            }
            throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("the.filter.1.is.not.supported", pdfName));
        }
        return arrby;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public static byte[] decodePredictor(byte[] arrby, PdfObject object) {
        PdfObject pdfObject;
        Object object2 = arrby;
        if (object == null) return object2;
        if (!object.isDictionary()) {
            return arrby;
        }
        PdfDictionary pdfDictionary = (PdfDictionary)object;
        Object object3 = PdfReader.getPdfObject(pdfDictionary.get(PdfName.PREDICTOR));
        object2 = arrby;
        if (object3 == null) return object2;
        if (!object3.isNumber()) {
            return arrby;
        }
        int n2 = ((PdfNumber)object3).intValue();
        if (n2 < 10 && n2 != 2) {
            return arrby;
        }
        object2 = PdfReader.getPdfObject(pdfDictionary.get(PdfName.COLUMNS));
        int n3 = 1;
        int n4 = object2 != null && object2.isNumber() ? ((PdfNumber)object2).intValue() : 1;
        object2 = PdfReader.getPdfObject(pdfDictionary.get(PdfName.COLORS));
        int n5 = n3;
        if (object2 != null) {
            n5 = n3;
            if (object2.isNumber()) {
                n5 = ((PdfNumber)object2).intValue();
            }
        }
        int n6 = (pdfObject = PdfReader.getPdfObject(pdfDictionary.get(PdfName.BITSPERCOMPONENT))) != null && pdfObject.isNumber() ? ((PdfNumber)pdfObject).intValue() : 8;
        DataInputStream dataInputStream = new DataInputStream(new ByteArrayInputStream(arrby));
        object3 = new ByteArrayOutputStream(arrby.length);
        n3 = n5 * n6 / 8;
        int n7 = (n5 * n4 * n6 + 7) / 8;
        byte[] arrby2 = new byte[n7];
        object2 = new byte[n7];
        n4 = 0;
        if (n2 == 2) {
            if (n6 != 8) return arrby;
            n6 = arrby.length / n7;
            while (n4 < n6) {
                for (n5 = n3 + 0; n5 < n7; ++n5) {
                    n2 = n4 * n7 + n5;
                    arrby[n2] = (byte)(arrby[n2] + arrby[n2 - n3]);
                }
                ++n4;
            }
            return arrby;
        }
        do {
            void var1_7;
            block29 : {
                n4 = dataInputStream.read();
                if (n4 < 0) {
                    return object3.toByteArray();
                }
                dataInputStream.readFully((byte[])var1_7, 0, n7);
                switch (n4) {
                    default: {
                        throw new RuntimeException(MessageLocalization.getComposedMessage("png.filter.unknown", new Object[0]));
                    }
                    case 4: {
                        for (n4 = 0; n4 < n3; ++n4) {
                            var1_7[n4] = (byte)(var1_7[n4] + object2[n4]);
                        }
                        for (n5 = n3; n5 < n7; ++n5) {
                            n2 = n5 - n3;
                            n4 = var1_7[n2] & 255;
                            n6 = object2[n5] & 255;
                            n2 = object2[n2] & 255;
                            int n8 = n4 + n6 - n2;
                            int n9 = Math.abs(n8 - n4);
                            int n10 = Math.abs(n8 - n6);
                            n8 = Math.abs(n8 - n2);
                            if (n9 > n10 || n9 > n8) {
                                n4 = n2;
                                if (n10 <= n8) {
                                    n4 = n6;
                                }
                            }
                            var1_7[n5] = (byte)(var1_7[n5] + (byte)n4);
                        }
                        break;
                    }
                    case 3: {
                        for (n4 = 0; n4 < n3; ++n4) {
                            var1_7[n4] = (byte)(var1_7[n4] + object2[n4] / 2);
                        }
                        for (n4 = n3; n4 < n7; ++n4) {
                            var1_7[n4] = (byte)(var1_7[n4] + ((var1_7[n4 - n3] & 255) + (object2[n4] & 255)) / 2);
                        }
                        break;
                    }
                    case 2: {
                        for (n4 = 0; n4 < n7; ++n4) {
                            var1_7[n4] = (byte)(var1_7[n4] + object2[n4]);
                        }
                        break;
                    }
                    case 1: {
                        for (n4 = n3; n4 < n7; ++n4) {
                            var1_7[n4] = (byte)(var1_7[n4] + var1_7[n4 - n3]);
                        }
                        break;
                    }
                    case 0: 
                }
                try {
                    object3.write((byte[])var1_7);
                    break block29;
                }
                catch (IOException iOException) {}
                catch (Exception exception) {}
                return object3.toByteArray();
            }
            arrby = var1_7;
            Object object4 = object2;
            object2 = arrby;
        } while (true);
    }

    protected static PdfDictionary duplicatePdfDictionary(PdfDictionary pdfDictionary, PdfDictionary object, PdfReader pdfReader) {
        PdfDictionary pdfDictionary2 = object;
        if (object == null) {
            pdfDictionary2 = new PdfDictionary(pdfDictionary.size());
        }
        for (PdfName pdfName : pdfDictionary.getKeys()) {
            pdfDictionary2.put(pdfName, PdfReader.duplicatePdfObject(pdfDictionary.get(pdfName), pdfReader));
        }
        return pdfDictionary2;
    }

    protected static PdfObject duplicatePdfObject(PdfObject pdfObject, PdfReader pdfReader) {
        if (pdfObject == null) {
            return null;
        }
        int n2 = pdfObject.type();
        if (n2 != 10) {
            switch (n2) {
                default: {
                    return pdfObject;
                }
                case 7: {
                    pdfObject = (PRStream)pdfObject;
                    PRStream pRStream = new PRStream((PRStream)pdfObject, null, pdfReader);
                    PdfReader.duplicatePdfDictionary((PdfDictionary)pdfObject, pRStream, pdfReader);
                    return pRStream;
                }
                case 6: {
                    return PdfReader.duplicatePdfDictionary((PdfDictionary)pdfObject, null, pdfReader);
                }
                case 5: 
            }
            Object object = (PdfArray)pdfObject;
            pdfObject = new PdfArray(object.size());
            object = object.listIterator();
            while (object.hasNext()) {
                pdfObject.add(PdfReader.duplicatePdfObject((PdfObject)object.next(), pdfReader));
            }
            return pdfObject;
        }
        pdfObject = (PRIndirectReference)pdfObject;
        return new PRIndirectReference(pdfReader, pdfObject.getNumber(), pdfObject.getGeneration());
    }

    /*
     * Enabled aggressive block sorting
     */
    private void ensureXrefSize(int n2) {
        long[] arrl;
        if (n2 == 0) {
            return;
        }
        if (this.xref == null) {
            arrl = new long[n2];
        } else {
            if (this.xref.length >= n2) {
                return;
            }
            arrl = new long[n2];
            System.arraycopy(this.xref, 0, arrl, 0, this.xref.length);
        }
        this.xref = arrl;
    }

    private boolean equalsArray(byte[] arrby, byte[] arrby2, int n2) {
        for (int i2 = 0; i2 < n2; ++i2) {
            if (arrby[i2] == arrby2[i2]) continue;
            return false;
        }
        return true;
    }

    static boolean equalsn(byte[] arrby, byte[] arrby2) {
        int n2 = arrby2.length;
        for (int i2 = 0; i2 < n2; ++i2) {
            if (arrby[i2] == arrby2[i2]) continue;
            return false;
        }
        return true;
    }

    static boolean existsName(PdfDictionary pdfObject, PdfName pdfName, PdfName pdfName2) {
        if ((pdfObject = PdfReader.getPdfObjectRelease(pdfObject.get(pdfName))) != null && pdfObject.isName()) {
            return ((PdfName)pdfObject).equals(pdfName2);
        }
        return false;
    }

    static String getFontName(PdfDictionary pdfObject) {
        if (pdfObject == null) {
            return null;
        }
        if ((pdfObject = PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.BASEFONT))) != null) {
            if (!pdfObject.isName()) {
                return null;
            }
            return PdfName.decodeName(pdfObject.toString());
        }
        return null;
    }

    private static PdfArray getNameArray(PdfObject pdfObject) {
        if (pdfObject == null) {
            return null;
        }
        if ((pdfObject = PdfReader.getPdfObjectRelease(pdfObject)) == null) {
            return null;
        }
        if (pdfObject.isArray()) {
            return (PdfArray)pdfObject;
        }
        if (pdfObject.isDictionary() && (pdfObject = PdfReader.getPdfObjectRelease(((PdfDictionary)pdfObject).get(PdfName.D))) != null && pdfObject.isArray()) {
            return (PdfArray)pdfObject;
        }
        return null;
    }

    public static Rectangle getNormalizedRectangle(PdfArray pdfArray) {
        float f2 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(0))).floatValue();
        float f3 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(1))).floatValue();
        float f4 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(2))).floatValue();
        float f5 = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(3))).floatValue();
        return new Rectangle(Math.min(f2, f4), Math.min(f3, f5), Math.max(f2, f4), Math.max(f3, f5));
    }

    private static PRTokeniser getOffsetTokeniser(RandomAccessSource randomAccessSource) {
        PRTokeniser pRTokeniser = new PRTokeniser(new RandomAccessFileOrArray(randomAccessSource));
        int n2 = pRTokeniser.getHeaderOffset();
        if (n2 != 0) {
            return new PRTokeniser(new RandomAccessFileOrArray(new WindowRandomAccessSource(randomAccessSource, n2)));
        }
        return pRTokeniser;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    public static byte[] getPageContent(PdfDictionary var0) {
        block24 : {
            block26 : {
                block23 : {
                    block27 : {
                        block25 : {
                            block21 : {
                                block22 : {
                                    var4_4 /* !! */  = null;
                                    var3_5 /* !! */  = null;
                                    if (var0 == null) {
                                        return null;
                                    }
                                    var2_8 /* !! */  = var4_4 /* !! */ ;
                                    var5_10 = PdfReader.getPdfObjectRelease(var0.get(PdfName.CONTENTS));
                                    var1_11 = 0;
                                    if (var5_10 == null) {
                                        var2_8 /* !! */  = var4_4 /* !! */ ;
                                        return new byte[0];
                                    }
                                    var2_8 /* !! */  = var4_4 /* !! */ ;
                                    if (!var5_10.isStream()) break block21;
                                    var2_8 /* !! */  = var4_4 /* !! */ ;
                                    var0 = ((PRStream)var5_10).getReader().getSafeFile();
                                    var0.reOpen();
                                    var2_8 /* !! */  = PdfReader.getStreamBytes((PRStream)var5_10, (RandomAccessFileOrArray)var0);
                                    if (var0 == null) break block22;
                                    var0.close();
                                }
                                return var2_8 /* !! */ ;
                                catch (Throwable var3_6) {
                                    var2_8 /* !! */  = var0;
                                    var0 = var3_6;
                                }
                                break block26;
                            }
                            var2_8 /* !! */  = var4_4 /* !! */ ;
                            if (!var5_10.isArray()) break block23;
                            var2_8 /* !! */  = var4_4 /* !! */ ;
                            var5_10 = (PdfArray)var5_10;
                            var2_8 /* !! */  = var4_4 /* !! */ ;
                            var6_12 = new ByteArrayOutputStream();
                            var0 = var3_5 /* !! */ ;
lbl37: // 2 sources:
                            var2_8 /* !! */  = var0;
                            if (var1_11 >= var5_10.size()) ** GOTO lbl70
                            var2_8 /* !! */  = var0;
                            var7_13 = PdfReader.getPdfObjectRelease(var5_10.getPdfObject(var1_11));
                            var4_4 /* !! */  = var0;
                            if (var7_13 == null) break block24;
                            var2_8 /* !! */  = var0;
                            if (!var7_13.isStream()) {
                                var4_4 /* !! */  = var0;
                                break block24;
                            }
                            var3_5 /* !! */  = var0;
                            if (var0 != null) break block25;
                            var2_8 /* !! */  = var0;
                            var0 = ((PRStream)var7_13).getReader().getSafeFile();
                            try {
                                var0.reOpen();
                                var3_5 /* !! */  = var0;
                            }
                            catch (Throwable var3_7) {
                                var2_8 /* !! */  = var0;
                                var0 = var3_7;
                                break block26;
                            }
                        }
                        var2_8 /* !! */  = var3_5 /* !! */ ;
                        var6_12.write(PdfReader.getStreamBytes((PRStream)var7_13, (RandomAccessFileOrArray)var3_5 /* !! */ ));
                        var2_8 /* !! */  = var3_5 /* !! */ ;
                        var4_4 /* !! */  = var3_5 /* !! */ ;
                        if (var1_11 != var5_10.size() - 1) {
                            var2_8 /* !! */  = var3_5 /* !! */ ;
                            var6_12.write(10);
                            var4_4 /* !! */  = var3_5 /* !! */ ;
                        }
                        break block24;
lbl70: // 1 sources:
                        var2_8 /* !! */  = var0;
                        var3_5 /* !! */  = var6_12.toByteArray();
                        if (var0 == null) break block27;
                        try {
                            var0.close();
                        }
                        catch (Exception var0_3) {
                            return var3_5 /* !! */ ;
                        }
                    }
                    return var3_5 /* !! */ ;
                }
                return new byte[0];
                catch (Throwable var0_1) {
                    // empty catch block
                }
            }
            if (var2_8 /* !! */  != null) {
                var2_8 /* !! */ .close();
            }
lbl85: // 4 sources:
            do {
                throw var0;
                break;
            } while (true);
            catch (Exception var0_2) {
                return var2_8 /* !! */ ;
            }
            catch (Exception var2_9) {
                ** continue;
            }
        }
        ++var1_11;
        var0 = var4_4 /* !! */ ;
        ** GOTO lbl37
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static PdfObject getPdfObject(PdfObject pdfObject) {
        if (pdfObject == null) {
            return null;
        }
        if (!pdfObject.isIndirect()) {
            return pdfObject;
        }
        try {
            PRIndirectReference pRIndirectReference = (PRIndirectReference)pdfObject;
            int n2 = pRIndirectReference.getNumber();
            boolean bl2 = pRIndirectReference.getReader().appendable;
            pdfObject = pRIndirectReference.getReader().getPdfObject(n2);
            if (pdfObject == null) {
                return null;
            }
            PdfObject pdfObject2 = pdfObject;
            if (!bl2) return pdfObject2;
            n2 = pdfObject.type();
            if (n2 != 1) {
                if (n2 != 4) {
                    if (n2 == 8) {
                        pdfObject = new PdfNull();
                    }
                } else {
                    pdfObject = new PdfName(pdfObject.getBytes());
                }
            } else {
                pdfObject = new PdfBoolean(((PdfBoolean)pdfObject).booleanValue());
            }
            pdfObject.setIndRef(pRIndirectReference);
            return pdfObject;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public static PdfObject getPdfObject(PdfObject pdfObject, PdfObject pdfObject2) {
        if (pdfObject == null) {
            return null;
        }
        if (!pdfObject.isIndirect()) {
            PdfObject pdfObject3 = pdfObject;
            if (pdfObject2 != null) {
                pdfObject2 = pdfObject2.getIndRef();
                pdfObject3 = pdfObject;
                if (pdfObject2 != null) {
                    pdfObject3 = pdfObject;
                    if (pdfObject2.getReader().isAppendable()) {
                        int n2 = pdfObject.type();
                        if (n2 != 1) {
                            if (n2 != 4) {
                                if (n2 == 8) {
                                    pdfObject = new PdfNull();
                                }
                            } else {
                                pdfObject = new PdfName(pdfObject.getBytes());
                            }
                        } else {
                            pdfObject = new PdfBoolean(((PdfBoolean)pdfObject).booleanValue());
                        }
                        pdfObject.setIndRef((PRIndirectReference)pdfObject2);
                        pdfObject3 = pdfObject;
                    }
                }
            }
            return pdfObject3;
        }
        return PdfReader.getPdfObject(pdfObject);
    }

    public static PdfObject getPdfObjectRelease(PdfObject pdfObject) {
        PdfObject pdfObject2 = PdfReader.getPdfObject(pdfObject);
        PdfReader.releaseLastXrefPartial(pdfObject);
        return pdfObject2;
    }

    public static PdfObject getPdfObjectRelease(PdfObject pdfObject, PdfObject pdfObject2) {
        pdfObject2 = PdfReader.getPdfObject(pdfObject, pdfObject2);
        PdfReader.releaseLastXrefPartial(pdfObject);
        return pdfObject2;
    }

    public static byte[] getStreamBytes(PRStream arrby) {
        RandomAccessFileOrArray randomAccessFileOrArray = arrby.getReader().getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            arrby = PdfReader.getStreamBytes((PRStream)arrby, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public static byte[] getStreamBytes(PRStream pRStream, RandomAccessFileOrArray randomAccessFileOrArray) {
        return PdfReader.decodeBytes(PdfReader.getStreamBytesRaw(pRStream, randomAccessFileOrArray), pRStream);
    }

    public static byte[] getStreamBytesRaw(PRStream arrby) {
        RandomAccessFileOrArray randomAccessFileOrArray = arrby.getReader().getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            arrby = PdfReader.getStreamBytesRaw((PRStream)arrby, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public static byte[] getStreamBytesRaw(PRStream pRStream, RandomAccessFileOrArray arrayList) {
        Object object = pRStream.getReader();
        if (pRStream.getOffset() < 0L) {
            return pRStream.getBytes();
        }
        byte[] arrby = new byte[pRStream.getLength()];
        arrayList.seek(pRStream.getOffset());
        arrayList.readFully(arrby);
        PdfEncryption pdfEncryption = object.getDecrypt();
        if (pdfEncryption != null) {
            boolean bl2;
            PdfObject pdfObject = PdfReader.getPdfObjectRelease(pRStream.get(PdfName.FILTER));
            object = new ArrayList();
            arrayList = object;
            if (pdfObject != null) {
                if (pdfObject.isName()) {
                    object.add(pdfObject);
                    arrayList = object;
                } else {
                    arrayList = object;
                    if (pdfObject.isArray()) {
                        arrayList = ((PdfArray)pdfObject).getArrayList();
                    }
                }
            }
            boolean bl3 = false;
            int n2 = 0;
            do {
                bl2 = bl3;
                if (n2 >= arrayList.size()) break;
                object = PdfReader.getPdfObjectRelease(arrayList.get(n2));
                if (object != null && object.toString().equals("/Crypt")) {
                    bl2 = true;
                    break;
                }
                ++n2;
            } while (true);
            if (!bl2) {
                pdfEncryption.setHashKey(pRStream.getObjNum(), pRStream.getObjGen());
                return pdfEncryption.decryptByteArray(arrby);
            }
        }
        return arrby;
    }

    static String getSubsetPrefix(PdfDictionary object) {
        if (object == null) {
            return null;
        }
        if ((object = PdfReader.getFontName((PdfDictionary)object)) == null) {
            return null;
        }
        if (object.length() >= 8) {
            if (object.charAt(6) != '+') {
                return null;
            }
            for (int i2 = 0; i2 < 6; ++i2) {
                char c2 = object.charAt(i2);
                if (c2 >= 'A') {
                    if (c2 <= 'Z') continue;
                    return null;
                }
                return null;
            }
            return object;
        }
        return null;
    }

    private void iterateBookmarks(PdfObject pdfObject, HashMap<Object, PdfObject> hashMap) {
        while (pdfObject != null) {
            this.replaceNamedDestination(pdfObject, hashMap);
            pdfObject = (PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject);
            PdfObject pdfObject2 = pdfObject.get(PdfName.FIRST);
            if (pdfObject2 != null) {
                this.iterateBookmarks(pdfObject2, hashMap);
            }
            pdfObject = pdfObject.get(PdfName.NEXT);
        }
    }

    public static PdfObject killIndirect(PdfObject pdfObject) {
        if (pdfObject != null) {
            if (pdfObject.isNull()) {
                return null;
            }
            PdfObject pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject);
            if (pdfObject.isIndirect()) {
                pdfObject = (PRIndirectReference)pdfObject;
                PdfReader pdfReader = pdfObject.getReader();
                int n2 = pdfObject.getNumber();
                pdfReader.xrefObj.set(n2, null);
                if (pdfReader.partial) {
                    pdfReader.xref[n2 * 2] = -1L;
                }
            }
            return pdfObject2;
        }
        return null;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void readDecryptedDocObj() {
        block70 : {
            block71 : {
                block68 : {
                    block73 : {
                        block72 : {
                            block69 : {
                                block65 : {
                                    block66 : {
                                        block67 : {
                                            block63 : {
                                                block64 : {
                                                    if (this.encrypted) {
                                                        return;
                                                    }
                                                    var12_1 = this.trailer.get(PdfName.ENCRYPT);
                                                    if (var12_1 == null) return;
                                                    if (var12_1.toString().equals("null")) {
                                                        return;
                                                    }
                                                    this.encryptionError = true;
                                                    this.encrypted = true;
                                                    var13_2 = (PdfDictionary)PdfReader.getPdfObject(var12_1);
                                                    var7_3 = var13_2.getAsDict(PdfName.CF);
                                                    if (var7_3 != null && (var7_3 = var7_3.getAsDict(PdfName.STDCF)) != null && (var7_3 = var7_3.getAsName(PdfName.AUTHEVENT)) != null && var7_3.compareTo(PdfName.EFOPEN) == 0 && !this.ownerPasswordUsed) {
                                                        return;
                                                    }
                                                    var9_8 = this.trailer.getAsArray(PdfName.ID);
                                                    if (var9_8 != null) {
                                                        var7_3 = var9_8.getPdfObject(0);
                                                        this.strings.remove(var7_3);
                                                        var7_3 = var8_9 = DocWriter.getISOBytes(var7_3.toString());
                                                        if (var9_8.size() > 1) {
                                                            this.strings.remove(var9_8.getPdfObject(1));
                                                            var7_3 = var8_9;
                                                        }
                                                    } else {
                                                        var7_3 = null;
                                                    }
                                                    var10_10 = var7_3;
                                                    if (var7_3 == null) {
                                                        var10_10 = new byte[]{};
                                                    }
                                                    var14_11 = PdfReader.getPdfObjectRelease(var13_2.get(PdfName.FILTER));
                                                    var6_12 = var14_11.equals(PdfName.STANDARD);
                                                    var1_13 = 40;
                                                    var2_14 = 128;
                                                    if (!var6_12) break block64;
                                                    var7_3 = var13_2.get(PdfName.U).toString();
                                                    this.strings.remove(var13_2.get(PdfName.U));
                                                    var7_3 = DocWriter.getISOBytes((String)var7_3);
                                                    var8_9 = var13_2.get(PdfName.O).toString();
                                                    this.strings.remove(var13_2.get(PdfName.O));
                                                    var8_9 = DocWriter.getISOBytes((String)var8_9);
                                                    if (var13_2.contains(PdfName.OE)) {
                                                        this.strings.remove(var13_2.get(PdfName.OE));
                                                    }
                                                    if (var13_2.contains(PdfName.UE)) {
                                                        this.strings.remove(var13_2.get(PdfName.UE));
                                                    }
                                                    if (var13_2.contains(PdfName.PERMS)) {
                                                        this.strings.remove(var13_2.get(PdfName.PERMS));
                                                    }
                                                    if ((var9_8 = var13_2.get(PdfName.P)).isNumber() == false) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.p.value", new Object[0]));
                                                    this.pValue = ((PdfNumber)var9_8).longValue();
                                                    var9_8 = var13_2.get(PdfName.R);
                                                    if (var9_8.isNumber() == false) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.r.value", new Object[0]));
                                                    this.rValue = ((PdfNumber)var9_8).intValue();
                                                    switch (this.rValue) {
                                                        default: {
                                                            throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("unknown.encryption.type.r.eq.1", this.rValue));
                                                        }
                                                        case 5: {
                                                            var9_8 = var13_2.get(PdfName.ENCRYPTMETADATA);
                                                            if (var9_8 != null && var9_8.toString().equals("false")) {
                                                                var1_13 = 11;
                                                                ** break;
                                                            }
                                                            var1_13 = 3;
                                                            ** break;
                                                        }
                                                        case 4: {
                                                            var9_8 = (PdfDictionary)var13_2.get(PdfName.CF);
                                                            if (var9_8 == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage("cf.not.found.encryption", new Object[0]));
                                                            if ((var9_8 = (PdfDictionary)var9_8.get(PdfName.STDCF)) == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage("stdcf.not.found.encryption", new Object[0]));
                                                            if (PdfName.V2.equals(var9_8.get(PdfName.CFM))) {
                                                                var1_13 = 1;
                                                            } else {
                                                                if (PdfName.AESV2.equals(var9_8.get(PdfName.CFM)) == false) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("no.compatible.encryption.found", new Object[0]));
                                                                var1_13 = 2;
                                                            }
                                                            var9_8 = var13_2.get(PdfName.ENCRYPTMETADATA);
                                                            if (var9_8 != null && var9_8.toString().equals("false")) {
                                                                var1_13 |= 8;
                                                                ** break;
                                                            }
                                                            var11_15 = null;
                                                            var2_14 = 0;
                                                            var9_8 = var8_9;
                                                            var8_9 = var11_15;
                                                            break block65;
                                                        }
                                                        case 3: {
                                                            var9_8 = var13_2.get(PdfName.LENGTH);
                                                            if (var9_8.isNumber() == false) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            var2_14 = ((PdfNumber)var9_8).intValue();
                                                            if (var2_14 > 128) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            if (var2_14 < 40) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            if (var2_14 % 8 != 0) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            var9_8 = var8_9;
                                                            var8_9 = null;
                                                            var1_13 = 1;
                                                            break block65;
                                                        }
                                                        case 2: 
                                                    }
                                                    var1_13 = 0;
lbl89: // 4 sources:
                                                    var9_8 = var8_9;
                                                    var8_9 = null;
                                                    var2_14 = 0;
                                                    break block65;
                                                }
                                                if (var14_11.equals(PdfName.PUBSEC)) {
                                                    var7_3 = var13_2.get(PdfName.V);
                                                    if (var7_3.isNumber() == false) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.v.value", new Object[0]));
                                                    var3_16 = ((PdfNumber)var7_3).intValue();
                                                    switch (var3_16) {
                                                        default: {
                                                            throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("unknown.encryption.type.v.eq.1", var3_16));
                                                        }
                                                        case 4: 
                                                        case 5: {
                                                            var7_3 = (PdfDictionary)var13_2.get(PdfName.CF);
                                                            if (var7_3 == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage("cf.not.found.encryption", new Object[0]));
                                                            if ((var7_3 = (PdfDictionary)var7_3.get(PdfName.DEFAULTCRYPTFILTER)) == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage("defaultcryptfilter.not.found.encryption", new Object[0]));
                                                            if (PdfName.V2.equals(var7_3.get(PdfName.CFM))) {
                                                                var1_13 = 1;
                                                            } else if (PdfName.AESV2.equals(var7_3.get(PdfName.CFM))) {
                                                                var1_13 = 2;
                                                            } else {
                                                                if (PdfName.AESV3.equals(var7_3.get(PdfName.CFM)) == false) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("no.compatible.encryption.found", new Object[0]));
                                                                var2_14 = 256;
                                                                var1_13 = 3;
                                                            }
                                                            var8_9 = var7_3.get(PdfName.ENCRYPTMETADATA);
                                                            var3_16 = var1_13;
                                                            if (var8_9 != null) {
                                                                var3_16 = var1_13;
                                                                if (var8_9.toString().equals("false")) {
                                                                    var3_16 = var1_13 | 8;
                                                                }
                                                            }
                                                            var7_3 = (PdfArray)var7_3.get(PdfName.RECIPIENTS);
                                                            var1_13 = var2_14;
                                                            var2_14 = var3_16;
                                                            ** break;
                                                        }
                                                        case 2: {
                                                            var7_3 = var13_2.get(PdfName.LENGTH);
                                                            if (var7_3.isNumber() == false) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            var1_13 = ((PdfNumber)var7_3).intValue();
                                                            if (var1_13 > 128) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            if (var1_13 < 40) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            if (var1_13 % 8 != 0) throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.length.value", new Object[0]));
                                                            var7_3 = (PdfArray)var13_2.get(PdfName.RECIPIENTS);
                                                            var2_14 = 1;
                                                            ** break;
                                                        }
                                                        case 1: 
                                                    }
                                                    var7_3 = (PdfArray)var13_2.get(PdfName.RECIPIENTS);
                                                    var2_14 = 0;
lbl137: // 3 sources:
                                                    try {
                                                        var11_15 = new X509CertificateHolder(this.certificate.getEncoded());
                                                        if (this.externalDecryptionProcess == null) {
                                                            var3_16 = 0;
                                                            var8_9 = null;
                                                            break block63;
                                                        }
                                                        var4_17 = 0;
                                                        var3_16 = 0;
                                                        var8_9 = null;
                                                    }
                                                    catch (Exception var7_7) {
                                                        throw new ExceptionConverter(var7_7);
                                                    }
                                                }
                                                var8_9 = null;
                                                var1_13 = 0;
                                                var2_14 = 0;
                                                break block66;
                                            }
                                            for (var4_17 = 0; var4_17 < var7_3.size(); ++var4_17) {
                                                var9_8 = var7_3.getPdfObject(var4_17);
                                                this.strings.remove(var9_8);
                                                try {
                                                    for (RecipientInformation var16_20 : new CMSEnvelopedData(var9_8.getBytes()).getRecipientInfos().getRecipients()) {
                                                        var5_18 = var3_16;
                                                        var9_8 = var8_9;
                                                        if (var16_20.getRID().match((Object)var11_15)) {
                                                            var5_18 = var3_16;
                                                            var9_8 = var8_9;
                                                            if (var3_16 == 0) {
                                                                var9_8 = PdfEncryptor.getContent(var16_20, (PrivateKey)this.certificateKey, this.certificateKeyProvider);
                                                                var5_18 = 1;
                                                            }
                                                        }
                                                        var3_16 = var5_18;
                                                        var8_9 = var9_8;
                                                    }
                                                    continue;
                                                }
                                                catch (Exception var7_4) {
                                                    throw new ExceptionConverter(var7_4);
                                                }
                                            }
                                            var5_18 = var3_16;
                                            var9_8 = var8_9;
                                            break block67;
                                            do {
                                                var5_18 = var3_16;
                                                var9_8 = var8_9;
                                                if (var4_17 >= var7_3.size()) break;
                                                var9_8 = var7_3.getPdfObject(var4_17);
                                                this.strings.remove(var9_8);
                                                try {
                                                    var9_8 = new CMSEnvelopedData(var9_8.getBytes()).getRecipientInfos().get(this.externalDecryptionProcess.getCmsRecipientId());
                                                    if (var9_8 != null) {
                                                        var8_9 = var9_8.getContent(this.externalDecryptionProcess.getCmsRecipient());
                                                        var3_16 = 1;
                                                    }
                                                    ++var4_17;
                                                }
                                                catch (Exception var7_5) {
                                                    throw new ExceptionConverter(var7_5);
                                                }
                                            } while (true);
                                        }
                                        if (var5_18 == 0) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("bad.certificate.and.key", new Object[0]));
                                        if (var9_8 == null) throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("bad.certificate.and.key", new Object[0]));
                                        var8_9 = (var2_14 & 7) == 3 ? "SHA-256" : "SHA-1";
                                        var8_9 = MessageDigest.getInstance((String)var8_9);
                                        var8_9.update((byte[])var9_8, 0, 20);
                                        for (var3_16 = 0; var3_16 < var7_3.size(); ++var3_16) {
                                            var8_9.update(var7_3.getPdfObject(var3_16).getBytes());
                                        }
                                        if ((var2_14 & 8) == 0) ** GOTO lbl205
                                        try {
                                            var8_9.update(new byte[]{-1, -1, -1, -1});
lbl205: // 2 sources:
                                            var8_9 = var8_9.digest();
                                            var3_16 = var1_13;
                                            var1_13 = var2_14;
                                            var2_14 = var3_16;
                                        }
                                        catch (Exception var7_6) {
                                            throw new ExceptionConverter(var7_6);
                                        }
                                    }
                                    var7_3 = null;
                                    var9_8 = null;
                                }
                                this.decrypt = new PdfEncryption();
                                this.decrypt.setCryptoMode(var1_13, var2_14);
                                if (!var14_11.equals(PdfName.STANDARD)) break block68;
                                if (this.rValue != 5) break block69;
                                this.ownerPasswordUsed = this.decrypt.readKey(var13_2, this.password);
                                this.decrypt.documentID = var10_10;
                                this.pValue = this.decrypt.getPermissions();
                                break block70;
                            }
                            this.decrypt.setupByOwnerPassword(var10_10, this.password, (byte[])var7_3, (byte[])var9_8, this.pValue);
                            var8_9 = this.decrypt.userKey;
                            var1_13 = this.rValue;
                            var2_14 = 32;
                            var1_13 = var1_13 != 3 && this.rValue != 4 ? 32 : 16;
                            if (this.equalsArray((byte[])var7_3, (byte[])var8_9, var1_13)) break block71;
                            this.decrypt.setupByUserPassword(var10_10, this.password, (byte[])var9_8, this.pValue);
                            var8_9 = this.decrypt.userKey;
                            if (this.rValue == 3) break block72;
                            var1_13 = var2_14;
                            if (this.rValue != 4) break block73;
                        }
                        var1_13 = 16;
                    }
                    if (this.equalsArray((byte[])var7_3, (byte[])var8_9, var1_13) == false) throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
                    break block70;
                }
                if (!var14_11.equals(PdfName.PUBSEC)) break block70;
                if ((var1_13 & 7) == 3) {
                    this.decrypt.setKey((byte[])var8_9);
                } else {
                    this.decrypt.setupByEncryptionKey((byte[])var8_9, var2_14);
                }
            }
            this.ownerPasswordUsed = true;
        }
        for (var1_13 = 0; var1_13 < this.strings.size(); ++var1_13) {
            this.strings.get(var1_13).decrypt(this);
        }
        if (var12_1.isIndirect()) {
            this.cryptoRef = (PRIndirectReference)var12_1;
            this.xrefObj.set(this.cryptoRef.getNumber(), null);
        }
        this.encryptionError = false;
        return;
    }

    public static void releaseLastXrefPartial(PdfObject pdfObject) {
        if (pdfObject == null) {
            return;
        }
        if (!pdfObject.isIndirect()) {
            return;
        }
        if (!(pdfObject instanceof PRIndirectReference)) {
            return;
        }
        pdfObject = (PRIndirectReference)pdfObject;
        PdfReader pdfReader = pdfObject.getReader();
        if (pdfReader.partial && pdfReader.lastXrefPartial != -1 && pdfReader.lastXrefPartial == pdfObject.getNumber()) {
            pdfReader.xrefObj.set(pdfReader.lastXrefPartial, null);
        }
        pdfReader.lastXrefPartial = -1;
    }

    /*
     * Enabled aggressive block sorting
     */
    private boolean replaceNamedDestination(PdfObject object, HashMap<Object, PdfObject> hashMap) {
        block8 : {
            PdfObject pdfObject;
            int n2;
            block10 : {
                PdfObject pdfObject2;
                Object var5_6;
                block9 : {
                    pdfObject = PdfReader.getPdfObject((PdfObject)object);
                    n2 = this.lastXrefPartial;
                    this.releaseLastXrefPartial();
                    if (pdfObject == null || !pdfObject.isDictionary()) break block8;
                    pdfObject2 = (PdfDictionary)pdfObject;
                    object = PdfReader.getPdfObjectRelease(pdfObject2.get(PdfName.DEST));
                    var5_6 = null;
                    if (object == null) break block9;
                    if (!object.isName()) {
                        object = object.isString() ? object.toString() : null;
                    }
                    if ((object = (PdfArray)hashMap.get(object)) == null) break block8;
                    pdfObject2.put(PdfName.DEST, (PdfObject)object);
                    break block10;
                }
                PdfObject pdfObject3 = PdfReader.getPdfObject(pdfObject2.get(PdfName.A));
                if (pdfObject3 == null) break block8;
                int n3 = this.lastXrefPartial;
                this.releaseLastXrefPartial();
                PdfDictionary pdfDictionary = (PdfDictionary)pdfObject3;
                object = (PdfName)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.S));
                if (!PdfName.GOTO.equals(object)) break block8;
                pdfObject2 = PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.D));
                object = var5_6;
                if (pdfObject2 != null) {
                    if (pdfObject2.isName()) {
                        object = pdfObject2;
                    } else {
                        object = var5_6;
                        if (pdfObject2.isString()) {
                            object = pdfObject2.toString();
                        }
                    }
                }
                if ((object = (PdfArray)hashMap.get(object)) == null) break block8;
                pdfDictionary.put(PdfName.D, (PdfObject)object);
                this.setXrefPartialObject(n3, pdfObject3);
            }
            this.setXrefPartialObject(n2, pdfObject);
            return true;
        }
        return false;
    }

    private void setXrefPartialObject(int n2, PdfObject pdfObject) {
        if (this.partial) {
            if (n2 < 0) {
                return;
            }
            this.xrefObj.set(n2, pdfObject);
        }
    }

    public PRIndirectReference addPdfObject(PdfObject pdfObject) {
        this.xrefObj.add(pdfObject);
        return new PRIndirectReference(this, this.xrefObj.size() - 1);
    }

    @Override
    public void addViewerPreference(PdfName pdfName, PdfObject pdfObject) {
        this.viewerPreferences.addViewerPreference(pdfName, pdfObject);
        this.setViewerPreferences(this.viewerPreferences);
    }

    public void close() {
        try {
            this.tokens.close();
            return;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public byte[] computeUserPassword() {
        if (this.encrypted && this.ownerPasswordUsed) {
            return this.decrypt.computeUserPassword(this.password);
        }
        return null;
    }

    /*
     * Enabled aggressive block sorting
     */
    public void consolidateNamedDestinations() {
        PdfObject pdfObject;
        if (this.consolidateNamedDestinations) {
            return;
        }
        this.consolidateNamedDestinations = true;
        HashMap<Object, PdfObject> hashMap = this.getNamedDestination(true);
        if (hashMap.isEmpty()) {
            return;
        }
        for (int i2 = 1; i2 <= this.pageRefs.size(); ++i2) {
            pdfObject = this.pageRefs.getPageN(i2).get(PdfName.ANNOTS);
            PdfArray pdfArray = (PdfArray)PdfReader.getPdfObject(pdfObject);
            int n2 = this.lastXrefPartial;
            this.releaseLastXrefPartial();
            if (pdfArray != null) {
                boolean bl2 = false;
                for (int i3 = 0; i3 < pdfArray.size(); ++i3) {
                    PdfObject pdfObject2 = pdfArray.getPdfObject(i3);
                    boolean bl3 = bl2;
                    if (this.replaceNamedDestination(pdfObject2, hashMap)) {
                        bl3 = bl2;
                        if (!pdfObject2.isIndirect()) {
                            bl3 = true;
                        }
                    }
                    bl2 = bl3;
                }
            }
            this.pageRefs.releasePage(i2);
        }
        pdfObject = (PdfDictionary)PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.OUTLINES));
        if (pdfObject == null) {
            return;
        }
        this.iterateBookmarks(pdfObject.get(PdfName.FIRST), hashMap);
    }

    public int createFakeFontSubsets() {
        int n2 = 0;
        for (int i2 = 1; i2 < this.xrefObj.size(); ++i2) {
            int n3;
            block12 : {
                PdfObject pdfObject;
                block15 : {
                    block14 : {
                        block13 : {
                            pdfObject = this.getPdfObjectRelease(i2);
                            n3 = n2;
                            if (pdfObject == null) break block12;
                            if (pdfObject.isDictionary()) break block13;
                            n3 = n2;
                            break block12;
                        }
                        if (PdfReader.existsName((PdfDictionary)(pdfObject = (PdfDictionary)pdfObject), PdfName.TYPE, PdfName.FONT)) break block14;
                        n3 = n2;
                        break block12;
                    }
                    if (PdfReader.existsName((PdfDictionary)pdfObject, PdfName.SUBTYPE, PdfName.TYPE1) || PdfReader.existsName((PdfDictionary)pdfObject, PdfName.SUBTYPE, PdfName.MMTYPE1)) break block15;
                    n3 = n2;
                    if (!PdfReader.existsName((PdfDictionary)pdfObject, PdfName.SUBTYPE, PdfName.TRUETYPE)) break block12;
                }
                if (PdfReader.getSubsetPrefix((PdfDictionary)pdfObject) != null) {
                    n3 = n2;
                } else {
                    Object object = PdfReader.getFontName((PdfDictionary)pdfObject);
                    if (object == null) {
                        n3 = n2;
                    } else {
                        Serializable serializable = new StringBuilder();
                        serializable.append(BaseFont.createSubsetPrefix());
                        serializable.append((String)object);
                        object = serializable.toString();
                        serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.FONTDESCRIPTOR));
                        if (serializable == null) {
                            n3 = n2;
                        } else if (serializable.get(PdfName.FONTFILE) == null && serializable.get(PdfName.FONTFILE2) == null && serializable.get(PdfName.FONTFILE3) == null) {
                            n3 = n2;
                        } else {
                            serializable = pdfObject.getAsDict(PdfName.FONTDESCRIPTOR);
                            object = new PdfName((String)object);
                            pdfObject.put(PdfName.BASEFONT, (PdfObject)object);
                            serializable.put(PdfName.FONTNAME, (PdfObject)object);
                            this.setXrefPartialObject(i2, pdfObject);
                            n3 = n2 + 1;
                        }
                    }
                }
            }
            n2 = n3;
        }
        return n2;
    }

    public double dumpPerc() {
        int n2 = 0;
        for (int i2 = 0; i2 < this.xrefObj.size(); ++i2) {
            int n3 = n2;
            if (this.xrefObj.get(i2) != null) {
                n3 = n2 + 1;
            }
            n2 = n3;
        }
        return (double)n2 * 100.0 / (double)this.xrefObj.size();
    }

    public void eliminateSharedStreams() {
        int n2;
        if (!this.sharedStreams) {
            return;
        }
        this.sharedStreams = false;
        if (this.pageRefs.size() == 1) {
            return;
        }
        ArrayList<PdfObject> arrayList = new ArrayList<PdfObject>();
        ArrayList<PRStream> arrayList2 = new ArrayList<PRStream>();
        IntHashtable intHashtable = new IntHashtable();
        for (n2 = 1; n2 <= this.pageRefs.size(); ++n2) {
            PdfObject pdfObject;
            PdfObject pdfObject2 = this.pageRefs.getPageN(n2);
            if (pdfObject2 == null || (pdfObject = PdfReader.getPdfObject(pdfObject2.get(PdfName.CONTENTS))) == null) continue;
            if (pdfObject.isStream()) {
                if (intHashtable.containsKey((pdfObject2 = (PRIndirectReference)pdfObject2.get(PdfName.CONTENTS)).getNumber())) {
                    arrayList.add(pdfObject2);
                    arrayList2.add(new PRStream((PRStream)pdfObject, null));
                    continue;
                }
                intHashtable.put(pdfObject2.getNumber(), 1);
                continue;
            }
            if (!pdfObject.isArray()) continue;
            pdfObject = (PdfArray)pdfObject;
            for (int i2 = 0; i2 < pdfObject.size(); ++i2) {
                pdfObject2 = (PRIndirectReference)pdfObject.getPdfObject(i2);
                if (intHashtable.containsKey(pdfObject2.getNumber())) {
                    arrayList.add(pdfObject2);
                    arrayList2.add(new PRStream((PRStream)PdfReader.getPdfObject(pdfObject2), null));
                    continue;
                }
                intHashtable.put(pdfObject2.getNumber(), 1);
            }
        }
        if (arrayList2.isEmpty()) {
            return;
        }
        for (n2 = 0; n2 < arrayList2.size(); ++n2) {
            this.xrefObj.add((PdfObject)arrayList2.get(n2));
            ((PRIndirectReference)arrayList.get(n2)).setNumber(this.xrefObj.size() - 1, 0);
        }
    }

    public AcroFields getAcroFields() {
        return new AcroFields(this, null);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public PRAcroForm getAcroForm() {
        if (this.acroFormParsed) return this.acroForm;
        this.acroFormParsed = true;
        PdfObject pdfObject = this.catalog.get(PdfName.ACROFORM);
        if (pdfObject == null) return this.acroForm;
        try {
            this.acroForm = new PRAcroForm(this);
            this.acroForm.readAcroForm((PdfDictionary)PdfReader.getPdfObject(pdfObject));
            return this.acroForm;
        }
        catch (Exception exception) {}
        this.acroForm = null;
        return this.acroForm;
    }

    /*
     * Enabled aggressive block sorting
     */
    public Rectangle getBoxSize(int n2, String object) {
        PdfDictionary pdfDictionary = this.pageRefs.getPageNRelease(n2);
        if (object.equals("trim")) {
            object = PdfName.TRIMBOX;
        } else if (object.equals("art")) {
            object = PdfName.ARTBOX;
        } else if (object.equals("bleed")) {
            object = PdfName.BLEEDBOX;
        } else if (object.equals("crop")) {
            object = PdfName.CROPBOX;
        } else {
            if (!object.equals("media")) {
                return null;
            }
            object = PdfName.MEDIABOX;
        }
        object = (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get((PdfName)object));
        if (object != null) {
            return PdfReader.getNormalizedRectangle((PdfArray)object);
        }
        return null;
    }

    public PdfDictionary getCatalog() {
        return this.catalog;
    }

    public int getCertificationLevel() {
        PdfObject pdfObject = this.catalog.getAsDict(PdfName.PERMS);
        if (pdfObject == null) {
            return 0;
        }
        if ((pdfObject = pdfObject.getAsDict(PdfName.DOCMDP)) == null) {
            return 0;
        }
        if ((pdfObject = pdfObject.getAsArray(PdfName.REFERENCE)) != null) {
            if (pdfObject.size() == 0) {
                return 0;
            }
            if ((pdfObject = pdfObject.getAsDict(0)) == null) {
                return 0;
            }
            if ((pdfObject = pdfObject.getAsDict(PdfName.TRANSFORMPARAMS)) == null) {
                return 0;
            }
            if ((pdfObject = pdfObject.getAsNumber(PdfName.P)) == null) {
                return 0;
            }
            return pdfObject.intValue();
        }
        return 0;
    }

    protected Counter getCounter() {
        return COUNTER;
    }

    public Rectangle getCropBox(int n2) {
        PdfDictionary pdfDictionary = this.pageRefs.getPageNRelease(n2);
        PdfArray pdfArray = (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.CROPBOX));
        if (pdfArray == null) {
            return this.getPageSize(pdfDictionary);
        }
        return PdfReader.getNormalizedRectangle(pdfArray);
    }

    public int getCryptoMode() {
        if (this.decrypt == null) {
            return -1;
        }
        return this.decrypt.getCryptoMode();
    }

    PdfIndirectReference getCryptoRef() {
        if (this.cryptoRef == null) {
            return null;
        }
        return new PdfIndirectReference(0, this.cryptoRef.getNumber(), this.cryptoRef.getGeneration());
    }

    PdfEncryption getDecrypt() {
        return this.decrypt;
    }

    public long getEofPos() {
        return this.eofPos;
    }

    public long getFileLength() {
        return this.fileLength;
    }

    public HashMap<String, String> getInfo() {
        HashMap<String, String> hashMap = new HashMap<String, String>();
        PdfDictionary pdfDictionary = this.trailer.getAsDict(PdfName.INFO);
        if (pdfDictionary == null) {
            return hashMap;
        }
        for (PdfName pdfName : pdfDictionary.getKeys()) {
            PdfObject pdfObject = PdfReader.getPdfObject(pdfDictionary.get(pdfName));
            if (pdfObject == null) continue;
            String string2 = pdfObject.toString();
            switch (pdfObject.type()) {
                default: {
                    break;
                }
                case 4: {
                    string2 = PdfName.decodeName(string2);
                    break;
                }
                case 3: {
                    string2 = ((PdfString)pdfObject).toUnicodeString();
                }
            }
            hashMap.put(PdfName.decodeName(pdfName.toString()), string2);
        }
        return hashMap;
    }

    public String getJavaScript() {
        RandomAccessFileOrArray randomAccessFileOrArray = this.getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            String string2 = this.getJavaScript(randomAccessFileOrArray);
            return string2;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    public String getJavaScript(RandomAccessFileOrArray randomAccessFileOrArray) {
        Object object = (String[])PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.NAMES));
        if (object == null) {
            return null;
        }
        if ((object = (PdfDictionary)PdfReader.getPdfObjectRelease(object.get(PdfName.JAVASCRIPT))) == null) {
            return null;
        }
        HashMap<String, PdfObject> hashMap = PdfNameTree.readTree((PdfDictionary)object);
        object = new String[hashMap.size()];
        Object[] arrobject = hashMap.keySet().toArray((T[])object);
        Arrays.sort(arrobject);
        StringBuffer stringBuffer = new StringBuffer();
        int n2 = 0;
        while (n2 < arrobject.length) {
            block6 : {
                block8 : {
                    block7 : {
                        object = (PdfDictionary)PdfReader.getPdfObjectRelease(hashMap.get(arrobject[n2]));
                        if (object == null || (object = PdfReader.getPdfObjectRelease(object.get(PdfName.JS))) == null) break block6;
                        if (!object.isString()) break block7;
                        object = ((PdfString)object).toUnicodeString();
                        break block8;
                    }
                    if (!object.isStream()) break block6;
                    byte[] arrby = PdfReader.getStreamBytes((PRStream)object, randomAccessFileOrArray);
                    object = arrby.length >= 2 && arrby[0] == -2 && arrby[1] == -1 ? "UnicodeBig" : "PDF";
                    object = PdfEncodings.convertToString(arrby, (String)object);
                }
                stringBuffer.append((String)object);
                stringBuffer.append('\n');
            }
            ++n2;
        }
        return stringBuffer.toString();
    }

    public long getLastXref() {
        return this.lastXref;
    }

    public ArrayList<PdfAnnotation.PdfImportedLink> getLinks(int n2) {
        this.pageRefs.resetReleasePage();
        ArrayList<PdfAnnotation.PdfImportedLink> arrayList = new ArrayList<PdfAnnotation.PdfImportedLink>();
        PdfObject pdfObject = this.pageRefs.getPageN(n2);
        if (pdfObject.get(PdfName.ANNOTS) != null) {
            pdfObject = pdfObject.getAsArray(PdfName.ANNOTS);
            for (int i2 = 0; i2 < pdfObject.size(); ++i2) {
                PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject.getPdfObject(i2));
                if (!PdfName.LINK.equals(pdfDictionary.get(PdfName.SUBTYPE))) continue;
                arrayList.add(new PdfAnnotation.PdfImportedLink(pdfDictionary));
            }
        }
        this.pageRefs.releasePage(n2);
        this.pageRefs.resetReleasePage();
        return arrayList;
    }

    public byte[] getMetadata() {
        byte[] arrby = PdfReader.getPdfObject(this.catalog.get(PdfName.METADATA));
        if (!(arrby instanceof PRStream)) {
            return null;
        }
        RandomAccessFileOrArray randomAccessFileOrArray = this.getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            arrby = PdfReader.getStreamBytes((PRStream)arrby, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public HashMap<Object, PdfObject> getNamedDestination() {
        return this.getNamedDestination(false);
    }

    public HashMap<Object, PdfObject> getNamedDestination(boolean bl2) {
        HashMap<Object, PdfObject> hashMap = this.getNamedDestinationFromNames(bl2);
        hashMap.putAll(this.getNamedDestinationFromStrings());
        return hashMap;
    }

    public HashMap<String, PdfObject> getNamedDestinationFromNames() {
        return new HashMap<Object, PdfObject>(this.getNamedDestinationFromNames(false));
    }

    /*
     * Enabled aggressive block sorting
     */
    public HashMap<Object, PdfObject> getNamedDestinationFromNames(boolean bl2) {
        HashMap<Object, PdfObject> hashMap = new HashMap<Object, PdfObject>();
        if (this.catalog.get(PdfName.DESTS) != null) {
            PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.DESTS));
            if (pdfDictionary == null) {
                return hashMap;
            }
            for (PdfName pdfName : pdfDictionary.getKeys()) {
                void var2_5;
                PdfArray pdfArray = PdfReader.getNameArray(pdfDictionary.get(pdfName));
                if (pdfArray == null) continue;
                if (!bl2) {
                    String string2 = PdfName.decodeName(pdfName.toString());
                }
                hashMap.put(var2_5, pdfArray);
            }
        }
        return hashMap;
    }

    public HashMap<String, PdfObject> getNamedDestinationFromStrings() {
        Serializable serializable;
        if (this.catalog.get(PdfName.NAMES) != null && (serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(this.catalog.get(PdfName.NAMES))) != null && (serializable = (PdfDictionary)PdfReader.getPdfObjectRelease(serializable.get(PdfName.DESTS))) != null) {
            serializable = PdfNameTree.readTree((PdfDictionary)serializable);
            Iterator iterator = serializable.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry entry = iterator.next();
                PdfArray pdfArray = PdfReader.getNameArray((PdfObject)entry.getValue());
                if (pdfArray != null) {
                    entry.setValue(pdfArray);
                    continue;
                }
                iterator.remove();
            }
            return serializable;
        }
        return new HashMap<String, PdfObject>();
    }

    public int getNumberOfPages() {
        return this.pageRefs.size();
    }

    public byte[] getPageContent(int n2) {
        RandomAccessFileOrArray randomAccessFileOrArray = this.getSafeFile();
        try {
            randomAccessFileOrArray.reOpen();
            byte[] arrby = this.getPageContent(n2, randomAccessFileOrArray);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    public byte[] getPageContent(int n2, RandomAccessFileOrArray randomAccessFileOrArray) {
        PdfObject pdfObject = this.getPageNRelease(n2);
        if (pdfObject == null) {
            return null;
        }
        pdfObject = PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.CONTENTS));
        if (pdfObject == null) {
            return new byte[0];
        }
        if (pdfObject.isStream()) {
            return PdfReader.getStreamBytes((PRStream)pdfObject, randomAccessFileOrArray);
        }
        if (pdfObject.isArray()) {
            pdfObject = (PdfArray)pdfObject;
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            for (n2 = 0; n2 < pdfObject.size(); ++n2) {
                PdfObject pdfObject2 = PdfReader.getPdfObjectRelease(pdfObject.getPdfObject(n2));
                if (pdfObject2 == null || !pdfObject2.isStream()) continue;
                byteArrayOutputStream.write(PdfReader.getStreamBytes((PRStream)pdfObject2, randomAccessFileOrArray));
                if (n2 == pdfObject.size() - 1) continue;
                byteArrayOutputStream.write(10);
            }
            return byteArrayOutputStream.toByteArray();
        }
        return new byte[0];
    }

    public PdfDictionary getPageN(int n2) {
        PdfDictionary pdfDictionary = this.pageRefs.getPageN(n2);
        if (pdfDictionary == null) {
            return null;
        }
        if (this.appendable) {
            pdfDictionary.setIndRef(this.pageRefs.getPageOrigRef(n2));
        }
        return pdfDictionary;
    }

    public PdfDictionary getPageNRelease(int n2) {
        PdfDictionary pdfDictionary = this.getPageN(n2);
        this.pageRefs.releasePage(n2);
        return pdfDictionary;
    }

    public PRIndirectReference getPageOrigRef(int n2) {
        return this.pageRefs.getPageOrigRef(n2);
    }

    public PdfDictionary getPageResources(int n2) {
        return this.getPageResources(this.getPageN(n2));
    }

    public PdfDictionary getPageResources(PdfDictionary pdfDictionary) {
        return pdfDictionary.getAsDict(PdfName.RESOURCES);
    }

    public int getPageRotation(int n2) {
        return this.getPageRotation(this.pageRefs.getPageNRelease(n2));
    }

    int getPageRotation(PdfDictionary pdfObject) {
        int n2;
        if ((pdfObject = pdfObject.getAsNumber(PdfName.ROTATE)) == null) {
            return 0;
        }
        int n3 = n2 = pdfObject.intValue() % 360;
        if (n2 < 0) {
            n3 = n2 + 360;
        }
        return n3;
    }

    public Rectangle getPageSize(int n2) {
        return this.getPageSize(this.pageRefs.getPageNRelease(n2));
    }

    public Rectangle getPageSize(PdfDictionary pdfDictionary) {
        return PdfReader.getNormalizedRectangle(pdfDictionary.getAsArray(PdfName.MEDIABOX));
    }

    public Rectangle getPageSizeWithRotation(int n2) {
        return this.getPageSizeWithRotation(this.pageRefs.getPageNRelease(n2));
    }

    public Rectangle getPageSizeWithRotation(PdfDictionary object) {
        Rectangle rectangle = this.getPageSize((PdfDictionary)object);
        int n2 = this.getPageRotation((PdfDictionary)object);
        object = rectangle;
        while (n2 > 0) {
            object = object.rotate();
            n2 -= 90;
        }
        return object;
    }

    public PdfObject getPdfObject(int n2) {
        block7 : {
            PdfObject pdfObject;
            block9 : {
                block12 : {
                    block11 : {
                        block10 : {
                            block8 : {
                                try {
                                    this.lastXrefPartial = -1;
                                    if (n2 < 0) break block7;
                                }
                                catch (Exception exception) {
                                    throw new ExceptionConverter(exception);
                                }
                                if (n2 < this.xrefObj.size()) break block8;
                                return null;
                            }
                            pdfObject = this.xrefObj.get(n2);
                            if (!this.partial) break block9;
                            if (pdfObject == null) break block10;
                            return pdfObject;
                        }
                        if (n2 * 2 < this.xref.length) break block11;
                        return null;
                    }
                    pdfObject = this.readSingleObject(n2);
                    this.lastXrefPartial = -1;
                    if (pdfObject == null) break block12;
                    this.lastXrefPartial = n2;
                }
                return pdfObject;
            }
            return pdfObject;
        }
        return null;
    }

    public PdfObject getPdfObjectRelease(int n2) {
        PdfObject pdfObject = this.getPdfObject(n2);
        this.releaseLastXrefPartial();
        return pdfObject;
    }

    protected PdfReaderInstance getPdfReaderInstance(PdfWriter pdfWriter) {
        return new PdfReaderInstance(this, pdfWriter);
    }

    public char getPdfVersion() {
        return this.pdfVersion;
    }

    public long getPermissions() {
        return this.pValue;
    }

    public RandomAccessFileOrArray getSafeFile() {
        return this.tokens.getSafeFile();
    }

    public int getSimpleViewerPreferences() {
        return PdfViewerPreferencesImp.getViewerPreferences(this.catalog).getPageLayoutAndMode();
    }

    public PdfDictionary getTrailer() {
        return this.trailer;
    }

    public int getXrefSize() {
        return this.xrefObj.size();
    }

    public boolean hasUsageRights() {
        PdfDictionary pdfDictionary = this.catalog.getAsDict(PdfName.PERMS);
        boolean bl2 = false;
        if (pdfDictionary == null) {
            return false;
        }
        if (pdfDictionary.contains(PdfName.UR) || pdfDictionary.contains(PdfName.UR3)) {
            bl2 = true;
        }
        return bl2;
    }

    public boolean is128Key() {
        if (this.rValue == 3) {
            return true;
        }
        return false;
    }

    public boolean isAppendable() {
        return this.appendable;
    }

    public boolean isEncrypted() {
        return this.encrypted;
    }

    public boolean isHybridXref() {
        return this.hybridXref;
    }

    public boolean isMetadataEncrypted() {
        if (this.decrypt == null) {
            return false;
        }
        return this.decrypt.isMetadataEncrypted();
    }

    public boolean isNewXrefType() {
        return this.newXrefType;
    }

    public final boolean isOpenedWithFullPermissions() {
        if (this.encrypted && !this.ownerPasswordUsed && !unethicalreading) {
            return false;
        }
        return true;
    }

    public boolean isRebuilt() {
        return this.rebuilt;
    }

    public boolean isTagged() {
        PdfDictionary pdfDictionary = this.catalog.getAsDict(PdfName.MARKINFO);
        boolean bl2 = false;
        if (pdfDictionary == null) {
            return false;
        }
        boolean bl3 = bl2;
        if (PdfBoolean.PDFTRUE.equals(pdfDictionary.getAsBoolean(PdfName.MARKED))) {
            bl3 = bl2;
            if (this.catalog.getAsDict(PdfName.STRUCTTREEROOT) != null) {
                bl3 = true;
            }
        }
        return bl3;
    }

    public boolean isTampered() {
        return this.tampered;
    }

    protected void killXref(PdfObject pdfObject) {
        block9 : {
            int n2;
            block8 : {
                if (pdfObject == null) {
                    return;
                }
                if (pdfObject instanceof PdfIndirectReference && !pdfObject.isIndirect()) {
                    return;
                }
                n2 = pdfObject.type();
                if (n2 == 10) break block8;
                block0 : switch (n2) {
                    default: {
                        return;
                    }
                    case 6: 
                    case 7: {
                        pdfObject = (PdfDictionary)pdfObject;
                        Iterator<PdfName> iterator = pdfObject.getKeys().iterator();
                        while (iterator.hasNext()) {
                            this.killXref(pdfObject.get(iterator.next()));
                        }
                        break block9;
                    }
                    case 5: {
                        pdfObject = (PdfArray)pdfObject;
                        n2 = 0;
                        while (n2 < pdfObject.size()) {
                            this.killXref(pdfObject.getPdfObject(n2));
                            ++n2;
                            break block0;
                        }
                        break block9;
                    }
                }
                {
                    continue;
                    break;
                }
            }
            n2 = ((PRIndirectReference)pdfObject).getNumber();
            pdfObject = this.xrefObj.get(n2);
            this.xrefObj.set(n2, null);
            this.freeXref = n2;
            this.killXref(pdfObject);
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    public void makeRemoteNamedDestinationsLocal() {
        if (this.remoteToLocalNamedDestinations) {
            return;
        }
        this.remoteToLocalNamedDestinations = true;
        HashMap<Object, PdfObject> hashMap = this.getNamedDestination(true);
        if (hashMap.isEmpty()) {
            return;
        }
        int n2 = 1;
        while (n2 <= this.pageRefs.size()) {
            PdfObject pdfObject = this.pageRefs.getPageN(n2).get(PdfName.ANNOTS);
            PdfArray pdfArray = (PdfArray)PdfReader.getPdfObject(pdfObject);
            int n3 = this.lastXrefPartial;
            this.releaseLastXrefPartial();
            if (pdfArray != null) {
                boolean bl2 = false;
                for (int i2 = 0; i2 < pdfArray.size(); ++i2) {
                    PdfObject pdfObject2 = pdfArray.getPdfObject(i2);
                    boolean bl3 = bl2;
                    if (this.convertNamedDestination(pdfObject2, hashMap)) {
                        bl3 = bl2;
                        if (!pdfObject2.isIndirect()) {
                            bl3 = true;
                        }
                    }
                    bl2 = bl3;
                }
            }
            this.pageRefs.releasePage(n2);
            ++n2;
        }
    }

    protected PdfArray readArray() {
        PdfArray pdfArray = new PdfArray();
        int n2;
        PdfObject pdfObject;
        while ((n2 = - (pdfObject = this.readPRObject()).type()) != PRTokeniser.TokenType.END_ARRAY.ordinal()) {
            if (n2 == PRTokeniser.TokenType.END_DIC.ordinal()) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("unexpected.gt.gt", new Object[0]));
            }
            pdfArray.add(pdfObject);
        }
        return pdfArray;
    }

    protected PdfDictionary readDictionary() {
        PdfDictionary pdfDictionary = new PdfDictionary();
        do {
            this.tokens.nextValidToken();
            if (this.tokens.getTokenType() == PRTokeniser.TokenType.END_DIC) {
                return pdfDictionary;
            }
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NAME) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("dictionary.key.1.is.not.a.name", this.tokens.getStringValue()));
            }
            PdfName pdfName = new PdfName(this.tokens.getStringValue(), false);
            PdfObject pdfObject = this.readPRObject();
            int n2 = - pdfObject.type();
            if (n2 == PRTokeniser.TokenType.END_DIC.ordinal()) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("unexpected.gt.gt", new Object[0]));
            }
            if (n2 == PRTokeniser.TokenType.END_ARRAY.ordinal()) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("unexpected.close.bracket", new Object[0]));
            }
            pdfDictionary.put(pdfName, pdfObject);
        } while (true);
    }

    protected void readDocObj() {
        ArrayList<PRStream> arrayList = new ArrayList<PRStream>();
        int n2 = this.xref.length;
        int n3 = 2;
        this.xrefObj = new ArrayList(n2 / 2);
        this.xrefObj.addAll(Collections.nCopies(this.xref.length / 2, null));
        do {
            block14 : {
                int n4 = this.xref.length;
                if (n3 >= n4) break;
                long l2 = this.xref[n3];
                if (l2 > 0L && this.xref[n3 + 1] <= 0L) {
                    IOException iOException22;
                    block13 : {
                        this.tokens.seek(l2);
                        this.tokens.nextValidToken();
                        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                            this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.object.number", new Object[0]));
                        }
                        this.objNum = this.tokens.intValue();
                        this.tokens.nextValidToken();
                        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                            this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.generation.number", new Object[0]));
                        }
                        this.objGen = this.tokens.intValue();
                        this.tokens.nextValidToken();
                        if (!this.tokens.getStringValue().equals("obj")) {
                            this.tokens.throwError(MessageLocalization.getComposedMessage("token.obj.expected", new Object[0]));
                        }
                        PdfObject object = this.readPRObject();
                        Object object2 = object;
                        try {
                            if (object.isStream()) {
                                arrayList.add((PRStream)object);
                                object2 = object;
                            }
                        }
                        catch (IOException iOException22) {
                            if (!debugmode) break block13;
                            if (LOGGER.isLogging(Level.ERROR)) {
                                LOGGER.error(iOException22.getMessage(), iOException22);
                            }
                            object2 = null;
                        }
                        this.xrefObj.set(n3 / 2, (PdfObject)object2);
                        break block14;
                    }
                    throw iOException22;
                }
            }
            n3 += 2;
        } while (true);
        for (n2 = 0; n2 < arrayList.size(); ++n2) {
            this.checkPRStreamLength((PRStream)arrayList.get(n2));
        }
        this.readDecryptedDocObj();
        if (this.objStmMark != null) {
            for (Map.Entry<Integer, IntHashtable> entry : this.objStmMark.entrySet()) {
                n3 = entry.getKey();
                IntHashtable intHashtable = entry.getValue();
                this.readObjStm((PRStream)this.xrefObj.get(n3), intHashtable);
                this.xrefObj.set(n3, null);
            }
            this.objStmMark = null;
        }
        this.xref = null;
    }

    protected void readDocObjPartial() {
        this.xrefObj = new ArrayList(this.xref.length / 2);
        this.xrefObj.addAll(Collections.nCopies(this.xref.length / 2, null));
        this.readDecryptedDocObj();
        if (this.objStmToOffset != null) {
            long[] arrl = this.objStmToOffset.getKeys();
            for (int i2 = 0; i2 < arrl.length; ++i2) {
                long l2 = arrl[i2];
                LongHashtable longHashtable = this.objStmToOffset;
                long[] arrl2 = this.xref;
                int n2 = (int)(2L * l2);
                longHashtable.put(l2, arrl2[n2]);
                this.xref[n2] = -1L;
            }
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected void readObjStm(PRStream var1_1, IntHashtable var2_3) {
        if (var1_1 == null) {
            return;
        }
        var6_9 = var1_1.getAsNumber(PdfName.FIRST).intValue();
        var5_10 = var1_1.getAsNumber(PdfName.N).intValue();
        var1_2 = PdfReader.getStreamBytes((PRStream)var1_1, this.tokens.getFile());
        var8_11 = this.tokens;
        this.tokens = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(var1_2)));
        try {
            var9_12 = new int[var5_10];
            var10_13 = new int[var5_10];
            var4_14 = 0;
            var7_16 = true;
            for (var3_15 = 0; var3_15 < var5_10; ++var3_15) {
                var7_16 = this.tokens.nextToken();
                if (var7_16) {
                    if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                        var10_13[var3_15] = this.tokens.intValue();
                        var7_16 = this.tokens.nextToken();
                        if (var7_16) {
                            if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                                var9_12[var3_15] = this.tokens.intValue() + var6_9;
                                continue;
                            } else {
                                ** GOTO lbl-1000
                            }
                        }
                    } else lbl-1000: // 3 sources:
                    {
                        var7_16 = false;
                    }
                }
                if (var7_16) break;
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("error.reading.objstm", new Object[0]));
            }
        }
        catch (Throwable var1_7) {
            this.tokens = var8_11;
            throw var1_7;
        }
        var3_15 = var4_14;
        do {
            if (var3_15 >= var5_10) {
                this.tokens = var8_11;
                return;
            }
            if (var2_8.containsKey(var3_15)) {
                this.tokens.seek(var9_12[var3_15]);
                this.tokens.nextToken();
                if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                    var1_4 = new PdfNumber(this.tokens.getStringValue());
                } else {
                    this.tokens.seek(var9_12[var3_15]);
                    var1_5 = this.readPRObject();
                }
                this.xrefObj.set(var10_13[var3_15], (PdfObject)var1_6);
            }
            ++var3_15;
            continue;
            break;
        } while (true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected PdfObject readOneObjStm(PRStream var1_1, int var2_3) {
        block11 : {
            var5_4 = var1_1.getAsNumber(PdfName.FIRST).intValue();
            var1_1 = PdfReader.getStreamBytes((PRStream)var1_1, this.tokens.getFile());
            var9_5 = this.tokens;
            this.tokens = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource((byte[])var1_1)));
            var4_7 = 0;
            var6_8 = true;
            for (var3_6 = 0; var3_6 < var2_3 + 1; ++var3_6) {
                block10 : {
                    var6_8 = this.tokens.nextToken();
                    if (!var6_8) break block10;
                    if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                        var6_8 = this.tokens.nextToken();
                        if (var6_8) {
                            if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                                var4_7 = this.tokens.intValue() + var5_4;
                                continue;
                            } else {
                                ** GOTO lbl18
                            }
                        }
                        break block10;
                    }
lbl18: // 4 sources:
                    var6_8 = false;
                }
                if (!var6_8) break block11;
            }
            try {
                var1_1 = this.tokens;
                var7_9 = var4_7;
                var1_1.seek(var7_9);
                this.tokens.nextToken();
                if (this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
                    var1_1 = new PdfNumber(this.tokens.getStringValue());
                } else {
                    this.tokens.seek(var7_9);
                    var1_1 = this.readPRObject();
                }
                this.tokens = var9_5;
                return var1_1;
            }
            catch (Throwable var1_2) {}
        }
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("error.reading.objstm", new Object[0]));
        this.tokens = var9_5;
        throw var1_2;
    }

    protected PdfObject readPRObject() {
        Object object;
        String string2;
        block21 : {
            this.tokens.nextValidToken();
            object = this.tokens.getTokenType();
            switch (.$SwitchMap$com$itextpdf$text$pdf$PRTokeniser$TokenType[object.ordinal()]) {
                default: {
                    string2 = this.tokens.getStringValue();
                    if ("null".equals(string2)) {
                        if (this.readDepth != 0) break;
                        return new PdfNull();
                    }
                    break block21;
                }
                case 7: {
                    throw new IOException(MessageLocalization.getComposedMessage("unexpected.end.of.file", new Object[0]));
                }
                case 6: {
                    return new PRIndirectReference(this, this.tokens.getReference(), this.tokens.getGeneration());
                }
                case 5: {
                    object = PdfName.staticNames.get(this.tokens.getStringValue());
                    if (this.readDepth > 0 && object != null) {
                        return object;
                    }
                    return new PdfName(this.tokens.getStringValue(), false);
                }
                case 4: {
                    object = new PdfString(this.tokens.getStringValue(), null).setHexWriting(this.tokens.isHexString());
                    object.setObjNum(this.objNum, this.objGen);
                    if (this.strings != null) {
                        this.strings.add((PdfString)object);
                    }
                    return object;
                }
                case 3: {
                    return new PdfNumber(this.tokens.getStringValue());
                }
                case 2: {
                    ++this.readDepth;
                    object = this.readArray();
                    --this.readDepth;
                    return object;
                }
                case 1: {
                    boolean bl2;
                    ++this.readDepth;
                    object = this.readDictionary();
                    --this.readDepth;
                    long l2 = this.tokens.getFilePointer();
                    while ((bl2 = this.tokens.nextToken()) && this.tokens.getTokenType() == PRTokeniser.TokenType.COMMENT) {
                    }
                    if (bl2 && this.tokens.getStringValue().equals("stream")) {
                        int n2;
                        while ((n2 = this.tokens.read()) == 32 || n2 == 9 || n2 == 0 || n2 == 12) {
                        }
                        int n3 = n2;
                        if (n2 != 10) {
                            n3 = this.tokens.read();
                        }
                        if (n3 != 10) {
                            this.tokens.backOnePosition(n3);
                        }
                        PRStream pRStream = new PRStream(this, this.tokens.getFilePointer());
                        pRStream.putAll((PdfDictionary)object);
                        pRStream.setObjNum(this.objNum, this.objGen);
                        return pRStream;
                    }
                    this.tokens.seek(l2);
                    return object;
                }
            }
            return PdfNull.PDFNULL;
        }
        if ("true".equals(string2)) {
            if (this.readDepth == 0) {
                return new PdfBoolean(true);
            }
            return PdfBoolean.PDFTRUE;
        }
        if ("false".equals(string2)) {
            if (this.readDepth == 0) {
                return new PdfBoolean(false);
            }
            return PdfBoolean.PDFFALSE;
        }
        return new PdfLiteral(- object.ordinal(), this.tokens.getStringValue());
    }

    protected void readPages() {
        block4 : {
            block6 : {
                block5 : {
                    this.catalog = this.trailer.getAsDict(PdfName.ROOT);
                    if (this.catalog == null) break block4;
                    this.rootPages = this.catalog.getAsDict(PdfName.PAGES);
                    if (this.rootPages != null && (PdfName.PAGES.equals(this.rootPages.get(PdfName.TYPE)) || PdfName.PAGES.equals(this.rootPages.get(new PdfName("Types"))))) break block5;
                    if (!debugmode) break block6;
                    if (LOGGER.isLogging(Level.ERROR)) {
                        LOGGER.error(MessageLocalization.getComposedMessage("the.document.has.no.page.root", new Object[0]));
                    }
                }
                this.pageRefs = new PageRefs(this);
                return;
            }
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("the.document.has.no.page.root", new Object[0]));
        }
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("the.document.has.no.catalog.object", new Object[0]));
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void readPdf() {
        Exception exception322;
        block8 : {
            block9 : {
                this.fileLength = this.tokens.getFile().length();
                this.pdfVersion = this.tokens.checkPdfHeader();
                try {
                    this.readXref();
                }
                catch (Exception exception222) {
                    try {
                        this.rebuilt = true;
                        this.rebuildXref();
                        this.lastXref = -1L;
                    }
                    catch (Exception exception5) {
                        throw new InvalidPdfException(MessageLocalization.getComposedMessage("rebuild.failed.1.original.message.2", exception5.getMessage(), exception222.getMessage()));
                    }
                }
                try {
                    this.readDocObj();
                }
                catch (Exception exception322) {
                    if (exception322 instanceof BadPasswordException) break block8;
                    if (this.rebuilt || this.encryptionError) break block9;
                    this.rebuilt = true;
                    this.encrypted = false;
                    try {
                        this.rebuildXref();
                        this.lastXref = -1L;
                        this.readDocObj();
                    }
                    catch (Exception exception4) {
                        throw new InvalidPdfException(MessageLocalization.getComposedMessage("rebuild.failed.1.original.message.2", exception4.getMessage(), exception322.getMessage()));
                    }
                }
                this.strings.clear();
                this.readPages();
                this.removeUnusedObjects();
                return;
            }
            throw new InvalidPdfException(exception322.getMessage());
        }
        throw new BadPasswordException(exception322.getMessage());
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void readPdfPartial() {
        this.fileLength = this.tokens.getFile().length();
        this.pdfVersion = this.tokens.checkPdfHeader();
        try {
            this.readXref();
        }
        catch (Exception exception) {
            try {
                this.rebuilt = true;
                this.rebuildXref();
                this.lastXref = -1L;
            }
            catch (Exception exception2) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("rebuild.failed.1.original.message.2", exception2.getMessage(), exception.getMessage()), exception2);
            }
        }
        this.readDocObjPartial();
        this.readPages();
    }

    protected PdfObject readSingleObject(int n2) {
        IOException iOException2;
        block13 : {
            this.strings.clear();
            int n3 = n2 * 2;
            long l2 = this.xref[n3];
            if (l2 < 0L) {
                return null;
            }
            Object object = this.xref;
            int n4 = n3 + 1;
            if (object[n4] > 0L) {
                l2 = this.objStmToOffset.get(this.xref[n4]);
            }
            if (l2 == 0L) {
                return null;
            }
            this.tokens.seek(l2);
            this.tokens.nextValidToken();
            object = this.tokens.getTokenType();
            Object object2 = PRTokeniser.TokenType.NUMBER;
            int n5 = 0;
            if (object != object2) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.object.number", new Object[0]));
            }
            this.objNum = this.tokens.intValue();
            this.tokens.nextValidToken();
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.generation.number", new Object[0]));
            }
            this.objGen = this.tokens.intValue();
            this.tokens.nextValidToken();
            if (!this.tokens.getStringValue().equals("obj")) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("token.obj.expected", new Object[0]));
            }
            object2 = this.readPRObject();
            while (n5 < this.strings.size()) {
                this.strings.get(n5).decrypt(this);
                ++n5;
            }
            object = object2;
            try {
                if (object2.isStream()) {
                    this.checkPRStreamLength((PRStream)object2);
                    object = object2;
                }
            }
            catch (IOException iOException2) {
                if (!debugmode) break block13;
                if (LOGGER.isLogging(Level.ERROR)) {
                    LOGGER.error(iOException2.getMessage(), iOException2);
                }
                object = null;
            }
            object2 = object;
            if (this.xref[n4] > 0L) {
                object2 = this.readOneObjStm((PRStream)object, (int)this.xref[n3]);
            }
            this.xrefObj.set(n2, (PdfObject)object2);
            return object2;
        }
        throw iOException2;
    }

    protected boolean readXRefStream(long l2) {
        this.tokens.seek(l2);
        if (!this.tokens.nextToken()) {
            return false;
        }
        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
            return false;
        }
        int n2 = this.tokens.intValue();
        if (this.tokens.nextToken() && this.tokens.getTokenType() == PRTokeniser.TokenType.NUMBER) {
            if (this.tokens.nextToken() && this.tokens.getStringValue().equals("obj")) {
                int[] arrn = this.readPRObject();
                if (arrn.isStream()) {
                    int n3;
                    PdfObject pdfObject = (PRStream)arrn;
                    if (!PdfName.XREF.equals(pdfObject.get(PdfName.TYPE))) {
                        return false;
                    }
                    if (this.trailer == null) {
                        this.trailer = new PdfDictionary();
                        this.trailer.putAll((PdfDictionary)pdfObject);
                    }
                    pdfObject.setLength(((PdfNumber)pdfObject.get(PdfName.LENGTH)).intValue());
                    int n4 = ((PdfNumber)pdfObject.get(PdfName.SIZE)).intValue();
                    arrn = pdfObject.get(PdfName.INDEX);
                    if (arrn == null) {
                        arrn = new PdfArray();
                        arrn.add(new int[]{0, n4});
                    } else {
                        arrn = (PdfArray)arrn;
                    }
                    Object object = (PdfArray)pdfObject.get(PdfName.W);
                    byte[] arrby = pdfObject.get(PdfName.PREV);
                    l2 = arrby != null ? ((PdfNumber)arrby).longValue() : -1L;
                    this.ensureXrefSize(n4 * 2);
                    if (this.objStmMark == null && !this.partial) {
                        this.objStmMark = new HashMap();
                    }
                    if (this.objStmToOffset == null && this.partial) {
                        this.objStmToOffset = new LongHashtable();
                    }
                    arrby = PdfReader.getStreamBytes((PRStream)pdfObject, this.tokens.getFile());
                    Object object2 = new int[3];
                    for (n4 = 0; n4 < 3; ++n4) {
                        object2[n4] = object.getAsNumber(n4).intValue();
                    }
                    n4 = 0;
                    pdfObject = arrn;
                    for (int i2 = 0; i2 < pdfObject.size(); i2 += 2) {
                        int n5;
                        int n6 = pdfObject.getAsNumber(i2).intValue();
                        this.ensureXrefSize((n6 + n5) * 2);
                        arrn = object2;
                        for (n5 = pdfObject.getAsNumber((int)(i2 + 1)).intValue(); n5 > 0; --n5) {
                            int n7;
                            int n8;
                            int n9;
                            if (arrn[0] > 0) {
                                n9 = 0;
                                n7 = 0;
                                n3 = n4;
                                n4 = n7;
                                do {
                                    n8 = n4;
                                    n7 = n3;
                                    if (n9 < arrn[0]) {
                                        n7 = arrby[n3];
                                        ++n9;
                                        ++n3;
                                        n4 = (n4 << 8) + (n7 & 255);
                                        continue;
                                    }
                                    break;
                                } while (true);
                            } else {
                                n8 = 1;
                                n7 = n4;
                            }
                            long l3 = 0L;
                            n4 = 0;
                            while (n4 < arrn[1]) {
                                l3 = (l3 << 8) + (long)(arrby[n7] & 255);
                                ++n4;
                                ++n7;
                            }
                            n4 = n7;
                            n7 = 0;
                            n3 = 0;
                            while (n7 < arrn[2]) {
                                n9 = arrby[n4];
                                ++n7;
                                ++n4;
                                n3 = (n3 << 8) + (n9 & 255);
                            }
                            n7 = n6 * 2;
                            if (this.xref[n7] == 0L && (object2 = this.xref)[n9 = n7 + 1] == 0L) {
                                switch (n8) {
                                    default: {
                                        break;
                                    }
                                    case 2: {
                                        this.xref[n7] = n3;
                                        this.xref[n9] = l3;
                                        if (this.partial) {
                                            this.objStmToOffset.put(l3, 0L);
                                            break;
                                        }
                                        object2 = (int)l3;
                                        object = this.objStmMark.get(object2);
                                        if (object == null) {
                                            object = new IntHashtable();
                                            object.put(n3, 1);
                                            this.objStmMark.put((Integer)object2, (IntHashtable)object);
                                            break;
                                        }
                                        object.put(n3, 1);
                                        break;
                                    }
                                    case 1: {
                                        this.xref[n7] = l3;
                                        break;
                                    }
                                    case 0: {
                                        this.xref[n7] = -1L;
                                    }
                                }
                            }
                            ++n6;
                        }
                        object2 = arrn;
                    }
                    n4 = n2 * 2;
                    n3 = n4 + 1;
                    if (n3 < this.xref.length && this.xref[n4] == 0L && this.xref[n3] == 0L) {
                        this.xref[n4] = -1L;
                    }
                    if (l2 == -1L) {
                        return true;
                    }
                    return this.readXRefStream(l2);
                }
                return false;
            }
            return false;
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected void readXref() {
        long l2;
        this.hybridXref = false;
        this.newXrefType = false;
        this.tokens.seek(this.tokens.getStartxref());
        this.tokens.nextToken();
        if (!this.tokens.getStringValue().equals("startxref")) {
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("startxref.not.found", new Object[0]));
        }
        this.tokens.nextToken();
        if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("startxref.is.not.followed.by.a.number", new Object[0]));
        }
        this.lastXref = l2 = this.tokens.longValue();
        this.eofPos = this.tokens.getFilePointer();
        try {
            if (this.readXRefStream(l2)) {
                this.newXrefType = true;
                return;
            }
        }
        catch (Exception exception) {}
        this.xref = null;
        this.tokens.seek(l2);
        this.trailer = this.readXrefSection();
        PdfObject pdfObject = this.trailer;
        while ((pdfObject = (PdfNumber)pdfObject.get(PdfName.PREV)) != null) {
            if (pdfObject.longValue() == l2) {
                throw new InvalidPdfException(MessageLocalization.getComposedMessage("trailer.prev.entry.points.to.its.own.cross.reference.section", new Object[0]));
            }
            l2 = pdfObject.longValue();
            this.tokens.seek(l2);
            pdfObject = this.readXrefSection();
        }
        return;
    }

    protected PdfDictionary readXrefSection() {
        this.tokens.nextValidToken();
        if (!this.tokens.getStringValue().equals("xref")) {
            this.tokens.throwError(MessageLocalization.getComposedMessage("xref.subsection.not.found", new Object[0]));
        }
        block2 : do {
            long l2;
            this.tokens.nextValidToken();
            if (this.tokens.getStringValue().equals("trailer")) {
                PdfDictionary pdfDictionary = (PdfDictionary)this.readPRObject();
                this.ensureXrefSize(((PdfNumber)pdfDictionary.get(PdfName.SIZE)).intValue() * 2);
                PdfObject pdfObject = pdfDictionary.get(PdfName.XREFSTM);
                if (pdfObject != null && pdfObject.isNumber()) {
                    l2 = ((PdfNumber)pdfObject).intValue();
                    try {
                        this.readXRefStream(l2);
                        this.newXrefType = true;
                        this.hybridXref = true;
                        return pdfDictionary;
                    }
                    catch (IOException iOException) {
                        this.xref = null;
                        throw iOException;
                    }
                }
                return pdfDictionary;
            }
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("object.number.of.the.first.object.in.this.xref.subsection.not.found", new Object[0]));
            }
            int n2 = this.tokens.intValue();
            this.tokens.nextValidToken();
            if (this.tokens.getTokenType() != PRTokeniser.TokenType.NUMBER) {
                this.tokens.throwError(MessageLocalization.getComposedMessage("number.of.entries.in.this.xref.subsection.not.found", new Object[0]));
            }
            int n3 = this.tokens.intValue() + n2;
            int n4 = n2;
            int n5 = n3;
            if (n2 == 1) {
                l2 = this.tokens.getFilePointer();
                this.tokens.nextValidToken();
                long l3 = this.tokens.longValue();
                this.tokens.nextValidToken();
                int n6 = this.tokens.intValue();
                n4 = n2;
                n5 = n3;
                if (l3 == 0L) {
                    n4 = n2;
                    n5 = n3;
                    if (n6 == 65535) {
                        n4 = n2 - 1;
                        n5 = n3 - 1;
                    }
                }
                this.tokens.seek(l2);
            }
            this.ensureXrefSize(n5 * 2);
            do {
                if (n4 >= n5) continue block2;
                this.tokens.nextValidToken();
                l2 = this.tokens.longValue();
                this.tokens.nextValidToken();
                this.tokens.intValue();
                this.tokens.nextValidToken();
                n3 = n4 * 2;
                if (this.tokens.getStringValue().equals("n")) {
                    if (this.xref[n3] == 0L && this.xref[n3 + 1] == 0L) {
                        this.xref[n3] = l2;
                    }
                } else if (this.tokens.getStringValue().equals("f")) {
                    if (this.xref[n3] == 0L && this.xref[n3 + 1] == 0L) {
                        this.xref[n3] = -1L;
                    }
                } else {
                    this.tokens.throwError(MessageLocalization.getComposedMessage("invalid.cross.reference.entry.in.this.xref.subsection", new Object[0]));
                }
                ++n4;
            } while (true);
            break;
        } while (true);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected void rebuildXref() {
        this.hybridXref = false;
        this.newXrefType = false;
        PRTokeniser pRTokeniser = this.tokens;
        long l2 = 0L;
        pRTokeniser.seek(0L);
        long[][] arrarrl = new long[1024][];
        this.trailer = null;
        byte[] arrby = new byte[64];
        do {
            long l3;
            int n2;
            void var12_3;
            long[] arrl;
            long[][] arrarrl2;
            long l4 = this.tokens.getFilePointer();
            if (!this.tokens.readLineSegment(arrby, true)) {
                if (this.trailer == null) throw new InvalidPdfException(MessageLocalization.getComposedMessage("trailer.not.found", new Object[0]));
                this.xref = new long[(int)(2L * l2)];
                n2 = 0;
                while ((long)n2 < l2) {
                    arrarrl2 = var12_3[n2];
                    if (arrarrl2 != null) {
                        this.xref[n2 * 2] = (long)arrarrl2[0];
                    }
                    ++n2;
                }
                return;
            }
            if (arrby[0] == 116) {
                if (!PdfEncodings.convertToString(arrby, null).startsWith("trailer")) continue;
                this.tokens.seek(l4);
                this.tokens.nextToken();
                l3 = this.tokens.getFilePointer();
                arrarrl2 = (long[][])this.readPRObject();
                if (arrarrl2.get(PdfName.ROOT) != null) {
                    this.trailer = arrarrl2;
                    continue;
                }
                this.tokens.seek(l3);
                continue;
            }
            if (arrby[0] < 48 || arrby[0] > 57 || (arrl = PRTokeniser.checkObjectStart(arrby)) == null) continue;
            long l5 = arrl[0];
            long l6 = arrl[1];
            if (l5 >= (long)((void)var12_3).length) {
                arrarrl2 = new long[(int)(2L * l5)][];
                System.arraycopy(var12_3, 0, arrarrl2, 0, (int)l2);
                long[][] arrarrl3 = arrarrl2;
            }
            l3 = l2;
            if (l5 >= l2) {
                l3 = 1L + l5;
            }
            if (var12_3[n2 = (int)l5] != null && l6 < var12_3[n2][1]) {
                l2 = l3;
                continue;
            }
            arrl[0] = l4;
            var12_3[n2] = arrl;
            l2 = l3;
            continue;
            catch (Exception exception) {}
            this.tokens.seek(l3);
        } while (true);
    }

    public void releaseLastXrefPartial() {
        if (this.partial && this.lastXrefPartial != -1) {
            this.xrefObj.set(this.lastXrefPartial, null);
            this.lastXrefPartial = -1;
        }
    }

    public void releasePage(int n2) {
        this.pageRefs.releasePage(n2);
    }

    public void removeAnnotations() {
        this.pageRefs.resetReleasePage();
        for (int i2 = 1; i2 <= this.pageRefs.size(); ++i2) {
            PdfDictionary pdfDictionary = this.pageRefs.getPageN(i2);
            if (pdfDictionary.get(PdfName.ANNOTS) == null) {
                this.pageRefs.releasePage(i2);
                continue;
            }
            pdfDictionary.remove(PdfName.ANNOTS);
        }
        this.catalog.remove(PdfName.ACROFORM);
        this.pageRefs.resetReleasePage();
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public void removeFields() {
        this.pageRefs.resetReleasePage();
        var2_1 = 1;
        do {
            block10 : {
                if (var2_1 > this.pageRefs.size()) {
                    this.catalog.remove(PdfName.ACROFORM);
                    this.pageRefs.resetReleasePage();
                    return;
                }
                var4_4 = this.pageRefs.getPageN(var2_1);
                var5_5 = var4_4.getAsArray(PdfName.ANNOTS);
                if (var5_5 != null) {
                    var1_2 = 0;
                } else {
                    do {
                        this.pageRefs.releasePage(var2_1);
                        break block10;
                        break;
                    } while (true);
                }
                while (var1_2 < var5_5.size()) {
                    var6_6 = PdfReader.getPdfObjectRelease(var5_5.getPdfObject(var1_2));
                    var3_3 = var1_2;
                    if (var6_6 != null) {
                        if (!var6_6.isDictionary()) {
                            var3_3 = var1_2;
                        } else {
                            var6_6 = (PdfDictionary)var6_6;
                            var3_3 = var1_2;
                            if (PdfName.WIDGET.equals(var6_6.get(PdfName.SUBTYPE))) {
                                var5_5.remove(var1_2);
                                var3_3 = var1_2 - 1;
                            }
                        }
                    }
                    var1_2 = var3_3 + 1;
                }
                if (!var5_5.isEmpty()) ** continue;
                var4_4.remove(PdfName.ANNOTS);
            }
            ++var2_1;
        } while (true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    protected void removeUnusedNode(PdfObject var1_1, boolean[] var2_2) {
        var9_3 = new Stack<Object>();
        block4 : do {
            var9_3.push(var1_1 /* !! */ );
            block5 : while (var9_3.empty() == false) {
                var1_1 /* !! */  = var9_3.pop();
                if (var1_1 /* !! */  == null) continue;
                var5_6 = var1_1 /* !! */  instanceof PdfObject;
                var8_9 = null;
                if (!var5_6) ** GOTO lbl35
                var3_4 = (var1_1 /* !! */  = (PdfObject)var1_1 /* !! */ ).type();
                if (var3_4 != 10) {
                    switch (var3_4) {
                        default: {
                            continue block5;
                        }
                        case 6: 
                        case 7: {
                            var6_7 = (PdfDictionary)var1_1 /* !! */ ;
                            var7_8 /* !! */  = new PdfName[var6_7.size()];
                            var6_7.getKeys().toArray(var7_8 /* !! */ );
                            var3_4 = 0;
                            var1_1 /* !! */  = null;
                            ** break;
                        }
                        case 5: 
                    }
                    var8_9 = ((PdfArray)var1_1 /* !! */ ).getArrayList();
                    var6_7 = null;
                    var7_8 /* !! */  = var6_7;
                    var3_4 = 0;
                    var1_1 /* !! */  = var7_8 /* !! */ ;
                    ** break;
lbl29: // 2 sources:
                } else {
                    var3_4 = (var1_1 /* !! */  = (PRIndirectReference)var1_1 /* !! */ ).getNumber();
                    if (var2_2[var3_4]) continue;
                    var2_2[var3_4] = true;
                    var1_1 /* !! */  = PdfReader.getPdfObjectRelease((PdfObject)var1_1 /* !! */ );
                    continue block4;
lbl35: // 1 sources:
                    if (var1_1 /* !! */ [0] instanceof ArrayList) {
                        var8_9 = (ArrayList<PdfObject>)var1_1 /* !! */ [0];
                        var3_4 = (Integer)var1_1 /* !! */ [1];
                        var7_8 /* !! */  = null;
                        var6_7 = var7_8 /* !! */ ;
                    } else {
                        var7_8 /* !! */  = (PdfName[])var1_1 /* !! */ [0];
                        var6_7 = (PdfDictionary)var1_1 /* !! */ [1];
                        var3_4 = (Integer)var1_1 /* !! */ [2];
                    }
                }
                var4_5 = var3_4;
                if (var8_9 != null) {
                    do {
                        if (var3_4 >= var8_9.size()) continue block5;
                        var6_7 = var8_9.get(var3_4);
                        if (!var6_7.isIndirect() || (var4_5 = ((PRIndirectReference)var6_7).getNumber()) < this.xrefObj.size() && (this.partial || this.xrefObj.get(var4_5) != null)) break;
                        var8_9.set(var3_4, PdfNull.PDFNULL);
                        ++var3_4;
                    } while (true);
                    if (var1_1 /* !! */  == null) {
                        var1_1 /* !! */  = new Object[]{var8_9, var3_4 + 1};
                    } else {
                        var1_1 /* !! */ [1] = var3_4 + 1;
                    }
                    var9_3.push(var1_1 /* !! */ );
                    var9_3.push(var6_7);
                    continue;
                }
                do {
                    if (var4_5 >= var7_8 /* !! */ .length) continue block5;
                    var10_10 = var7_8 /* !! */ [var4_5];
                    var8_9 = var6_7.get(var10_10);
                    if (!var8_9.isIndirect() || (var3_4 = ((PRIndirectReference)var8_9).getNumber()) >= 0 && var3_4 < this.xrefObj.size() && (this.partial || this.xrefObj.get(var3_4) != null)) break;
                    var6_7.put(var10_10, PdfNull.PDFNULL);
                    ++var4_5;
                } while (true);
                if (var1_1 /* !! */  == null) {
                    var1_1 /* !! */  = new Object[]{var7_8 /* !! */ , var6_7, var4_5 + 1};
                } else {
                    var1_1 /* !! */ [2] = var4_5 + 1;
                }
                var9_3.push(var1_1 /* !! */ );
                var9_3.push(var8_9);
            }
            return;
            break;
        } while (true);
    }

    public int removeUnusedObjects() {
        boolean[] arrbl = new boolean[this.xrefObj.size()];
        this.removeUnusedNode(this.trailer, arrbl);
        boolean bl2 = this.partial;
        int n2 = 1;
        int n3 = 0;
        int n4 = 0;
        if (bl2) {
            n2 = 1;
            n3 = n4;
            do {
                n4 = n3;
                if (n2 < arrbl.length) {
                    n4 = n3;
                    if (!arrbl[n2]) {
                        long[] arrl = this.xref;
                        n4 = n2 * 2;
                        arrl[n4] = -1L;
                        this.xref[n4 + 1] = 0L;
                        this.xrefObj.set(n2, null);
                        n4 = n3 + 1;
                    }
                    ++n2;
                    n3 = n4;
                    continue;
                }
                break;
            } while (true);
        } else {
            do {
                n4 = n3;
                if (n2 >= arrbl.length) break;
                n4 = n3;
                if (!arrbl[n2]) {
                    this.xrefObj.set(n2, null);
                    n4 = n3 + 1;
                }
                ++n2;
                n3 = n4;
            } while (true);
        }
        return n4;
    }

    public void removeUsageRights() {
        PdfDictionary pdfDictionary = this.catalog.getAsDict(PdfName.PERMS);
        if (pdfDictionary == null) {
            return;
        }
        pdfDictionary.remove(PdfName.UR);
        pdfDictionary.remove(PdfName.UR3);
        if (pdfDictionary.size() == 0) {
            this.catalog.remove(PdfName.PERMS);
        }
    }

    public void resetLastXrefPartial() {
        this.lastXrefPartial = -1;
    }

    public void resetReleasePage() {
        this.pageRefs.resetReleasePage();
    }

    public void selectPages(String string2) {
        this.selectPages(SequenceList.expand(string2, this.getNumberOfPages()));
    }

    public void selectPages(List<Integer> list) {
        this.selectPages(list, true);
    }

    protected void selectPages(List<Integer> list, boolean bl2) {
        this.pageRefs.selectPages(list);
        if (bl2) {
            this.removeUnusedObjects();
        }
    }

    public void setAppendable(boolean bl2) {
        this.appendable = bl2;
        if (bl2) {
            PdfReader.getPdfObject(this.trailer.get(PdfName.ROOT));
        }
    }

    public void setPageContent(int n2, byte[] arrby) {
        this.setPageContent(n2, arrby, -1);
    }

    public void setPageContent(int n2, byte[] arrby, int n3) {
        this.setPageContent(n2, arrby, n3, false);
    }

    public void setPageContent(int n2, byte[] arrby, int n3, boolean bl2) {
        PdfDictionary pdfDictionary = this.getPageN(n2);
        if (pdfDictionary == null) {
            return;
        }
        PdfObject pdfObject = pdfDictionary.get(PdfName.CONTENTS);
        this.freeXref = -1;
        if (bl2) {
            this.killXref(pdfObject);
        }
        if (this.freeXref == -1) {
            this.xrefObj.add(null);
            this.freeXref = this.xrefObj.size() - 1;
        }
        pdfDictionary.put(PdfName.CONTENTS, new PRIndirectReference(this, this.freeXref));
        this.xrefObj.set(this.freeXref, new PRStream(this, arrby, n3));
    }

    public void setTampered(boolean bl2) {
        this.tampered = bl2;
        this.pageRefs.keepPages();
    }

    @Override
    public void setViewerPreferences(int n2) {
        this.viewerPreferences.setViewerPreferences(n2);
        this.setViewerPreferences(this.viewerPreferences);
    }

    public void setViewerPreferences(PdfViewerPreferencesImp pdfViewerPreferencesImp) {
        pdfViewerPreferencesImp.addToCatalog(this.catalog);
    }

    public int shuffleSubsetNames() {
        int n2 = 0;
        for (int i2 = 1; i2 < this.xrefObj.size(); ++i2) {
            Serializable serializable = this.getPdfObjectRelease(i2);
            int n3 = n2;
            if (serializable != null) {
                CharSequence charSequence;
                Object object;
                if (!serializable.isDictionary()) {
                    n3 = n2;
                } else if (!PdfReader.existsName((PdfDictionary)(serializable = (PdfDictionary)serializable), PdfName.TYPE, PdfName.FONT)) {
                    n3 = n2;
                } else if (!(PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.TYPE1) || PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.MMTYPE1) || PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.TRUETYPE))) {
                    n3 = n2;
                    if (PdfReader.existsName((PdfDictionary)serializable, PdfName.SUBTYPE, PdfName.TYPE0)) {
                        charSequence = PdfReader.getSubsetPrefix((PdfDictionary)serializable);
                        object = serializable.getAsArray(PdfName.DESCENDANTFONTS);
                        if (object == null) {
                            n3 = n2;
                        } else if (object.isEmpty()) {
                            n3 = n2;
                        } else {
                            String string2 = PdfReader.getSubsetPrefix((PdfDictionary)(object = object.getAsDict(0)));
                            if (string2 == null) {
                                n3 = n2;
                            } else {
                                String string3 = BaseFont.createSubsetPrefix();
                                if (charSequence != null) {
                                    PdfName pdfName = PdfName.BASEFONT;
                                    StringBuilder stringBuilder = new StringBuilder();
                                    stringBuilder.append(string3);
                                    stringBuilder.append(charSequence.substring(7));
                                    serializable.put(pdfName, new PdfName(stringBuilder.toString()));
                                }
                                this.setXrefPartialObject(i2, (PdfObject)serializable);
                                serializable = new StringBuilder();
                                serializable.append(string3);
                                serializable.append(string2.substring(7));
                                serializable = new PdfName(serializable.toString());
                                object.put(PdfName.BASEFONT, (PdfObject)serializable);
                                n3 = n2 + 1;
                                object = object.getAsDict(PdfName.FONTDESCRIPTOR);
                                if (object != null) {
                                    object.put(PdfName.FONTNAME, (PdfObject)serializable);
                                }
                            }
                        }
                    }
                } else {
                    object = PdfReader.getSubsetPrefix((PdfDictionary)serializable);
                    if (object == null) {
                        n3 = n2;
                    } else {
                        charSequence = new StringBuilder();
                        charSequence.append(BaseFont.createSubsetPrefix());
                        charSequence.append(object.substring(7));
                        object = new PdfName(charSequence.toString());
                        serializable.put(PdfName.BASEFONT, (PdfObject)object);
                        this.setXrefPartialObject(i2, (PdfObject)serializable);
                        n3 = n2 + 1;
                        serializable = serializable.getAsDict(PdfName.FONTDESCRIPTOR);
                        if (serializable != null) {
                            serializable.put(PdfName.FONTNAME, (PdfObject)object);
                        }
                    }
                }
            }
            n2 = n3;
        }
        return n2;
    }

    static class PageRefs {
        private boolean keepPages;
        private int lastPageRead = -1;
        private ArrayList<PdfDictionary> pageInh;
        private Set<PdfObject> pagesNodes = new HashSet<PdfObject>();
        private final PdfReader reader;
        private ArrayList<PRIndirectReference> refsn;
        private IntHashtable refsp;
        private int sizep;

        PageRefs(PageRefs pageRefs, PdfReader pdfReader) {
            this.reader = pdfReader;
            this.sizep = pageRefs.sizep;
            if (pageRefs.refsn != null) {
                this.refsn = new ArrayList<PRIndirectReference>(pageRefs.refsn);
                for (int i2 = 0; i2 < this.refsn.size(); ++i2) {
                    this.refsn.set(i2, (PRIndirectReference)PdfReader.duplicatePdfObject(this.refsn.get(i2), pdfReader));
                }
            } else {
                this.refsp = (IntHashtable)pageRefs.refsp.clone();
            }
        }

        private PageRefs(PdfReader pdfReader) {
            this.reader = pdfReader;
            if (pdfReader.partial) {
                this.refsp = new IntHashtable();
                this.sizep = ((PdfNumber)PdfReader.getPdfObjectRelease(pdfReader.rootPages.get(PdfName.COUNT))).intValue();
                return;
            }
            this.readPages();
        }

        private void iteratePages(PRIndirectReference pdfObject) {
            boolean bl2 = this.pagesNodes.add(PdfReader.getPdfObject(pdfObject));
            if (bl2) {
                PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObject(pdfObject);
                if (pdfDictionary == null) {
                    return;
                }
                PdfObject pdfObject2 = pdfDictionary.getAsArray(PdfName.KIDS);
                if (pdfObject2 == null) {
                    pdfDictionary.put(PdfName.TYPE, PdfName.PAGE);
                    pdfObject2 = this.pageInh.get(this.pageInh.size() - 1);
                    for (PdfName pdfName : pdfObject2.getKeys()) {
                        if (pdfDictionary.get(pdfName) != null) continue;
                        pdfDictionary.put(pdfName, pdfObject2.get(pdfName));
                    }
                    if (pdfDictionary.get(PdfName.MEDIABOX) == null) {
                        pdfObject2 = new PdfArray(new float[]{0.0f, 0.0f, PageSize.LETTER.getRight(), PageSize.LETTER.getTop()});
                        pdfDictionary.put(PdfName.MEDIABOX, pdfObject2);
                    }
                    this.refsn.add((PRIndirectReference)pdfObject);
                    return;
                }
                pdfDictionary.put(PdfName.TYPE, PdfName.PAGES);
                this.pushPageAttributes(pdfDictionary);
                for (int i2 = 0; i2 < pdfObject2.size(); ++i2) {
                    pdfObject = pdfObject2.getPdfObject(i2);
                    if (!pdfObject.isIndirect()) {
                        while (i2 < pdfObject2.size()) {
                            pdfObject2.remove(i2);
                        }
                        break;
                    }
                    this.iteratePages((PRIndirectReference)pdfObject);
                }
                this.popPageAttributes();
                return;
            }
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.pages.tree", new Object[0]));
        }

        private void popPageAttributes() {
            this.pageInh.remove(this.pageInh.size() - 1);
        }

        private void pushPageAttributes(PdfDictionary pdfDictionary) {
            PdfDictionary pdfDictionary2 = new PdfDictionary();
            if (!this.pageInh.isEmpty()) {
                pdfDictionary2.putAll(this.pageInh.get(this.pageInh.size() - 1));
            }
            for (int i2 = 0; i2 < PdfReader.pageInhCandidates.length; ++i2) {
                PdfObject pdfObject = pdfDictionary.get(PdfReader.pageInhCandidates[i2]);
                if (pdfObject == null) continue;
                pdfDictionary2.put(PdfReader.pageInhCandidates[i2], pdfObject);
            }
            this.pageInh.add(pdfDictionary2);
        }

        private void selectPages(List<Integer> object) {
            int n2;
            long[] arrl;
            Serializable serializable;
            int n3;
            IntHashtable intHashtable = new IntHashtable();
            ArrayList<Integer> arrayList = new ArrayList<Integer>();
            int n4 = this.size();
            object = object.iterator();
            while (object.hasNext()) {
                serializable = (Integer)object.next();
                n2 = serializable.intValue();
                if (n2 < 1 || n2 > n4 || intHashtable.put(n2, 1) != 0) continue;
                arrayList.add((Integer)serializable);
            }
            if (this.reader.partial) {
                for (n2 = 1; n2 <= n4; ++n2) {
                    this.getPageOrigRef(n2);
                    this.resetReleasePage();
                }
            }
            Object object2 = (PRIndirectReference)this.reader.catalog.get(PdfName.PAGES);
            object = (PdfDictionary)PdfReader.getPdfObject((PdfObject)object2);
            serializable = new ArrayList(arrayList.size());
            PdfArray pdfArray = new PdfArray();
            int n5 = 0;
            for (n2 = 0; n2 < arrayList.size(); ++n2) {
                n3 = (Integer)arrayList.get(n2);
                arrl = this.getPageOrigRef(n3);
                this.resetReleasePage();
                pdfArray.add((PdfObject)arrl);
                serializable.add(arrl);
                this.getPageN(n3).put(PdfName.PARENT, (PdfObject)object2);
            }
            object2 = this.reader.getAcroFields();
            n2 = n5;
            if (object2.getFields().size() > 0) {
                n2 = 1;
            }
            for (n5 = 1; n5 <= n4; ++n5) {
                if (intHashtable.containsKey(n5)) continue;
                if (n2 != 0) {
                    object2.removeFieldsFromPage(n5);
                }
                n3 = this.getPageOrigRef(n5).getNumber();
                this.reader.xrefObj.set(n3, null);
                if (!this.reader.partial) continue;
                arrl = this.reader.xref;
                arrl[n3 *= 2] = -1L;
                this.reader.xref[n3 + 1] = 0L;
            }
            object.put(PdfName.COUNT, new PdfNumber(arrayList.size()));
            object.put(PdfName.KIDS, pdfArray);
            this.refsp = null;
            this.refsn = serializable;
        }

        public PdfDictionary getPageN(int n2) {
            return (PdfDictionary)PdfReader.getPdfObject(this.getPageOrigRef(n2));
        }

        public PdfDictionary getPageNRelease(int n2) {
            PdfDictionary pdfDictionary = this.getPageN(n2);
            this.releasePage(n2);
            return pdfDictionary;
        }

        public PRIndirectReference getPageOrigRef(int n2) {
            PRIndirectReference pRIndirectReference;
            block11 : {
                block9 : {
                    if (--n2 >= 0) {
                        int n3;
                        block10 : {
                            try {
                                if (n2 >= this.size()) break block9;
                                if (this.refsn != null) {
                                    return this.refsn.get(n2);
                                }
                                n3 = this.refsp.get(n2);
                                if (n3 != 0) break block10;
                            }
                            catch (Exception exception) {
                                throw new ExceptionConverter(exception);
                            }
                            pRIndirectReference = this.getSinglePage(n2);
                            this.lastPageRead = this.reader.lastXrefPartial == -1 ? -1 : n2;
                            this.reader.lastXrefPartial = -1;
                            this.refsp.put(n2, pRIndirectReference.getNumber());
                            if (this.keepPages) {
                                this.lastPageRead = -1;
                                return pRIndirectReference;
                            }
                            break block11;
                        }
                        if (this.lastPageRead != n2) {
                            this.lastPageRead = -1;
                        }
                        if (this.keepPages) {
                            this.lastPageRead = -1;
                        }
                        PRIndirectReference pRIndirectReference2 = new PRIndirectReference(this.reader, n3);
                        return pRIndirectReference2;
                    }
                }
                return null;
            }
            return pRIndirectReference;
        }

        public PRIndirectReference getPageOrigRefRelease(int n2) {
            PRIndirectReference pRIndirectReference = this.getPageOrigRef(n2);
            this.releasePage(n2);
            return pRIndirectReference;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        protected PRIndirectReference getSinglePage(int var1_1) {
            var6_2 = new PdfDictionary();
            var4_3 = this.reader.rootPages;
            var3_6 = 0;
            do lbl-1000: // 5 sources:
            {
                for (var2_7 = 0; var2_7 < PdfReader.pageInhCandidates.length; ++var2_7) {
                    var5_8 = var4_4.get(PdfReader.pageInhCandidates[var2_7]);
                    if (var5_8 == null) continue;
                    var6_2.put(PdfReader.pageInhCandidates[var2_7], var5_8);
                }
                var7_9 = ((PdfArray)PdfReader.getPdfObjectRelease(var4_4.get(PdfName.KIDS))).listIterator();
                var2_7 = var3_6;
                do {
                    var3_6 = var2_7;
                    if (!var7_9.hasNext()) ** continue;
                    var8_10 = (PRIndirectReference)var7_9.next();
                    var5_8 = (PdfDictionary)PdfReader.getPdfObject(var8_10);
                    var3_6 = PdfReader.access$300(this.reader);
                    var9_11 = PdfReader.getPdfObjectRelease(var5_8.get(PdfName.COUNT));
                    PdfReader.access$302(this.reader, var3_6);
                    var3_6 = var9_11 != null && var9_11.type() == 2 ? ((PdfNumber)var9_11).intValue() : 1;
                    if (var1_1 < (var3_6 += var2_7)) {
                        if (var9_11 == null) {
                            var5_8.mergeDifferent(var6_2);
                            return var8_10;
                        }
                        this.reader.releaseLastXrefPartial();
                        var4_5 = var5_8;
                        var3_6 = var2_7;
                        ** continue;
                    }
                    this.reader.releaseLastXrefPartial();
                    var2_7 = var3_6;
                } while (true);
                break;
            } while (true);
        }

        void insertPage(int n2, PRIndirectReference pRIndirectReference) {
            int n3 = n2 - 1;
            if (this.refsn != null) {
                if (n3 >= this.refsn.size()) {
                    this.refsn.add(pRIndirectReference);
                    return;
                }
                this.refsn.add(n3, pRIndirectReference);
                return;
            }
            ++this.sizep;
            this.lastPageRead = -1;
            if (n3 >= this.size()) {
                this.refsp.put(this.size(), pRIndirectReference.getNumber());
                return;
            }
            IntHashtable intHashtable = new IntHashtable((this.refsp.size() + 1) * 2);
            Iterator<IntHashtable.Entry> iterator = this.refsp.getEntryIterator();
            while (iterator.hasNext()) {
                int n4;
                IntHashtable.Entry entry = iterator.next();
                n2 = n4 = entry.getKey();
                if (n4 >= n3) {
                    n2 = n4 + 1;
                }
                intHashtable.put(n2, entry.getValue());
            }
            intHashtable.put(n3, pRIndirectReference.getNumber());
            this.refsp = intHashtable;
        }

        void keepPages() {
            if (this.refsp != null) {
                if (this.keepPages) {
                    return;
                }
                this.keepPages = true;
                this.refsp.clear();
            }
        }

        void reReadPages() {
            this.refsn = null;
            this.readPages();
        }

        void readPages() {
            if (this.refsn != null) {
                return;
            }
            this.refsp = null;
            this.refsn = new ArrayList();
            this.pageInh = new ArrayList();
            this.iteratePages((PRIndirectReference)this.reader.catalog.get(PdfName.PAGES));
            this.pageInh = null;
            this.reader.rootPages.put(PdfName.COUNT, new PdfNumber(this.refsn.size()));
        }

        public void releasePage(int n2) {
            if (this.refsp == null) {
                return;
            }
            if (--n2 >= 0) {
                if (n2 >= this.size()) {
                    return;
                }
                if (n2 != this.lastPageRead) {
                    return;
                }
                this.lastPageRead = -1;
                this.reader.lastXrefPartial = this.refsp.get(n2);
                this.reader.releaseLastXrefPartial();
                this.refsp.remove(n2);
            }
        }

        public void resetReleasePage() {
            if (this.refsp == null) {
                return;
            }
            this.lastPageRead = -1;
        }

        int size() {
            if (this.refsn != null) {
                return this.refsn.size();
            }
            return this.sizep;
        }
    }

}

