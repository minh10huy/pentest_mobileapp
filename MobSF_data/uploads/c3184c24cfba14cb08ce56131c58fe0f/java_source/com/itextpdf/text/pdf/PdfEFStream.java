/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.pdf.OutputStreamCounter;
import com.itextpdf.text.pdf.OutputStreamEncryption;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncryption;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNull;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfWriter;
import java.io.ByteArrayOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;

public class PdfEFStream
extends PdfStream {
    public PdfEFStream(InputStream inputStream, PdfWriter pdfWriter) {
        super(inputStream, pdfWriter);
    }

    public PdfEFStream(byte[] arrby) {
        super(arrby);
    }

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public void toPdf(PdfWriter object, OutputStream outputStream) {
        block21 : {
            Object object2;
            byte[] arrby;
            int n2;
            Object object3;
            Object object4;
            Object object5;
            block18 : {
                block22 : {
                    block19 : {
                        block20 : {
                            block16 : {
                                block17 : {
                                    if (this.inputStream != null && this.compressed) {
                                        this.put(PdfName.FILTER, PdfName.FLATEDECODE);
                                    }
                                    arrby = null;
                                    object2 = object != null ? object.getEncryption() : null;
                                    object4 = object2;
                                    if (object2 == null) break block16;
                                    object3 = this.get(PdfName.FILTER);
                                    object4 = object2;
                                    if (object3 == null) break block16;
                                    if (PdfName.CRYPT.equals(object3)) break block17;
                                    object4 = object2;
                                    if (!object3.isArray()) break block16;
                                    object3 = (PdfArray)object3;
                                    object4 = object2;
                                    if (object3.isEmpty()) break block16;
                                    object4 = object2;
                                    if (!PdfName.CRYPT.equals(object3.getPdfObject(0))) break block16;
                                }
                                object4 = null;
                            }
                            if (object4 != null && object4.isEmbeddedFilesOnly()) {
                                object2 = new PdfArray();
                                object3 = new PdfArray();
                                object5 = new PdfDictionary();
                                object5.put(PdfName.NAME, PdfName.STDCF);
                                object2.add(PdfName.CRYPT);
                                object3.add((PdfObject)object5);
                                if (this.compressed) {
                                    object2.add(PdfName.FLATEDECODE);
                                    object3.add(new PdfNull());
                                }
                                this.put(PdfName.FILTER, (PdfObject)object2);
                                this.put(PdfName.DECODEPARMS, (PdfObject)object3);
                            }
                            object2 = this.get(PdfName.LENGTH);
                            if (object4 != null && object2 != null && object2.isNumber()) {
                                n2 = ((PdfNumber)object2).intValue();
                                this.put(PdfName.LENGTH, new PdfNumber(object4.calculateStreamSize(n2)));
                                this.superToPdf((PdfWriter)object, outputStream);
                                this.put(PdfName.LENGTH, (PdfObject)object2);
                            } else {
                                this.superToPdf((PdfWriter)object, outputStream);
                            }
                            outputStream.write(STARTSTREAM);
                            if (this.inputStream != null) break block18;
                            if (object4 != null) break block19;
                            if (this.streamBytes == null) break block20;
                            this.streamBytes.writeTo(outputStream);
                            break block21;
                        }
                        object = this.bytes;
                        break block22;
                    }
                    object = this.streamBytes != null ? this.streamBytes.toByteArray() : this.bytes;
                    object = object4.encryptByteArray((byte[])object);
                }
                outputStream.write((byte[])object);
                break block21;
            }
            this.rawLength = 0;
            object5 = new OutputStreamCounter(outputStream);
            if (object4 != null) {
                object2 = object = object4.getEncryptionStream((OutputStream)object5);
            } else {
                object = object5;
                object2 = null;
            }
            if (this.compressed) {
                object3 = new Deflater(this.compressionLevel);
                object = object4 = new DeflaterOutputStream((OutputStream)object, (Deflater)object3, 32768);
            } else {
                object3 = null;
                object4 = object;
                object = arrby;
            }
            arrby = new byte[4192];
            do {
                if ((n2 = this.inputStream.read(arrby)) <= 0) {
                    if (object != null) {
                        object.finish();
                        object3.end();
                    }
                    if (object2 != null) {
                        object2.finish();
                    }
                    this.inputStreamLength = (int)object5.getCounter();
                    break;
                }
                object4.write(arrby, 0, n2);
                this.rawLength += n2;
            } while (true);
        }
        outputStream.write(ENDSTREAM);
    }
}

