/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.spongycastle.asn1.ASN1Encodable
 *  org.spongycastle.asn1.ASN1EncodableVector
 *  org.spongycastle.asn1.ASN1Enumerated
 *  org.spongycastle.asn1.ASN1InputStream
 *  org.spongycastle.asn1.ASN1Integer
 *  org.spongycastle.asn1.ASN1ObjectIdentifier
 *  org.spongycastle.asn1.ASN1OctetString
 *  org.spongycastle.asn1.ASN1OutputStream
 *  org.spongycastle.asn1.ASN1Primitive
 *  org.spongycastle.asn1.ASN1Sequence
 *  org.spongycastle.asn1.ASN1Set
 *  org.spongycastle.asn1.ASN1TaggedObject
 *  org.spongycastle.asn1.DERNull
 *  org.spongycastle.asn1.DEROctetString
 *  org.spongycastle.asn1.DERSequence
 *  org.spongycastle.asn1.DERSet
 *  org.spongycastle.asn1.DERTaggedObject
 *  org.spongycastle.asn1.cms.Attribute
 *  org.spongycastle.asn1.cms.AttributeTable
 *  org.spongycastle.asn1.cms.ContentInfo
 *  org.spongycastle.asn1.esf.SignaturePolicyIdentifier
 *  org.spongycastle.asn1.ess.ESSCertID
 *  org.spongycastle.asn1.ess.ESSCertIDv2
 *  org.spongycastle.asn1.ess.SigningCertificate
 *  org.spongycastle.asn1.ess.SigningCertificateV2
 *  org.spongycastle.asn1.ocsp.BasicOCSPResponse
 *  org.spongycastle.asn1.ocsp.OCSPObjectIdentifiers
 *  org.spongycastle.asn1.pkcs.PKCSObjectIdentifiers
 *  org.spongycastle.asn1.tsp.MessageImprint
 *  org.spongycastle.asn1.tsp.TSTInfo
 *  org.spongycastle.asn1.x509.AlgorithmIdentifier
 *  org.spongycastle.cert.X509CertificateHolder
 *  org.spongycastle.cert.jcajce.JcaX509CertificateHolder
 *  org.spongycastle.cert.ocsp.BasicOCSPResp
 *  org.spongycastle.cert.ocsp.CertificateID
 *  org.spongycastle.cert.ocsp.SingleResp
 *  org.spongycastle.jce.X509Principal
 *  org.spongycastle.jce.provider.X509CertParser
 *  org.spongycastle.operator.DigestCalculator
 *  org.spongycastle.operator.DigestCalculatorProvider
 *  org.spongycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder
 *  org.spongycastle.tsp.TimeStampToken
 *  org.spongycastle.tsp.TimeStampTokenInfo
 */
package com.itextpdf.text.pdf.security;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.security.BouncyCastleDigest;
import com.itextpdf.text.pdf.security.CertificateInfo;
import com.itextpdf.text.pdf.security.DigestAlgorithms;
import com.itextpdf.text.pdf.security.EncryptionAlgorithms;
import com.itextpdf.text.pdf.security.ExternalDigest;
import com.itextpdf.text.pdf.security.MakeSignature;
import com.itextpdf.text.pdf.security.SignaturePolicyInfo;
import com.itextpdf.text.pdf.security.TSAClient;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Principal;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.cert.CRL;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509CRL;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import org.spongycastle.asn1.ASN1Encodable;
import org.spongycastle.asn1.ASN1EncodableVector;
import org.spongycastle.asn1.ASN1Enumerated;
import org.spongycastle.asn1.ASN1InputStream;
import org.spongycastle.asn1.ASN1Integer;
import org.spongycastle.asn1.ASN1ObjectIdentifier;
import org.spongycastle.asn1.ASN1OctetString;
import org.spongycastle.asn1.ASN1OutputStream;
import org.spongycastle.asn1.ASN1Primitive;
import org.spongycastle.asn1.ASN1Sequence;
import org.spongycastle.asn1.ASN1Set;
import org.spongycastle.asn1.ASN1TaggedObject;
import org.spongycastle.asn1.DERNull;
import org.spongycastle.asn1.DEROctetString;
import org.spongycastle.asn1.DERSequence;
import org.spongycastle.asn1.DERSet;
import org.spongycastle.asn1.DERTaggedObject;
import org.spongycastle.asn1.cms.Attribute;
import org.spongycastle.asn1.cms.AttributeTable;
import org.spongycastle.asn1.cms.ContentInfo;
import org.spongycastle.asn1.esf.SignaturePolicyIdentifier;
import org.spongycastle.asn1.ess.ESSCertID;
import org.spongycastle.asn1.ess.ESSCertIDv2;
import org.spongycastle.asn1.ess.SigningCertificate;
import org.spongycastle.asn1.ess.SigningCertificateV2;
import org.spongycastle.asn1.ocsp.BasicOCSPResponse;
import org.spongycastle.asn1.ocsp.OCSPObjectIdentifiers;
import org.spongycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.spongycastle.asn1.tsp.MessageImprint;
import org.spongycastle.asn1.tsp.TSTInfo;
import org.spongycastle.asn1.x509.AlgorithmIdentifier;
import org.spongycastle.cert.X509CertificateHolder;
import org.spongycastle.cert.jcajce.JcaX509CertificateHolder;
import org.spongycastle.cert.ocsp.BasicOCSPResp;
import org.spongycastle.cert.ocsp.CertificateID;
import org.spongycastle.cert.ocsp.SingleResp;
import org.spongycastle.jce.X509Principal;
import org.spongycastle.jce.provider.X509CertParser;
import org.spongycastle.operator.DigestCalculator;
import org.spongycastle.operator.DigestCalculatorProvider;
import org.spongycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
import org.spongycastle.tsp.TimeStampToken;
import org.spongycastle.tsp.TimeStampTokenInfo;

public class PdfPKCS7 {
    private byte[] RSAdata;
    private BasicOCSPResp basicResp;
    private Collection<Certificate> certs;
    private Collection<CRL> crls;
    private byte[] digest;
    private String digestAlgorithmOid;
    private byte[] digestAttr;
    private String digestEncryptionAlgorithmOid;
    private Set<String> digestalgos;
    private MessageDigest encContDigest;
    private byte[] externalDigest;
    private byte[] externalRSAdata;
    private PdfName filterSubtype;
    private ExternalDigest interfaceDigest;
    private boolean isCades;
    private boolean isTsp;
    private String location;
    private MessageDigest messageDigest;
    private String provider;
    private String reason;
    private Signature sig;
    private byte[] sigAttr;
    private byte[] sigAttrDer;
    private X509Certificate signCert;
    private Collection<Certificate> signCerts;
    private Calendar signDate;
    private String signName;
    private SignaturePolicyIdentifier signaturePolicyIdentifier;
    private int signerversion;
    private TimeStampToken timeStampToken;
    private boolean verified;
    private boolean verifyResult;
    private int version;

    /*
     * Enabled aggressive block sorting
     */
    public PdfPKCS7(PrivateKey privateKey, Certificate[] object, String object2, String string2, ExternalDigest externalDigest, boolean bl2) {
        void var6_11;
        void var4_9;
        void var5_10;
        void var3_6;
        this.version = 1;
        this.signerversion = 1;
        this.provider = var4_9;
        this.interfaceDigest = var5_10;
        this.digestAlgorithmOid = DigestAlgorithms.getAllowedDigests((String)var3_6);
        if (this.digestAlgorithmOid == null) {
            throw new NoSuchAlgorithmException(MessageLocalization.getComposedMessage("unknown.hash.algorithm.1", var3_6));
        }
        this.signCert = (X509Certificate)object[0];
        this.certs = new ArrayList<Certificate>();
        for (Certificate certificate : object) {
            this.certs.add(certificate);
        }
        this.digestalgos = new HashSet<String>();
        this.digestalgos.add(this.digestAlgorithmOid);
        if (privateKey != null) {
            void var2_4;
            this.digestEncryptionAlgorithmOid = privateKey.getAlgorithm();
            if (this.digestEncryptionAlgorithmOid.equals("RSA")) {
                String string3 = "1.2.840.113549.1.1.1";
            } else {
                if (!this.digestEncryptionAlgorithmOid.equals("DSA")) {
                    throw new NoSuchAlgorithmException(MessageLocalization.getComposedMessage("unknown.key.algorithm.1", this.digestEncryptionAlgorithmOid));
                }
                String string4 = "1.2.840.10040.4.1";
            }
            this.digestEncryptionAlgorithmOid = var2_4;
        }
        if (var6_11 != false) {
            this.RSAdata = new byte[0];
            this.messageDigest = DigestAlgorithms.getMessageDigest(this.getHashAlgorithm(), (String)var4_9);
        }
        if (privateKey != null) {
            this.sig = this.initSignature(privateKey);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive exception aggregation
     */
    public PdfPKCS7(byte[] var1_1, PdfName var2_4, String var3_5) {
        block30 : {
            block31 : {
                block33 : {
                    block32 : {
                        block28 : {
                            block34 : {
                                block29 : {
                                    super();
                                    this.version = 1;
                                    this.signerversion = 1;
                                    this.filterSubtype = var2_4;
                                    this.isTsp = PdfName.ETSI_RFC3161.equals(var2_4);
                                    this.isCades = PdfName.ETSI_CADES_DETACHED.equals(var2_4);
                                    this.provider = var3_5;
                                    var2_4 = new ASN1InputStream((InputStream)new ByteArrayInputStream((byte[])var1_1));
                                    var2_4 = var2_4.readObject();
                                    if (!(var2_4 instanceof ASN1Sequence)) ** GOTO lbl125
                                    if (!((ASN1ObjectIdentifier)(var2_4 = (ASN1Sequence)var2_4).getObjectAt(0)).getId().equals("1.2.840.113549.1.7.2")) ** GOTO lbl124
                                    var8_6 = (ASN1Sequence)((ASN1TaggedObject)var2_4.getObjectAt(1)).getObject();
                                    this.version = ((ASN1Integer)var8_6.getObjectAt(0)).getValue().intValue();
                                    this.digestalgos = new HashSet<String>();
                                    var9_7 = ((ASN1Set)var8_6.getObjectAt(1)).getObjects();
                                    while (var9_7.hasMoreElements()) {
                                        var10_8 = (ASN1ObjectIdentifier)((ASN1Sequence)var9_7.nextElement()).getObjectAt(0);
                                        this.digestalgos.add(var10_8.getId());
                                    }
                                    var9_7 = (ASN1Sequence)var8_6.getObjectAt(2);
                                    if (var9_7.size() <= 1) break block28;
                                    this.RSAdata = ((ASN1OctetString)((ASN1TaggedObject)var9_7.getObjectAt(1)).getObject()).getOctets();
                                    break block28;
lbl26: // 2 sources:
                                    if (!(var8_6.getObjectAt(var4_9) instanceof ASN1TaggedObject)) break block29;
                                    ++var4_9;
                                    ** GOTO lbl26
                                }
                                var9_7 = new X509CertParser();
                                var9_7.engineInit((InputStream)new ByteArrayInputStream((byte[])var1_1));
                                this.certs = var9_7.engineReadAll();
                                var1_1 = (ASN1Set)var8_6.getObjectAt(var4_9);
                                if (var1_1.size() != 1) ** GOTO lbl123
                                var1_1 = (ASN1Sequence)var1_1.getObjectAt(0);
                                this.signerversion = ((ASN1Integer)var1_1.getObjectAt(0)).getValue().intValue();
                                var9_7 = (ASN1Sequence)var1_1.getObjectAt(1);
                                var8_6 = new X509Principal(var9_7.getObjectAt(0).toASN1Primitive().getEncoded());
                                var9_7 = ((ASN1Integer)var9_7.getObjectAt(1)).getValue();
                                for (X509Certificate var11_10 : this.certs) {
                                    if (!var11_10.getIssuerDN().equals((Object)var8_6) || !var9_7.equals(var11_10.getSerialNumber())) continue;
                                    this.signCert = var11_10;
                                    break;
                                }
                                if (this.signCert == null) ** GOTO lbl118
                                this.signCertificateChain();
                                this.digestAlgorithmOid = ((ASN1ObjectIdentifier)((ASN1Sequence)var1_1.getObjectAt(2)).getObjectAt(0)).getId();
                                if (!(var1_1.getObjectAt(3) instanceof ASN1TaggedObject)) break block30;
                                var8_6 = ASN1Set.getInstance((ASN1TaggedObject)((ASN1TaggedObject)var1_1.getObjectAt(3)), (boolean)false);
                                this.sigAttr = var8_6.getEncoded();
                                this.sigAttrDer = var8_6.getEncoded("DER");
                                var5_13 = 0;
                                var4_9 = 0;
lbl54: // 2 sources:
                                if (var5_13 < var8_6.size()) {
                                    var9_7 = (ASN1Sequence)var8_6.getObjectAt(var5_13);
                                    var10_8 = ((ASN1ObjectIdentifier)var9_7.getObjectAt(0)).getId();
                                    if (var10_8.equals("1.2.840.113549.1.9.4")) {
                                        this.digestAttr = ((ASN1OctetString)((ASN1Set)var9_7.getObjectAt(1)).getObjectAt(0)).getOctets();
                                        var6_14 = var4_9;
                                        break block31;
                                    }
                                    if (var10_8.equals("1.2.840.113583.1.1.8")) {
                                        var9_7 = (ASN1Sequence)((ASN1Set)var9_7.getObjectAt(1)).getObjectAt(0);
                                        var7_15 = 0;
lbl64: // 2 sources:
                                        var6_14 = var4_9;
                                        if (var7_15 >= var9_7.size()) break block31;
                                        var10_8 = (ASN1TaggedObject)var9_7.getObjectAt(var7_15);
                                        if (var10_8.getTagNo() == 0) {
                                            this.findCRL((ASN1Sequence)var10_8.getObject());
                                        }
                                        if (var10_8.getTagNo() != 1) break block32;
                                        this.findOcsp((ASN1Sequence)var10_8.getObject());
                                        break block32;
                                    }
                                    if (this.isCades && var10_8.equals("1.2.840.113549.1.9.16.2.12")) {
                                        var9_7 = SigningCertificate.getInstance((Object)((ASN1Sequence)((ASN1Set)var9_7.getObjectAt(1)).getObjectAt(0))).getCerts()[0];
                                        var10_8 = this.signCert.getEncoded();
                                        if (!Arrays.equals(new BouncyCastleDigest().getMessageDigest("SHA-1").digest((byte[])var10_8), var9_7.getCertHash())) {
                                            throw new IllegalArgumentException("Signing certificate doesn't match the ESS information.");
                                        }
                                        break block33;
                                    }
                                    var6_14 = var4_9;
                                    if (!this.isCades) break block31;
                                    var6_14 = var4_9;
                                    if (!var10_8.equals("1.2.840.113549.1.9.16.2.47")) break block31;
                                    var9_7 = SigningCertificateV2.getInstance((Object)((ASN1Sequence)((ASN1Set)var9_7.getObjectAt(1)).getObjectAt(0))).getCerts()[0];
                                    var10_8 = var9_7.getHashAlgorithm();
                                    var11_12 = this.signCert.getEncoded();
                                    if (!Arrays.equals(new BouncyCastleDigest().getMessageDigest(DigestAlgorithms.getDigest(var10_8.getAlgorithm().getId())).digest(var11_12), var9_7.getCertHash())) {
                                        throw new IllegalArgumentException("Signing certificate doesn't match the ESS information.");
                                    }
                                    break block33;
                                }
                                if (this.digestAttr != null) {
                                    var5_13 = 4;
                                } else {
                                    throw new IllegalArgumentException(MessageLocalization.getComposedMessage("authenticated.attribute.is.missing.the.digest", new Object[0]));
                                }
lbl92: // 2 sources:
                                if (!this.isCades || var4_9 != 0) break block34;
                                throw new IllegalArgumentException("CAdES ESS information missing.");
                            }
                            var4_9 = var5_13 + 1;
                            this.digestEncryptionAlgorithmOid = ((ASN1ObjectIdentifier)((ASN1Sequence)var1_1.getObjectAt(var5_13)).getObjectAt(0)).getId();
                            var5_13 = var4_9 + 1;
                            try {
                                this.digest = ((ASN1OctetString)var1_1.getObjectAt(var4_9)).getOctets();
                                if (var5_13 < var1_1.size() && var1_1.getObjectAt(var5_13) instanceof ASN1TaggedObject && (var1_1 = new AttributeTable(ASN1Set.getInstance((ASN1TaggedObject)((ASN1TaggedObject)var1_1.getObjectAt(var5_13)), (boolean)false)).get(PKCSObjectIdentifiers.id_aa_signatureTimeStampToken)) != null && var1_1.getAttrValues().size() > 0) {
                                    this.timeStampToken = new TimeStampToken(new ContentInfo(ASN1Sequence.getInstance((Object)var1_1.getAttrValues().getObjectAt(0))));
                                }
                                if (this.isTsp) {
                                    this.timeStampToken = new TimeStampToken(new ContentInfo((ASN1Sequence)var2_4));
                                    this.messageDigest = DigestAlgorithms.getMessageDigestFromOid(this.timeStampToken.getTimeStampInfo().getMessageImprintAlgOID().getId(), null);
                                    return;
                                }
                                if (this.RSAdata != null || this.digestAttr != null) {
                                    if (PdfName.ADBE_PKCS7_SHA1.equals(this.getFilterSubtype())) {
                                        var1_1 = DigestAlgorithms.getMessageDigest("SHA1", var3_5);
lbl110: // 2 sources:
                                        do {
                                            continue;
                                            break;
                                        } while (true);
                                    }
                                    var1_1 = DigestAlgorithms.getMessageDigest(this.getHashAlgorithm(), var3_5);
                                    ** continue;
                                    this.messageDigest = var1_1;
                                    this.encContDigest = DigestAlgorithms.getMessageDigest(this.getHashAlgorithm(), var3_5);
                                }
                                this.sig = this.initSignature(this.signCert.getPublicKey());
                                return;
lbl118: // 1 sources:
                                var1_1 = new StringBuilder();
                                var1_1.append(var8_6.getName());
                                var1_1.append(" / ");
                                var1_1.append(var9_7.toString(16));
                                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("can.t.find.signing.certificate.with.serial.1", new Object[]{var1_1.toString()}));
lbl123: // 1 sources:
                                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("this.pkcs.7.object.has.multiple.signerinfos.only.one.is.supported.at.this.time", new Object[0]));
lbl124: // 1 sources:
                                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("not.a.valid.pkcs.7.object.not.signed.data", new Object[0]));
lbl125: // 1 sources:
                                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("not.a.valid.pkcs.7.object.not.a.sequence", new Object[0]));
lbl126: // 1 sources:
                                do {
                                    throw new IllegalArgumentException(MessageLocalization.getComposedMessage("can.t.decode.pkcs7signeddata.object", new Object[0]));
                                    break;
                                } while (true);
                            }
                            catch (Exception var1_2) {
                                throw new ExceptionConverter(var1_2);
                            }
                            {
                                catch (IOException var1_3) {
                                    ** continue;
                                }
                            }
                        }
                        var4_9 = 3;
                        ** GOTO lbl26
                    }
                    ++var7_15;
                    ** GOTO lbl64
                }
                var6_14 = 1;
            }
            ++var5_13;
            var4_9 = var6_14;
            ** GOTO lbl54
        }
        var5_13 = 3;
        var4_9 = 0;
        ** GOTO lbl92
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public PdfPKCS7(byte[] object, byte[] arrby, String string2) {
        this.version = 1;
        this.signerversion = 1;
        try {
            void var1_3;
            void var2_6;
            void var3_7;
            this.provider = var3_7;
            X509CertParser x509CertParser = new X509CertParser();
            x509CertParser.engineInit((InputStream)new ByteArrayInputStream((byte[])var2_6));
            this.certs = x509CertParser.engineReadAll();
            this.signCerts = this.certs;
            this.signCert = (X509Certificate)this.certs.iterator().next();
            this.crls = new ArrayList<CRL>();
            this.digest = ((ASN1OctetString)new ASN1InputStream((InputStream)new ByteArrayInputStream((byte[])object)).readObject()).getOctets();
            if (var3_7 == null) {
                Signature signature = Signature.getInstance("SHA1withRSA");
            } else {
                Signature signature = Signature.getInstance("SHA1withRSA", (String)var3_7);
            }
            this.sig = var1_3;
            this.sig.initVerify(this.signCert.getPublicKey());
            this.digestAlgorithmOid = "1.2.840.10040.4.3";
            this.digestEncryptionAlgorithmOid = "1.3.36.3.3.1.2";
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    private ASN1EncodableVector buildUnauthenticatedAttributes(byte[] aSN1InputStream) {
        if (aSN1InputStream == null) {
            return null;
        }
        aSN1InputStream = new ASN1InputStream((InputStream)new ByteArrayInputStream((byte[])aSN1InputStream));
        ASN1EncodableVector aSN1EncodableVector = new ASN1EncodableVector();
        ASN1EncodableVector aSN1EncodableVector2 = new ASN1EncodableVector();
        aSN1EncodableVector2.add((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113549.1.9.16.2.14"));
        aSN1EncodableVector2.add((ASN1Encodable)new DERSet((ASN1Encodable)((ASN1Sequence)aSN1InputStream.readObject())));
        aSN1EncodableVector.add((ASN1Encodable)new DERSequence(aSN1EncodableVector2));
        return aSN1EncodableVector;
    }

    private void findCRL(ASN1Sequence aSN1Sequence) {
        int n2;
        try {
            this.crls = new ArrayList<CRL>();
            n2 = 0;
        }
        catch (Exception exception) {
            return;
        }
        do {
            if (n2 >= aSN1Sequence.size()) break;
            Object object = new ByteArrayInputStream(aSN1Sequence.getObjectAt(n2).toASN1Primitive().getEncoded("DER"));
            object = (X509CRL)CertificateFactory.getInstance("X.509").generateCRL((InputStream)object);
            this.crls.add((CRL)object);
            ++n2;
        } while (true);
        return;
    }

    /*
     * Enabled aggressive block sorting
     */
    private void findOcsp(ASN1Sequence aSN1Sequence) {
        this.basicResp = null;
        block0 : do {
            int n2 = 0;
            if (aSN1Sequence.getObjectAt(0) instanceof ASN1ObjectIdentifier && ((ASN1ObjectIdentifier)aSN1Sequence.getObjectAt(0)).getId().equals(OCSPObjectIdentifiers.id_pkix_ocsp_basic.getId())) {
                this.basicResp = new BasicOCSPResp(BasicOCSPResponse.getInstance((Object)new ASN1InputStream(((ASN1OctetString)aSN1Sequence.getObjectAt(1)).getOctets()).readObject()));
                return;
            }
            int n3 = 0;
            while (n3 < aSN1Sequence.size()) {
                block9 : {
                    block8 : {
                        block7 : {
                            if (!(aSN1Sequence.getObjectAt(n3) instanceof ASN1Sequence)) break block7;
                            aSN1Sequence = aSN1Sequence.getObjectAt(0);
                            break block8;
                        }
                        if (!(aSN1Sequence.getObjectAt(n3) instanceof ASN1TaggedObject)) break block9;
                        if (!((aSN1Sequence = (ASN1TaggedObject)aSN1Sequence.getObjectAt(n3)).getObject() instanceof ASN1Sequence)) {
                            return;
                        }
                        aSN1Sequence = aSN1Sequence.getObject();
                    }
                    if ((n3 = n2) == 0) continue block0;
                    return;
                }
                ++n3;
            }
            return;
            break;
        } while (true);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private DERSet getAuthenticatedAttributeSet(byte[] object, byte[] aSN1EncodableVector, Collection<byte[]> object2, MakeSignature.CryptoStandard cryptoStandard) {
        ASN1EncodableVector aSN1EncodableVector2;
        boolean bl2;
        ASN1EncodableVector aSN1EncodableVector3;
        block10 : {
            block9 : {
                try {
                    aSN1EncodableVector2 = new ASN1EncodableVector();
                    aSN1EncodableVector3 = new ASN1EncodableVector();
                    aSN1EncodableVector3.add((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113549.1.9.3"));
                    aSN1EncodableVector3.add((ASN1Encodable)new DERSet((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113549.1.7.1")));
                    aSN1EncodableVector2.add((ASN1Encodable)new DERSequence(aSN1EncodableVector3));
                    aSN1EncodableVector3 = new ASN1EncodableVector();
                    aSN1EncodableVector3.add((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113549.1.9.4"));
                    aSN1EncodableVector3.add((ASN1Encodable)new DERSet((ASN1Encodable)new DEROctetString((byte[])object)));
                    aSN1EncodableVector2.add((ASN1Encodable)new DERSequence(aSN1EncodableVector3));
                    if (object2 == null) break block9;
                    object = object2.iterator();
                    while (object.hasNext()) {
                        if ((byte[])object.next() == null) continue;
                        bl2 = true;
                        break block10;
                    }
                }
                catch (Exception exception) {
                    throw new ExceptionConverter(exception);
                }
            }
            bl2 = false;
        }
        if (aSN1EncodableVector != null || bl2) {
            ASN1EncodableVector aSN1EncodableVector4;
            ASN1EncodableVector aSN1EncodableVector5;
            object = new ASN1EncodableVector();
            object.add((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113583.1.1.8"));
            aSN1EncodableVector3 = new ASN1EncodableVector();
            if (bl2) {
                aSN1EncodableVector5 = new ASN1EncodableVector();
                object2 = object2.iterator();
                while (object2.hasNext()) {
                    aSN1EncodableVector4 = (ASN1EncodableVector)object2.next();
                    if (aSN1EncodableVector4 == null) continue;
                    aSN1EncodableVector5.add((ASN1Encodable)new ASN1InputStream((InputStream)new ByteArrayInputStream((byte[])aSN1EncodableVector4)).readObject());
                }
                aSN1EncodableVector3.add((ASN1Encodable)new DERTaggedObject(true, 0, (ASN1Encodable)new DERSequence(aSN1EncodableVector5)));
            }
            if (aSN1EncodableVector != null) {
                aSN1EncodableVector5 = new DEROctetString((byte[])aSN1EncodableVector);
                aSN1EncodableVector = new ASN1EncodableVector();
                object2 = new ASN1EncodableVector();
                object2.add((ASN1Encodable)OCSPObjectIdentifiers.id_pkix_ocsp_basic);
                object2.add((ASN1Encodable)aSN1EncodableVector5);
                aSN1EncodableVector5 = new ASN1Enumerated(0);
                aSN1EncodableVector4 = new ASN1EncodableVector();
                aSN1EncodableVector4.add((ASN1Encodable)aSN1EncodableVector5);
                aSN1EncodableVector4.add((ASN1Encodable)new DERTaggedObject(true, 0, (ASN1Encodable)new DERSequence((ASN1EncodableVector)object2)));
                aSN1EncodableVector.add((ASN1Encodable)new DERSequence(aSN1EncodableVector4));
                aSN1EncodableVector3.add((ASN1Encodable)new DERTaggedObject(true, 1, (ASN1Encodable)new DERSequence(aSN1EncodableVector)));
            }
            object.add((ASN1Encodable)new DERSet((ASN1Encodable)new DERSequence(aSN1EncodableVector3)));
            aSN1EncodableVector2.add((ASN1Encodable)new DERSequence((ASN1EncodableVector)object));
        }
        if (cryptoStandard == MakeSignature.CryptoStandard.CADES) {
            object = new ASN1EncodableVector();
            object.add((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113549.1.9.16.2.47"));
            aSN1EncodableVector = new ASN1EncodableVector();
            if (!DigestAlgorithms.getAllowedDigests("SHA-256").equals(this.digestAlgorithmOid)) {
                aSN1EncodableVector.add((ASN1Encodable)new AlgorithmIdentifier(new ASN1ObjectIdentifier(this.digestAlgorithmOid)));
            }
            aSN1EncodableVector.add((ASN1Encodable)new DEROctetString(this.interfaceDigest.getMessageDigest(this.getHashAlgorithm()).digest(this.signCert.getEncoded())));
            object.add((ASN1Encodable)new DERSet((ASN1Encodable)new DERSequence((ASN1Encodable)new DERSequence((ASN1Encodable)new DERSequence(aSN1EncodableVector)))));
            aSN1EncodableVector2.add((ASN1Encodable)new DERSequence((ASN1EncodableVector)object));
        }
        if (this.signaturePolicyIdentifier == null) return new DERSet(aSN1EncodableVector2);
        aSN1EncodableVector2.add((ASN1Encodable)new Attribute(PKCSObjectIdentifiers.id_aa_ets_sigPolicyId, (ASN1Set)new DERSet((ASN1Encodable)this.signaturePolicyIdentifier)));
        return new DERSet(aSN1EncodableVector2);
    }

    private Signature initSignature(PrivateKey privateKey) {
        Signature signature = this.provider == null ? Signature.getInstance(this.getDigestAlgorithm()) : Signature.getInstance(this.getDigestAlgorithm(), this.provider);
        signature.initSign(privateKey);
        return signature;
    }

    private Signature initSignature(PublicKey publicKey) {
        Object object = this.getDigestAlgorithm();
        if (PdfName.ADBE_X509_RSA_SHA1.equals(this.getFilterSubtype())) {
            object = "SHA1withRSA";
        }
        object = this.provider == null ? Signature.getInstance((String)object) : Signature.getInstance((String)object, this.provider);
        object.initVerify(publicKey);
        return object;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void signCertificateChain() {
        int n2;
        ArrayList<Certificate> arrayList = new ArrayList<Certificate>();
        arrayList.add(this.signCert);
        ArrayList<Certificate> arrayList2 = new ArrayList<Certificate>(this.certs);
        int n3 = 0;
        while (n3 < arrayList2.size()) {
            n2 = n3;
            if (this.signCert.equals(arrayList2.get(n3))) {
                arrayList2.remove(n3);
                n2 = n3 - 1;
            }
            n3 = n2 + 1;
        }
        block5 : while ((n3 = 1) != 0) {
            X509Certificate x509Certificate = (X509Certificate)arrayList.get(arrayList.size() - 1);
            n3 = 0;
            for (n2 = 0; n2 < arrayList2.size(); ++n2) {
                block9 : {
                    X509Certificate x509Certificate2 = (X509Certificate)arrayList2.get(n2);
                    try {
                        if (this.provider == null) {
                            x509Certificate.verify(x509Certificate2.getPublicKey());
                            break block9;
                        }
                        x509Certificate.verify(x509Certificate2.getPublicKey(), this.provider);
                    }
                    catch (Exception exception) {
                        continue;
                    }
                }
                try {
                    arrayList.add(arrayList2.get(n2));
                    arrayList2.remove(n2);
                    continue block5;
                }
                catch (Exception exception) {}
                n3 = 1;
            }
        }
        this.signCerts = arrayList;
    }

    private boolean verifySigAttributes(byte[] arrby) {
        Signature signature = this.initSignature(this.signCert.getPublicKey());
        signature.update(arrby);
        return signature.verify(this.digest);
    }

    public byte[] getAuthenticatedAttributeBytes(byte[] arrby, byte[] arrby2, Collection<byte[]> collection, MakeSignature.CryptoStandard cryptoStandard) {
        try {
            arrby = this.getAuthenticatedAttributeSet(arrby, arrby2, collection, cryptoStandard).getEncoded("DER");
            return arrby;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public Collection<CRL> getCRLs() {
        return this.crls;
    }

    public Certificate[] getCertificates() {
        return this.certs.toArray(new X509Certificate[this.certs.size()]);
    }

    public String getDigestAlgorithm() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(this.getHashAlgorithm());
        stringBuilder.append("with");
        stringBuilder.append(this.getEncryptionAlgorithm());
        return stringBuilder.toString();
    }

    public String getDigestAlgorithmOid() {
        return this.digestAlgorithmOid;
    }

    public String getDigestEncryptionAlgorithmOid() {
        return this.digestEncryptionAlgorithmOid;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public byte[] getEncodedPKCS1() {
        try {
            Object object = this.externalDigest != null ? this.externalDigest : this.sig.sign();
            this.digest = object;
            object = new ByteArrayOutputStream();
            ASN1OutputStream aSN1OutputStream = new ASN1OutputStream((OutputStream)object);
            aSN1OutputStream.writeObject((ASN1Encodable)new DEROctetString(this.digest));
            aSN1OutputStream.close();
            return object.toByteArray();
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public byte[] getEncodedPKCS7() {
        return this.getEncodedPKCS7(null, null, null, null, MakeSignature.CryptoStandard.CMS);
    }

    public byte[] getEncodedPKCS7(byte[] arrby) {
        return this.getEncodedPKCS7(arrby, null, null, null, MakeSignature.CryptoStandard.CMS);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public byte[] getEncodedPKCS7(byte[] object, TSAClient tSAClient, byte[] aSN1OutputStream, Collection<byte[]> collection, MakeSignature.CryptoStandard cryptoStandard) {
        try {
            byte[] arrby;
            String string22;
            Object object2;
            if (this.externalDigest != null) {
                this.digest = this.externalDigest;
                if (this.RSAdata != null) {
                    this.RSAdata = this.externalRSAdata;
                }
            } else {
                if (this.externalRSAdata != null && this.RSAdata != null) {
                    this.RSAdata = this.externalRSAdata;
                    this.sig.update(this.RSAdata);
                    arrby = this.sig.sign();
                } else {
                    if (this.RSAdata != null) {
                        this.RSAdata = this.messageDigest.digest();
                        this.sig.update(this.RSAdata);
                    }
                    arrby = this.sig.sign();
                }
                this.digest = arrby;
            }
            arrby = new byte[]();
            for (String string22 : this.digestalgos) {
                object2 = new ASN1EncodableVector();
                object2.add((ASN1Encodable)new ASN1ObjectIdentifier(string22));
                object2.add((ASN1Encodable)DERNull.INSTANCE);
                arrby.add((ASN1Encodable)new DERSequence((ASN1EncodableVector)object2));
            }
            ASN1EncodableVector aSN1EncodableVector = new ASN1EncodableVector();
            aSN1EncodableVector.add((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113549.1.7.1"));
            if (this.RSAdata != null) {
                aSN1EncodableVector.add((ASN1Encodable)new DERTaggedObject(0, (ASN1Encodable)new DEROctetString(this.RSAdata)));
            }
            aSN1EncodableVector = new DERSequence(aSN1EncodableVector);
            string22 = new ASN1EncodableVector();
            object2 = this.certs.iterator();
            while (object2.hasNext()) {
                string22.add((ASN1Encodable)new ASN1InputStream((InputStream)new ByteArrayInputStream(((X509Certificate)object2.next()).getEncoded())).readObject());
            }
            string22 = new DERSet((ASN1EncodableVector)string22);
            object2 = new ASN1EncodableVector();
            object2.add((ASN1Encodable)new ASN1Integer(this.signerversion));
            ASN1EncodableVector aSN1EncodableVector2 = new ASN1EncodableVector();
            aSN1EncodableVector2.add((ASN1Encodable)CertificateInfo.getIssuer(this.signCert.getTBSCertificate()));
            aSN1EncodableVector2.add((ASN1Encodable)new ASN1Integer(this.signCert.getSerialNumber()));
            object2.add((ASN1Encodable)new DERSequence(aSN1EncodableVector2));
            aSN1EncodableVector2 = new ASN1EncodableVector();
            aSN1EncodableVector2.add((ASN1Encodable)new ASN1ObjectIdentifier(this.digestAlgorithmOid));
            aSN1EncodableVector2.add((ASN1Encodable)new DERNull());
            object2.add((ASN1Encodable)new DERSequence(aSN1EncodableVector2));
            if (object != null) {
                object2.add((ASN1Encodable)new DERTaggedObject(false, 0, (ASN1Encodable)this.getAuthenticatedAttributeSet((byte[])object, (byte[])aSN1OutputStream, collection, cryptoStandard)));
            }
            object = new ASN1EncodableVector();
            object.add((ASN1Encodable)new ASN1ObjectIdentifier(this.digestEncryptionAlgorithmOid));
            object.add((ASN1Encodable)new DERNull());
            object2.add((ASN1Encodable)new DERSequence((ASN1EncodableVector)object));
            object2.add((ASN1Encodable)new DEROctetString(this.digest));
            if (tSAClient != null && (object = tSAClient.getTimeStampToken(tSAClient.getMessageDigest().digest(this.digest))) != null && (object = this.buildUnauthenticatedAttributes((byte[])object)) != null) {
                object2.add((ASN1Encodable)new DERTaggedObject(false, 1, (ASN1Encodable)new DERSet((ASN1EncodableVector)object)));
            }
            object = new ASN1EncodableVector();
            object.add((ASN1Encodable)new ASN1Integer(this.version));
            object.add((ASN1Encodable)new DERSet((ASN1EncodableVector)arrby));
            object.add((ASN1Encodable)aSN1EncodableVector);
            object.add((ASN1Encodable)new DERTaggedObject(false, 0, (ASN1Encodable)string22));
            object.add((ASN1Encodable)new DERSet((ASN1Encodable)new DERSequence((ASN1EncodableVector)object2)));
            tSAClient = new ASN1EncodableVector();
            tSAClient.add((ASN1Encodable)new ASN1ObjectIdentifier("1.2.840.113549.1.7.2"));
            tSAClient.add((ASN1Encodable)new DERTaggedObject(0, (ASN1Encodable)new DERSequence((ASN1EncodableVector)object)));
            object = new ByteArrayOutputStream();
            aSN1OutputStream = new ASN1OutputStream((OutputStream)object);
            aSN1OutputStream.writeObject((ASN1Encodable)new DERSequence((ASN1EncodableVector)tSAClient));
            aSN1OutputStream.close();
            return object.toByteArray();
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public String getEncryptionAlgorithm() {
        String string2;
        String string3 = string2 = EncryptionAlgorithms.getAlgorithm(this.digestEncryptionAlgorithmOid);
        if (string2 == null) {
            string3 = this.digestEncryptionAlgorithmOid;
        }
        return string3;
    }

    public PdfName getFilterSubtype() {
        return this.filterSubtype;
    }

    public String getHashAlgorithm() {
        return DigestAlgorithms.getDigest(this.digestAlgorithmOid);
    }

    public String getLocation() {
        return this.location;
    }

    public BasicOCSPResp getOcsp() {
        return this.basicResp;
    }

    public String getReason() {
        return this.reason;
    }

    public Certificate[] getSignCertificateChain() {
        return this.signCerts.toArray(new X509Certificate[this.signCerts.size()]);
    }

    public Calendar getSignDate() {
        Calendar calendar;
        Calendar calendar2 = calendar = this.getTimeStampDate();
        if (calendar == null) {
            calendar2 = this.signDate;
        }
        return calendar2;
    }

    public String getSignName() {
        return this.signName;
    }

    public X509Certificate getSigningCertificate() {
        return this.signCert;
    }

    public int getSigningInfoVersion() {
        return this.signerversion;
    }

    public Calendar getTimeStampDate() {
        if (this.timeStampToken == null) {
            return null;
        }
        GregorianCalendar gregorianCalendar = new GregorianCalendar();
        gregorianCalendar.setTime(this.timeStampToken.getTimeStampInfo().getGenTime());
        return gregorianCalendar;
    }

    public TimeStampToken getTimeStampToken() {
        return this.timeStampToken;
    }

    public int getVersion() {
        return this.version;
    }

    public boolean isRevocationValid() {
        if (this.basicResp == null) {
            return false;
        }
        if (this.signCerts.size() < 2) {
            return false;
        }
        try {
            X509Certificate[] arrx509Certificate = (X509Certificate[])this.getSignCertificateChain();
            CertificateID certificateID = this.basicResp.getResponses()[0].getCertID();
            DigestCalculator digestCalculator = new JcaDigestCalculatorProviderBuilder().build().get(new AlgorithmIdentifier(certificateID.getHashAlgOID(), (ASN1Encodable)DERNull.INSTANCE));
            X509Certificate x509Certificate = this.getSigningCertificate();
            boolean bl2 = new CertificateID(digestCalculator, (X509CertificateHolder)new JcaX509CertificateHolder(arrx509Certificate[1]), x509Certificate.getSerialNumber()).equals((Object)certificateID);
            return bl2;
        }
        catch (Exception exception) {
            return false;
        }
    }

    public boolean isTsp() {
        return this.isTsp;
    }

    /*
     * Enabled aggressive block sorting
     */
    public void setExternalDigest(byte[] object, byte[] arrby, String string2) {
        void var1_3;
        void var2_6;
        void var3_7;
        this.externalDigest = object;
        this.externalRSAdata = var2_6;
        if (var3_7 == null) {
            return;
        }
        if (var3_7.equals("RSA")) {
            String string3 = "1.2.840.113549.1.1.1";
        } else if (var3_7.equals("DSA")) {
            String string4 = "1.2.840.10040.4.1";
        } else {
            if (!var3_7.equals("ECDSA")) {
                throw new ExceptionConverter(new NoSuchAlgorithmException(MessageLocalization.getComposedMessage("unknown.key.algorithm.1", var3_7)));
            }
            String string5 = "1.2.840.10045.2.1";
        }
        this.digestEncryptionAlgorithmOid = var1_3;
    }

    public void setLocation(String string2) {
        this.location = string2;
    }

    public void setReason(String string2) {
        this.reason = string2;
    }

    public void setSignDate(Calendar calendar) {
        this.signDate = calendar;
    }

    public void setSignName(String string2) {
        this.signName = string2;
    }

    public void setSignaturePolicy(SignaturePolicyInfo signaturePolicyInfo) {
        this.signaturePolicyIdentifier = signaturePolicyInfo.toSignaturePolicyIdentifier();
    }

    public void setSignaturePolicy(SignaturePolicyIdentifier signaturePolicyIdentifier) {
        this.signaturePolicyIdentifier = signaturePolicyIdentifier;
    }

    public void update(byte[] arrby, int n2, int n3) {
        if (this.RSAdata == null && this.digestAttr == null && !this.isTsp) {
            this.sig.update(arrby, n2, n3);
            return;
        }
        this.messageDigest.update(arrby, n2, n3);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public boolean verify() {
        block9 : {
            if (this.verified) {
                return this.verifyResult;
            }
            if (!this.isTsp) break block9;
            var6_1 = this.timeStampToken.getTimeStampInfo().toASN1Structure().getMessageImprint();
            var3_3 = Arrays.equals(this.messageDigest.digest(), var6_1.getHashedMessage());
            ** GOTO lbl12
        }
        if (this.sigAttr == null && this.sigAttrDer == null) {
            if (this.RSAdata != null) {
                this.sig.update(this.messageDigest.digest());
            }
            var3_3 = this.sig.verify(this.digest);
lbl12: // 2 sources:
            this.verifyResult = var3_3;
        } else {
            var6_2 = this.messageDigest.digest();
            var7_5 = this.RSAdata;
            var5_6 = false;
            if (var7_5 != null) {
                var3_4 = Arrays.equals(var6_2, this.RSAdata);
                this.encContDigest.update(this.RSAdata);
                var4_7 = Arrays.equals(this.encContDigest.digest(), this.digestAttr);
            } else {
                var3_4 = true;
                var4_7 = false;
            }
            var1_8 = Arrays.equals(var6_2, this.digestAttr) || var4_7;
            var2_9 = this.verifySigAttributes(this.sigAttr) || this.verifySigAttributes(this.sigAttrDer);
            var4_7 = var5_6;
            if (var1_8) {
                var4_7 = var5_6;
                if (var2_9) {
                    var4_7 = var5_6;
                    if (var3_4) {
                        var4_7 = true;
                    }
                }
            }
            this.verifyResult = var4_7;
        }
        this.verified = true;
        return this.verifyResult;
    }

    public boolean verifyTimestampImprint() {
        if (this.timeStampToken == null) {
            return false;
        }
        Object object = this.timeStampToken.getTimeStampInfo();
        MessageImprint messageImprint = object.toASN1Structure().getMessageImprint();
        object = object.getMessageImprintAlgOID().getId();
        return Arrays.equals(new BouncyCastleDigest().getMessageDigest(DigestAlgorithms.getDigest((String)object)).digest(this.digest), messageImprint.getHashedMessage());
    }
}

