/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocWriter;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.BadPasswordException;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.OutputStreamEncryption;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfPublicKeyRecipient;
import com.itextpdf.text.pdf.PdfPublicKeySecurityHandler;
import com.itextpdf.text.pdf.StandardDecryption;
import com.itextpdf.text.pdf.StringUtils;
import com.itextpdf.text.pdf.crypto.AESCipherCBCnoPad;
import com.itextpdf.text.pdf.crypto.ARCFOUREncryption;
import com.itextpdf.text.pdf.crypto.IVGenerator;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.security.MessageDigest;
import java.security.cert.Certificate;

public class PdfEncryption {
    public static final int AES_128 = 4;
    public static final int AES_256 = 5;
    private static final int KEY_SALT_OFFSET = 40;
    private static final int OU_LENGHT = 48;
    private static final int SALT_LENGHT = 8;
    public static final int STANDARD_ENCRYPTION_128 = 3;
    public static final int STANDARD_ENCRYPTION_40 = 2;
    private static final int VALIDATION_SALT_OFFSET = 32;
    private static final byte[] metadataPad;
    private static final byte[] pad;
    private static final byte[] salt;
    static long seq;
    private ARCFOUREncryption arcfour = new ARCFOUREncryption();
    private int cryptoMode;
    byte[] documentID;
    private boolean embeddedFilesOnly;
    private boolean encryptMetadata;
    byte[] extra = new byte[5];
    byte[] key;
    private int keyLength;
    int keySize;
    MessageDigest md5;
    byte[] mkey = new byte[0];
    byte[] oeKey;
    byte[] ownerKey = new byte[32];
    long permissions;
    byte[] perms;
    protected PdfPublicKeySecurityHandler publicKeyHandler = null;
    private int revision;
    byte[] ueKey;
    byte[] userKey = new byte[32];

    static {
        pad = new byte[]{40, -65, 78, 94, 78, 117, -118, 65, 100, 0, 78, 86, -1, -6, 1, 8, 46, 46, 0, -74, -48, 104, 62, -128, 47, 12, -87, -2, 100, 83, 105, 122};
        salt = new byte[]{115, 65, 108, 84};
        metadataPad = new byte[]{-1, -1, -1, -1};
        seq = System.currentTimeMillis();
    }

    public PdfEncryption() {
        try {
            this.md5 = MessageDigest.getInstance("MD5");
            this.publicKeyHandler = new PdfPublicKeySecurityHandler();
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public PdfEncryption(PdfEncryption pdfEncryption) {
        this();
        if (pdfEncryption.key != null) {
            this.key = (byte[])pdfEncryption.key.clone();
        }
        this.keySize = pdfEncryption.keySize;
        this.mkey = (byte[])pdfEncryption.mkey.clone();
        this.ownerKey = (byte[])pdfEncryption.ownerKey.clone();
        this.userKey = (byte[])pdfEncryption.userKey.clone();
        this.permissions = pdfEncryption.permissions;
        if (pdfEncryption.documentID != null) {
            this.documentID = (byte[])pdfEncryption.documentID.clone();
        }
        this.revision = pdfEncryption.revision;
        this.keyLength = pdfEncryption.keyLength;
        this.encryptMetadata = pdfEncryption.encryptMetadata;
        this.embeddedFilesOnly = pdfEncryption.embeddedFilesOnly;
        this.publicKeyHandler = pdfEncryption.publicKeyHandler;
        if (pdfEncryption.ueKey != null) {
            this.ueKey = (byte[])pdfEncryption.ueKey.clone();
        }
        if (pdfEncryption.oeKey != null) {
            this.oeKey = (byte[])pdfEncryption.oeKey.clone();
        }
        if (pdfEncryption.perms != null) {
            this.perms = (byte[])pdfEncryption.perms.clone();
        }
    }

    private static boolean compareArray(byte[] arrby, byte[] arrby2, int n2) {
        for (int i2 = 0; i2 < n2; ++i2) {
            if (arrby[i2] == arrby2[i2]) continue;
            return false;
        }
        return true;
    }

    private byte[] computeOwnerKey(byte[] arrby, byte[] arrby2) {
        int n2;
        byte[] arrby3 = new byte[32];
        arrby2 = this.md5.digest(arrby2);
        if (this.revision != 3 && this.revision != 4) {
            this.arcfour.prepareARCFOURKey(arrby2, 0, 5);
            this.arcfour.encryptARCFOUR(arrby, arrby3);
            return arrby3;
        }
        byte[] arrby4 = new byte[this.keyLength / 8];
        for (n2 = 0; n2 < 50; ++n2) {
            this.md5.update(arrby2, 0, arrby4.length);
            System.arraycopy(this.md5.digest(), 0, arrby2, 0, arrby4.length);
        }
        System.arraycopy(arrby, 0, arrby3, 0, 32);
        for (n2 = 0; n2 < 20; ++n2) {
            for (int i2 = 0; i2 < arrby4.length; ++i2) {
                arrby4[i2] = (byte)(arrby2[i2] ^ n2);
            }
            this.arcfour.prepareARCFOURKey(arrby4);
            this.arcfour.encryptARCFOUR(arrby3);
        }
        return arrby3;
    }

    public static byte[] createDocumentId() {
        MessageDigest messageDigest;
        try {
            messageDigest = MessageDigest.getInstance("MD5");
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
        long l2 = System.currentTimeMillis();
        long l3 = Runtime.getRuntime().freeMemory();
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(l2);
        stringBuilder.append("+");
        stringBuilder.append(l3);
        stringBuilder.append("+");
        l2 = seq;
        seq = 1L + l2;
        stringBuilder.append(l2);
        return messageDigest.digest(stringBuilder.toString().getBytes());
    }

    public static PdfObject createInfoId(byte[] arrby, boolean bl2) {
        int n2;
        ByteBuffer byteBuffer = new ByteBuffer(90);
        byte[] arrby2 = arrby;
        if (arrby.length == 0) {
            arrby2 = PdfEncryption.createDocumentId();
        }
        byteBuffer.append('[').append('<');
        int n3 = 0;
        for (n2 = 0; n2 < arrby2.length; ++n2) {
            byteBuffer.appendHex(arrby2[n2]);
        }
        byteBuffer.append('>').append('<');
        n2 = n3;
        if (bl2) {
            arrby2 = PdfEncryption.createDocumentId();
            n2 = n3;
        }
        while (n2 < arrby2.length) {
            byteBuffer.appendHex(arrby2[n2]);
            ++n2;
        }
        byteBuffer.append('>').append(']');
        byteBuffer.close();
        return new PdfLiteral(byteBuffer.toByteArray());
    }

    private byte[] padPassword(byte[] arrby) {
        byte[] arrby2 = new byte[32];
        if (arrby == null) {
            System.arraycopy(pad, 0, arrby2, 0, 32);
            return arrby2;
        }
        System.arraycopy(arrby, 0, arrby2, 0, Math.min(arrby.length, 32));
        if (arrby.length < 32) {
            System.arraycopy(pad, 0, arrby2, arrby.length, 32 - arrby.length);
        }
        return arrby2;
    }

    private void setupByOwnerPad(byte[] arrby, byte[] arrby2, byte[] arrby3, byte[] arrby4, long l2) {
        this.setupGlobalEncryptionKey(arrby, this.computeOwnerKey(arrby4, arrby2), arrby4, l2);
        this.setupUserKey();
    }

    private void setupByUserPad(byte[] arrby, byte[] arrby2, byte[] arrby3, long l2) {
        this.setupGlobalEncryptionKey(arrby, arrby2, arrby3, l2);
        this.setupUserKey();
    }

    private void setupGlobalEncryptionKey(byte[] arrby, byte[] arrby2, byte[] arrby3, long l2) {
        this.documentID = arrby;
        this.ownerKey = arrby3;
        this.permissions = l2;
        this.mkey = new byte[this.keyLength / 8];
        this.md5.reset();
        this.md5.update(arrby2);
        this.md5.update(arrby3);
        byte by2 = (byte)l2;
        byte by3 = (byte)(l2 >> 8);
        byte by4 = (byte)(l2 >> 16);
        byte by5 = (byte)(l2 >> 24);
        this.md5.update(new byte[]{by2, by3, by4, by5}, 0, 4);
        if (arrby != null) {
            this.md5.update(arrby);
        }
        if (!this.encryptMetadata) {
            this.md5.update(metadataPad);
        }
        arrby = new byte[this.mkey.length];
        System.arraycopy(this.md5.digest(), 0, arrby, 0, this.mkey.length);
        if (this.revision == 3 || this.revision == 4) {
            for (int i2 = 0; i2 < 50; ++i2) {
                System.arraycopy(this.md5.digest(arrby), 0, arrby, 0, this.mkey.length);
            }
        }
        System.arraycopy(arrby, 0, this.mkey, 0, this.mkey.length);
    }

    private void setupUserKey() {
        int n2;
        if (this.revision != 3 && this.revision != 4) {
            this.arcfour.prepareARCFOURKey(this.mkey);
            this.arcfour.encryptARCFOUR(pad, this.userKey);
            return;
        }
        this.md5.update(pad);
        byte[] arrby = this.md5.digest(this.documentID);
        System.arraycopy(arrby, 0, this.userKey, 0, 16);
        for (n2 = 16; n2 < 32; ++n2) {
            this.userKey[n2] = 0;
        }
        for (n2 = 0; n2 < 20; ++n2) {
            for (int i2 = 0; i2 < this.mkey.length; ++i2) {
                arrby[i2] = (byte)(this.mkey[i2] ^ n2);
            }
            this.arcfour.prepareARCFOURKey(arrby, 0, this.mkey.length);
            this.arcfour.encryptARCFOUR(this.userKey, 0, 16);
        }
    }

    public void addRecipient(Certificate certificate, int n2) {
        this.documentID = PdfEncryption.createDocumentId();
        this.publicKeyHandler.addRecipient(new PdfPublicKeyRecipient(certificate, n2));
    }

    public int calculateStreamSize(int n2) {
        if (this.revision != 4 && this.revision != 5) {
            return n2;
        }
        return (n2 & 2147483632) + 32;
    }

    public byte[] computeUserPassword(byte[] arrby) {
        block3 : {
            if (this.publicKeyHandler.getRecipientsSize() == 0 && 2 <= this.revision && this.revision <= 4) {
                byte[] arrby2 = this.computeOwnerKey(this.ownerKey, this.padPassword(arrby));
                int n2 = 0;
                do {
                    int n3;
                    block4 : {
                        arrby = arrby2;
                        if (n2 >= arrby2.length) break block3;
                        for (n3 = 0; n3 < arrby2.length - n2; ++n3) {
                            if (arrby2[n2 + n3] == pad[n3]) continue;
                            n3 = 0;
                            break block4;
                        }
                        n3 = 1;
                    }
                    if (n3 != 0) break;
                    ++n2;
                } while (true);
                arrby = new byte[n2];
                System.arraycopy(arrby2, 0, arrby, 0, n2);
                return arrby;
            }
            arrby = null;
        }
        return arrby;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public byte[] decryptByteArray(byte[] arrby) {
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            StandardDecryption standardDecryption = this.getDecryptor();
            arrby = standardDecryption.update(arrby, 0, arrby.length);
            if (arrby != null) {
                byteArrayOutputStream.write(arrby);
            }
            if ((arrby = standardDecryption.finish()) == null) return byteArrayOutputStream.toByteArray();
            byteArrayOutputStream.write(arrby);
            return byteArrayOutputStream.toByteArray();
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public byte[] encryptByteArray(byte[] arrby) {
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            OutputStreamEncryption outputStreamEncryption = this.getEncryptionStream(byteArrayOutputStream);
            outputStreamEncryption.write(arrby);
            outputStreamEncryption.finish();
            arrby = byteArrayOutputStream.toByteArray();
            return arrby;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public int getCryptoMode() {
        return this.cryptoMode;
    }

    public StandardDecryption getDecryptor() {
        return new StandardDecryption(this.key, 0, this.keySize, this.revision);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public PdfDictionary getEncryptionDictionary() {
        block32 : {
            block33 : {
                block31 : {
                    block30 : {
                        var5_1 = new PdfDictionary();
                        if (this.publicKeyHandler.getRecipientsSize() <= 0) ** GOTO lbl69
                        var5_1.put(PdfName.FILTER, PdfName.PUBSEC);
                        var5_1.put(PdfName.R, new PdfNumber(this.revision));
                        var4_2 = this.publicKeyHandler.getEncodedRecipients();
                        if (this.revision == 2) {
                            var2_5 = PdfName.V;
                            var3_9 /* !! */  = new PdfNumber(1);
                            break block30;
                        }
                        if (this.revision != 3 || !this.encryptMetadata) break block31;
                        var5_1.put(PdfName.V, new PdfNumber(2));
                        var2_5 = PdfName.LENGTH;
                        var3_9 /* !! */  = new PdfNumber(128);
                        {
                            catch (Exception var2_7) {
                                throw new ExceptionConverter(var2_7);
                            }
                        }
                    }
                    var5_1.put((PdfName)var2_5, var3_9 /* !! */ );
                    var5_1.put(PdfName.SUBFILTER, PdfName.ADBE_PKCS7_S4);
                    var5_1.put(PdfName.RECIPIENTS, var4_2);
                    break block32;
                }
                if (this.revision == 5) {
                    var5_1.put(PdfName.R, new PdfNumber(5));
                    var2_5 = PdfName.V;
                    var3_9 /* !! */  = new PdfNumber(5);
                } else {
                    var5_1.put(PdfName.R, new PdfNumber(4));
                    var2_5 = PdfName.V;
                    var3_9 /* !! */  = new PdfNumber(4);
                }
                var5_1.put((PdfName)var2_5, var3_9 /* !! */ );
                var5_1.put(PdfName.SUBFILTER, PdfName.ADBE_PKCS7_S5);
                var6_11 = new PdfDictionary();
                var6_11.put(PdfName.RECIPIENTS, var4_2);
                if (!this.encryptMetadata) {
                    var6_11.put(PdfName.ENCRYPTMETADATA, PdfBoolean.PDFFALSE);
                }
                if (this.revision != 4) break block33;
                var6_11.put(PdfName.CFM, PdfName.AESV2);
                var2_5 = PdfName.LENGTH;
                var3_9 /* !! */  = new PdfNumber(128);
                ** GOTO lbl49
            }
            if (this.revision == 5) {
                var6_11.put(PdfName.CFM, PdfName.AESV3);
                var6_11.put(PdfName.LENGTH, new PdfNumber(256));
            } else {
                var2_5 = PdfName.CFM;
                var3_9 /* !! */  = PdfName.V2;
lbl49: // 2 sources:
                var6_11.put((PdfName)var2_5, var3_9 /* !! */ );
            }
            var2_5 = new PdfDictionary();
            var2_5.put(PdfName.DEFAULTCRYPTFILTER, var6_11);
            var5_1.put(PdfName.CF, (PdfObject)var2_5);
            if (this.embeddedFilesOnly) {
                var5_1.put(PdfName.EFF, PdfName.DEFAULTCRYPTFILTER);
                var5_1.put(PdfName.STRF, PdfName.IDENTITY);
                var2_5 = PdfName.STMF;
                var3_9 /* !! */  = PdfName.IDENTITY;
            } else {
                var5_1.put(PdfName.STRF, PdfName.DEFAULTCRYPTFILTER);
                var2_5 = PdfName.STMF;
                var3_9 /* !! */  = PdfName.DEFAULTCRYPTFILTER;
            }
            var5_1.put((PdfName)var2_5, var3_9 /* !! */ );
        }
        try {
            block34 : {
                var2_5 = this.revision == 5 ? "SHA-256" : "SHA-1";
                var2_5 = MessageDigest.getInstance((String)var2_5);
                var2_5.update(this.publicKeyHandler.getSeed());
                break block34;
lbl69: // 1 sources:
                var5_1.put(PdfName.FILTER, PdfName.STANDARD);
                var5_1.put(PdfName.O, new PdfLiteral(StringUtils.escapeString(this.ownerKey)));
                var5_1.put(PdfName.U, new PdfLiteral(StringUtils.escapeString(this.userKey)));
                var5_1.put(PdfName.P, new PdfNumber(this.permissions));
                var5_1.put(PdfName.R, new PdfNumber(this.revision));
                if (this.revision == 2) {
                    var3_10 /* !! */  = PdfName.V;
                    var2_8 = new PdfNumber(1);
                } else if (this.revision == 3 && this.encryptMetadata) {
                    var5_1.put(PdfName.V, new PdfNumber(2));
                    var3_10 /* !! */  = PdfName.LENGTH;
                    var2_8 = new PdfNumber(128);
                } else {
                    if (this.revision == 5) {
                        if (!this.encryptMetadata) {
                            var5_1.put(PdfName.ENCRYPTMETADATA, PdfBoolean.PDFFALSE);
                        }
                        var5_1.put(PdfName.OE, new PdfLiteral(StringUtils.escapeString(this.oeKey)));
                        var5_1.put(PdfName.UE, new PdfLiteral(StringUtils.escapeString(this.ueKey)));
                        var5_1.put(PdfName.PERMS, new PdfLiteral(StringUtils.escapeString(this.perms)));
                        var5_1.put(PdfName.V, new PdfNumber(this.revision));
                        var5_1.put(PdfName.LENGTH, new PdfNumber(256));
                        var4_3 = new PdfDictionary();
                        var4_3.put(PdfName.LENGTH, new PdfNumber(32));
                        if (this.embeddedFilesOnly) {
                            var4_3.put(PdfName.AUTHEVENT, PdfName.EFOPEN);
                            var5_1.put(PdfName.EFF, PdfName.STDCF);
                            var5_1.put(PdfName.STRF, PdfName.IDENTITY);
                            var2_8 = PdfName.STMF;
                            var3_10 /* !! */  = PdfName.IDENTITY;
                        } else {
                            var4_3.put(PdfName.AUTHEVENT, PdfName.DOCOPEN);
                            var5_1.put(PdfName.STRF, PdfName.STDCF);
                            var2_8 = PdfName.STMF;
                            var3_10 /* !! */  = PdfName.STDCF;
                        }
                        var5_1.put((PdfName)var2_8, var3_10 /* !! */ );
                        var4_3.put(PdfName.CFM, PdfName.AESV3);
                        var2_8 = new PdfDictionary();
                        var3_10 /* !! */  = var4_3;
                    } else {
                        if (!this.encryptMetadata) {
                            var5_1.put(PdfName.ENCRYPTMETADATA, PdfBoolean.PDFFALSE);
                        }
                        var5_1.put(PdfName.R, new PdfNumber(4));
                        var5_1.put(PdfName.V, new PdfNumber(4));
                        var5_1.put(PdfName.LENGTH, new PdfNumber(128));
                        var4_4 = new PdfDictionary();
                        var4_4.put(PdfName.LENGTH, new PdfNumber(16));
                        if (this.embeddedFilesOnly) {
                            var4_4.put(PdfName.AUTHEVENT, PdfName.EFOPEN);
                            var5_1.put(PdfName.EFF, PdfName.STDCF);
                            var5_1.put(PdfName.STRF, PdfName.IDENTITY);
                            var2_8 = PdfName.STMF;
                            var3_10 /* !! */  = PdfName.IDENTITY;
                        } else {
                            var4_4.put(PdfName.AUTHEVENT, PdfName.DOCOPEN);
                            var5_1.put(PdfName.STRF, PdfName.STDCF);
                            var2_8 = PdfName.STMF;
                            var3_10 /* !! */  = PdfName.STDCF;
                        }
                        var5_1.put((PdfName)var2_8, var3_10 /* !! */ );
                        if (this.revision == 4) {
                            var2_8 = PdfName.CFM;
                            var3_10 /* !! */  = PdfName.AESV2;
                        } else {
                            var2_8 = PdfName.CFM;
                            var3_10 /* !! */  = PdfName.V2;
                        }
                        var4_4.put((PdfName)var2_8, var3_10 /* !! */ );
                        var2_8 = new PdfDictionary();
                        var3_10 /* !! */  = var4_4;
                    }
                    var2_8.put(PdfName.STDCF, var3_10 /* !! */ );
                    var3_10 /* !! */  = PdfName.CF;
                }
                var5_1.put(var3_10 /* !! */ , var2_8);
                return var5_1;
            }
            for (var1_12 = 0; var1_12 < this.publicKeyHandler.getRecipientsSize(); ++var1_12) {
                var2_5.update(this.publicKeyHandler.getEncodedRecipient(var1_12));
            }
            if (!this.encryptMetadata) {
                var2_5.update(new byte[]{-1, -1, -1, -1});
            }
            var2_5 = var2_5.digest();
            if (this.revision == 5) {
                this.key = var2_5;
                return var5_1;
            }
            this.setupByEncryptionKey((byte[])var2_5, this.keyLength);
            return var5_1;
        }
        catch (Exception var2_6) {
            throw new ExceptionConverter(var2_6);
        }
    }

    public OutputStreamEncryption getEncryptionStream(OutputStream outputStream) {
        return new OutputStreamEncryption(outputStream, this.key, 0, this.keySize, this.revision);
    }

    public PdfObject getFileID(boolean bl2) {
        return PdfEncryption.createInfoId(this.documentID, bl2);
    }

    public long getPermissions() {
        return this.permissions;
    }

    public boolean isEmbeddedFilesOnly() {
        return this.embeddedFilesOnly;
    }

    public boolean isMetadataEncrypted() {
        return this.encryptMetadata;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public boolean readKey(PdfDictionary var1_1, byte[] var2_4) {
        var3_5 = false;
        var5_6 = var2_4;
        if (var2_4 != null) ** GOTO lbl6
        var5_6 = new byte[]{};
lbl6: // 2 sources:
        var6_7 = DocWriter.getISOBytes(var1_1.get(PdfName.O).toString());
        var7_8 = DocWriter.getISOBytes(var1_1.get(PdfName.U).toString());
        var8_9 = DocWriter.getISOBytes(var1_1.get(PdfName.OE).toString());
        var9_10 = DocWriter.getISOBytes(var1_1.get(PdfName.UE).toString());
        var2_4 = DocWriter.getISOBytes(var1_1.get(PdfName.PERMS).toString());
        var1_1 = (PdfNumber)var1_1.get(PdfName.P);
        this.oeKey = var8_9;
        this.ueKey = var9_10;
        this.perms = var2_4;
        this.ownerKey = var6_7;
        this.userKey = var7_8;
        this.permissions = var1_1.longValue();
        var1_1 = MessageDigest.getInstance("SHA-256");
        var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
        var1_1.update(var6_7, 32, 8);
        var1_1.update(var7_8, 0, 48);
        var4_11 = PdfEncryption.compareArray(var1_1.digest(), var6_7, 32);
        if (var4_11) {
            var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
            var1_1.update(var6_7, 40, 8);
            var1_1.update(var7_8, 0, 48);
            var1_1 = new AESCipherCBCnoPad(false, var1_1.digest()).processBlock(var8_9, 0, var8_9.length);
        } else {
            var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
            var1_1.update(var7_8, 32, 8);
            if (PdfEncryption.compareArray(var1_1.digest(), var7_8, 32) == false) throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
            var1_1.update(var5_6, 0, Math.min(var5_6.length, 127));
            var1_1.update(var7_8, 40, 8);
            var1_1 = new AESCipherCBCnoPad(false, var1_1.digest()).processBlock(var9_10, 0, var9_10.length);
        }
        this.key = var1_1;
        var1_1 = new AESCipherCBCnoPad(false, this.key).processBlock(var2_4, 0, var2_4.length);
        if (var1_1[9] != 97) throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
        if (var1_1[10] != 100) throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
        if (var1_1[11] != 98) throw new BadPasswordException(MessageLocalization.getComposedMessage("bad.user.password", new Object[0]));
        this.permissions = var1_1[0] & 255 | (var1_1[1] & 255) << 8 | (var1_1[2] & 255) << 16 | (var1_1[2] & 255) << 24;
        if (var1_1[8] == 84) {
            var3_5 = true;
        }
        try {
            this.encryptMetadata = var3_5;
            return var4_11;
        }
        catch (Exception var1_2) {
            throw new ExceptionConverter(var1_2);
        }
        catch (BadPasswordException var1_3) {
            throw var1_3;
        }
    }

    public void setCryptoMode(int n2, int n3) {
        this.cryptoMode = n2;
        boolean bl2 = (n2 & 8) != 8;
        this.encryptMetadata = bl2;
        bl2 = (n2 & 24) == 24;
        this.embeddedFilesOnly = bl2;
        switch (n2 & 7) {
            default: {
                throw new IllegalArgumentException(MessageLocalization.getComposedMessage("no.valid.encryption.mode", new Object[0]));
            }
            case 3: {
                this.keyLength = 256;
                this.keySize = 32;
                n2 = 5;
                break;
            }
            case 2: {
                this.keyLength = 128;
                n2 = 4;
                break;
            }
            case 1: {
                this.embeddedFilesOnly = false;
                this.keyLength = n3 > 0 ? n3 : 128;
                n2 = 3;
                break;
            }
            case 0: {
                this.encryptMetadata = true;
                this.embeddedFilesOnly = false;
                this.keyLength = 40;
                n2 = 2;
            }
        }
        this.revision = n2;
    }

    public void setHashKey(int n2, int n3) {
        if (this.revision == 5) {
            return;
        }
        this.md5.reset();
        this.extra[0] = (byte)n2;
        this.extra[1] = (byte)(n2 >> 8);
        this.extra[2] = (byte)(n2 >> 16);
        this.extra[3] = (byte)n3;
        this.extra[4] = (byte)(n3 >> 8);
        this.md5.update(this.mkey);
        this.md5.update(this.extra);
        if (this.revision == 4) {
            this.md5.update(salt);
        }
        this.key = this.md5.digest();
        this.keySize = this.mkey.length + 5;
        if (this.keySize > 16) {
            this.keySize = 16;
        }
    }

    public void setKey(byte[] arrby) {
        this.key = arrby;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void setupAllKeys(byte[] var1_1, byte[] var2_3, int var3_4) {
        block9 : {
            block8 : {
                var8_5 = var2_3;
                if (var8_5 == null) break block8;
                var2_3 = var8_5;
                if (((byte[])var8_5).length != 0) break block9;
            }
            var2_3 = this.md5.digest(PdfEncryption.createDocumentId());
        }
        var5_6 = this.revision != 3 && this.revision != 4 && this.revision != 5 ? -64 : -3904;
        var3_4 = (var3_4 | var5_6) & -4;
        this.permissions = var6_7 = (long)var3_4;
        if (this.revision != 5) {
            var1_1 = this.padPassword(var1_1);
            this.ownerKey = this.computeOwnerKey(var1_1, this.padPassword(var2_3));
            this.documentID = PdfEncryption.createDocumentId();
            this.setupByUserPad(this.documentID, var1_1, this.ownerKey, var6_7);
            return;
        }
        if (var1_1 != null) ** GOTO lbl20
        try {
            var1_1 = new byte[]{};
lbl20: // 2 sources:
            this.documentID = PdfEncryption.createDocumentId();
            var9_8 = IVGenerator.getIV(8);
            var10_9 = IVGenerator.getIV(8);
            this.key = IVGenerator.getIV(32);
            var8_5 = MessageDigest.getInstance("SHA-256");
            var8_5.update(var1_1, 0, Math.min(var1_1.length, 127));
            var8_5.update(var9_8);
            this.userKey = new byte[48];
            var8_5.digest(this.userKey, 0, 32);
            System.arraycopy(var9_8, 0, this.userKey, 32, 8);
            System.arraycopy(var10_9, 0, this.userKey, 40, 8);
            var8_5.update(var1_1, 0, Math.min(var1_1.length, 127));
            var8_5.update(var10_9);
            this.ueKey = new AESCipherCBCnoPad(true, var8_5.digest()).processBlock(this.key, 0, this.key.length);
            var1_1 = IVGenerator.getIV(8);
            var9_8 = IVGenerator.getIV(8);
            var8_5.update(var2_3, 0, Math.min(var2_3.length, 127));
            var8_5.update(var1_1);
            var8_5.update(this.userKey);
            this.ownerKey = new byte[48];
            var8_5.digest(this.ownerKey, 0, 32);
            System.arraycopy(var1_1, 0, this.ownerKey, 32, 8);
            System.arraycopy(var9_8, 0, this.ownerKey, 40, 8);
            var8_5.update(var2_3, 0, Math.min(var2_3.length, 127));
            var8_5.update(var9_8);
            var8_5.update(this.userKey);
            this.oeKey = new AESCipherCBCnoPad(true, var8_5.digest()).processBlock(this.key, 0, this.key.length);
            var1_1 = IVGenerator.getIV(16);
        }
        catch (Exception var1_2) {
            throw new ExceptionConverter(var1_2);
        }
        var1_1[0] = (byte)var3_4;
        var1_1[1] = (byte)(var3_4 >> 8);
        var1_1[2] = (byte)(var3_4 >> 16);
        var1_1[3] = (byte)(var3_4 >> 24);
        var1_1[4] = -1;
        var1_1[5] = -1;
        var1_1[6] = -1;
        var1_1[7] = -1;
        var4_10 = this.encryptMetadata != false ? 84 : 70;
        var1_1[8] = var4_10;
        var1_1[9] = 97;
        var1_1[10] = 100;
        var1_1[11] = 98;
        this.perms = new AESCipherCBCnoPad(true, this.key).processBlock(var1_1, 0, var1_1.length);
    }

    public void setupByEncryptionKey(byte[] arrby, int n2) {
        this.mkey = new byte[n2 / 8];
        System.arraycopy(arrby, 0, this.mkey, 0, this.mkey.length);
    }

    public void setupByOwnerPassword(byte[] arrby, byte[] arrby2, byte[] arrby3, byte[] arrby4, long l2) {
        this.setupByOwnerPad(arrby, this.padPassword(arrby2), arrby3, arrby4, l2);
    }

    public void setupByUserPassword(byte[] arrby, byte[] arrby2, byte[] arrby3, long l2) {
        this.setupByUserPad(arrby, this.padPassword(arrby2), arrby3, l2);
    }
}

