/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.parser.FilteredTextRenderListener;
import com.itextpdf.text.pdf.parser.MarkedContentRenderFilter;
import com.itextpdf.text.pdf.parser.PdfContentStreamProcessor;
import com.itextpdf.text.pdf.parser.RenderFilter;
import com.itextpdf.text.pdf.parser.RenderListener;
import com.itextpdf.text.pdf.parser.SimpleTextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TextExtractionStrategy;
import com.itextpdf.text.xml.XMLUtil;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.io.Writer;
import java.util.Set;

public class TaggedPdfReaderTool {
    protected PrintWriter out;
    protected PdfReader reader;

    private static String fixTagName(String string2) {
        StringBuilder stringBuilder = new StringBuilder();
        for (int i2 = 0; i2 < string2.length(); ++i2) {
            boolean bl2;
            boolean bl3;
            char c2;
            block9 : {
                boolean bl4;
                block12 : {
                    block11 : {
                        block10 : {
                            c2 = string2.charAt(i2);
                            bl4 = true;
                            bl3 = c2 == ':' || c2 >= 'A' && c2 <= 'Z' || c2 == '_' || c2 >= 'a' && c2 <= 'z' || c2 >= '\u00c0' && c2 <= '\u00d6' || c2 >= '\u00d8' && c2 <= '\u00f6' || c2 >= '\u00f8' && c2 <= '\u02ff' || c2 >= '\u0370' && c2 <= '\u037d' || c2 >= '\u037f' && c2 <= '\u1fff' || c2 >= '\u200c' && c2 <= '\u200d' || c2 >= '\u2070' && c2 <= '\u218f' || c2 >= '\u2c00' && c2 <= '\u2fef' || c2 >= '\u3001' && c2 <= '\ud7ff' || c2 >= '\uf900' && c2 <= '\ufdcf' || c2 >= '\ufdf0' && c2 <= '\ufffd';
                            bl2 = bl4;
                            if (c2 == '-') break block9;
                            bl2 = bl4;
                            if (c2 == '.') break block9;
                            if (c2 < 48) break block10;
                            bl2 = bl4;
                            if (c2 <= 57) break block9;
                        }
                        bl2 = bl4;
                        if (c2 == 183) break block9;
                        if (c2 < 768) break block11;
                        bl2 = bl4;
                        if (c2 <= 879) break block9;
                    }
                    if (c2 < 8255) break block12;
                    bl2 = bl4;
                    if (c2 <= 8256) break block9;
                }
                bl2 = bl3 ? bl4 : false;
            }
            if (i2 == 0) {
                if (!bl3) {
                    c2 = '_';
                }
            } else if (!bl2) {
                c2 = '-';
            }
            stringBuilder.append(c2);
        }
        return stringBuilder.toString();
    }

    public void convertToXml(PdfReader pdfReader, OutputStream outputStream) {
        this.convertToXml(pdfReader, outputStream, "UTF-8");
    }

    public void convertToXml(PdfReader object, OutputStream outputStream, String string2) {
        this.reader = object;
        this.out = new PrintWriter(new OutputStreamWriter(outputStream, string2));
        if ((object = object.getCatalog().getAsDict(PdfName.STRUCTTREEROOT)) != null) {
            this.inspectChild(object.getDirectObject(PdfName.K));
            this.out.flush();
            this.out.close();
            return;
        }
        throw new IOException(MessageLocalization.getComposedMessage("no.structtreeroot.found", new Object[0]));
    }

    public void inspectChild(PdfObject pdfObject) {
        if (pdfObject == null) {
            return;
        }
        if (pdfObject instanceof PdfArray) {
            this.inspectChildArray((PdfArray)pdfObject);
            return;
        }
        if (pdfObject instanceof PdfDictionary) {
            this.inspectChildDictionary((PdfDictionary)pdfObject);
        }
    }

    public void inspectChildArray(PdfArray pdfArray) {
        if (pdfArray == null) {
            return;
        }
        for (int i2 = 0; i2 < pdfArray.size(); ++i2) {
            this.inspectChild(pdfArray.getDirectObject(i2));
        }
    }

    public void inspectChildDictionary(PdfDictionary pdfDictionary) {
        this.inspectChildDictionary(pdfDictionary, false);
    }

    public void inspectChildDictionary(PdfDictionary pdfDictionary, boolean bl2) {
        if (pdfDictionary == null) {
            return;
        }
        Object object = pdfDictionary.getAsName(PdfName.S);
        if (object != null) {
            PdfObject pdfObject;
            object = PdfName.decodeName(object.toString());
            String string2 = TaggedPdfReaderTool.fixTagName((String)object);
            this.out.print("<");
            this.out.print(string2);
            if (bl2 && (pdfObject = pdfDictionary.getAsDict(PdfName.A)) != null) {
                for (PdfName pdfName : pdfObject.getKeys()) {
                    this.out.print(' ');
                    PdfObject pdfObject2 = PdfReader.getPdfObject(pdfObject.get(pdfName));
                    this.out.print(this.xmlName(pdfName));
                    this.out.print("=\"");
                    this.out.print(pdfObject2.toString());
                    this.out.print("\"");
                }
            }
            this.out.print(">");
            pdfObject = pdfDictionary.get(PdfName.ALT);
            if (pdfObject != null && pdfObject.toString() != null) {
                this.out.print("<alt><![CDATA[");
                this.out.print(pdfObject.toString().replaceAll("[\\000]*", ""));
                this.out.print("]]></alt>");
            }
            if ((pdfObject = pdfDictionary.getAsDict(PdfName.PG)) != null) {
                this.parseTag((String)object, pdfDictionary.getDirectObject(PdfName.K), (PdfDictionary)pdfObject);
            }
            this.inspectChild(pdfDictionary.getDirectObject(PdfName.K));
            this.out.print("</");
            this.out.print(string2);
            this.out.println(">");
            return;
        }
        this.inspectChild(pdfDictionary.getDirectObject(PdfName.K));
    }

    public void parseTag(String object, PdfObject pdfObject, PdfDictionary pdfDictionary) {
        boolean bl2 = pdfObject instanceof PdfNumber;
        if (bl2) {
            object = new MarkedContentRenderFilter(((PdfNumber)pdfObject).intValue());
            object = new FilteredTextRenderListener(new SimpleTextExtractionStrategy(), new RenderFilter[]{object});
            new PdfContentStreamProcessor((RenderListener)object).processContent(PdfReader.getPageContent(pdfDictionary), pdfDictionary.getAsDict(PdfName.RESOURCES));
            this.out.print(XMLUtil.escapeXML(object.getResultantText(), true));
            return;
        }
        if (pdfObject instanceof PdfArray) {
            pdfObject = (PdfArray)pdfObject;
            int n2 = pdfObject.size();
            for (int i2 = 0; i2 < n2; ++i2) {
                this.parseTag((String)object, pdfObject.getPdfObject(i2), pdfDictionary);
                if (i2 >= n2 - 1) continue;
                this.out.println();
            }
        } else if (pdfObject instanceof PdfDictionary) {
            pdfObject = (PdfDictionary)pdfObject;
            this.parseTag((String)object, pdfObject.getDirectObject(PdfName.MCID), pdfObject.getAsDict(PdfName.PG));
        }
    }

    protected String xmlName(PdfName object) {
        object = object.toString().replaceFirst("/", "");
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(Character.toLowerCase(object.charAt(0)));
        stringBuilder.append(object.substring(1));
        return stringBuilder.toString();
    }
}

