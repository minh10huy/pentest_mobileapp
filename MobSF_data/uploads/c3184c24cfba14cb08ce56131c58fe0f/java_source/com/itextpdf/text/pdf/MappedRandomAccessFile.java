/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.lang.reflect.Method;
import java.nio.Buffer;
import java.nio.BufferUnderflowException;
import java.nio.ByteBuffer;
import java.nio.MappedByteBuffer;
import java.nio.channels.FileChannel;
import java.security.AccessController;
import java.security.PrivilegedAction;

public class MappedRandomAccessFile {
    private static final int BUFSIZE = 1073741824;
    private FileChannel channel = null;
    private MappedByteBuffer[] mappedBuffers;
    private long pos;
    private long size;

    /*
     * Enabled aggressive block sorting
     */
    public MappedRandomAccessFile(String object, String object2) {
        if (object2.equals("rw")) {
            object = new RandomAccessFile((String)object, (String)object2).getChannel();
            object2 = FileChannel.MapMode.READ_WRITE;
        } else {
            object = new FileInputStream((String)object).getChannel();
            object2 = FileChannel.MapMode.READ_ONLY;
        }
        this.init((FileChannel)object, (FileChannel.MapMode)object2);
    }

    public static boolean clean(final ByteBuffer byteBuffer) {
        if (byteBuffer != null && byteBuffer.isDirect()) {
            return (Boolean)AccessController.doPrivileged(new PrivilegedAction<Boolean>(){

                @Override
                public Boolean run() {
                    Boolean bl2 = Boolean.FALSE;
                    try {
                        Object object = byteBuffer.getClass().getMethod("cleaner", null);
                        object.setAccessible(true);
                        object = object.invoke(byteBuffer, null);
                        object.getClass().getMethod("clean", null).invoke(object, null);
                        object = Boolean.TRUE;
                        return object;
                    }
                    catch (Exception exception) {
                        return bl2;
                    }
                }
            });
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void init(FileChannel object, FileChannel.MapMode mapMode) {
        this.channel = object;
        this.size = object.size();
        this.pos = 0L;
        int n2 = (int)(this.size / 0x40000000L);
        long l2 = this.size;
        int n3 = 0;
        int n4 = l2 % 0x40000000L == 0L ? 0 : 1;
        this.mappedBuffers = new MappedByteBuffer[n2 += n4];
        n4 = n3;
        try {
            for (long i2 = 0L; i2 < this.size; ++n4, i2 += 0x40000000L) {
                l2 = Math.min(this.size - i2, 0x40000000L);
                this.mappedBuffers[n4] = object.map(mapMode, i2, l2);
                this.mappedBuffers[n4].load();
            }
            if (n4 == n2) {
                return;
            }
            object = new StringBuilder();
            object.append("Should never happen - ");
            object.append(n4);
            object.append(" != ");
            object.append(n2);
            throw new Error(object.toString());
        }
        catch (RuntimeException runtimeException) {
            this.close();
            throw runtimeException;
        }
        catch (IOException iOException) {
            this.close();
            throw iOException;
        }
    }

    public void close() {
        for (int i2 = 0; i2 < this.mappedBuffers.length; ++i2) {
            if (this.mappedBuffers[i2] == null) continue;
            MappedRandomAccessFile.clean(this.mappedBuffers[i2]);
            this.mappedBuffers[i2] = null;
        }
        if (this.channel != null) {
            this.channel.close();
        }
        this.channel = null;
    }

    protected void finalize() {
        this.close();
        super.finalize();
    }

    public FileChannel getChannel() {
        return this.channel;
    }

    public long getFilePointer() {
        return this.pos;
    }

    public long length() {
        return this.size;
    }

    public int read() {
        int n2;
        int n3;
        block5 : {
            block4 : {
                try {
                    n2 = (int)(this.pos / 0x40000000L);
                    n3 = (int)(this.pos % 0x40000000L);
                    if (n2 < this.mappedBuffers.length) break block4;
                    return -1;
                }
                catch (BufferUnderflowException bufferUnderflowException) {
                    return -1;
                }
            }
            if (n3 < this.mappedBuffers[n2].limit()) break block5;
            return -1;
        }
        n2 = this.mappedBuffers[n2].get(n3);
        ++this.pos;
        return n2 & 255;
    }

    public int read(byte[] arrby, int n2, int n3) {
        MappedByteBuffer mappedByteBuffer;
        int n4 = (int)(this.pos / 0x40000000L);
        int n5 = (int)(this.pos % 0x40000000L);
        int n6 = n2;
        for (n2 = 0; n2 < n3 && n4 < this.mappedBuffers.length && n5 <= (mappedByteBuffer = this.mappedBuffers[n4]).limit(); n2 += n5, ++n4) {
            mappedByteBuffer.position(n5);
            n5 = Math.min(n3 - n2, mappedByteBuffer.remaining());
            mappedByteBuffer.get(arrby, n6, n5);
            n6 += n5;
            this.pos += (long)n5;
            n5 = 0;
        }
        n3 = n2;
        if (n2 == 0) {
            n3 = -1;
        }
        return n3;
    }

    public void seek(long l2) {
        this.pos = l2;
    }

}

