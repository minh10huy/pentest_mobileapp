/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.pdf.ArrayBasedStringTokenizer;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.CJKFont;
import com.itextpdf.text.pdf.Glyph;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.TrueTypeFontUnicode;
import com.itextpdf.text.pdf.fonts.otf.Language;
import com.itextpdf.text.pdf.languages.BanglaGlyphRepositioner;
import com.itextpdf.text.pdf.languages.GlyphRepositioner;
import com.itextpdf.text.pdf.languages.IndicCompositeCharacterComparator;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

class FontDetails {
    BaseFont baseFont;
    CJKFont cjkFont;
    IntHashtable cjkTag;
    PdfName fontName;
    int fontType;
    PdfIndirectReference indirectReference;
    HashMap<Integer, int[]> longTag;
    byte[] shortTag;
    protected boolean subset = true;
    boolean symbolic;
    TrueTypeFontUnicode ttu;

    FontDetails(PdfName pdfName, PdfIndirectReference pdfIndirectReference, BaseFont baseFont) {
        this.fontName = pdfName;
        this.indirectReference = pdfIndirectReference;
        this.baseFont = baseFont;
        this.fontType = baseFont.getFontType();
        switch (this.fontType) {
            default: {
                return;
            }
            case 3: {
                this.longTag = new HashMap();
                this.ttu = (TrueTypeFontUnicode)baseFont;
                this.symbolic = baseFont.isFontSpecific();
                return;
            }
            case 2: {
                this.cjkTag = new IntHashtable();
                this.cjkFont = (CJKFont)baseFont;
                return;
            }
            case 0: 
            case 1: 
        }
        this.shortTag = new byte[256];
    }

    private boolean canApplyGlyphSubstitution() {
        if (this.fontType == 3 && this.ttu.getGlyphSubstitutionMap() != null) {
            return true;
        }
        return false;
    }

    private byte[] convertToBytesAfterGlyphSubstitution(String object) {
        if (this.canApplyGlyphSubstitution()) {
            Object object2;
            int n2;
            Object object3 = this.ttu.getGlyphSubstitutionMap();
            Object object4 = new String[](new IndicCompositeCharacterComparator());
            object4.addAll(object3.keySet());
            object4 = new ArrayBasedStringTokenizer(object4.toArray(new String[0])).tokenize((String)object);
            object = new ArrayList(50);
            int n3 = ((String[])object4).length;
            for (n2 = 0; n2 < n3; ++n2) {
                object2 = object4[n2];
                int[] arrn = (int[])object3.get(object2);
                if (arrn != null) {
                    object.add(arrn);
                    continue;
                }
                for (char c2 : object2.toCharArray()) {
                    arrn = this.ttu.getMetricsTT(c2);
                    object.add(new Glyph(arrn[0], arrn[1], String.valueOf(c2)));
                }
            }
            object3 = this.getGlyphRepositioner();
            if (object3 != null) {
                object3.repositionGlyphs((List<Glyph>)object);
            }
            object3 = new char[object.size()];
            for (n2 = 0; n2 < object.size(); ++n2) {
                object4 = (Glyph)object.get(n2);
                object3[n2] = (char)object4.code;
                object2 = object4.code;
                if (this.longTag.containsKey(object2)) continue;
                this.longTag.put((Integer)object2, new int[]{object4.code, object4.width, object4.chars.charAt(0)});
            }
            return new String((char[])object3).getBytes("UnicodeBigUnmarked");
        }
        throw new IllegalArgumentException("Make sure the font type if TTF Unicode and a valid GlyphSubstitutionTable exists!");
    }

    private GlyphRepositioner getGlyphRepositioner() {
        Object object = this.ttu.getSupportedLanguage();
        if (object != null) {
            if (.$SwitchMap$com$itextpdf$text$pdf$fonts$otf$Language[object.ordinal()] != 1) {
                return null;
            }
            return new BanglaGlyphRepositioner(Collections.unmodifiableMap(this.ttu.cmap31), this.ttu.getGlyphSubstitutionMap());
        }
        object = new StringBuilder();
        object.append("The supported language field cannot be null in ");
        object.append(this.ttu.getClass().getName());
        throw new IllegalArgumentException(object.toString());
    }

    /*
     * Exception decompiling
     */
    byte[] convertToBytes(String var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.CannotPerformDecode: reachable test BLOCK was exited and re-entered.
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.Misc.getFarthestReachableInRange(Misc.java:143)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:385)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    /*
     * Unable to fully structure code
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    Object[] convertToBytesGid(String var1_1) {
        block7 : {
            if (this.fontType != 3) throw new IllegalArgumentException("GID require TT Unicode");
            var8_3 = new StringBuilder();
            var9_4 = var1_1.toCharArray();
            var4_5 = var9_4.length;
            var2_6 = 0;
            var3_7 = 0;
lbl8: // 2 sources:
            if (var2_6 >= var4_5) ** GOTO lbl23
            var5_8 = var9_4[var2_6];
            try {
                var6_9 = this.ttu.getGlyphWidth(var5_8);
            }
            catch (Exception var1_2) {
                throw new ExceptionConverter(var1_2);
            }
            var3_7 += var6_9;
            var7_10 = this.ttu.GetCharFromGlyphId(var5_8);
            if (var7_10 == 0) ** GOTO lbl20
            var8_3.append(Utilities.convertFromUtf32(var7_10));
lbl20: // 2 sources:
            if (!this.longTag.containsKey(var10_11 = Integer.valueOf(var5_8))) {
                this.longTag.put(var10_11, new int[]{var5_8, var6_9, var7_10});
            }
            break block7;
lbl23: // 1 sources:
            var1_1 = var1_1.getBytes("UnicodeBigUnmarked");
            var8_3 = var8_3.toString();
            return new Object[]{var1_1, var8_3, var3_7};
        }
        ++var2_6;
        ** GOTO lbl8
    }

    BaseFont getBaseFont() {
        return this.baseFont;
    }

    PdfName getFontName() {
        return this.fontName;
    }

    PdfIndirectReference getIndirectReference() {
        return this.indirectReference;
    }

    public boolean isSubset() {
        return this.subset;
    }

    public void setSubset(boolean bl2) {
        this.subset = bl2;
    }

    /*
     * Exception decompiling
     */
    public void writeFont(PdfWriter var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [4[CASE]], but top level block is 1[TRYBLOCK]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

}

