/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocWriter;
import com.itextpdf.text.Document;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.OutputStreamCounter;
import com.itextpdf.text.pdf.OutputStreamEncryption;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncryption;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfWriter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;

public class PdfStream
extends PdfDictionary {
    public static final int BEST_COMPRESSION = 9;
    public static final int BEST_SPEED = 1;
    public static final int DEFAULT_COMPRESSION = -1;
    static final byte[] ENDSTREAM;
    public static final int NO_COMPRESSION = 0;
    static final int SIZESTREAM;
    static final byte[] STARTSTREAM;
    protected boolean compressed = false;
    protected int compressionLevel = 0;
    protected InputStream inputStream;
    protected int inputStreamLength = -1;
    protected int rawLength;
    protected PdfIndirectReference ref;
    protected ByteArrayOutputStream streamBytes = null;
    protected PdfWriter writer;

    static {
        STARTSTREAM = DocWriter.getISOBytes("stream\n");
        ENDSTREAM = DocWriter.getISOBytes("\nendstream");
        SIZESTREAM = STARTSTREAM.length + ENDSTREAM.length;
    }

    protected PdfStream() {
        this.type = 7;
    }

    public PdfStream(InputStream inputStream, PdfWriter pdfWriter) {
        this.type = 7;
        this.inputStream = inputStream;
        this.writer = pdfWriter;
        this.ref = pdfWriter.getPdfIndirectReference();
        this.put(PdfName.LENGTH, this.ref);
    }

    public PdfStream(byte[] arrby) {
        this.type = 7;
        this.bytes = arrby;
        this.rawLength = arrby.length;
        this.put(PdfName.LENGTH, new PdfNumber(arrby.length));
    }

    public void flateCompress() {
        this.flateCompress(-1);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public void flateCompress(int n2) {
        if (!Document.compress) {
            return;
        }
        if (this.compressed) {
            return;
        }
        this.compressionLevel = n2;
        if (this.inputStream != null) {
            this.compressed = true;
            return;
        }
        PdfObject pdfObject = PdfReader.getPdfObject(this.get(PdfName.FILTER));
        if (pdfObject != null) {
            if (pdfObject.isName()) {
                if (PdfName.FLATEDECODE.equals(pdfObject)) {
                    return;
                }
            } else {
                if (!pdfObject.isArray()) {
                    throw new RuntimeException(MessageLocalization.getComposedMessage("stream.could.not.be.compressed.filter.is.not.a.name.or.array", new Object[0]));
                }
                if (((PdfArray)pdfObject).contains(PdfName.FLATEDECODE)) {
                    return;
                }
            }
        }
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            Deflater deflater = new Deflater(n2);
            DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream((OutputStream)byteArrayOutputStream, deflater);
            if (this.streamBytes != null) {
                this.streamBytes.writeTo(deflaterOutputStream);
            } else {
                deflaterOutputStream.write(this.bytes);
            }
            deflaterOutputStream.close();
            deflater.end();
            this.streamBytes = byteArrayOutputStream;
            this.bytes = null;
            this.put(PdfName.LENGTH, new PdfNumber(this.streamBytes.size()));
            if (pdfObject == null) {
                this.put(PdfName.FILTER, PdfName.FLATEDECODE);
            } else {
                pdfObject = new PdfArray(pdfObject);
                pdfObject.add(0, PdfName.FLATEDECODE);
                this.put(PdfName.FILTER, pdfObject);
            }
            this.compressed = true;
            return;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public int getRawLength() {
        return this.rawLength;
    }

    protected void superToPdf(PdfWriter pdfWriter, OutputStream outputStream) {
        super.toPdf(pdfWriter, outputStream);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    @Override
    public void toPdf(PdfWriter var1_1, OutputStream var2_2) {
        block20 : {
            block18 : {
                block19 : {
                    block16 : {
                        block17 : {
                            if (this.inputStream != null && this.compressed) {
                                this.put(PdfName.FILTER, PdfName.FLATEDECODE);
                            }
                            var7_3 = null;
                            var4_4 = var1_1 != null ? var1_1.getEncryption() : null;
                            var5_5 = var4_4;
                            if (var4_4 == null) break block16;
                            var6_6 = this.get(PdfName.FILTER);
                            var5_5 = var4_4;
                            if (var6_6 == null) break block16;
                            if (PdfName.CRYPT.equals(var6_6)) break block17;
                            var5_5 = var4_4;
                            if (!var6_6.isArray()) break block16;
                            var6_6 = (PdfArray)var6_6;
                            var5_5 = var4_4;
                            if (var6_6.isEmpty()) break block16;
                            var5_5 = var4_4;
                            if (!PdfName.CRYPT.equals(var6_6.getPdfObject(0))) break block16;
                        }
                        var5_5 = null;
                    }
                    var4_4 = this.get(PdfName.LENGTH);
                    if (var5_5 != null && var4_4 != null && var4_4.isNumber()) {
                        var3_7 = ((PdfNumber)var4_4).intValue();
                        this.put(PdfName.LENGTH, new PdfNumber(var5_5.calculateStreamSize(var3_7)));
                        this.superToPdf((PdfWriter)var1_1, var2_2);
                        this.put(PdfName.LENGTH, (PdfObject)var4_4);
                    } else {
                        this.superToPdf((PdfWriter)var1_1, var2_2);
                    }
                    PdfWriter.checkPdfIsoConformance((PdfWriter)var1_1, 9, this);
                    var2_2.write(PdfStream.STARTSTREAM);
                    if (this.inputStream != null) break block18;
                    if (var5_5 == null || var5_5.isEmbeddedFilesOnly()) break block19;
                    var1_1 = this.streamBytes != null ? this.streamBytes.toByteArray() : this.bytes;
                    var1_1 = var5_5.encryptByteArray((byte[])var1_1);
                    ** GOTO lbl41
                }
                if (this.streamBytes != null) {
                    this.streamBytes.writeTo(var2_2);
                } else {
                    var1_1 = this.bytes;
lbl41: // 2 sources:
                    var2_2.write((byte[])var1_1);
                }
                break block20;
            }
            this.rawLength = 0;
            var8_8 = new OutputStreamCounter(var2_2);
            if (var5_5 != null && !var5_5.isEmbeddedFilesOnly()) {
                var4_4 = var1_1 = var5_5.getEncryptionStream(var8_8);
            } else {
                var1_1 = var8_8;
                var4_4 = null;
            }
            if (this.compressed) {
                var6_6 = new Deflater(this.compressionLevel);
                var1_1 = var5_5 = new DeflaterOutputStream((OutputStream)var1_1, (Deflater)var6_6, 32768);
            } else {
                var6_6 = null;
                var5_5 = var1_1;
                var1_1 = var7_3;
            }
            var7_3 = new byte[4192];
            do {
                if ((var3_7 = this.inputStream.read(var7_3)) <= 0) {
                    if (var1_1 != null) {
                        var1_1.finish();
                        var6_6.end();
                    }
                    if (var4_4 != null) {
                        var4_4.finish();
                    }
                    this.inputStreamLength = (int)var8_8.getCounter();
                    break;
                }
                var5_5.write(var7_3, 0, var3_7);
                this.rawLength += var3_7;
            } while (true);
        }
        var2_2.write(PdfStream.ENDSTREAM);
    }

    @Override
    public String toString() {
        if (this.get(PdfName.TYPE) == null) {
            return "Stream";
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("Stream of type: ");
        stringBuilder.append(this.get(PdfName.TYPE));
        return stringBuilder.toString();
    }

    public void writeContent(OutputStream outputStream) {
        if (this.streamBytes != null) {
            this.streamBytes.writeTo(outputStream);
            return;
        }
        if (this.bytes != null) {
            outputStream.write(this.bytes);
        }
    }

    public void writeLength() {
        if (this.inputStream != null) {
            if (this.inputStreamLength != -1) {
                this.writer.addToBody((PdfObject)new PdfNumber(this.inputStreamLength), this.ref, false);
                return;
            }
            throw new IOException(MessageLocalization.getComposedMessage("writelength.can.only.be.called.after.output.of.the.stream.body", new Object[0]));
        }
        throw new UnsupportedOperationException(MessageLocalization.getComposedMessage("writelength.can.only.be.called.in.a.contructed.pdfstream.inputstream.pdfwriter", new Object[0]));
    }
}

