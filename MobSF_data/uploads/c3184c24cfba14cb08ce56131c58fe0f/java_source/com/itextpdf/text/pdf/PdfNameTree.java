/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import java.io.Serializable;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Set;

public class PdfNameTree {
    private static final int leafSize = 64;

    private static PdfString iterateItems(PdfDictionary pdfObject, HashMap<String, PdfObject> hashMap, PdfString pdfObject2) {
        block6 : {
            int n2;
            block5 : {
                PdfArray pdfArray = (PdfArray)PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.NAMES));
                int n3 = 0;
                if (pdfArray == null) break block5;
                for (n2 = 0; n2 < pdfArray.size(); ++n2) {
                    if (pdfObject2 == null) {
                        n3 = n2 + 1;
                        PdfString pdfString = (PdfString)PdfReader.getPdfObjectRelease(pdfArray.getPdfObject(n2));
                        pdfObject = pdfObject2;
                        pdfObject2 = pdfString;
                        n2 = n3;
                    } else {
                        pdfObject = null;
                    }
                    if (n2 < pdfArray.size()) {
                        hashMap.put(PdfEncodings.convertToString(pdfObject2.getBytes(), null), pdfArray.getPdfObject(n2));
                        pdfObject2 = pdfObject;
                        continue;
                    }
                    return pdfObject2;
                }
                break block6;
            }
            if ((pdfObject = (PdfArray)PdfReader.getPdfObjectRelease(pdfObject.get(PdfName.KIDS))) == null) break block6;
            for (n2 = n3; n2 < pdfObject.size(); ++n2) {
                pdfObject2 = PdfNameTree.iterateItems((PdfDictionary)PdfReader.getPdfObjectRelease(pdfObject.getPdfObject(n2)), hashMap, pdfObject2);
            }
        }
        return null;
    }

    public static HashMap<String, PdfObject> readTree(PdfDictionary pdfDictionary) {
        HashMap<String, PdfObject> hashMap = new HashMap<String, PdfObject>();
        if (pdfDictionary != null) {
            PdfNameTree.iterateItems(pdfDictionary, hashMap, null);
        }
        return hashMap;
    }

    public static PdfDictionary writeTree(HashMap<String, ? extends PdfObject> serializable, PdfWriter object) {
        PdfObject pdfObject;
        int n2;
        int n3;
        if (serializable.isEmpty()) {
            return null;
        }
        Object[] arrobject = new String[serializable.size()];
        arrobject = serializable.keySet().toArray(arrobject);
        Arrays.sort(arrobject);
        int n4 = arrobject.length;
        int n5 = 64;
        if (n4 <= 64) {
            object = new PdfDictionary();
            PdfArray pdfArray = new PdfArray();
            for (n4 = 0; n4 < arrobject.length; ++n4) {
                pdfArray.add(new PdfString((String)arrobject[n4], null));
                pdfArray.add(serializable.get(arrobject[n4]));
            }
            object.put(PdfName.NAMES, pdfArray);
            return object;
        }
        PdfIndirectReference[] arrpdfIndirectReference = new PdfIndirectReference[(arrobject.length + 64 - 1) / 64];
        for (n4 = 0; n4 < arrpdfIndirectReference.length; ++n4) {
            n3 = Math.min(n2 + 64, arrobject.length);
            pdfObject = new PdfDictionary();
            PdfArray pdfArray = new PdfArray();
            pdfArray.add(new PdfString((String)arrobject[n2], null));
            pdfArray.add(new PdfString((String)arrobject[n3 - 1], null));
            pdfObject.put(PdfName.LIMITS, pdfArray);
            pdfArray = new PdfArray();
            for (n2 = n4 * 64; n2 < n3; ++n2) {
                pdfArray.add(new PdfString((String)arrobject[n2], null));
                pdfArray.add((PdfObject)serializable.get(arrobject[n2]));
            }
            pdfObject.put(PdfName.NAMES, pdfArray);
            arrpdfIndirectReference[n4] = object.addToBody(pdfObject).getIndirectReference();
        }
        n4 = arrpdfIndirectReference.length;
        n2 = 64;
        do {
            if (n4 <= n5) {
                serializable = new PdfArray();
                for (n2 = 0; n2 < n4; ++n2) {
                    serializable.add(arrpdfIndirectReference[n2]);
                }
                object = new PdfDictionary();
                object.put(PdfName.KIDS, (PdfObject)serializable);
                return object;
            }
            n3 = n2 * 64;
            int n6 = (arrobject.length + n3 - 1) / n3;
            n2 = 0;
            while (n2 < n6) {
                int n7 = Math.min(n5 + 64, n4);
                serializable = new PdfDictionary();
                pdfObject = new PdfArray();
                pdfObject.add(new PdfString((String)arrobject[n2 * n3], null));
                int n8 = n2 + 1;
                pdfObject.add(new PdfString((String)arrobject[Math.min(n8 * n3, arrobject.length) - 1], null));
                serializable.put(PdfName.LIMITS, pdfObject);
                pdfObject = new PdfArray();
                for (n5 = n2 * 64; n5 < n7; ++n5) {
                    pdfObject.add(arrpdfIndirectReference[n5]);
                }
                serializable.put(PdfName.KIDS, pdfObject);
                arrpdfIndirectReference[n2] = object.addToBody((PdfObject)serializable).getIndirectReference();
                n2 = n8;
                n5 = 64;
            }
            n4 = n6;
            n2 = n3;
        } while (true);
    }
}

