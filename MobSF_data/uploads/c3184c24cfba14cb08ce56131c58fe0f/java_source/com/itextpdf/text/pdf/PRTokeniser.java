/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.InvalidPdfException;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;

public class PRTokeniser {
    static final String EMPTY = "";
    public static final boolean[] delims = new boolean[]{true, true, false, false, false, false, false, false, false, false, true, true, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, false, true, true, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false};
    private final RandomAccessFileOrArray file;
    protected int generation;
    protected boolean hexString;
    private final StringBuilder outBuf = new StringBuilder();
    protected int reference;
    protected String stringValue;
    protected TokenType type;

    public PRTokeniser(RandomAccessFileOrArray randomAccessFileOrArray) {
        this.file = randomAccessFileOrArray;
    }

    public static long[] checkObjectStart(byte[] object) {
        block5 : {
            int n2;
            int n3;
            block9 : {
                block8 : {
                    block7 : {
                        block6 : {
                            try {
                                object = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource((byte[])object)));
                                if (!object.nextToken()) break block5;
                                if (object.getTokenType() == TokenType.NUMBER) break block6;
                                return null;
                            }
                            catch (Exception exception) {
                                return null;
                            }
                        }
                        n2 = object.intValue();
                        if (!object.nextToken()) break block5;
                        if (object.getTokenType() == TokenType.NUMBER) break block7;
                        return null;
                    }
                    n3 = object.intValue();
                    if (object.nextToken()) break block8;
                    return null;
                }
                if (object.getStringValue().equals("obj")) break block9;
                return null;
            }
            long l2 = n2;
            long l3 = n3;
            return new long[]{l2, l3};
        }
        return null;
    }

    /*
     * Enabled aggressive block sorting
     */
    public static int getHex(int n2) {
        if (n2 >= 48 && n2 <= 57) {
            return n2 - 48;
        }
        int n3 = 65;
        if (n2 >= 65 && n2 <= 70) {
            return n2 - n3 + 10;
        }
        n3 = 97;
        if (n2 < 97) return -1;
        if (n2 > 102) return -1;
        return n2 - n3 + 10;
    }

    public static final boolean isDelimiter(int n2) {
        if (n2 != 40 && n2 != 41 && n2 != 60 && n2 != 62 && n2 != 91 && n2 != 93 && n2 != 47 && n2 != 37) {
            return false;
        }
        return true;
    }

    public static final boolean isDelimiterWhitespace(int n2) {
        return delims[n2 + 1];
    }

    public static final boolean isWhitespace(int n2) {
        return PRTokeniser.isWhitespace(n2, true);
    }

    public static final boolean isWhitespace(int n2, boolean bl2) {
        if (!(bl2 && n2 == 0 || n2 == 9 || n2 == 10 || n2 == 12 || n2 == 13 || n2 == 32)) {
            return false;
        }
        return true;
    }

    public void backOnePosition(int n2) {
        if (n2 != -1) {
            this.file.pushBack((byte)n2);
        }
    }

    public void checkFdfHeader() {
        this.file.seek(0L);
        if (this.readString(1024).indexOf("%FDF-") == 0) {
            return;
        }
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("fdf.header.not.found", new Object[0]));
    }

    public char checkPdfHeader() {
        this.file.seek(0L);
        String string2 = this.readString(1024);
        if (string2.indexOf("%PDF-") == 0) {
            return string2.charAt(7);
        }
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("pdf.header.not.found", new Object[0]));
    }

    public void close() {
        this.file.close();
    }

    public RandomAccessFileOrArray getFile() {
        return this.file;
    }

    public long getFilePointer() {
        return this.file.getFilePointer();
    }

    public int getGeneration() {
        return this.generation;
    }

    public int getHeaderOffset() {
        String string2 = this.readString(1024);
        int n2 = string2.indexOf("%PDF-");
        if (n2 < 0) {
            n2 = string2.indexOf("%FDF-");
            if (n2 >= 0) {
                return n2;
            }
            throw new InvalidPdfException(MessageLocalization.getComposedMessage("pdf.header.not.found", new Object[0]));
        }
        return n2;
    }

    public int getReference() {
        return this.reference;
    }

    public RandomAccessFileOrArray getSafeFile() {
        return new RandomAccessFileOrArray(this.file);
    }

    public long getStartxref() {
        long l2;
        long l3 = this.file.length();
        long l4 = 1024;
        l3 = l2 = l3 - l4;
        if (l2 < 1L) {
            l3 = 1L;
        }
        while (l3 > 0L) {
            this.file.seek(l3);
            int n2 = this.readString(1024).lastIndexOf("startxref");
            if (n2 >= 0) {
                return l3 + (long)n2;
            }
            l3 = l3 - l4 + 9L;
        }
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("pdf.startxref.not.found", new Object[0]));
    }

    public String getStringValue() {
        return this.stringValue;
    }

    public TokenType getTokenType() {
        return this.type;
    }

    public int intValue() {
        return Integer.parseInt(this.stringValue);
    }

    public boolean isHexString() {
        return this.hexString;
    }

    public long length() {
        return this.file.length();
    }

    public long longValue() {
        return Long.parseLong(this.stringValue);
    }

    /*
     * Exception decompiling
     */
    public boolean nextToken() {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Extractable last case doesn't follow previous
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:486)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public void nextValidToken() {
        String string2 = null;
        int n2 = 0;
        long l2 = 0L;
        String string3 = null;
        while (this.nextToken()) {
            block9 : {
                block8 : {
                    if (this.type == TokenType.COMMENT) continue;
                    switch (n2) {
                        default: {
                            if (this.type == TokenType.OTHER && this.stringValue.equals("R")) break block8;
                            break block9;
                        }
                        case 1: {
                            if (this.type != TokenType.NUMBER) {
                                this.file.seek(l2);
                                this.type = TokenType.NUMBER;
                                this.stringValue = string2;
                                return;
                            }
                            string3 = this.stringValue;
                            break;
                        }
                        case 0: {
                            if (this.type != TokenType.NUMBER) {
                                return;
                            }
                            l2 = this.file.getFilePointer();
                            string2 = this.stringValue;
                        }
                    }
                    ++n2;
                    continue;
                }
                this.type = TokenType.REF;
                this.reference = Integer.parseInt(string2);
                this.generation = Integer.parseInt(string3);
                return;
            }
            this.file.seek(l2);
            this.type = TokenType.NUMBER;
            this.stringValue = string2;
            return;
        }
        if (n2 == 1) {
            this.type = TokenType.NUMBER;
        }
    }

    public int read() {
        return this.file.read();
    }

    public boolean readLineSegment(byte[] arrby) {
        return this.readLineSegment(arrby, true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public boolean readLineSegment(byte[] var1_1, boolean var2_2) {
        var7_3 = var1_1.length;
        if (var7_3 > 0) {
            while (PRTokeniser.isWhitespace(var3_4 = this.read(), var2_2)) {
            }
            var5_5 = 0;
            var4_6 = 0;
        } else {
            var5_5 = 0;
            var4_6 = 0;
            var3_4 = -1;
        }
        do {
            var6_7 = var4_6;
            if (var5_5 != 0) break;
            var6_7 = var4_6;
            if (var4_6 >= var7_3) break;
            if (var3_4 == -1 || var3_4 == 10) ** GOTO lbl24
            if (var3_4 != 13) {
                var1_1[var4_6] = (byte)var3_4;
                ++var4_6;
            } else {
                var8_8 = this.getFilePointer();
                if (this.read() != 10) {
                    this.seek(var8_8);
                }
lbl24: // 4 sources:
                var5_5 = 1;
            }
            var6_7 = var4_6;
            if (var5_5 != 0) break;
            if (var7_3 <= var4_6) {
                var6_7 = var4_6;
                break;
            }
            var3_4 = this.read();
        } while (true);
        var5_5 = var3_4;
        if (var6_7 >= var7_3) {
            var4_6 = 0;
            do {
                var5_5 = var3_4;
                if (var4_6 != 0) break;
                var3_4 = this.read();
                if (var3_4 != -1 && var3_4 != 10) {
                    if (var3_4 != 13) continue;
                    var8_8 = this.getFilePointer();
                    if (this.read() != 10) {
                        this.seek(var8_8);
                    }
                }
                var4_6 = 1;
            } while (true);
        }
        if (var5_5 == -1 && var6_7 == 0) {
            return false;
        }
        if (var6_7 + 2 > var7_3) return true;
        var1_1[var6_7] = 32;
        var1_1[var6_7 + 1] = 88;
        return true;
    }

    public String readString(int n2) {
        int n3;
        StringBuilder stringBuilder = new StringBuilder();
        while (n2 > 0 && (n3 = this.read()) != -1) {
            stringBuilder.append((char)n3);
            --n2;
        }
        return stringBuilder.toString();
    }

    public void seek(long l2) {
        this.file.seek(l2);
    }

    public void throwError(String string2) {
        throw new InvalidPdfException(MessageLocalization.getComposedMessage("1.at.file.pointer.2", string2, String.valueOf(this.file.getFilePointer())));
    }

    public static enum TokenType {
        NUMBER,
        STRING,
        NAME,
        COMMENT,
        START_ARRAY,
        END_ARRAY,
        START_DIC,
        END_DIC,
        REF,
        OTHER,
        ENDOFFILE;
        

        private TokenType() {
        }
    }

}

