/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.qrcode;

import com.itextpdf.text.pdf.qrcode.ByteMatrix;
import com.itextpdf.text.pdf.qrcode.EncodeHintType;
import com.itextpdf.text.pdf.qrcode.Encoder;
import com.itextpdf.text.pdf.qrcode.ErrorCorrectionLevel;
import com.itextpdf.text.pdf.qrcode.QRCode;
import java.util.Map;

public final class QRCodeWriter {
    private static final int QUIET_ZONE_SIZE = 4;

    private static ByteMatrix renderResult(QRCode arrby, int n2, int n3) {
        arrby = arrby.getMatrix();
        int n4 = arrby.getWidth();
        int n5 = arrby.getHeight();
        int n6 = n4 + 8;
        int n7 = n5 + 8;
        int n8 = Math.max(n2, n6);
        int n9 = Math.max(n3, n7);
        int n10 = Math.min(n8 / n6, n9 / n7);
        int n11 = n4 * n10;
        int n12 = (n8 - n11) / 2;
        int n13 = n5 * n10;
        int n14 = (n9 - n13) / 2;
        ByteMatrix byteMatrix = new ByteMatrix(n8, n9);
        byte[][] arrby2 = byteMatrix.getArray();
        byte[] arrby3 = new byte[n8];
        for (n2 = 0; n2 < n14; ++n2) {
            QRCodeWriter.setRowColor(arrby2[n2], (byte)-1);
        }
        arrby = arrby.getArray();
        for (n2 = 0; n2 < n5; ++n2) {
            for (n3 = 0; n3 < n12; ++n3) {
                arrby3[n3] = -1;
            }
            n6 = n12;
            for (n3 = 0; n3 < n4; ++n3) {
                int n15 = arrby[n2][n3] == 1 ? 0 : -1;
                for (n7 = 0; n7 < n10; ++n7) {
                    arrby3[n6 + n7] = n15;
                }
                n6 += n10;
            }
            for (n3 = n12 + n11; n3 < n8; ++n3) {
                arrby3[n3] = -1;
            }
            n3 = n2 * n10 + n14;
            for (n6 = 0; n6 < n10; ++n6) {
                System.arraycopy(arrby3, 0, arrby2[n3 + n6], 0, n8);
            }
        }
        for (n2 = n14 + n13; n2 < n9; ++n2) {
            QRCodeWriter.setRowColor(arrby2[n2], (byte)-1);
        }
        return byteMatrix;
    }

    private static void setRowColor(byte[] arrby, byte by2) {
        for (int i2 = 0; i2 < arrby.length; ++i2) {
            arrby[i2] = by2;
        }
    }

    public ByteMatrix encode(String string2, int n2, int n3) {
        return this.encode(string2, n2, n3, null);
    }

    public ByteMatrix encode(String charSequence, int n2, int n3, Map<EncodeHintType, Object> map) {
        if (charSequence != null && charSequence.length() != 0) {
            if (n2 >= 0 && n3 >= 0) {
                Object object;
                Object object2 = object = ErrorCorrectionLevel.L;
                if (map != null) {
                    ErrorCorrectionLevel errorCorrectionLevel = (ErrorCorrectionLevel)map.get(EncodeHintType.ERROR_CORRECTION);
                    object2 = object;
                    if (errorCorrectionLevel != null) {
                        object2 = errorCorrectionLevel;
                    }
                }
                object = new QRCode();
                Encoder.encode((String)charSequence, (ErrorCorrectionLevel)object2, map, (QRCode)object);
                return QRCodeWriter.renderResult((QRCode)object, n2, n3);
            }
            charSequence = new StringBuilder();
            charSequence.append("Requested dimensions are too small: ");
            charSequence.append(n2);
            charSequence.append('x');
            charSequence.append(n3);
            throw new IllegalArgumentException(charSequence.toString());
        }
        throw new IllegalArgumentException("Found empty contents");
    }
}

