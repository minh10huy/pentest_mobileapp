/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.InvalidPdfException;
import com.itextpdf.text.pdf.CJKFont;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.EnumerateTTC;
import com.itextpdf.text.pdf.GlyphList;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.TrueTypeFont;
import com.itextpdf.text.pdf.TrueTypeFontUnicode;
import com.itextpdf.text.pdf.Type1Font;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.concurrent.ConcurrentHashMap;

public abstract class BaseFont {
    public static final int ASCENT = 1;
    public static final int AWT_ASCENT = 9;
    public static final int AWT_DESCENT = 10;
    public static final int AWT_LEADING = 11;
    public static final int AWT_MAXADVANCE = 12;
    public static final int BBOXLLX = 5;
    public static final int BBOXLLY = 6;
    public static final int BBOXURX = 7;
    public static final int BBOXURY = 8;
    protected static final HashMap<String, PdfName> BuiltinFonts14;
    public static final boolean CACHED = true;
    public static final int CAPHEIGHT = 2;
    public static final int[] CHAR_RANGE_ARABIC;
    public static final int[] CHAR_RANGE_CYRILLIC;
    public static final int[] CHAR_RANGE_HEBREW;
    public static final int[] CHAR_RANGE_LATIN;
    public static final char CID_NEWLINE = '\u7fff';
    public static final String COURIER = "Courier";
    public static final String COURIER_BOLD = "Courier-Bold";
    public static final String COURIER_BOLDOBLIQUE = "Courier-BoldOblique";
    public static final String COURIER_OBLIQUE = "Courier-Oblique";
    public static final String CP1250 = "Cp1250";
    public static final String CP1252 = "Cp1252";
    public static final String CP1257 = "Cp1257";
    public static final double[] DEFAULT_FONT_MATRIX;
    public static final int DESCENT = 3;
    public static final boolean EMBEDDED = true;
    public static final int FONT_TYPE_CJK = 2;
    public static final int FONT_TYPE_DOCUMENT = 4;
    public static final int FONT_TYPE_T1 = 0;
    public static final int FONT_TYPE_T3 = 5;
    public static final int FONT_TYPE_TT = 1;
    public static final int FONT_TYPE_TTUNI = 3;
    public static final int FONT_WEIGHT = 23;
    public static final String HELVETICA = "Helvetica";
    public static final String HELVETICA_BOLD = "Helvetica-Bold";
    public static final String HELVETICA_BOLDOBLIQUE = "Helvetica-BoldOblique";
    public static final String HELVETICA_OBLIQUE = "Helvetica-Oblique";
    public static final String IDENTITY_H = "Identity-H";
    public static final String IDENTITY_V = "Identity-V";
    public static final int ITALICANGLE = 4;
    public static final String MACROMAN = "MacRoman";
    public static final boolean NOT_CACHED = false;
    public static final boolean NOT_EMBEDDED = false;
    public static final char PARAGRAPH_SEPARATOR = '\u2029';
    public static final String RESOURCE_PATH = "com/itextpdf/text/pdf/fonts/";
    public static final int STRIKETHROUGH_POSITION = 15;
    public static final int STRIKETHROUGH_THICKNESS = 16;
    public static final int SUBSCRIPT_OFFSET = 18;
    public static final int SUBSCRIPT_SIZE = 17;
    public static final int SUPERSCRIPT_OFFSET = 20;
    public static final int SUPERSCRIPT_SIZE = 19;
    public static final String SYMBOL = "Symbol";
    public static final String TIMES_BOLD = "Times-Bold";
    public static final String TIMES_BOLDITALIC = "Times-BoldItalic";
    public static final String TIMES_ITALIC = "Times-Italic";
    public static final String TIMES_ROMAN = "Times-Roman";
    public static final int UNDERLINE_POSITION = 13;
    public static final int UNDERLINE_THICKNESS = 14;
    public static final int WEIGHT_CLASS = 21;
    public static final int WIDTH_CLASS = 22;
    public static final String WINANSI = "Cp1252";
    public static final String ZAPFDINGBATS = "ZapfDingbats";
    protected static ConcurrentHashMap<String, BaseFont> fontCache;
    public static final String notdef = ".notdef";
    protected int[][] charBBoxes = new int[256][];
    protected int compressionLevel = -1;
    protected String[] differences = new String[256];
    protected boolean directTextToByte = false;
    protected boolean embedded;
    protected String encoding;
    protected boolean fastWinansi = false;
    protected boolean fontSpecific = true;
    int fontType;
    protected boolean forceWidthsOutput = false;
    protected IntHashtable specialMap;
    protected boolean subset = true;
    protected ArrayList<int[]> subsetRanges;
    protected char[] unicodeDifferences = new char[256];
    protected boolean vertical = false;
    protected int[] widths = new int[256];

    static {
        CHAR_RANGE_LATIN = new int[]{0, 383, 8192, 8303, 8352, 8399, 64256, 64262};
        CHAR_RANGE_ARABIC = new int[]{0, 127, 1536, 1663, 8352, 8399, 64336, 64511, 65136, 65279};
        CHAR_RANGE_HEBREW = new int[]{0, 127, 1424, 1535, 8352, 8399, 64285, 64335};
        CHAR_RANGE_CYRILLIC = new int[]{0, 127, 1024, 1327, 8192, 8303, 8352, 8399};
        DEFAULT_FONT_MATRIX = new double[]{0.001, 0.0, 0.0, 0.001, 0.0, 0.0};
        fontCache = new ConcurrentHashMap();
        BuiltinFonts14 = new HashMap();
        BuiltinFonts14.put(COURIER, PdfName.COURIER);
        BuiltinFonts14.put(COURIER_BOLD, PdfName.COURIER_BOLD);
        BuiltinFonts14.put(COURIER_BOLDOBLIQUE, PdfName.COURIER_BOLDOBLIQUE);
        BuiltinFonts14.put(COURIER_OBLIQUE, PdfName.COURIER_OBLIQUE);
        BuiltinFonts14.put(HELVETICA, PdfName.HELVETICA);
        BuiltinFonts14.put(HELVETICA_BOLD, PdfName.HELVETICA_BOLD);
        BuiltinFonts14.put(HELVETICA_BOLDOBLIQUE, PdfName.HELVETICA_BOLDOBLIQUE);
        BuiltinFonts14.put(HELVETICA_OBLIQUE, PdfName.HELVETICA_OBLIQUE);
        BuiltinFonts14.put(SYMBOL, PdfName.SYMBOL);
        BuiltinFonts14.put(TIMES_ROMAN, PdfName.TIMES_ROMAN);
        BuiltinFonts14.put(TIMES_BOLD, PdfName.TIMES_BOLD);
        BuiltinFonts14.put(TIMES_BOLDITALIC, PdfName.TIMES_BOLDITALIC);
        BuiltinFonts14.put(TIMES_ITALIC, PdfName.TIMES_ITALIC);
        BuiltinFonts14.put(ZAPFDINGBATS, PdfName.ZAPFDINGBATS);
    }

    protected BaseFont() {
    }

    private static void addFont(PRIndirectReference pRIndirectReference, IntHashtable intHashtable, ArrayList<Object[]> arrayList) {
        PdfObject pdfObject = PdfReader.getPdfObject(pRIndirectReference);
        if (pdfObject != null) {
            if (!pdfObject.isDictionary()) {
                return;
            }
            PdfName pdfName = (pdfObject = (PdfDictionary)pdfObject).getAsName(PdfName.SUBTYPE);
            if (!(PdfName.TYPE1.equals(pdfName) || PdfName.TRUETYPE.equals(pdfName) || PdfName.TYPE0.equals(pdfName))) {
                return;
            }
            arrayList.add(new Object[]{PdfName.decodeName(pdfObject.getAsName(PdfName.BASEFONT).toString()), pRIndirectReference});
            intHashtable.put(pRIndirectReference.getNumber(), 1);
        }
    }

    public static BaseFont createFont() {
        return BaseFont.createFont(HELVETICA, "Cp1252", false);
    }

    public static BaseFont createFont(PRIndirectReference pRIndirectReference) {
        return new DocumentFont(pRIndirectReference);
    }

    public static BaseFont createFont(String string2, String string3, boolean bl2) {
        return BaseFont.createFont(string2, string3, bl2, true, null, null, false);
    }

    public static BaseFont createFont(String string2, String string3, boolean bl2, boolean bl3) {
        return BaseFont.createFont(string2, string3, bl2, true, null, null, bl3);
    }

    public static BaseFont createFont(String string2, String string3, boolean bl2, boolean bl3, byte[] arrby, byte[] arrby2) {
        return BaseFont.createFont(string2, string3, bl2, bl3, arrby, arrby2, false);
    }

    public static BaseFont createFont(String string2, String string3, boolean bl2, boolean bl3, byte[] arrby, byte[] arrby2, boolean bl4) {
        return BaseFont.createFont(string2, string3, bl2, bl3, arrby, arrby2, bl4, false);
    }

    public static BaseFont createFont(String object, String charSequence, boolean bl2, boolean bl3, byte[] object2, byte[] arrby, boolean bl4, boolean bl5) {
        block10 : {
            String string2;
            block12 : {
                block7 : {
                    block11 : {
                        block8 : {
                            block9 : {
                                BaseFont baseFont;
                                String string3 = BaseFont.getBaseName((String)object);
                                string2 = BaseFont.normalizeEncoding((String)charSequence);
                                boolean bl6 = BuiltinFonts14.containsKey(object);
                                boolean bl7 = bl6 ? false : CJKFont.isCJKFont(string3, string2);
                                if (!bl6 && !bl7) {
                                    if (string2.equals(IDENTITY_H) || string2.equals(IDENTITY_V)) {
                                        bl2 = true;
                                    }
                                } else {
                                    bl2 = false;
                                }
                                charSequence = new StringBuilder();
                                charSequence.append((String)object);
                                charSequence.append("\n");
                                charSequence.append(string2);
                                charSequence.append("\n");
                                charSequence.append(bl2);
                                charSequence = charSequence.toString();
                                if (bl3 && (baseFont = fontCache.get(charSequence)) != null) {
                                    return baseFont;
                                }
                                if (bl6 || object.toLowerCase().endsWith(".afm") || object.toLowerCase().endsWith(".pfm")) break block7;
                                if (string3.toLowerCase().endsWith(".ttf") || string3.toLowerCase().endsWith(".otf") || string3.toLowerCase().indexOf(".ttc,") > 0) break block8;
                                if (!bl7) break block9;
                                object = new CJKFont((String)object, string2, bl2);
                                break block10;
                            }
                            if (bl4) {
                                return null;
                            }
                            throw new DocumentException(MessageLocalization.getComposedMessage("font.1.with.2.is.not.recognized", object, string2));
                        }
                        if (string2.equals(IDENTITY_H) || string2.equals(IDENTITY_V)) break block11;
                        object = new TrueTypeFont((String)object, string2, bl2, (byte[])object2, false, bl5);
                        break block12;
                    }
                    object = new TrueTypeFontUnicode((String)object, string2, bl2, (byte[])object2, bl5);
                    break block10;
                }
                object = new Type1Font((String)object, string2, bl2, (byte[])object2, arrby, bl5);
            }
            object.fastWinansi = string2.equals("Cp1252");
        }
        if (bl3) {
            object2 = fontCache.get(charSequence);
            if (object2 != null) {
                return object2;
            }
            fontCache.putIfAbsent((String)charSequence, (BaseFont)object);
        }
        return object;
    }

    public static String createSubsetPrefix() {
        StringBuilder stringBuilder = new StringBuilder("");
        for (int i2 = 0; i2 < 6; ++i2) {
            stringBuilder.append((char)(Math.random() * 26.0 + 65.0));
        }
        StringBuilder stringBuilder2 = new StringBuilder();
        stringBuilder2.append((Object)stringBuilder);
        stringBuilder2.append("+");
        return stringBuilder2.toString();
    }

    public static String[] enumerateTTCNames(String string2) {
        return new EnumerateTTC(string2).getNames();
    }

    public static String[] enumerateTTCNames(byte[] arrby) {
        return new EnumerateTTC(arrby).getNames();
    }

    public static Object[] getAllFontNames(String object, String string2, byte[] arrby) {
        String string3 = BaseFont.getBaseName((String)object);
        object = !string3.toLowerCase().endsWith(".ttf") && !string3.toLowerCase().endsWith(".otf") && string3.toLowerCase().indexOf(".ttc,") <= 0 ? BaseFont.createFont((String)object, string2, false, false, arrby, null) : new TrueTypeFont((String)object, "Cp1252", false, arrby, true, false);
        return new Object[]{object.getPostscriptFontName(), object.getFamilyFontName(), object.getFullFontName()};
    }

    public static String[][] getAllNameEntries(String object, String string2, byte[] arrby) {
        String string3 = BaseFont.getBaseName((String)object);
        object = !string3.toLowerCase().endsWith(".ttf") && !string3.toLowerCase().endsWith(".otf") && string3.toLowerCase().indexOf(".ttc,") <= 0 ? BaseFont.createFont((String)object, string2, false, false, arrby, null) : new TrueTypeFont((String)object, "Cp1252", false, arrby, true, false);
        return object.getAllNameEntries();
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    protected static String getBaseName(String string2) {
        int n2;
        if (string2.endsWith(",Bold")) {
            n2 = string2.length() - 5;
            do {
                return string2.substring(0, n2);
                break;
            } while (true);
        }
        if (string2.endsWith(",Italic")) {
            n2 = string2.length() - 7;
            return string2.substring(0, n2);
        }
        if (!string2.endsWith(",BoldItalic")) return string2;
        n2 = string2.length() - 11;
        return string2.substring(0, n2);
    }

    public static ArrayList<Object[]> getDocumentFonts(PdfReader pdfReader) {
        IntHashtable intHashtable = new IntHashtable();
        ArrayList<Object[]> arrayList = new ArrayList<Object[]>();
        int n2 = pdfReader.getNumberOfPages();
        for (int i2 = 1; i2 <= n2; ++i2) {
            BaseFont.recourseFonts(pdfReader.getPageN(i2), intHashtable, arrayList, 1, new HashSet<PdfDictionary>());
        }
        return arrayList;
    }

    public static ArrayList<Object[]> getDocumentFonts(PdfReader pdfReader, int n2) {
        IntHashtable intHashtable = new IntHashtable();
        ArrayList<Object[]> arrayList = new ArrayList<Object[]>();
        BaseFont.recourseFonts(pdfReader.getPageN(n2), intHashtable, arrayList, 1, new HashSet<PdfDictionary>());
        return arrayList;
    }

    public static String[][] getFullFontName(String object, String string2, byte[] arrby) {
        String string3 = BaseFont.getBaseName((String)object);
        object = !string3.toLowerCase().endsWith(".ttf") && !string3.toLowerCase().endsWith(".otf") && string3.toLowerCase().indexOf(".ttc,") <= 0 ? BaseFont.createFont((String)object, string2, false, false, arrby, null) : new TrueTypeFont((String)object, "Cp1252", false, arrby, true, false);
        return object.getFullFontName();
    }

    protected static String normalizeEncoding(String string2) {
        if (!string2.equals("winansi") && !string2.equals("")) {
            String string3 = string2;
            if (string2.equals("macroman")) {
                string3 = MACROMAN;
            }
            return string3;
        }
        return "Cp1252";
    }

    private static void recourseFonts(PdfDictionary pdfDictionary, IntHashtable intHashtable, ArrayList<Object[]> arrayList, int n2, HashSet<PdfDictionary> hashSet) {
        Object object;
        if (++n2 > 50) {
            return;
        }
        if (pdfDictionary == null) {
            return;
        }
        if ((pdfDictionary = pdfDictionary.getAsDict(PdfName.RESOURCES)) == null) {
            return;
        }
        Object object2 = pdfDictionary.getAsDict(PdfName.FONT);
        if (object2 != null) {
            object = object2.getKeys().iterator();
            while (object.hasNext()) {
                PdfObject pdfObject = object2.get(object.next());
                if (pdfObject == null || !pdfObject.isIndirect() || intHashtable.containsKey((pdfObject = (PRIndirectReference)pdfObject).getNumber())) continue;
                BaseFont.addFont((PRIndirectReference)pdfObject, intHashtable, arrayList);
            }
        }
        if ((pdfDictionary = pdfDictionary.getAsDict(PdfName.XOBJECT)) != null) {
            if (hashSet.add(pdfDictionary)) {
                object2 = pdfDictionary.getKeys().iterator();
                while (object2.hasNext()) {
                    object = pdfDictionary.getDirectObject((PdfName)object2.next());
                    if (!(object instanceof PdfDictionary)) continue;
                    BaseFont.recourseFonts((PdfDictionary)object, intHashtable, arrayList, n2, hashSet);
                }
                hashSet.remove(pdfDictionary);
                return;
            }
            throw new ExceptionConverter(new InvalidPdfException(MessageLocalization.getComposedMessage("illegal.resources.tree", new Object[0])));
        }
    }

    public void addSubsetRange(int[] arrn) {
        if (this.subsetRanges == null) {
            this.subsetRanges = new ArrayList();
        }
        this.subsetRanges.add(arrn);
    }

    public boolean charExists(int n2) {
        if (this.convertToBytes(n2).length > 0) {
            return true;
        }
        return false;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    byte[] convertToBytes(int n2) {
        String string2;
        char c2;
        if (this.directTextToByte) {
            c2 = (char)n2;
            string2 = null;
            do {
                return PdfEncodings.convertToBytes(c2, string2);
                break;
            } while (true);
        }
        if (this.specialMap != null) {
            if (!this.specialMap.containsKey(n2)) return new byte[0];
            return new byte[]{(byte)this.specialMap.get(n2)};
        }
        c2 = (char)n2;
        string2 = this.encoding;
        return PdfEncodings.convertToBytes(c2, string2);
    }

    public byte[] convertToBytes(String arrby) {
        if (this.directTextToByte) {
            return PdfEncodings.convertToBytes((String)arrby, null);
        }
        if (this.specialMap != null) {
            byte[] arrby2 = new byte[arrby.length()];
            int n2 = arrby.length();
            int n3 = 0;
            for (int i2 = 0; i2 < n2; ++i2) {
                char c2 = arrby.charAt(i2);
                int n4 = n3;
                if (this.specialMap.containsKey(c2)) {
                    arrby2[n3] = (byte)this.specialMap.get(c2);
                    n4 = n3 + 1;
                }
                n3 = n4;
            }
            if (n3 < n2) {
                arrby = new byte[n3];
                System.arraycopy(arrby2, 0, arrby, 0, n3);
                return arrby;
            }
            return arrby2;
        }
        return PdfEncodings.convertToBytes((String)arrby, this.encoding);
    }

    public void correctArabicAdvance() {
        int n2;
        for (n2 = 1611; n2 <= 1624; n2 = (int)((char)(n2 + 1))) {
            this.setCharAdvance(n2, 0);
        }
        this.setCharAdvance(1648, 0);
        for (n2 = 1750; n2 <= 1756; n2 = (int)((char)(n2 + 1))) {
            this.setCharAdvance(n2, 0);
        }
        for (n2 = 1759; n2 <= 1764; n2 = (int)((char)(n2 + 1))) {
            this.setCharAdvance(n2, 0);
        }
        for (n2 = 1767; n2 <= 1768; n2 = (int)((char)(n2 + 1))) {
            this.setCharAdvance(n2, 0);
        }
        for (n2 = 1770; n2 <= 1773; n2 = (int)((char)(n2 + 1))) {
            this.setCharAdvance(n2, 0);
        }
    }

    protected void createEncoding() {
        int n2;
        boolean bl2 = this.encoding.startsWith("#");
        int n3 = 0;
        if (bl2) {
            String string2;
            int n4;
            this.specialMap = new IntHashtable();
            StringTokenizer stringTokenizer = new StringTokenizer(this.encoding.substring(1), " ,\t\n\r\f");
            if (stringTokenizer.nextToken().equals("full")) {
                do {
                    n4 = n3;
                    if (stringTokenizer.hasMoreTokens()) {
                        string2 = stringTokenizer.nextToken();
                        String string3 = stringTokenizer.nextToken();
                        char c2 = (char)Integer.parseInt(stringTokenizer.nextToken(), 16);
                        n2 = string2.startsWith("'") ? (int)string2.charAt(1) : Integer.parseInt(string2);
                        this.specialMap.put(c2, n2 %= 256);
                        this.differences[n2] = string3;
                        this.unicodeDifferences[n2] = c2;
                        this.widths[n2] = this.getRawWidth(c2, string3);
                        this.charBBoxes[n2] = this.getRawCharBBox(c2, string3);
                        continue;
                    }
                    break;
                } while (true);
            } else {
                n2 = stringTokenizer.hasMoreTokens() ? Integer.parseInt(stringTokenizer.nextToken()) : 0;
                do {
                    n4 = n3;
                    if (!stringTokenizer.hasMoreTokens()) break;
                    n4 = n3;
                    if (n2 >= 256) break;
                    n4 = Integer.parseInt(stringTokenizer.nextToken(), 16) % 65536;
                    string2 = GlyphList.unicodeToName(n4);
                    if (string2 == null) continue;
                    this.specialMap.put(n4, n2);
                    this.differences[n2] = string2;
                    this.unicodeDifferences[n2] = (char)n4;
                    this.widths[n2] = this.getRawWidth(n4, string2);
                    this.charBBoxes[n2] = this.getRawCharBBox(n4, string2);
                    ++n2;
                } while (true);
            }
            while (n4 < 256) {
                if (this.differences[n4] == null) {
                    this.differences[n4] = notdef;
                }
                ++n4;
            }
        } else if (this.fontSpecific) {
            for (n2 = 0; n2 < 256; ++n2) {
                this.widths[n2] = this.getRawWidth(n2, null);
                this.charBBoxes[n2] = this.getRawCharBBox(n2, null);
            }
        } else {
            byte[] arrby = new byte[1];
            for (n2 = 0; n2 < 256; ++n2) {
                String string4;
                arrby[0] = (byte)n2;
                String string5 = PdfEncodings.convertToString(arrby, this.encoding);
                int n5 = string5.length() > 0 ? (int)string5.charAt(0) : 63;
                string5 = string4 = GlyphList.unicodeToName(n5);
                if (string4 == null) {
                    string5 = notdef;
                }
                this.differences[n2] = string5;
                this.unicodeDifferences[n2] = n5;
                this.widths[n2] = this.getRawWidth(n5, string5);
                this.charBBoxes[n2] = this.getRawCharBBox(n5, string5);
            }
        }
    }

    public abstract String[][] getAllNameEntries();

    public int getAscent(String arrc) {
        arrc = arrc.toCharArray();
        int n2 = 0;
        for (int i2 = 0; i2 < arrc.length; ++i2) {
            int[] arrn = this.getCharBBox(arrc[i2]);
            int n3 = n2;
            if (arrn != null) {
                n3 = n2;
                if (arrn[3] > n2) {
                    n3 = arrn[3];
                }
            }
            n2 = n3;
        }
        return n2;
    }

    public float getAscentPoint(String string2, float f2) {
        return (float)this.getAscent(string2) * 0.001f * f2;
    }

    public int[] getCharBBox(int n2) {
        byte[] arrby = this.convertToBytes(n2);
        if (arrby.length == 0) {
            return null;
        }
        return this.charBBoxes[arrby[0] & 255];
    }

    public int getCidCode(int n2) {
        return n2;
    }

    public String[] getCodePagesSupported() {
        return new String[0];
    }

    public int getCompressionLevel() {
        return this.compressionLevel;
    }

    public int getDescent(String arrc) {
        arrc = arrc.toCharArray();
        int n2 = 0;
        for (int i2 = 0; i2 < arrc.length; ++i2) {
            int[] arrn = this.getCharBBox(arrc[i2]);
            int n3 = n2;
            if (arrn != null) {
                n3 = n2;
                if (arrn[1] < n2) {
                    n3 = arrn[1];
                }
            }
            n2 = n3;
        }
        return n2;
    }

    public float getDescentPoint(String string2, float f2) {
        return (float)this.getDescent(string2) * 0.001f * f2;
    }

    public String[] getDifferences() {
        return this.differences;
    }

    public String getEncoding() {
        return this.encoding;
    }

    public abstract String[][] getFamilyFontName();

    public abstract float getFontDescriptor(int var1, float var2);

    public double[] getFontMatrix() {
        return DEFAULT_FONT_MATRIX;
    }

    public int getFontType() {
        return this.fontType;
    }

    public abstract String[][] getFullFontName();

    abstract PdfStream getFullFontStream();

    public abstract int getKerning(int var1, int var2);

    public abstract String getPostscriptFontName();

    protected abstract int[] getRawCharBBox(int var1, String var2);

    abstract int getRawWidth(int var1, String var2);

    public String getSubfamily() {
        return "";
    }

    char getUnicodeDifferences(int n2) {
        return this.unicodeDifferences[n2];
    }

    public char[] getUnicodeDifferences() {
        return this.unicodeDifferences;
    }

    public int getUnicodeEquivalent(int n2) {
        return n2;
    }

    public int getWidth(int n2) {
        if (this.fastWinansi) {
            if (n2 >= 128 && (n2 < 160 || n2 > 255)) {
                return this.widths[PdfEncodings.winansi.get(n2)];
            }
            return this.widths[n2];
        }
        byte[] arrby = this.convertToBytes(n2);
        int n3 = 0;
        for (n2 = 0; n2 < arrby.length; ++n2) {
            n3 += this.widths[arrby[n2] & 255];
        }
        return n3;
    }

    public int getWidth(String arrby) {
        int n2;
        boolean bl2 = this.fastWinansi;
        int n3 = 0;
        if (bl2) {
            int n4 = arrby.length();
            int n5 = 0;
            for (n2 = 0; n2 < n4; ++n2) {
                n3 = arrby.charAt(n2);
                n3 = n3 >= 128 && (n3 < 160 || n3 > 255) ? this.widths[PdfEncodings.winansi.get(n3)] : this.widths[n3];
                n5 += n3;
            }
            return n5;
        }
        arrby = this.convertToBytes((String)arrby);
        int n6 = 0;
        for (n2 = n3; n2 < arrby.length; ++n2) {
            n6 += this.widths[arrby[n2] & 255];
        }
        return n6;
    }

    public float getWidthPoint(int n2, float f2) {
        return (float)this.getWidth(n2) * 0.001f * f2;
    }

    public float getWidthPoint(String string2, float f2) {
        return (float)this.getWidth(string2) * 0.001f * f2;
    }

    public float getWidthPointKerned(String arrc, float f2) {
        float f3 = (float)this.getWidth((String)arrc) * 0.001f * f2;
        if (!this.hasKernPairs()) {
            return f3;
        }
        int n2 = arrc.length();
        arrc = arrc.toCharArray();
        int n3 = 0;
        int n4 = 0;
        while (n3 < n2 - 1) {
            char c2 = arrc[n3];
            n4 += this.getKerning(c2, arrc[++n3]);
        }
        return f3 + (float)n4 * 0.001f * f2;
    }

    public int[] getWidths() {
        return this.widths;
    }

    public abstract boolean hasKernPairs();

    public boolean isDirectTextToByte() {
        return this.directTextToByte;
    }

    public boolean isEmbedded() {
        return this.embedded;
    }

    public boolean isFontSpecific() {
        return this.fontSpecific;
    }

    public boolean isForceWidthsOutput() {
        return this.forceWidthsOutput;
    }

    public boolean isSubset() {
        return this.subset;
    }

    public boolean isVertical() {
        return this.vertical;
    }

    public boolean setCharAdvance(int n2, int n3) {
        byte[] arrby = this.convertToBytes(n2);
        if (arrby.length == 0) {
            return false;
        }
        this.widths[arrby[0] & 255] = n3;
        return true;
    }

    public void setCompressionLevel(int n2) {
        int n3;
        block3 : {
            block2 : {
                if (n2 < 0) break block2;
                n3 = n2;
                if (n2 <= 9) break block3;
            }
            n3 = -1;
        }
        this.compressionLevel = n3;
    }

    public void setDirectTextToByte(boolean bl2) {
        this.directTextToByte = bl2;
    }

    public void setFontDescriptor(int n2, float f2) {
    }

    public void setForceWidthsOutput(boolean bl2) {
        this.forceWidthsOutput = bl2;
    }

    public abstract boolean setKerning(int var1, int var2, int var3);

    public abstract void setPostscriptFontName(String var1);

    public void setSubset(boolean bl2) {
        this.subset = bl2;
    }

    abstract void writeFont(PdfWriter var1, PdfIndirectReference var2, Object[] var3);

    static class StreamFont
    extends PdfStream {
        /*
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         */
        public StreamFont(byte[] arrby, String string2, int n2) {
            try {
                this.bytes = arrby;
                this.put(PdfName.LENGTH, new PdfNumber(this.bytes.length));
                if (string2 != null) {
                    this.put(PdfName.SUBTYPE, new PdfName(string2));
                }
                this.flateCompress(n2);
                return;
            }
            catch (Exception exception) {
                throw new DocumentException(exception);
            }
        }

        public StreamFont(byte[] object, int[] arrn, int n2) {
            this.bytes = object;
            this.put(PdfName.LENGTH, new PdfNumber(this.bytes.length));
            int n3 = 0;
            do {
                if (n3 >= arrn.length) break;
                object = new StringBuilder();
                object.append("Length");
                int n4 = n3 + 1;
                object.append(n4);
                this.put(new PdfName(object.toString()), new PdfNumber(arrn[n3]));
                n3 = n4;
                continue;
                break;
            } while (true);
            try {
                this.flateCompress(n2);
                return;
            }
            catch (Exception exception) {
                throw new DocumentException(exception);
            }
        }
    }

}

