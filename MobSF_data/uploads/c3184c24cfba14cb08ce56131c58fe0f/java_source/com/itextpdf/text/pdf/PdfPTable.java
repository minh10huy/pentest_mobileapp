/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.AccessibleElementId;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Element;
import com.itextpdf.text.ElementListener;
import com.itextpdf.text.Image;
import com.itextpdf.text.LargeElement;
import com.itextpdf.text.Phrase;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.api.Spaceable;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.PdfArtifact;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfPCell;
import com.itextpdf.text.pdf.PdfPHeaderCell;
import com.itextpdf.text.pdf.PdfPRow;
import com.itextpdf.text.pdf.PdfPTableBody;
import com.itextpdf.text.pdf.PdfPTableEvent;
import com.itextpdf.text.pdf.PdfPTableFooter;
import com.itextpdf.text.pdf.PdfPTableHeader;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.events.PdfPTableEventForwarder;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class PdfPTable
implements LargeElement,
Spaceable,
IAccessibleElement {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    public static final int BACKGROUNDCANVAS = 1;
    public static final int BASECANVAS = 0;
    public static final int LINECANVAS = 2;
    public static final int TEXTCANVAS = 3;
    private final Logger LOGGER = LoggerFactory.getLogger(PdfPTable.class);
    protected float[] absoluteWidths;
    protected HashMap<PdfName, PdfObject> accessibleAttributes;
    private PdfPTableBody body;
    protected boolean complete;
    protected int currentColIdx;
    protected PdfPCell[] currentRow;
    protected PdfPCell defaultCell;
    private boolean[] extendLastRow;
    private PdfPTableFooter footer;
    private int footerRows;
    private PdfPTableHeader header;
    protected int headerRows;
    private boolean headersInEvent;
    private int horizontalAlignment;
    protected AccessibleElementId id;
    protected boolean isColspan;
    private boolean keepTogether;
    private boolean lockedWidth;
    protected boolean loopCheck;
    private int numberOfWrittenRows;
    protected float paddingTop;
    protected float[] relativeWidths;
    protected PdfName role;
    protected boolean rowCompleted;
    protected ArrayList<PdfPRow> rows = new ArrayList();
    protected boolean rowsNotChecked;
    protected int runDirection;
    private boolean skipFirstHeader;
    private boolean skipLastFooter;
    protected float spacingAfter;
    protected float spacingBefore;
    private boolean splitLate;
    private boolean splitRows;
    protected PdfPTableEvent tableEvent;
    protected float totalHeight = 0.0f;
    protected float totalWidth;
    protected float widthPercentage;

    protected PdfPTable() {
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
    }

    public PdfPTable(int n2) {
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
        if (n2 > 0) {
            this.relativeWidths = new float[n2];
            for (int i2 = 0; i2 < n2; ++i2) {
                this.relativeWidths[i2] = 1.0f;
            }
            this.absoluteWidths = new float[this.relativeWidths.length];
            this.calculateWidths();
            this.currentRow = new PdfPCell[this.absoluteWidths.length];
            this.keepTogether = false;
            return;
        }
        throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.number.of.columns.in.pdfptable.constructor.must.be.greater.than.zero", new Object[0]));
    }

    public PdfPTable(PdfPTable pdfPTable) {
        int n2;
        int n3 = 0;
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
        this.copyFormat(pdfPTable);
        int n4 = 0;
        do {
            n2 = n3;
            if (n4 >= this.currentRow.length) break;
            if (pdfPTable.currentRow[n4] == null) {
                n2 = n3;
                break;
            }
            this.currentRow[n4] = new PdfPCell(pdfPTable.currentRow[n4]);
            ++n4;
        } while (true);
        while (n2 < pdfPTable.rows.size()) {
            PdfPRow pdfPRow;
            PdfPRow pdfPRow2 = pdfPRow = pdfPTable.rows.get(n2);
            if (pdfPRow != null) {
                pdfPRow2 = new PdfPRow(pdfPRow);
            }
            this.rows.add(pdfPRow2);
            ++n2;
        }
    }

    public PdfPTable(float[] arrf) {
        this.currentColIdx = 0;
        this.defaultCell = new PdfPCell((Phrase)null);
        this.totalWidth = 0.0f;
        this.widthPercentage = 80.0f;
        this.horizontalAlignment = 1;
        this.skipFirstHeader = false;
        this.skipLastFooter = false;
        this.isColspan = false;
        this.runDirection = 1;
        this.lockedWidth = false;
        this.splitRows = true;
        this.extendLastRow = new boolean[]{false, false};
        this.splitLate = true;
        this.complete = true;
        this.rowCompleted = true;
        this.loopCheck = true;
        this.rowsNotChecked = true;
        this.role = PdfName.TABLE;
        this.accessibleAttributes = null;
        this.id = new AccessibleElementId();
        this.header = null;
        this.body = null;
        this.footer = null;
        if (arrf != null) {
            if (arrf.length != 0) {
                this.relativeWidths = new float[arrf.length];
                System.arraycopy(arrf, 0, this.relativeWidths, 0, arrf.length);
                this.absoluteWidths = new float[arrf.length];
                this.calculateWidths();
                this.currentRow = new PdfPCell[this.absoluteWidths.length];
                this.keepTogether = false;
                return;
            }
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.widths.array.in.pdfptable.constructor.can.not.have.zero.length", new Object[0]));
        }
        throw new NullPointerException(MessageLocalization.getComposedMessage("the.widths.array.in.pdfptable.constructor.can.not.be.null", new Object[0]));
    }

    public static PdfContentByte[] beginWritingRows(PdfContentByte pdfContentByte) {
        return new PdfContentByte[]{pdfContentByte, pdfContentByte.getDuplicate(), pdfContentByte.getDuplicate(), pdfContentByte.getDuplicate()};
    }

    private PdfPTableBody closeTableBlock(PdfPTableBody pdfPTableBody, PdfContentByte pdfContentByte) {
        if (pdfContentByte.writer.getStandardStructElems().contains(pdfPTableBody.getRole())) {
            pdfContentByte.closeMCBlock(pdfPTableBody);
        }
        return null;
    }

    public static void endWritingRows(PdfContentByte[] arrpdfContentByte) {
        PdfContentByte pdfContentByte = arrpdfContentByte[0];
        PdfArtifact pdfArtifact = new PdfArtifact();
        pdfContentByte.openMCBlock(pdfArtifact);
        pdfContentByte.saveState();
        pdfContentByte.add(arrpdfContentByte[1]);
        pdfContentByte.restoreState();
        pdfContentByte.saveState();
        pdfContentByte.setLineCap(2);
        pdfContentByte.resetRGBColorStroke();
        pdfContentByte.add(arrpdfContentByte[2]);
        pdfContentByte.restoreState();
        pdfContentByte.closeMCBlock(pdfArtifact);
        pdfContentByte.add(arrpdfContentByte[3]);
    }

    private PdfPTableBody openTableBlock(PdfPTableBody pdfPTableBody, PdfContentByte pdfContentByte) {
        if (pdfContentByte.writer.getStandardStructElems().contains(pdfPTableBody.getRole())) {
            pdfContentByte.openMCBlock(pdfPTableBody);
            return pdfPTableBody;
        }
        return null;
    }

    public static PdfPTable shallowCopy(PdfPTable pdfPTable) {
        PdfPTable pdfPTable2 = new PdfPTable();
        pdfPTable2.copyFormat(pdfPTable);
        return pdfPTable2;
    }

    private void skipColsWithRowspanAbove() {
        int n2 = this.runDirection == 3 ? -1 : 1;
        while (this.rowSpanAbove(this.rows.size(), this.currentColIdx)) {
            this.currentColIdx += n2;
        }
    }

    public PdfPCell addCell(PdfPCell pdfPCell) {
        boolean bl2;
        this.rowCompleted = false;
        pdfPCell = pdfPCell instanceof PdfPHeaderCell ? new PdfPHeaderCell((PdfPHeaderCell)pdfPCell) : new PdfPCell(pdfPCell);
        int n2 = Math.min(Math.max(pdfPCell.getColspan(), 1), this.currentRow.length - this.currentColIdx);
        pdfPCell.setColspan(n2);
        if (n2 != 1) {
            this.isColspan = true;
        }
        if (pdfPCell.getRunDirection() == 1) {
            pdfPCell.setRunDirection(this.runDirection);
        }
        this.skipColsWithRowspanAbove();
        if (this.currentColIdx < this.currentRow.length) {
            this.currentRow[this.currentColIdx] = pdfPCell;
            this.currentColIdx += n2;
            bl2 = true;
        } else {
            bl2 = false;
        }
        this.skipColsWithRowspanAbove();
        while (this.currentColIdx >= this.currentRow.length) {
            Object object;
            int n3 = this.getNumberOfColumns();
            if (this.runDirection == 3) {
                object = new PdfPCell[n3];
                int n4 = this.currentRow.length;
                int n5 = 0;
                while (n5 < this.currentRow.length) {
                    PdfPCell pdfPCell2 = this.currentRow[n5];
                    int n6 = pdfPCell2.getColspan();
                    object[n4 -= n6] = pdfPCell2;
                    n5 = n5 + (n6 - 1) + 1;
                }
                this.currentRow = object;
            }
            object = new PdfPRow(this.currentRow);
            if (this.totalWidth > 0.0f) {
                object.setWidths(this.absoluteWidths);
                this.totalHeight += object.getMaxHeights();
            }
            this.rows.add((PdfPRow)object);
            this.currentRow = new PdfPCell[n3];
            this.currentColIdx = 0;
            this.skipColsWithRowspanAbove();
            this.rowCompleted = true;
        }
        if (!bl2) {
            this.currentRow[this.currentColIdx] = pdfPCell;
            this.currentColIdx += n2;
        }
        return pdfPCell;
    }

    public void addCell(Image image) {
        this.defaultCell.setImage(image);
        this.addCell((PdfPCell)this.defaultCell).id = new AccessibleElementId();
        this.defaultCell.setImage(null);
    }

    public void addCell(Phrase phrase) {
        this.defaultCell.setPhrase(phrase);
        this.addCell((PdfPCell)this.defaultCell).id = new AccessibleElementId();
        this.defaultCell.setPhrase(null);
    }

    public void addCell(PdfPTable pdfPTable) {
        this.defaultCell.setTable(pdfPTable);
        this.addCell((PdfPCell)this.defaultCell).id = new AccessibleElementId();
        this.defaultCell.setTable(null);
    }

    public void addCell(String string2) {
        this.addCell(new Phrase(string2));
    }

    void addNumberOfRowsWritten(int n2) {
        this.numberOfWrittenRows += n2;
    }

    protected PdfPRow adjustCellsInRow(int n2, int n3) {
        PdfPRow pdfPRow = this.getRow(n2);
        if (pdfPRow.isAdjusted()) {
            return pdfPRow;
        }
        pdfPRow = new PdfPRow(pdfPRow);
        PdfPCell[] arrpdfPCell = pdfPRow.getCells();
        for (int i2 = 0; i2 < arrpdfPCell.length; ++i2) {
            PdfPCell pdfPCell = arrpdfPCell[i2];
            if (pdfPCell == null || pdfPCell.getRowspan() == 1) continue;
            int n4 = Math.min(n3, pdfPCell.getRowspan() + n2);
            float f2 = 0.0f;
            for (int i3 = 1 + n2; i3 < n4; ++i3) {
                f2 += this.getRow(i3).getMaxHeights();
            }
            pdfPRow.setExtraHeight(i2, f2);
        }
        pdfPRow.setAdjusted(true);
        return pdfPRow;
    }

    public float calculateHeights() {
        if (this.totalWidth <= 0.0f) {
            return 0.0f;
        }
        this.totalHeight = 0.0f;
        for (int i2 = 0; i2 < this.rows.size(); ++i2) {
            this.totalHeight += this.getRowHeight(i2, true);
        }
        return this.totalHeight;
    }

    protected void calculateWidths() {
        if (this.totalWidth <= 0.0f) {
            return;
        }
        int n2 = this.getNumberOfColumns();
        int n3 = 0;
        int n4 = 0;
        float f2 = 0.0f;
        do {
            if (n4 >= n2) break;
            f2 += this.relativeWidths[n4];
            ++n4;
        } while (true);
        for (int i2 = n3; i2 < n2; ++i2) {
            this.absoluteWidths[i2] = this.totalWidth * this.relativeWidths[i2] / f2;
        }
    }

    PdfPCell cellAt(int n2, int n3) {
        PdfPCell[] arrpdfPCell = this.rows.get(n2).getCells();
        for (n2 = 0; n2 < arrpdfPCell.length; ++n2) {
            if (arrpdfPCell[n2] == null || n3 < n2 || n3 >= arrpdfPCell[n2].getColspan() + n2) continue;
            return arrpdfPCell[n2];
        }
        return null;
    }

    public void completeRow() {
        while (!this.rowCompleted) {
            this.addCell(this.defaultCell);
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void copyFormat(PdfPTable pdfPTable) {
        this.rowsNotChecked = pdfPTable.rowsNotChecked;
        this.relativeWidths = new float[pdfPTable.getNumberOfColumns()];
        this.absoluteWidths = new float[pdfPTable.getNumberOfColumns()];
        System.arraycopy(pdfPTable.relativeWidths, 0, this.relativeWidths, 0, this.getNumberOfColumns());
        System.arraycopy(pdfPTable.absoluteWidths, 0, this.absoluteWidths, 0, this.getNumberOfColumns());
        this.totalWidth = pdfPTable.totalWidth;
        this.totalHeight = pdfPTable.totalHeight;
        this.currentColIdx = 0;
        this.tableEvent = pdfPTable.tableEvent;
        this.runDirection = pdfPTable.runDirection;
        PdfPCell pdfPCell = pdfPTable.defaultCell instanceof PdfPHeaderCell ? new PdfPHeaderCell((PdfPHeaderCell)pdfPTable.defaultCell) : new PdfPCell(pdfPTable.defaultCell);
        this.defaultCell = pdfPCell;
        this.currentRow = new PdfPCell[pdfPTable.currentRow.length];
        this.isColspan = pdfPTable.isColspan;
        this.splitRows = pdfPTable.splitRows;
        this.spacingAfter = pdfPTable.spacingAfter;
        this.spacingBefore = pdfPTable.spacingBefore;
        this.headerRows = pdfPTable.headerRows;
        this.footerRows = pdfPTable.footerRows;
        this.lockedWidth = pdfPTable.lockedWidth;
        this.extendLastRow = pdfPTable.extendLastRow;
        this.headersInEvent = pdfPTable.headersInEvent;
        this.widthPercentage = pdfPTable.widthPercentage;
        this.splitLate = pdfPTable.splitLate;
        this.skipFirstHeader = pdfPTable.skipFirstHeader;
        this.skipLastFooter = pdfPTable.skipLastFooter;
        this.horizontalAlignment = pdfPTable.horizontalAlignment;
        this.keepTogether = pdfPTable.keepTogether;
        this.complete = pdfPTable.complete;
        this.loopCheck = pdfPTable.loopCheck;
        this.id = pdfPTable.id;
        this.role = pdfPTable.role;
        if (pdfPTable.accessibleAttributes != null) {
            this.accessibleAttributes = new HashMap<PdfName, PdfObject>(pdfPTable.accessibleAttributes);
        }
        this.header = pdfPTable.getHeader();
        this.body = pdfPTable.getBody();
        this.footer = pdfPTable.getFooter();
    }

    public void deleteBodyRows() {
        ArrayList<PdfPRow> arrayList = new ArrayList<PdfPRow>();
        for (int i2 = 0; i2 < this.headerRows; ++i2) {
            arrayList.add(this.rows.get(i2));
        }
        this.rows = arrayList;
        this.totalHeight = 0.0f;
        if (this.totalWidth > 0.0f) {
            this.totalHeight = this.getHeaderHeight();
        }
    }

    public boolean deleteLastRow() {
        return this.deleteRow(this.rows.size() - 1);
    }

    public boolean deleteRow(int n2) {
        if (n2 >= 0 && n2 < this.rows.size()) {
            PdfPRow pdfPRow;
            if (this.totalWidth > 0.0f && (pdfPRow = this.rows.get(n2)) != null) {
                this.totalHeight -= pdfPRow.getMaxHeights();
            }
            this.rows.remove(n2);
            if (n2 < this.headerRows) {
                --this.headerRows;
                if (n2 >= this.headerRows - this.footerRows) {
                    --this.footerRows;
                }
            }
            return true;
        }
        return false;
    }

    @Override
    public void flushContent() {
        this.deleteBodyRows();
        if (this.numberOfWrittenRows > 0) {
            this.setSkipFirstHeader(true);
        }
    }

    public float[] getAbsoluteWidths() {
        return this.absoluteWidths;
    }

    @Override
    public PdfObject getAccessibleAttribute(PdfName pdfName) {
        if (this.accessibleAttributes != null) {
            return this.accessibleAttributes.get(pdfName);
        }
        return null;
    }

    @Override
    public HashMap<PdfName, PdfObject> getAccessibleAttributes() {
        return this.accessibleAttributes;
    }

    public PdfPTableBody getBody() {
        if (this.body == null) {
            this.body = new PdfPTableBody();
        }
        return this.body;
    }

    public int getCellStartRowIndex(int n2, int n3) {
        while (this.getRow(n2).getCells()[n3] == null && n2 > 0) {
            --n2;
        }
        return n2;
    }

    @Override
    public List<Chunk> getChunks() {
        return new ArrayList<Chunk>();
    }

    public PdfPCell getDefaultCell() {
        return this.defaultCell;
    }

    float[][] getEventWidths(float f2, int n2, int n3, boolean bl2) {
        float[][] arrarrf;
        int n4 = n2;
        int n5 = n3;
        if (bl2) {
            n4 = Math.max(n2, this.headerRows);
            n5 = Math.max(n3, this.headerRows);
        }
        int n6 = 0;
        n3 = 0;
        n2 = bl2 ? this.headerRows : 0;
        arrarrf = new float[n2 + n5 - n4][];
        if (this.isColspan) {
            PdfPRow pdfPRow;
            int n7;
            if (bl2) {
                n2 = 0;
                n6 = n3;
                do {
                    n7 = n4;
                    n3 = n2++;
                    if (n6 < this.headerRows) {
                        pdfPRow = this.rows.get(n6);
                        if (pdfPRow != null) {
                            arrarrf[n2] = pdfPRow.getEventWidth(f2, this.absoluteWidths);
                            ++n2;
                        }
                        ++n6;
                        continue;
                    }
                    break;
                } while (true);
            } else {
                n3 = 0;
                n7 = n4;
            }
            while (n7 < n5) {
                pdfPRow = this.rows.get(n7);
                if (pdfPRow == null) {
                    ++n3;
                } else {
                    arrarrf[n3] = pdfPRow.getEventWidth(f2, this.absoluteWidths);
                    ++n3;
                }
                ++n7;
            }
        } else {
            n4 = this.getNumberOfColumns();
            float[] arrf = new float[n4 + 1];
            arrf[0] = f2;
            n2 = 0;
            do {
                if (n2 >= n4) break;
                n3 = n2 + 1;
                arrf[n3] = arrf[n2] + this.absoluteWidths[n2];
                n2 = n3;
            } while (true);
            for (n3 = n6; n3 < arrarrf.length; ++n3) {
                arrarrf[n3] = arrf;
            }
        }
        return arrarrf;
    }

    public FittingRows getFittingRows(float f2, int n2) {
        int n3;
        int n4;
        this.LOGGER.info(String.format("getFittingRows(%s, %s)", Float.valueOf(f2), n2));
        if (n2 > 0) {
            this.rows.size();
        }
        int n5 = this.getNumberOfColumns();
        ColumnMeasurementState[] arrcolumnMeasurementState = new ColumnMeasurementState[n5];
        for (n3 = 0; n3 < n5; ++n3) {
            arrcolumnMeasurementState[n3] = new ColumnMeasurementState();
        }
        HashMap<Integer, Float> hashMap = new HashMap<Integer, Float>();
        float f3 = 0.0f;
        float f4 = 0.0f;
        n3 = n5;
        for (n4 = n2; n4 < this.size(); ++n4) {
            Object object;
            float f5;
            int n6;
            PdfPRow pdfPRow = this.getRow(n4);
            float f6 = pdfPRow.getMaxRowHeightsWithoutCalculating();
            float f7 = 0.0f;
            for (n5 = 0; n5 < n3; n5 += columnMeasurementState.colspan) {
                object = pdfPRow.getCells()[n5];
                ColumnMeasurementState columnMeasurementState = arrcolumnMeasurementState[n5];
                if (object == null) {
                    columnMeasurementState.consumeRowspan(f3, f6);
                } else {
                    columnMeasurementState.beginCell((PdfPCell)object, f3, f6);
                    this.LOGGER.info(String.format("Height after beginCell: %s (cell: %s)", Float.valueOf(columnMeasurementState.height), Float.valueOf(object.getCachedMaxHeight())));
                }
                f5 = f7;
                if (columnMeasurementState.cellEnds()) {
                    f5 = f7;
                    if (columnMeasurementState.height > f7) {
                        f5 = columnMeasurementState.height;
                    }
                }
                for (n6 = 1; n6 < columnMeasurementState.colspan; ++n6) {
                    arrcolumnMeasurementState[n5 + n6].height = columnMeasurementState.height;
                }
                f7 = f5;
            }
            n6 = arrcolumnMeasurementState.length;
            f5 = 0.0f;
            for (n5 = 0; n5 < n6; ++n5) {
                object = arrcolumnMeasurementState[n5];
                f6 = f5;
                if (object.height > f5) {
                    f6 = object.height;
                }
                f5 = f6;
            }
            pdfPRow.setFinalMaxHeights(f7 - f3);
            f6 = this.isSplitLate() ? f5 : f7;
            if (f2 - f6 < 0.0f) break;
            hashMap.put(n4, Float.valueOf(f5 - f3));
            f3 = f7;
            f4 = f5;
        }
        this.rowsNotChecked = false;
        return new FittingRows(n2, n4 - 1, f4, f3, hashMap);
    }

    public PdfPTableFooter getFooter() {
        if (this.footer == null) {
            this.footer = new PdfPTableFooter();
        }
        return this.footer;
    }

    public float getFooterHeight() {
        int n2 = Math.min(this.rows.size(), this.headerRows);
        float f2 = 0.0f;
        for (int i2 = Math.max((int)0, (int)(this.headerRows - this.footerRows)); i2 < n2; ++i2) {
            PdfPRow pdfPRow = this.rows.get(i2);
            float f3 = f2;
            if (pdfPRow != null) {
                f3 = f2 + pdfPRow.getMaxHeights();
            }
            f2 = f3;
        }
        return f2;
    }

    public int getFooterRows() {
        return this.footerRows;
    }

    public PdfPTableHeader getHeader() {
        if (this.header == null) {
            this.header = new PdfPTableHeader();
        }
        return this.header;
    }

    public float getHeaderHeight() {
        int n2 = Math.min(this.rows.size(), this.headerRows);
        float f2 = 0.0f;
        for (int i2 = 0; i2 < n2; ++i2) {
            PdfPRow pdfPRow = this.rows.get(i2);
            float f3 = f2;
            if (pdfPRow != null) {
                f3 = f2 + pdfPRow.getMaxHeights();
            }
            f2 = f3;
        }
        return f2;
    }

    public int getHeaderRows() {
        return this.headerRows;
    }

    public int getHorizontalAlignment() {
        return this.horizontalAlignment;
    }

    @Override
    public AccessibleElementId getId() {
        return this.id;
    }

    public boolean getKeepTogether() {
        return this.keepTogether;
    }

    public int getLastCompletedRowIndex() {
        return this.rows.size() - 1;
    }

    public int getNumberOfColumns() {
        return this.relativeWidths.length;
    }

    @Override
    public float getPaddingTop() {
        return this.paddingTop;
    }

    @Override
    public PdfName getRole() {
        return this.role;
    }

    public PdfPRow getRow(int n2) {
        return this.rows.get(n2);
    }

    public float getRowHeight(int n2) {
        return this.getRowHeight(n2, false);
    }

    protected float getRowHeight(int n2, boolean bl2) {
        if (this.totalWidth > 0.0f && n2 >= 0) {
            if (n2 >= this.rows.size()) {
                return 0.0f;
            }
            PdfPRow pdfPRow = this.rows.get(n2);
            if (pdfPRow == null) {
                return 0.0f;
            }
            if (bl2) {
                pdfPRow.setWidths(this.absoluteWidths);
            }
            float f2 = pdfPRow.getMaxHeights();
            for (int i2 = 0; i2 < this.relativeWidths.length; ++i2) {
                float f3;
                if (!this.rowSpanAbove(n2, i2)) {
                    f3 = f2;
                } else {
                    float f4;
                    int n3;
                    int n4 = 1;
                    while (this.rowSpanAbove(n3 = n2 - n4, i2)) {
                        ++n4;
                    }
                    PdfPCell pdfPCell = this.rows.get(n3).getCells()[i2];
                    if (pdfPCell != null && pdfPCell.getRowspan() == n4 + 1) {
                        f3 = pdfPCell.getMaxHeight();
                        do {
                            f4 = f3;
                            if (n4 > 0) {
                                f3 -= this.getRowHeight(n2 - n4);
                                --n4;
                                continue;
                            }
                            break;
                        } while (true);
                    } else {
                        f4 = 0.0f;
                    }
                    f3 = f2;
                    if (f4 > f2) {
                        f3 = f4;
                    }
                }
                f2 = f3;
            }
            pdfPRow.setMaxHeights(f2);
            return f2;
        }
        return 0.0f;
    }

    public ArrayList<PdfPRow> getRows() {
        return this.rows;
    }

    public ArrayList<PdfPRow> getRows(int n2, int n3) {
        ArrayList<PdfPRow> arrayList = new ArrayList<PdfPRow>();
        if (n2 >= 0) {
            if (n3 > this.size()) {
                return arrayList;
            }
            while (n2 < n3) {
                arrayList.add(this.adjustCellsInRow(n2, n3));
                ++n2;
            }
        }
        return arrayList;
    }

    public float getRowspanHeight(int n2, int n3) {
        float f2 = this.totalWidth;
        float f3 = 0.0f;
        float f4 = 0.0f;
        float f5 = f3;
        if (f2 > 0.0f) {
            f5 = f3;
            if (n2 >= 0) {
                if (n2 >= this.rows.size()) {
                    return 0.0f;
                }
                IAccessibleElement iAccessibleElement = this.rows.get(n2);
                f5 = f3;
                if (iAccessibleElement != null) {
                    if (n3 >= iAccessibleElement.getCells().length) {
                        return 0.0f;
                    }
                    if ((iAccessibleElement = iAccessibleElement.getCells()[n3]) == null) {
                        return 0.0f;
                    }
                    n3 = 0;
                    do {
                        f5 = f4;
                        if (n3 >= iAccessibleElement.getRowspan()) break;
                        f4 += this.getRowHeight(n2 + n3);
                        ++n3;
                    } while (true);
                }
            }
        }
        return f5;
    }

    public int getRunDirection() {
        return this.runDirection;
    }

    @Override
    public float getSpacingAfter() {
        return this.spacingAfter;
    }

    @Override
    public float getSpacingBefore() {
        return this.spacingBefore;
    }

    public String getSummary() {
        return this.getAccessibleAttribute(PdfName.SUMMARY).toString();
    }

    public PdfPTableEvent getTableEvent() {
        return this.tableEvent;
    }

    public float getTotalHeight() {
        return this.totalHeight;
    }

    public float getTotalWidth() {
        return this.totalWidth;
    }

    public float getWidthPercentage() {
        return this.widthPercentage;
    }

    public boolean hasRowspan(int n2) {
        if (n2 < this.rows.size() && this.getRow(n2).hasRowspan()) {
            return true;
        }
        PdfPRow pdfPRow = n2 > 0 ? this.getRow(n2 - 1) : null;
        if (pdfPRow != null && pdfPRow.hasRowspan()) {
            return true;
        }
        for (int i2 = 0; i2 < this.getNumberOfColumns(); ++i2) {
            if (!this.rowSpanAbove(n2 - 1, i2)) continue;
            return true;
        }
        return false;
    }

    public void init() {
        this.LOGGER.info("Initialize row and cell heights");
        for (PdfPRow pdfPRow : this.getRows()) {
            if (pdfPRow == null) continue;
            pdfPRow.calculated = false;
            for (PdfPCell pdfPCell : pdfPRow.getCells()) {
                if (pdfPCell == null) continue;
                pdfPCell.setCalculatedHeight(0.0f);
            }
        }
    }

    @Override
    public boolean isComplete() {
        return this.complete;
    }

    @Override
    public boolean isContent() {
        return true;
    }

    public boolean isExtendLastRow() {
        return this.extendLastRow[0];
    }

    public boolean isExtendLastRow(boolean bl2) {
        if (bl2) {
            return this.extendLastRow[0];
        }
        return this.extendLastRow[1];
    }

    public boolean isHeadersInEvent() {
        return this.headersInEvent;
    }

    @Override
    public boolean isInline() {
        return false;
    }

    public boolean isLockedWidth() {
        return this.lockedWidth;
    }

    public boolean isLoopCheck() {
        return this.loopCheck;
    }

    @Override
    public boolean isNestable() {
        return true;
    }

    public boolean isSkipFirstHeader() {
        return this.skipFirstHeader;
    }

    public boolean isSkipLastFooter() {
        return this.skipLastFooter;
    }

    public boolean isSplitLate() {
        return this.splitLate;
    }

    public boolean isSplitRows() {
        return this.splitRows;
    }

    public void keepRowsTogether(int n2) {
        this.keepRowsTogether(n2, this.rows.size());
    }

    public void keepRowsTogether(int n2, int n3) {
        if (n2 < n3) {
            while (n2 < n3) {
                this.getRow(n2).setMayNotBreak(true);
                ++n2;
            }
        }
    }

    public void keepRowsTogether(int[] arrn) {
        for (int i2 = 0; i2 < arrn.length; ++i2) {
            this.getRow(arrn[i2]).setMayNotBreak(true);
        }
    }

    public void normalizeHeadersFooters() {
        if (this.footerRows > this.headerRows) {
            this.footerRows = this.headerRows;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public boolean process(ElementListener elementListener) {
        try {
            return elementListener.add(this);
        }
        catch (DocumentException documentException) {
            return false;
        }
    }

    public void resetColumnCount(int n2) {
        if (n2 > 0) {
            this.relativeWidths = new float[n2];
            for (int i2 = 0; i2 < n2; ++i2) {
                this.relativeWidths[i2] = 1.0f;
            }
            this.absoluteWidths = new float[this.relativeWidths.length];
            this.calculateWidths();
            this.currentRow = new PdfPCell[this.absoluteWidths.length];
            this.totalHeight = 0.0f;
            return;
        }
        throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.number.of.columns.in.pdfptable.constructor.must.be.greater.than.zero", new Object[0]));
    }

    boolean rowSpanAbove(int n2, int n3) {
        if (n3 < this.getNumberOfColumns() && n3 >= 0) {
            int n4;
            Object object;
            if (n2 < 1) {
                return false;
            }
            int n5 = n4 = n2 - 1;
            if (this.rows.get(n4) == null) {
                return false;
            }
            while ((object = this.cellAt(n5, n3)) == null && n5 > 0) {
                object = this.rows;
                n5 = n4 = n5 - 1;
                if ((PdfPRow)object.get(n4) != null) continue;
                return false;
            }
            n4 = n2 - n5;
            PdfPCell[] arrpdfPCell = object;
            n2 = n4;
            if (object.getRowspan() == 1) {
                arrpdfPCell = object;
                n2 = n4;
                if (n4 > 1) {
                    PdfPRow pdfPRow = this.rows.get(n5 + 1);
                    n5 = n4 - 1;
                    object = pdfPRow.getCells()[--n3];
                    do {
                        arrpdfPCell = object;
                        n2 = n5;
                        if (object != null) break;
                        arrpdfPCell = object;
                        n2 = n5;
                        if (n3 <= 0) break;
                        object = pdfPRow.getCells();
                        object = object[--n3];
                    } while (true);
                }
            }
            if (arrpdfPCell != null && arrpdfPCell.getRowspan() > n2) {
                return true;
            }
            return false;
        }
        return false;
    }

    @Override
    public void setAccessibleAttribute(PdfName pdfName, PdfObject pdfObject) {
        if (this.accessibleAttributes == null) {
            this.accessibleAttributes = new HashMap();
        }
        this.accessibleAttributes.put(pdfName, pdfObject);
    }

    public /* varargs */ void setBreakPoints(int ... arrn) {
        this.keepRowsTogether(0, this.rows.size());
        for (int i2 = 0; i2 < arrn.length; ++i2) {
            this.getRow(arrn[i2]).setMayNotBreak(false);
        }
    }

    @Override
    public void setComplete(boolean bl2) {
        this.complete = bl2;
    }

    public void setExtendLastRow(boolean bl2) {
        this.extendLastRow[0] = bl2;
        this.extendLastRow[1] = bl2;
    }

    public void setExtendLastRow(boolean bl2, boolean bl3) {
        this.extendLastRow[0] = bl2;
        this.extendLastRow[1] = bl3;
    }

    public void setFooterRows(int n2) {
        int n3 = n2;
        if (n2 < 0) {
            n3 = 0;
        }
        this.footerRows = n3;
    }

    public void setHeaderRows(int n2) {
        int n3 = n2;
        if (n2 < 0) {
            n3 = 0;
        }
        this.headerRows = n3;
    }

    public void setHeadersInEvent(boolean bl2) {
        this.headersInEvent = bl2;
    }

    public void setHorizontalAlignment(int n2) {
        this.horizontalAlignment = n2;
    }

    @Override
    public void setId(AccessibleElementId accessibleElementId) {
        this.id = accessibleElementId;
    }

    public void setKeepTogether(boolean bl2) {
        this.keepTogether = bl2;
    }

    public void setLockedWidth(boolean bl2) {
        this.lockedWidth = bl2;
    }

    public void setLoopCheck(boolean bl2) {
        this.loopCheck = bl2;
    }

    @Override
    public void setPaddingTop(float f2) {
        this.paddingTop = f2;
    }

    @Override
    public void setRole(PdfName pdfName) {
        this.role = pdfName;
    }

    public void setRunDirection(int n2) {
        switch (n2) {
            default: {
                throw new RuntimeException(MessageLocalization.getComposedMessage("invalid.run.direction.1", n2));
            }
            case 0: 
            case 1: 
            case 2: 
            case 3: 
        }
        this.runDirection = n2;
    }

    public void setSkipFirstHeader(boolean bl2) {
        this.skipFirstHeader = bl2;
    }

    public void setSkipLastFooter(boolean bl2) {
        this.skipLastFooter = bl2;
    }

    @Override
    public void setSpacingAfter(float f2) {
        this.spacingAfter = f2;
    }

    @Override
    public void setSpacingBefore(float f2) {
        this.spacingBefore = f2;
    }

    public void setSplitLate(boolean bl2) {
        this.splitLate = bl2;
    }

    public void setSplitRows(boolean bl2) {
        this.splitRows = bl2;
    }

    public void setSummary(String string2) {
        this.setAccessibleAttribute(PdfName.SUMMARY, new PdfString(string2));
    }

    /*
     * Enabled aggressive block sorting
     */
    public void setTableEvent(PdfPTableEvent pdfPTableEvent) {
        block6 : {
            block5 : {
                block4 : {
                    if (pdfPTableEvent != null) break block4;
                    pdfPTableEvent = null;
                    break block5;
                }
                if (this.tableEvent != null) break block6;
            }
            this.tableEvent = pdfPTableEvent;
            return;
        }
        if (this.tableEvent instanceof PdfPTableEventForwarder) {
            ((PdfPTableEventForwarder)this.tableEvent).addTableEvent(pdfPTableEvent);
            return;
        }
        PdfPTableEventForwarder pdfPTableEventForwarder = new PdfPTableEventForwarder();
        pdfPTableEventForwarder.addTableEvent(this.tableEvent);
        pdfPTableEventForwarder.addTableEvent(pdfPTableEvent);
        this.tableEvent = pdfPTableEventForwarder;
    }

    public void setTotalWidth(float f2) {
        if (this.totalWidth == f2) {
            return;
        }
        this.totalWidth = f2;
        this.totalHeight = 0.0f;
        this.calculateWidths();
        this.calculateHeights();
    }

    public void setTotalWidth(float[] arrf) {
        int n2 = arrf.length;
        int n3 = this.getNumberOfColumns();
        if (n2 == n3) {
            this.totalWidth = 0.0f;
            for (int i2 = 0; i2 < arrf.length; ++i2) {
                this.totalWidth += arrf[i2];
            }
            this.setWidths(arrf);
            return;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("wrong.number.of.columns", new Object[0]));
    }

    public void setWidthPercentage(float f2) {
        this.widthPercentage = f2;
    }

    public void setWidthPercentage(float[] arrf, Rectangle rectangle) {
        if (arrf.length == this.getNumberOfColumns()) {
            this.setTotalWidth(arrf);
            this.widthPercentage = this.totalWidth / (rectangle.getRight() - rectangle.getLeft()) * 100.0f;
            return;
        }
        throw new IllegalArgumentException(MessageLocalization.getComposedMessage("wrong.number.of.columns", new Object[0]));
    }

    public void setWidths(float[] arrf) {
        if (arrf.length == this.getNumberOfColumns()) {
            this.relativeWidths = new float[arrf.length];
            System.arraycopy(arrf, 0, this.relativeWidths, 0, arrf.length);
            this.absoluteWidths = new float[arrf.length];
            this.totalHeight = 0.0f;
            this.calculateWidths();
            this.calculateHeights();
            return;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("wrong.number.of.columns", new Object[0]));
    }

    public void setWidths(int[] arrn) {
        float[] arrf = new float[arrn.length];
        for (int i2 = 0; i2 < arrn.length; ++i2) {
            arrf[i2] = arrn[i2];
        }
        this.setWidths(arrf);
    }

    public int size() {
        return this.rows.size();
    }

    public float spacingAfter() {
        return this.spacingAfter;
    }

    public float spacingBefore() {
        return this.spacingBefore;
    }

    @Override
    public int type() {
        return 23;
    }

    public float writeSelectedRows(int n2, int n3, float f2, float f3, PdfContentByte pdfContentByte) {
        return this.writeSelectedRows(0, -1, n2, n3, f2, f3, pdfContentByte);
    }

    public float writeSelectedRows(int n2, int n3, float f2, float f3, PdfContentByte[] arrpdfContentByte) {
        return this.writeSelectedRows(0, -1, n2, n3, f2, f3, arrpdfContentByte);
    }

    public float writeSelectedRows(int n2, int n3, int n4, int n5, float f2, float f3, PdfContentByte pdfContentByte) {
        return this.writeSelectedRows(n2, n3, n4, n5, f2, f3, pdfContentByte, true);
    }

    public float writeSelectedRows(int n2, int n3, int n4, int n5, float f2, float f3, PdfContentByte pdfContentByte, boolean bl2) {
        int n6 = this.getNumberOfColumns();
        boolean bl3 = false;
        n2 = n2 < 0 ? 0 : Math.min(n2, n6);
        n3 = n3 < 0 ? n6 : Math.min(n3, n6);
        if (n2 != 0 || n3 != n6) {
            bl3 = true;
        }
        if (bl3) {
            float f4 = 0.0f;
            for (int i2 = n2; i2 < n3; ++i2) {
                f4 += this.absoluteWidths[i2];
            }
            pdfContentByte.saveState();
            float f5 = 10000.0f;
            float f6 = n2 == 0 ? 10000.0f : 0.0f;
            if (n3 != n6) {
                f5 = 0.0f;
            }
            pdfContentByte.rectangle(f2 - f6, -10000.0f, f4 + f6 + f5, 20000.0f);
            pdfContentByte.clip();
            pdfContentByte.newPath();
        }
        PdfContentByte[] arrpdfContentByte = PdfPTable.beginWritingRows(pdfContentByte);
        f2 = this.writeSelectedRows(n2, n3, n4, n5, f2, f3, arrpdfContentByte, bl2);
        PdfPTable.endWritingRows(arrpdfContentByte);
        if (bl3) {
            pdfContentByte.restoreState();
        }
        return f2;
    }

    public float writeSelectedRows(int n2, int n3, int n4, int n5, float f2, float f3, PdfContentByte[] arrpdfContentByte) {
        return this.writeSelectedRows(n2, n3, n4, n5, f2, f3, arrpdfContentByte, true);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public float writeSelectedRows(int var1_1, int var2_2, int var3_3, int var4_4, float var5_5, float var6_6, PdfContentByte[] var7_7, boolean var8_8) {
        if (this.totalWidth <= 0.0f) throw new RuntimeException(MessageLocalization.getComposedMessage("the.table.width.must.be.greater.than.zero", new Object[0]));
        var10_9 = this.rows.size();
        if (var3_3 < 0) {
            var3_3 = 0;
        }
        var4_4 = var4_4 < 0 ? var10_9 : Math.min(var4_4, var10_9);
        if (var3_3 >= var4_4) {
            return var6_6;
        }
        var11_10 = this.getNumberOfColumns();
        var10_9 = var1_1 < 0 ? 0 : Math.min(var1_1, var11_10);
        var2_2 = var2_2 < 0 ? var11_10 : Math.min(var2_2, var11_10);
        this.LOGGER.info(String.format("Writing row %s to %s; column %s to %s", new Object[]{var3_3, var4_4, var10_9, var2_2}));
        var14_11 /* !! */  = null;
        if (this.rowsNotChecked) {
            this.getFittingRows(Float.MAX_VALUE, var3_3);
        }
        var12_12 = this.getRows(var3_3, var4_4);
        var16_13 = var12_12.iterator();
        var9_14 = var6_6;
        var1_1 = var3_3;
        while (var16_13.hasNext()) {
            block16 : {
                block15 : {
                    block14 : {
                        block12 : {
                            block13 : {
                                block11 : {
                                    var15_30 = var16_13.next();
                                    if (this.getHeader().rows == null || !this.getHeader().rows.contains(var15_30) || var14_11 /* !! */  != null) break block11;
                                    var13_16 = this.getHeader();
                                    var14_11 /* !! */  = var7_7[3];
                                    break block12;
                                }
                                if (this.getBody().rows == null || !this.getBody().rows.contains(var15_30) || var14_11 /* !! */  != null) break block13;
                                var13_19 = this.getBody();
                                var14_11 /* !! */  = var7_7[3];
                                break block12;
                            }
                            var13_20 = var14_11 /* !! */ ;
                            if (this.getFooter().rows == null) break block14;
                            var13_21 = var14_11 /* !! */ ;
                            if (!this.getFooter().rows.contains(var15_30)) break block14;
                            var13_22 = var14_11 /* !! */ ;
                            if (var14_11 /* !! */  != null) break block14;
                            var13_23 = this.getFooter();
                            var14_11 /* !! */  = var7_7[3];
                        }
                        var13_18 = this.openTableBlock((PdfPTableBody)var13_17, (PdfContentByte)var14_11 /* !! */ );
                    }
                    if (var15_30 != null) {
                        var15_30.writeCells(var10_9, var2_2, var5_5, var9_14, var7_7, var8_8);
                        var9_14 -= var15_30.getMaxHeights();
                    }
                    var14_11 /* !! */  = var15_30;
                    var15_30 = var12_12;
                    if (this.getHeader().rows == null || !this.getHeader().rows.contains(var14_11 /* !! */ ) || var1_1 != var4_4 - 1 && this.getHeader().rows.contains(var15_30.get(var1_1 + 1))) break block15;
                    var12_12 = this.getHeader();
                    var13_25 = var7_7[3];
                    ** GOTO lbl60
                }
                if (this.getBody().rows == null || !this.getBody().rows.contains(var14_11 /* !! */ ) || var1_1 != var4_4 - 1 && this.getBody().rows.contains(var15_30.get(var1_1 + 1))) break block16;
                var12_12 = this.getBody();
                var13_27 = var7_7[3];
                ** GOTO lbl60
            }
            if (this.getFooter().rows != null && this.getFooter().rows.contains(var14_11 /* !! */ ) && (var1_1 == var4_4 - 1 || !this.getFooter().rows.contains(var15_30.get(var1_1 + 1)))) {
                var12_12 = this.getFooter();
                var13_28 = var7_7[3];
lbl60: // 3 sources:
                var14_11 /* !! */  = this.closeTableBlock((PdfPTableBody)var12_12, (PdfContentByte)var13_26);
            } else {
                var14_11 /* !! */  = var13_24;
            }
            ++var1_1;
            var12_12 = var15_30;
        }
        if (this.tableEvent == null) return var9_14;
        if (var10_9 != 0) return var9_14;
        if (var2_2 != var11_10) return var9_14;
        var13_29 = new float[var4_4 - var3_3 + 1];
        var13_29[0] = var6_6;
        for (var1_1 = var3_3; var1_1 < var4_4; ++var1_1) {
            var14_11 /* !! */  = var12_12.get(var1_1);
            var6_6 = var14_11 /* !! */  != null ? var14_11 /* !! */ .getMaxHeights() : 0.0f;
            var2_2 = var1_1 - var3_3;
            var13_29[var2_2 + 1] = var13_29[var2_2] - var6_6;
        }
        var12_12 = this.tableEvent;
        var14_11 /* !! */  = this.getEventWidths(var5_5, var3_3, var4_4, this.headersInEvent);
        var1_1 = this.headersInEvent != false ? this.headerRows : 0;
        var12_12.tableLayout(this, var14_11 /* !! */ , var13_29, var1_1, var3_3, var7_7);
        return var9_14;
    }

    public static class ColumnMeasurementState {
        public int colspan = 1;
        public float height = 0.0f;
        public int rowspan = 1;

        public void beginCell(PdfPCell pdfPCell, float f2, float f3) {
            this.rowspan = pdfPCell.getRowspan();
            this.colspan = pdfPCell.getColspan();
            float f4 = pdfPCell.hasCachedMaxHeight() ? pdfPCell.getCachedMaxHeight() : pdfPCell.getMaxHeight();
            this.height = f2 + Math.max(f4, f3);
        }

        public boolean cellEnds() {
            if (this.rowspan == 1) {
                return true;
            }
            return false;
        }

        public void consumeRowspan(float f2, float f3) {
            --this.rowspan;
        }
    }

    public static class FittingRows {
        public final float completedRowsHeight;
        private final Map<Integer, Float> correctedHeightsForLastRow;
        public final int firstRow;
        public final float height;
        public final int lastRow;

        public FittingRows(int n2, int n3, float f2, float f3, Map<Integer, Float> map) {
            this.firstRow = n2;
            this.lastRow = n3;
            this.height = f2;
            this.completedRowsHeight = f3;
            this.correctedHeightsForLastRow = map;
        }

        public void correctLastRowChosen(PdfPTable iAccessibleElement, int n2) {
            iAccessibleElement = iAccessibleElement.getRow(n2);
            Float f2 = this.correctedHeightsForLastRow.get(n2);
            if (f2 != null) {
                iAccessibleElement.setFinalMaxHeights(f2.floatValue());
            }
        }
    }

}

