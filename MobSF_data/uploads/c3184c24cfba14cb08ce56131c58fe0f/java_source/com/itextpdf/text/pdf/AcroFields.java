/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Image;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.io.RASInputStream;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.io.WindowRandomAccessSource;
import com.itextpdf.text.pdf.BaseField;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.CMYKColor;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.ExtendedColor;
import com.itextpdf.text.pdf.FdfReader;
import com.itextpdf.text.pdf.FdfWriter;
import com.itextpdf.text.pdf.GrayColor;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfAppearance;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDate;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfFormField;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStamperImp;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfTemplate;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.PushbuttonField;
import com.itextpdf.text.pdf.RadioCheckField;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.TextField;
import com.itextpdf.text.pdf.XfaForm;
import com.itextpdf.text.pdf.XfdfReader;
import com.itextpdf.text.pdf.codec.Base64;
import com.itextpdf.text.pdf.security.PdfPKCS7;
import com.itextpdf.text.xml.XmlToTxt;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import org.w3c.dom.Node;

public class AcroFields {
    public static final int DA_COLOR = 2;
    public static final int DA_FONT = 0;
    public static final int DA_SIZE = 1;
    public static final int FIELD_TYPE_CHECKBOX = 2;
    public static final int FIELD_TYPE_COMBO = 6;
    public static final int FIELD_TYPE_LIST = 5;
    public static final int FIELD_TYPE_NONE = 0;
    public static final int FIELD_TYPE_PUSHBUTTON = 1;
    public static final int FIELD_TYPE_RADIOBUTTON = 3;
    public static final int FIELD_TYPE_SIGNATURE = 7;
    public static final int FIELD_TYPE_TEXT = 4;
    private static final PdfName[] buttonRemove;
    private static final HashMap<String, String[]> stdFieldFontNames;
    private boolean append;
    private HashMap<Integer, BaseFont> extensionFonts = new HashMap();
    private float extraMarginLeft;
    private float extraMarginTop;
    private Map<String, TextField> fieldCache;
    Map<String, Item> fields;
    private boolean generateAppearances = true;
    private boolean lastWasString;
    private HashMap<String, BaseFont> localFonts = new HashMap();
    private ArrayList<String> orderedSignatureNames;
    PdfReader reader;
    private HashMap<String, int[]> sigNames;
    private ArrayList<BaseFont> substitutionFonts;
    private int topFirst;
    private int totalRevisions;
    PdfWriter writer;
    private XfaForm xfa;

    static {
        stdFieldFontNames = new HashMap();
        stdFieldFontNames.put("CoBO", new String[]{"Courier-BoldOblique"});
        stdFieldFontNames.put("CoBo", new String[]{"Courier-Bold"});
        stdFieldFontNames.put("CoOb", new String[]{"Courier-Oblique"});
        stdFieldFontNames.put("Cour", new String[]{"Courier"});
        stdFieldFontNames.put("HeBO", new String[]{"Helvetica-BoldOblique"});
        stdFieldFontNames.put("HeBo", new String[]{"Helvetica-Bold"});
        stdFieldFontNames.put("HeOb", new String[]{"Helvetica-Oblique"});
        stdFieldFontNames.put("Helv", new String[]{"Helvetica"});
        stdFieldFontNames.put("Symb", new String[]{"Symbol"});
        stdFieldFontNames.put("TiBI", new String[]{"Times-BoldItalic"});
        stdFieldFontNames.put("TiBo", new String[]{"Times-Bold"});
        stdFieldFontNames.put("TiIt", new String[]{"Times-Italic"});
        stdFieldFontNames.put("TiRo", new String[]{"Times-Roman"});
        stdFieldFontNames.put("ZaDb", new String[]{"ZapfDingbats"});
        stdFieldFontNames.put("HySm", new String[]{"HYSMyeongJo-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("HyGo", new String[]{"HYGoThic-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaGo", new String[]{"HeiseiKakuGo-W5", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaMi", new String[]{"HeiseiMin-W3", "UniJIS-UCS2-H"});
        stdFieldFontNames.put("MHei", new String[]{"MHei-Medium", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("MSun", new String[]{"MSung-Light", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("STSo", new String[]{"STSong-Light", "UniGB-UCS2-H"});
        buttonRemove = new PdfName[]{PdfName.MK, PdfName.F, PdfName.FF, PdfName.Q, PdfName.BS, PdfName.BORDER};
    }

    AcroFields(PdfReader pdfReader, PdfWriter pdfWriter) {
        this.reader = pdfReader;
        this.writer = pdfWriter;
        try {
            this.xfa = new XfaForm(pdfReader);
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
        if (pdfWriter instanceof PdfStamperImp) {
            this.append = ((PdfStamperImp)pdfWriter).isAppend();
        }
        this.fill();
    }

    private static void clearSigDic(PdfDictionary pdfDictionary) {
        pdfDictionary.remove(PdfName.AP);
        pdfDictionary.remove(PdfName.AS);
        pdfDictionary.remove(PdfName.V);
        pdfDictionary.remove(PdfName.DV);
        pdfDictionary.remove(PdfName.SV);
        pdfDictionary.remove(PdfName.FF);
        pdfDictionary.put(PdfName.F, new PdfNumber(4));
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private String[] getListOption(String object, int n2) {
        if ((object = this.getFieldItem((String)object)) == null) {
            return null;
        }
        int n3 = 0;
        PdfArray pdfArray = object.getMerged(0).getAsArray(PdfName.OPT);
        if (pdfArray == null) {
            return null;
        }
        String[] arrstring = new String[pdfArray.size()];
        do {
            block7 : {
                if (n3 >= pdfArray.size()) {
                    return arrstring;
                }
                PdfObject pdfObject = pdfArray.getDirectObject(n3);
                object = pdfObject;
                try {
                    if (pdfObject.isArray()) {
                        object = ((PdfArray)pdfObject).getDirectObject(n2);
                    }
                    arrstring[n3] = object.isString() ? ((PdfString)object).toUnicodeString() : object.toString();
                    break block7;
                }
                catch (Exception exception) {}
                arrstring[n3] = "";
            }
            ++n3;
        } while (true);
    }

    private void markUsed(PdfObject pdfObject) {
        if (!this.append) {
            return;
        }
        ((PdfStamperImp)this.writer).markUsed(pdfObject);
    }

    private int removeRefFromArray(PdfArray pdfArray, PdfObject pdfObject) {
        if (pdfObject != null && pdfObject.isIndirect()) {
            pdfObject = (PdfIndirectReference)pdfObject;
            int n2 = 0;
            while (n2 < pdfArray.size()) {
                int n3;
                PdfObject pdfObject2 = pdfArray.getPdfObject(n2);
                if (!pdfObject2.isIndirect()) {
                    n3 = n2;
                } else {
                    n3 = n2;
                    if (((PdfIndirectReference)pdfObject2).getNumber() == pdfObject.getNumber()) {
                        pdfArray.remove(n2);
                        n3 = n2 - 1;
                    }
                }
                n2 = n3 + 1;
            }
            return pdfArray.size();
        }
        return pdfArray.size();
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public static Object[] splitDAelements(String object) {
        try {
            object = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(PdfEncodings.convertToBytes((String)object, null))));
            ArrayList<String> arrayList = new ArrayList<String>();
            Object[] arrobject = new Object[3];
            while (object.nextToken()) {
                if (object.getTokenType() == PRTokeniser.TokenType.COMMENT) continue;
                if (object.getTokenType() == PRTokeniser.TokenType.OTHER) {
                    String string2 = object.getStringValue();
                    if (string2.equals("Tf")) {
                        if (arrayList.size() >= 2) {
                            arrobject[0] = arrayList.get(arrayList.size() - 2);
                            arrobject[1] = new Float((String)arrayList.get(arrayList.size() - 1));
                        }
                    } else if (string2.equals("g")) {
                        float f2;
                        if (arrayList.size() >= 1 && (f2 = new Float((String)arrayList.get(arrayList.size() - 1)).floatValue()) != 0.0f) {
                            arrobject[2] = new GrayColor(f2);
                        }
                    } else if (string2.equals("rg")) {
                        if (arrayList.size() >= 3) {
                            arrobject[2] = new BaseColor(new Float((String)arrayList.get(arrayList.size() - 3)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 2)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 1)).floatValue());
                        }
                    } else if (string2.equals("k") && arrayList.size() >= 4) {
                        arrobject[2] = new CMYKColor(new Float((String)arrayList.get(arrayList.size() - 4)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 3)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 2)).floatValue(), new Float((String)arrayList.get(arrayList.size() - 1)).floatValue());
                    }
                    arrayList.clear();
                    continue;
                }
                arrayList.add(object.getStringValue());
            }
            return arrobject;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    /*
     * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private void updateByteRange(PdfPKCS7 pdfPKCS7, PdfDictionary object) {
        void var1_7;
        block12 : {
            int n2;
            Object object2 = object.getAsArray(PdfName.BYTERANGE);
            RandomAccessFileOrArray randomAccessFileOrArray = this.reader.getSafeFile();
            Object var5_12 = null;
            object = null;
            object2 = new RASInputStream(new RandomAccessSourceFactory().createRanged(randomAccessFileOrArray.createSourceView(), object2.asLongArray()));
            object = new byte[8192];
            while ((n2 = object2.read((byte[])object, 0, ((Object)object).length)) > 0) {
                pdfPKCS7.update((byte[])object, 0, n2);
            }
            try {
                object2.close();
                return;
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
            catch (Throwable throwable) {
                object = object2;
                break block12;
            }
            catch (Exception exception) {
                object = object2;
                throw new ExceptionConverter((Exception)((Object)pdfPKCS7));
            }
            catch (Throwable throwable) {
                break block12;
            }
            catch (Exception exception) {
                object = var5_12;
            }
            {
                throw new ExceptionConverter((Exception)((Object)pdfPKCS7));
            }
        }
        if (object == null) throw var1_7;
        try {
            object.close();
            throw var1_7;
        }
        catch (IOException iOException) {
            throw new ExceptionConverter(iOException);
        }
    }

    public void addSubstitutionFont(BaseFont baseFont) {
        if (this.substitutionFonts == null) {
            this.substitutionFonts = new ArrayList();
        }
        this.substitutionFonts.add(baseFont);
    }

    public boolean clearSignatureField(String object) {
        this.sigNames = null;
        this.getSignatureNames();
        boolean bl2 = this.sigNames.containsKey(object);
        if (!bl2) {
            return false;
        }
        object = this.fields.get(object);
        object.markUsed(this, 6);
        int n2 = object.size();
        for (int i2 = 0; i2 < n2; ++i2) {
            AcroFields.clearSigDic(object.getMerged(i2));
            AcroFields.clearSigDic(object.getWidget(i2));
            AcroFields.clearSigDic(object.getValue(i2));
        }
        return true;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public void decodeGenericDictionary(PdfDictionary pdfObject, BaseField baseField) {
        int n2;
        int n3;
        Object object2;
        Object object;
        block37 : {
            Object[] arrobject;
            block42 : {
                block38 : {
                    block40 : {
                        Integer n4;
                        block35 : {
                            block39 : {
                                block41 : {
                                    PdfObject pdfObject2;
                                    object = pdfObject.getAsString(PdfName.DA);
                                    n2 = 0;
                                    if (object == null) break block37;
                                    arrobject = AcroFields.splitDAelements(object.toUnicodeString());
                                    if (arrobject[1] != null) {
                                        baseField.setFontSize(((Float)arrobject[1]).floatValue());
                                    }
                                    if (arrobject[2] != null) {
                                        baseField.setTextColor((BaseColor)arrobject[2]);
                                    }
                                    if (arrobject[0] == null) break block38;
                                    object = pdfObject.getAsDict(PdfName.DR);
                                    if (object == null || (object2 = object.getAsDict(PdfName.FONT)) == null || (pdfObject2 = object2.get(new PdfName((String)arrobject[0]))) == null || pdfObject2.type() != 10) break block39;
                                    object2 = (PRIndirectReference)pdfObject2;
                                    baseField.setFont(new DocumentFont((PRIndirectReference)object2, object.getAsDict(PdfName.ENCODING)));
                                    n4 = object2.getNumber();
                                    object2 = object = this.extensionFonts.get(n4);
                                    if (object != null) break block40;
                                    object2 = object;
                                    if (this.extensionFonts.containsKey(n4)) break block40;
                                    PdfDictionary pdfDictionary = ((PdfDictionary)PdfReader.getPdfObject(pdfObject2)).getAsDict(PdfName.FONTDESCRIPTOR);
                                    object2 = object;
                                    if (pdfDictionary == null) break block40;
                                    pdfObject2 = (PRStream)PdfReader.getPdfObject(pdfDictionary.get(PdfName.FONTFILE2));
                                    object2 = pdfObject2;
                                    if (pdfObject2 == null) {
                                        object2 = (PRStream)PdfReader.getPdfObject(pdfDictionary.get(PdfName.FONTFILE3));
                                    }
                                    if (object2 != null) break block41;
                                    this.extensionFonts.put(n4, null);
                                    object2 = object;
                                    break block40;
                                }
                                try {
                                    object = object2 = BaseFont.createFont("font.ttf", "Identity-H", true, false, PdfReader.getStreamBytes((PRStream)object2), null);
                                    break block35;
                                }
                                catch (Exception exception) {}
                            }
                            n3 = 1;
                            break block42;
                        }
                        this.extensionFonts.put(n4, (BaseFont)object);
                        object2 = object;
                    }
                    if (baseField instanceof TextField) {
                        ((TextField)baseField).setExtensionFont((BaseFont)object2);
                    }
                }
                n3 = 0;
            }
            if (n3 != 0) {
                object = this.localFonts.get(arrobject[0]);
                if (object == null) {
                    object2 = stdFieldFontNames.get(arrobject[0]);
                    if (object2 != null) {
                        block36 : {
                            object = "winansi";
                            if (((String[])object2).length <= 1) break block36;
                            object = object2[1];
                        }
                        baseField.setFont(BaseFont.createFont(object2[0], (String)object, false));
                    }
                } else {
                    baseField.setFont((BaseFont)object);
                }
                break block37;
                catch (Exception exception) {}
            }
        }
        if ((object = pdfObject.getAsDict(PdfName.MK)) != null) {
            object2 = this.getMKColor(object.getAsArray(PdfName.BC));
            baseField.setBorderColor((BaseColor)object2);
            if (object2 != null) {
                baseField.setBorderWidth(1.0f);
            }
            baseField.setBackgroundColor(this.getMKColor(object.getAsArray(PdfName.BG)));
            object = object.getAsNumber(PdfName.R);
            if (object != null) {
                baseField.setRotation(object.intValue());
            }
        }
        object = pdfObject.getAsNumber(PdfName.F);
        baseField.setVisibility(2);
        if (object != null) {
            n3 = object.intValue();
            int n5 = n3 & 4;
            if (n5 != 0 && (n3 & 2) != 0) {
                baseField.setVisibility(1);
            } else if (n5 != 0 && (n3 & 32) != 0) {
                baseField.setVisibility(3);
            } else if (n5 != 0) {
                baseField.setVisibility(0);
            }
        }
        n3 = (object = pdfObject.getAsNumber(PdfName.FF)) != null ? object.intValue() : 0;
        baseField.setOptions(n3);
        if ((n3 & 16777216) != 0) {
            object = pdfObject.getAsNumber(PdfName.MAXLEN);
            n3 = n2;
            if (object != null) {
                n3 = object.intValue();
            }
            baseField.setMaxCharacterLength(n3);
        }
        if ((object = pdfObject.getAsNumber(PdfName.Q)) != null) {
            if (object.intValue() == 1) {
                baseField.setAlignment(1);
            } else if (object.intValue() == 2) {
                baseField.setAlignment(2);
            }
        }
        if ((object = pdfObject.getAsDict(PdfName.BS)) != null) {
            pdfObject = object.getAsNumber(PdfName.W);
            if (pdfObject != null) {
                baseField.setBorderWidth(pdfObject.floatValue());
            }
            if (!PdfName.D.equals(pdfObject = object.getAsName(PdfName.S))) {
                if (PdfName.B.equals(pdfObject)) {
                    baseField.setBorderStyle(2);
                    return;
                }
                if (PdfName.I.equals(pdfObject)) {
                    baseField.setBorderStyle(3);
                    return;
                }
                if (!PdfName.U.equals(pdfObject)) return;
                baseField.setBorderStyle(4);
                return;
            }
        } else {
            if ((pdfObject = pdfObject.getAsArray(PdfName.BORDER)) == null) return;
            if (pdfObject.size() >= 3) {
                baseField.setBorderWidth(pdfObject.getAsNumber(2).floatValue());
            }
            if (pdfObject.size() < 4) return;
        }
        baseField.setBorderStyle(1);
    }

    public boolean doesSignatureFieldExist(String string2) {
        if (!this.getBlankSignatureNames().contains(string2) && !this.getSignatureNames().contains(string2)) {
            return false;
        }
        return true;
    }

    public void exportAsFdf(FdfWriter fdfWriter) {
        for (Map.Entry<String, Item> entry : this.fields.entrySet()) {
            Object object2 = entry.getValue();
            String object = entry.getKey();
            if (object2.getMerged(0).get(PdfName.V) == null) continue;
            object2 = this.getField(object);
            if (this.lastWasString) {
                fdfWriter.setFieldAsString(object, (String)object2);
                continue;
            }
            fdfWriter.setFieldAsName(object, (String)object2);
        }
    }

    public InputStream extractRevision(String string2) {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        if (!this.sigNames.containsKey(string2)) {
            return null;
        }
        int n2 = this.sigNames.get(string2)[0];
        return new RASInputStream(new WindowRandomAccessSource(this.reader.getSafeFile().createSourceView(), 0L, n2));
    }

    /*
     * Enabled aggressive block sorting
     */
    void fill() {
        block21 : {
            Item item;
            Object object;
            this.fields = new LinkedHashMap<String, Item>();
            PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObjectRelease(this.reader.getCatalog().get(PdfName.ACROFORM));
            if (pdfDictionary == null) {
                return;
            }
            Object object2 = pdfDictionary.getAsBoolean(PdfName.NEEDAPPEARANCES);
            if (object2 != null && object2.booleanValue()) {
                this.setGenerateAppearances(false);
            } else {
                this.setGenerateAppearances(true);
            }
            PdfArray pdfArray = (PdfArray)PdfReader.getPdfObjectRelease(pdfDictionary.get(PdfName.FIELDS));
            if (pdfArray == null) break block21;
            if (pdfArray.size() == 0) {
                return;
            }
            int n2 = 1;
            do {
                block23 : {
                    PdfArray pdfArray2;
                    block24 : {
                        block22 : {
                            if (n2 > this.reader.getNumberOfPages()) break block22;
                            object2 = this.reader.getPageNRelease(n2);
                            pdfArray2 = (PdfArray)PdfReader.getPdfObjectRelease(object2.get(PdfName.ANNOTS), (PdfObject)object2);
                            if (pdfArray2 == null) break block23;
                            break block24;
                        }
                        object2 = pdfDictionary.getAsNumber(PdfName.SIGFLAGS);
                        if (object2 == null) return;
                        if ((object2.intValue() & 1) == 1) break;
                        return;
                    }
                    for (int i2 = 0; i2 < pdfArray2.size(); ++i2) {
                        PdfDictionary pdfDictionary2 = pdfArray2.getAsDict(i2);
                        if (pdfDictionary2 == null || !PdfName.WIDGET.equals(pdfDictionary2.getAsName(PdfName.SUBTYPE))) {
                            PdfReader.releaseLastXrefPartial(pdfArray2.getAsIndirectObject(i2));
                            continue;
                        }
                        PdfDictionary pdfDictionary3 = new PdfDictionary();
                        pdfDictionary3.putAll(pdfDictionary2);
                        Object object3 = null;
                        item = object3;
                        object = "";
                        for (object2 = pdfDictionary2; object2 != null; object2 = object2.getAsDict((PdfName)PdfName.PARENT)) {
                            pdfDictionary3.mergeDifferent((PdfDictionary)object2);
                            PdfString pdfString = object2.getAsString(PdfName.T);
                            Object object4 = object;
                            if (pdfString != null) {
                                object4 = new StringBuilder();
                                object4.append(pdfString.toUnicodeString());
                                object4.append(".");
                                object4.append((String)object);
                                object4 = object4.toString();
                            }
                            Object object5 = object3;
                            if (object3 == null) {
                                object5 = object3;
                                if (object2.get(PdfName.V) != null) {
                                    object5 = PdfReader.getPdfObjectRelease(object2.get(PdfName.V));
                                }
                            }
                            Object object6 = item;
                            if (item == null) {
                                object6 = item;
                                if (pdfString != null) {
                                    if (object2.get(PdfName.V) == null && object5 != null) {
                                        object2.put(PdfName.V, (PdfObject)object5);
                                    }
                                    object6 = object2;
                                }
                            }
                            object = object4;
                            object3 = object5;
                            item = object6;
                        }
                        if (object.length() > 0) {
                            object = object.substring(0, object.length() - 1);
                        }
                        object2 = object3 = this.fields.get(object);
                        if (object3 == null) {
                            object2 = new Item();
                            this.fields.put((String)object, (Item)object2);
                        }
                        if (item == null) {
                            object2.addValue(pdfDictionary2);
                        } else {
                            object2.addValue((PdfDictionary)((Object)item));
                        }
                        object2.addWidget(pdfDictionary2);
                        object2.addWidgetRef(pdfArray2.getAsIndirectObject(i2));
                        if (pdfDictionary != null) {
                            pdfDictionary3.mergeDifferent(pdfDictionary);
                        }
                        object2.addMerged(pdfDictionary3);
                        object2.addPage(n2);
                        object2.addTabOrder(i2);
                    }
                }
                ++n2;
            } while (true);
            for (n2 = 0; n2 < pdfArray.size(); ++n2) {
                object = pdfArray.getAsDict(n2);
                if (object == null || !PdfName.WIDGET.equals(object.getAsName(PdfName.SUBTYPE))) {
                    PdfReader.releaseLastXrefPartial(pdfArray.getAsIndirectObject(n2));
                    continue;
                }
                if ((PdfArray)PdfReader.getPdfObjectRelease(object.get(PdfName.KIDS)) != null) continue;
                object2 = new PdfDictionary();
                object2.putAll((PdfDictionary)object);
                object = object.getAsString(PdfName.T);
                if (object == null || this.fields.containsKey(object = object.toUnicodeString())) continue;
                item = new Item();
                this.fields.put((String)object, item);
                item.addValue((PdfDictionary)object2);
                item.addWidget((PdfDictionary)object2);
                item.addWidgetRef(pdfArray.getAsIndirectObject(n2));
                item.addMerged((PdfDictionary)object2);
                item.addPage(-1);
                item.addTabOrder(-1);
            }
        }
    }

    PdfAppearance getAppearance(PdfDictionary pdfDictionary, String string2, String string3) {
        return this.getAppearance(pdfDictionary, new String[]{string2}, string3);
    }

    PdfAppearance getAppearance(PdfDictionary object, String[] object2, String object3) {
        int n2;
        String[] arrstring;
        Object object4;
        PdfName pdfName;
        String[] arrstring2;
        String[] arrstring3;
        block26 : {
            block28 : {
                block27 : {
                    block25 : {
                        block22 : {
                            boolean bl2;
                            RadioCheckField radioCheckField;
                            block24 : {
                                block23 : {
                                    pdfName = object.getAsName(PdfName.FT);
                                    bl2 = PdfName.BTN.equals(pdfName);
                                    n2 = 0;
                                    boolean bl3 = false;
                                    if (!bl2) break block22;
                                    object2 = object.getAsNumber(PdfName.FF);
                                    bl2 = bl3;
                                    if (object2 != null) {
                                        bl2 = bl3;
                                        if ((object2.intValue() & 32768) != 0) {
                                            bl2 = true;
                                        }
                                    }
                                    radioCheckField = new RadioCheckField(this.writer, null, null, null);
                                    this.decodeGenericDictionary((PdfDictionary)object, radioCheckField);
                                    object3 = PdfReader.getNormalizedRectangle(object.getAsArray(PdfName.RECT));
                                    if (radioCheckField.getRotation() == 90) break block23;
                                    object2 = object3;
                                    if (radioCheckField.getRotation() != 270) break block24;
                                }
                                object2 = object3.rotate();
                            }
                            radioCheckField.setBox((Rectangle)object2);
                            if (!bl2) {
                                radioCheckField.setCheckType(3);
                            }
                            return radioCheckField.getAppearance(bl2, object.getAsName(PdfName.AS).equals(PdfName.Off) ^ true);
                        }
                        this.topFirst = 0;
                        object4 = ((String[])object2).length > 0 ? object2[0] : null;
                        if (this.fieldCache == null || !this.fieldCache.containsKey(object3)) break block25;
                        object3 = this.fieldCache.get(object3);
                        object3.setWriter(this.writer);
                        break block26;
                    }
                    arrstring = new String[](this.writer, null, null);
                    arrstring.setExtraMargin(this.extraMarginLeft, this.extraMarginTop);
                    arrstring.setBorderWidth(0.0f);
                    arrstring.setSubstitutionFonts(this.substitutionFonts);
                    this.decodeGenericDictionary((PdfDictionary)object, (BaseField)arrstring);
                    arrstring2 = PdfReader.getNormalizedRectangle(object.getAsArray(PdfName.RECT));
                    if (arrstring.getRotation() == 90) break block27;
                    arrstring3 = arrstring2;
                    if (arrstring.getRotation() != 270) break block28;
                }
                arrstring3 = arrstring2.rotate();
            }
            arrstring.setBox((Rectangle)arrstring3);
            if (this.fieldCache != null) {
                this.fieldCache.put((String)object3, (TextField)arrstring);
            }
            object3 = arrstring;
        }
        if (PdfName.TX.equals(pdfName)) {
            if (((Object)object2).length > 0 && object2[0] != null) {
                object3.setText((String)object2[0]);
            }
            return object3.getAppearance();
        }
        if (PdfName.CH.equals(pdfName)) {
            arrstring2 = object.getAsArray(PdfName.OPT);
            int n3 = (object = object.getAsNumber(PdfName.FF)) != null ? object.intValue() : 0;
            int n4 = n3 & 131072;
            if (n4 != 0 && arrstring2 == null) {
                object3.setText((String)object4);
                return object3.getAppearance();
            }
            if (arrstring2 != null) {
                arrstring3 = new String[arrstring2.size()];
                arrstring = new String[arrstring2.size()];
                for (n3 = 0; n3 < arrstring2.size(); ++n3) {
                    object = arrstring2.getPdfObject(n3);
                    if (object.isString()) {
                        arrstring[n3] = object = ((PdfString)object).toUnicodeString();
                        arrstring3[n3] = object;
                        continue;
                    }
                    object = (PdfArray)object;
                    arrstring[n3] = object.getAsString(0).toUnicodeString();
                    arrstring3[n3] = object.getAsString(1).toUnicodeString();
                }
                if (n4 != 0) {
                    n3 = n2;
                    do {
                        object = object4;
                        if (n3 >= arrstring3.length) break;
                        if (object4.equals(arrstring[n3])) {
                            object = arrstring3[n3];
                            break;
                        }
                        ++n3;
                    } while (true);
                    object3.setText((String)object);
                    return object3.getAppearance();
                }
                object = new ArrayList();
                block2 : for (n3 = 0; n3 < arrstring.length; ++n3) {
                    for (n2 = 0; n2 < ((Object)object2).length; ++n2) {
                        object4 = object2[n2];
                        if (object4 == null || !object4.equals(arrstring[n3])) continue;
                        object.add(n3);
                        continue block2;
                    }
                }
                object3.setChoices(arrstring3);
                object3.setChoiceExports(arrstring);
                object3.setChoiceSelections((ArrayList<Integer>)object);
            }
            object = object3.getListAppearance();
            this.topFirst = object3.getTopFirst();
            return object;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("an.appearance.was.requested.without.a.variable.text.field", new Object[0]));
    }

    public String[] getAppearanceStates(String object) {
        int n2;
        Item item = this.fields.get(object);
        if (item == null) {
            return null;
        }
        LinkedHashSet<String> linkedHashSet = new LinkedHashSet<String>();
        int n3 = 0;
        object = item.getValue(0);
        PdfObject pdfObject = object.getAsString(PdfName.OPT);
        if (pdfObject != null) {
            linkedHashSet.add(pdfObject.toUnicodeString());
            n2 = n3;
        } else {
            pdfObject = object.getAsArray(PdfName.OPT);
            n2 = n3;
            if (pdfObject != null) {
                int n4 = 0;
                do {
                    n2 = n3;
                    if (n4 >= pdfObject.size()) break;
                    object = pdfObject.getDirectObject(n4);
                    n2 = object.type();
                    object = n2 != 3 ? (n2 != 5 ? null : ((PdfArray)object).getAsString(1)) : (PdfString)object;
                    if (object != null) {
                        linkedHashSet.add(object.toUnicodeString());
                    }
                    ++n4;
                } while (true);
            }
        }
        while (n2 < item.size()) {
            object = item.getWidget(n2).getAsDict(PdfName.AP);
            if (object != null && (object = object.getAsDict(PdfName.N)) != null) {
                object = object.getKeys().iterator();
                while (object.hasNext()) {
                    linkedHashSet.add(PdfName.decodeName(((PdfName)object.next()).toString()));
                }
            }
            ++n2;
        }
        return linkedHashSet.toArray(new String[linkedHashSet.size()]);
    }

    public ArrayList<String> getBlankSignatureNames() {
        this.getSignatureNames();
        ArrayList<String> arrayList = new ArrayList<String>();
        for (Map.Entry<String, Item> entry : this.fields.entrySet()) {
            PdfDictionary pdfDictionary = entry.getValue().getMerged(0);
            if (!PdfName.SIG.equals(pdfDictionary.getAsName(PdfName.FT)) || this.sigNames.containsKey(entry.getKey())) continue;
            arrayList.add(entry.getKey());
        }
        return arrayList;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public String getField(String object) {
        if (this.xfa.isXfaPresent()) {
            if ((object = this.xfa.findFieldName((String)object, this)) == null) {
                return null;
            }
            object = XfaForm.Xml2Som.getShortName((String)object);
            return XfaForm.getNodeText(this.xfa.findDatasetsNode((String)object));
        }
        Object object2 = this.fields.get(object);
        if (object2 == null) {
            return null;
        }
        this.lastWasString = false;
        object = object2.getMerged(0);
        PdfObject pdfObject = PdfReader.getPdfObject(object.get(PdfName.V));
        if (pdfObject == null) {
            return "";
        }
        if (pdfObject instanceof PRStream) {
            try {
                return new String(PdfReader.getStreamBytes((PRStream)pdfObject));
            }
            catch (IOException iOException) {
                throw new ExceptionConverter(iOException);
            }
        }
        PdfName pdfName = object.getAsName(PdfName.FT);
        if (PdfName.BTN.equals(pdfName)) {
            int n2 = (object = object.getAsNumber(PdfName.FF)) != null ? object.intValue() : 0;
            if ((n2 & 65536) != 0) {
                return "";
            }
            object = "";
            if (pdfObject instanceof PdfName) {
                object = PdfName.decodeName(pdfObject.toString());
            } else if (pdfObject instanceof PdfString) {
                object = ((PdfString)pdfObject).toUnicodeString();
            }
            pdfObject = object2.getValue(0).getAsArray(PdfName.OPT);
            object2 = object;
            if (pdfObject == null) return object2;
            object2 = pdfObject.getAsString(Integer.parseInt((String)object)).toUnicodeString();
            this.lastWasString = true;
            return object2;
        }
        if (pdfObject instanceof PdfString) {
            this.lastWasString = true;
            return ((PdfString)pdfObject).toUnicodeString();
        }
        if (!(pdfObject instanceof PdfName)) return "";
        return PdfName.decodeName(pdfObject.toString());
        catch (Exception exception) {
            return object;
        }
        catch (Exception exception) {
            return object2;
        }
    }

    public Map<String, TextField> getFieldCache() {
        return this.fieldCache;
    }

    public Item getFieldItem(String string2) {
        String string3 = string2;
        if (this.xfa.isXfaPresent()) {
            string3 = string2 = this.xfa.findFieldName(string2, this);
            if (string2 == null) {
                return null;
            }
        }
        return this.fields.get(string3);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public List<FieldPosition> getFieldPositions(String object) {
        Item item = this.getFieldItem((String)object);
        if (item == null) {
            return null;
        }
        ArrayList<FieldPosition> arrayList = new ArrayList<FieldPosition>();
        int n2 = 0;
        while (n2 < item.size()) {
            try {
                object = item.getWidget(n2).getAsArray(PdfName.RECT);
                if (object != null) {
                    object = PdfReader.getNormalizedRectangle((PdfArray)object);
                    int n3 = item.getPage(n2);
                    int n4 = this.reader.getPageRotation(n3);
                    FieldPosition fieldPosition = new FieldPosition();
                    fieldPosition.page = n3;
                    Object object2 = object;
                    if (n4 != 0) {
                        object2 = this.reader.getPageSize(n3);
                        if (n4 != 90) {
                            if (n4 != 180) {
                                if (n4 == 270) {
                                    object = new Rectangle(object2.getTop() - object.getBottom(), object.getLeft(), object2.getTop() - object.getTop(), object.getRight());
                                }
                            } else {
                                object = new Rectangle(object2.getRight() - object.getLeft(), object2.getTop() - object.getBottom(), object2.getRight() - object.getRight(), object2.getTop() - object.getTop());
                            }
                        } else {
                            object = new Rectangle(object.getBottom(), object2.getRight() - object.getLeft(), object.getTop(), object2.getRight() - object.getRight());
                        }
                        object.normalize();
                        object2 = object;
                    }
                    fieldPosition.position = object2;
                    arrayList.add(fieldPosition);
                }
            }
            catch (Exception exception) {}
            ++n2;
        }
        return arrayList;
    }

    public String getFieldRichValue(String object) {
        boolean bl2 = this.xfa.isXfaPresent();
        Object var3_3 = null;
        if (bl2) {
            return null;
        }
        if ((object = this.fields.get(object)) == null) {
            return null;
        }
        PdfString pdfString = object.getMerged(0).getAsString(PdfName.RV);
        object = var3_3;
        if (pdfString != null) {
            object = pdfString.toString();
        }
        return object;
    }

    public int getFieldType(String object) {
        if ((object = this.getFieldItem((String)object)) == null) {
            return 0;
        }
        PdfObject pdfObject = object.getMerged(0);
        object = pdfObject.getAsName(PdfName.FT);
        if (object == null) {
            return 0;
        }
        int n2 = (pdfObject = pdfObject.getAsNumber(PdfName.FF)) != null ? pdfObject.intValue() : 0;
        if (PdfName.BTN.equals(object)) {
            if ((65536 & n2) != 0) {
                return 1;
            }
            if ((n2 & 32768) != 0) {
                return 3;
            }
            return 2;
        }
        if (PdfName.TX.equals(object)) {
            return 4;
        }
        if (PdfName.CH.equals(object)) {
            if ((n2 & 131072) != 0) {
                return 6;
            }
            return 5;
        }
        if (PdfName.SIG.equals(object)) {
            return 7;
        }
        return 0;
    }

    public Map<String, Item> getFields() {
        return this.fields;
    }

    public String[] getListOptionDisplay(String string2) {
        return this.getListOption(string2, 1);
    }

    public String[] getListOptionExport(String string2) {
        return this.getListOption(string2, 0);
    }

    public String[] getListSelection(String arrstring) {
        String[] arrstring2 = this.getField((String)arrstring);
        int n2 = 0;
        arrstring2 = arrstring2 == null ? new String[]{} : new String[]{arrstring2};
        Object object = this.fields.get(arrstring);
        if (object == null) {
            return arrstring2;
        }
        if ((object = object.getMerged(0).getAsArray(PdfName.I)) == null) {
            return arrstring2;
        }
        arrstring2 = new String[object.size()];
        arrstring = this.getListOptionExport((String)arrstring);
        object = object.listIterator();
        while (object.hasNext()) {
            arrstring2[n2] = arrstring[((PdfNumber)object.next()).intValue()];
            ++n2;
        }
        return arrstring2;
    }

    BaseColor getMKColor(PdfArray pdfArray) {
        if (pdfArray == null) {
            return null;
        }
        int n2 = pdfArray.size();
        if (n2 != 1) {
            switch (n2) {
                default: {
                    return null;
                }
                case 4: {
                    return new CMYKColor(pdfArray.getAsNumber(0).floatValue(), pdfArray.getAsNumber(1).floatValue(), pdfArray.getAsNumber(2).floatValue(), pdfArray.getAsNumber(3).floatValue());
                }
                case 3: 
            }
            return new BaseColor(ExtendedColor.normalize(pdfArray.getAsNumber(0).floatValue()), ExtendedColor.normalize(pdfArray.getAsNumber(1).floatValue()), ExtendedColor.normalize(pdfArray.getAsNumber(2).floatValue()));
        }
        return new GrayColor(pdfArray.getAsNumber(0).floatValue());
    }

    public PushbuttonField getNewPushbuttonFromField(String string2) {
        return this.getNewPushbuttonFromField(string2, 0);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public PushbuttonField getNewPushbuttonFromField(String object, int n2) {
        try {
            if (this.getFieldType((String)object) != 1) {
                return null;
            }
            Object object2 = this.getFieldItem((String)object);
            if (n2 >= object2.size()) {
                return null;
            }
            object = this.getFieldPositions((String)object).get((int)n2).position;
            object = new PushbuttonField(this.writer, (Rectangle)object, null);
            object2 = object2.getMerged(n2);
            this.decodeGenericDictionary((PdfDictionary)object2, (BaseField)object);
            object2 = object2.getAsDict(PdfName.MK);
            if (object2 != null) {
                PdfObject pdfObject = object2.getAsString(PdfName.CA);
                if (pdfObject != null) {
                    object.setText(pdfObject.toUnicodeString());
                }
                if ((pdfObject = object2.getAsNumber(PdfName.TP)) != null) {
                    object.setLayout(pdfObject.intValue() + 1);
                }
                if ((pdfObject = object2.getAsDict(PdfName.IF)) != null) {
                    PdfObject pdfObject2 = pdfObject.getAsName(PdfName.SW);
                    if (pdfObject2 != null) {
                        n2 = pdfObject2.equals(PdfName.B) ? 3 : (pdfObject2.equals(PdfName.S) ? 4 : (pdfObject2.equals(PdfName.N) ? 2 : 1));
                        object.setScaleIcon(n2);
                    }
                    if ((pdfObject2 = pdfObject.getAsName(PdfName.S)) != null && pdfObject2.equals(PdfName.A)) {
                        object.setProportionalIcon(false);
                    }
                    if ((pdfObject2 = pdfObject.getAsArray(PdfName.A)) != null && pdfObject2.size() == 2) {
                        float f2 = pdfObject2.getAsNumber(0).floatValue();
                        float f3 = pdfObject2.getAsNumber(1).floatValue();
                        object.setIconHorizontalAdjustment(f2);
                        object.setIconVerticalAdjustment(f3);
                    }
                    if ((pdfObject = pdfObject.getAsBoolean(PdfName.FB)) != null && pdfObject.booleanValue()) {
                        object.setIconFitToBounds(true);
                    }
                }
                if ((object2 = object2.get(PdfName.I)) != null && object2.isIndirect()) {
                    object.setIconReference((PRIndirectReference)object2);
                }
            }
            return object;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public PdfIndirectReference getNormalAppearance(String object) {
        this.getSignatureNames();
        object = this.getTranslatedFieldName((String)object);
        object = this.fields.get(object);
        if (object == null) {
            return null;
        }
        if ((object = object.getMerged(0).getAsDict(PdfName.AP)) == null) {
            return null;
        }
        if ((object = object.getAsIndirectObject(PdfName.N)) == null) {
            return null;
        }
        return object;
    }

    public int getRevision(String string2) {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        if (!this.sigNames.containsKey(string2)) {
            return 0;
        }
        return this.sigNames.get(string2)[1];
    }

    public PdfDictionary getSignatureDictionary(String string2) {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        if (!this.sigNames.containsKey(string2)) {
            return null;
        }
        return this.fields.get(string2).getMerged(0).getAsDict(PdfName.V);
    }

    /*
     * Enabled aggressive block sorting
     */
    public ArrayList<String> getSignatureNames() {
        int n2;
        if (this.sigNames != null) {
            return new ArrayList<String>(this.orderedSignatureNames);
        }
        this.sigNames = new HashMap();
        this.orderedSignatureNames = new ArrayList();
        ArrayList<Object[]> arrayList = new ArrayList<Object[]>();
        for (Map.Entry<String, Item> entry : this.fields.entrySet()) {
            int n3;
            PdfObject pdfObject = entry.getValue().getMerged(0);
            if (!PdfName.SIG.equals(pdfObject.get(PdfName.FT)) || (pdfObject = pdfObject.getAsDict(PdfName.V)) == null || pdfObject.getAsString(PdfName.CONTENTS) == null || (pdfObject = pdfObject.getAsArray(PdfName.BYTERANGE)) == null || (n3 = pdfObject.size()) < 2) continue;
            n2 = pdfObject.getAsNumber(n3 - 1).intValue();
            n3 = pdfObject.getAsNumber(n3 - 2).intValue();
            arrayList.add(new Object[]{entry.getKey(), new int[]{n2 + n3, 0}});
        }
        Collections.sort(arrayList, new SorterComparator());
        if (arrayList.isEmpty()) {
            return new ArrayList<String>(this.orderedSignatureNames);
        }
        n2 = (long)((int[])((Object[])arrayList.get(arrayList.size() - 1))[1])[0] == this.reader.getFileLength() ? arrayList.size() : arrayList.size() + 1;
        this.totalRevisions = n2;
        n2 = 0;
        while (n2 < arrayList.size()) {
            Object[] arrobject = (Object[])arrayList.get(n2);
            String string2 = (String)arrobject[0];
            int[] arrn = (int[])arrobject[1];
            arrn[1] = ++n2;
            this.sigNames.put(string2, arrn);
            this.orderedSignatureNames.add(string2);
        }
        return new ArrayList<String>(this.orderedSignatureNames);
    }

    public ArrayList<BaseFont> getSubstitutionFonts() {
        return this.substitutionFonts;
    }

    public int getTotalRevisions() {
        this.getSignatureNames();
        return this.totalRevisions;
    }

    public String getTranslatedFieldName(String string2) {
        String string3 = string2;
        if (this.xfa.isXfaPresent()) {
            String string4 = this.xfa.findFieldName(string2, this);
            string3 = string2;
            if (string4 != null) {
                string3 = string4;
            }
        }
        return string3;
    }

    public XfaForm getXfa() {
        return this.xfa;
    }

    public boolean isGenerateAppearances() {
        return this.generateAppearances;
    }

    boolean isInAP(PdfDictionary pdfDictionary, PdfName pdfName) {
        if (pdfDictionary != null && pdfDictionary.get(pdfName) != null) {
            return true;
        }
        return false;
    }

    public void mergeXfaData(Node object) {
        object = new XfaForm.Xml2SomDatasets((Node)object);
        for (String string2 : object.getOrder()) {
            this.setField(string2, XfaForm.getNodeText(object.getName2Node().get(string2)));
        }
    }

    public boolean regenerateField(String string2) {
        String string3 = this.getField(string2);
        return this.setField(string2, string3, string3);
    }

    public boolean removeField(String string2) {
        return this.removeField(string2, -1);
    }

    public boolean removeField(String string2, int n2) {
        Item item = this.getFieldItem(string2);
        int n3 = 0;
        if (item == null) {
            return false;
        }
        PdfObject pdfObject = (PdfDictionary)PdfReader.getPdfObject(this.reader.getCatalog().get(PdfName.ACROFORM), this.reader.getCatalog());
        if (pdfObject == null) {
            return false;
        }
        PdfArray pdfArray = pdfObject.getAsArray(PdfName.FIELDS);
        if (pdfArray == null) {
            return false;
        }
        while (n3 < item.size()) {
            int n4 = item.getPage(n3);
            if (n2 != -1 && n2 != n4) {
                n4 = n3;
            } else {
                PdfIndirectReference pdfIndirectReference = item.getWidgetRef(n3);
                PdfDictionary pdfDictionary = item.getWidget(n3);
                PdfDictionary pdfDictionary2 = this.reader.getPageN(n4);
                pdfObject = pdfDictionary2 != null ? pdfDictionary2.getAsArray(PdfName.ANNOTS) : null;
                if (pdfObject != null) {
                    if (this.removeRefFromArray((PdfArray)pdfObject, pdfIndirectReference) == 0) {
                        pdfDictionary2.remove(PdfName.ANNOTS);
                        this.markUsed(pdfDictionary2);
                    } else {
                        this.markUsed(pdfObject);
                    }
                }
                PdfReader.killIndirect(pdfIndirectReference);
                pdfObject = pdfIndirectReference;
                while ((pdfIndirectReference = pdfDictionary.getAsIndirectObject(PdfName.PARENT)) != null && this.removeRefFromArray((pdfDictionary = pdfDictionary.getAsDict(PdfName.PARENT)).getAsArray(PdfName.KIDS), pdfObject) == 0) {
                    PdfReader.killIndirect(pdfIndirectReference);
                    pdfObject = pdfIndirectReference;
                }
                if (pdfIndirectReference == null) {
                    this.removeRefFromArray(pdfArray, pdfObject);
                    this.markUsed(pdfArray);
                }
                n4 = n3;
                if (n2 != -1) {
                    item.remove(n3);
                    n4 = n3 - 1;
                }
            }
            n3 = n4 + 1;
        }
        if (n2 == -1 || item.size() == 0) {
            this.fields.remove(string2);
        }
        return true;
    }

    public boolean removeFieldsFromPage(int n2) {
        if (n2 < 1) {
            return false;
        }
        String[] arrstring = new String[this.fields.size()];
        this.fields.keySet().toArray(arrstring);
        boolean bl2 = false;
        for (int i2 = 0; i2 < arrstring.length; ++i2) {
            boolean bl3 = this.removeField(arrstring[i2], n2);
            if (!bl2 && !bl3) {
                bl2 = false;
                continue;
            }
            bl2 = true;
        }
        return bl2;
    }

    public void removeXfa() {
        this.reader.getCatalog().getAsDict(PdfName.ACROFORM).remove(PdfName.XFA);
        try {
            this.xfa = new XfaForm(this.reader);
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public boolean renameField(String string2, String string3) {
        int n2;
        int n3 = string2.lastIndexOf(46) + 1;
        if (n3 != (n2 = string3.lastIndexOf(46) + 1)) {
            return false;
        }
        if (!string2.substring(0, n3).equals(string3.substring(0, n2))) {
            return false;
        }
        if (this.fields.containsKey(string3)) {
            return false;
        }
        Item item = this.fields.get(string2);
        if (item == null) {
            return false;
        }
        string3 = string3.substring(n2);
        PdfString pdfString = new PdfString(string3, "UnicodeBig");
        item.writeToAll(PdfName.T, pdfString, 5);
        item.markUsed(this, 4);
        this.fields.remove(string2);
        this.fields.put(string3, item);
        return true;
    }

    public boolean replacePushbuttonField(String string2, PdfFormField pdfFormField) {
        return this.replacePushbuttonField(string2, pdfFormField, 0);
    }

    public boolean replacePushbuttonField(String object, PdfFormField pdfFormField, int n2) {
        int n3 = this.getFieldType((String)object);
        int n4 = 0;
        if (n3 != 1) {
            return false;
        }
        Object object2 = this.getFieldItem((String)object);
        if (n2 >= object2.size()) {
            return false;
        }
        object = object2.getMerged(n2);
        PdfDictionary pdfDictionary = object2.getValue(n2);
        object2 = object2.getWidget(n2);
        for (n2 = n4; n2 < buttonRemove.length; ++n2) {
            object.remove(buttonRemove[n2]);
            pdfDictionary.remove(buttonRemove[n2]);
            object2.remove(buttonRemove[n2]);
        }
        for (PdfName pdfName : pdfFormField.getKeys()) {
            if (pdfName.equals(PdfName.T)) continue;
            if (pdfName.equals(PdfName.FF)) {
                pdfDictionary.put(pdfName, pdfFormField.get(pdfName));
            } else {
                object2.put(pdfName, pdfFormField.get(pdfName));
            }
            object.put(pdfName, pdfFormField.get(pdfName));
            this.markUsed(pdfDictionary);
            this.markUsed((PdfObject)object2);
        }
        return true;
    }

    public void setExtraMargin(float f2, float f3) {
        this.extraMarginLeft = f2;
        this.extraMarginTop = f3;
    }

    public boolean setField(String string2, String string3) {
        return this.setField(string2, string3, null);
    }

    public boolean setField(String string2, String string3, String string4) {
        return this.setField(string2, string3, string4, false);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public boolean setField(String object, String object2, String object3, boolean bl2) {
        int n3;
        Object object4;
        Object object6;
        Object object5;
        Serializable serializable;
        int n2;
        block24 : {
            PdfObject pdfObject;
            block25 : {
                block26 : {
                    object5 = this.writer;
                    n3 = 0;
                    if (object5 == null) throw new DocumentException(MessageLocalization.getComposedMessage("this.acrofields.instance.is.read.only", new Object[0]));
                    object5 = object;
                    if (this.xfa.isXfaPresent()) {
                        object5 = this.xfa.findFieldName((String)object, this);
                        if (object5 == null) {
                            return false;
                        }
                        object6 = XfaForm.Xml2Som.getShortName((String)object5);
                        object = object4 = this.xfa.findDatasetsNode((String)object6);
                        if (object4 == null) {
                            object = this.xfa.getDatasetsSom().insertNode(this.xfa.getDatasetsNode(), (String)object6);
                        }
                        this.xfa.setNodeText((Node)object, (String)object2);
                    }
                    if ((object6 = this.fields.get(object5)) == null) {
                        return false;
                    }
                    serializable = object6.getMerged(0);
                    object4 = serializable.getAsName(PdfName.FT);
                    object = object2;
                    if (PdfName.TX.equals(object4)) {
                        object = serializable.getAsNumber(PdfName.MAXLEN);
                        n2 = object != null ? object.intValue() : 0;
                        object = object2;
                        if (n2 > 0) {
                            object = object2.substring(0, Math.min(n2, object2.length()));
                        }
                    }
                    object2 = object3;
                    if (object3 == null) {
                        object2 = object;
                    }
                    if (PdfName.TX.equals(object4) || PdfName.CH.equals(object4)) break block24;
                    if (!PdfName.BTN.equals(object4)) return false;
                    object3 = object6.getMerged(0).getAsNumber(PdfName.FF);
                    n2 = object3 != null ? object3.intValue() : 0;
                    if ((n2 & 65536) != 0) {
                        object = Image.getInstance(Base64.decode((String)object));
                        object2 = this.getNewPushbuttonFromField((String)object5);
                        object2.setImage((Image)object);
                        this.replacePushbuttonField((String)object5, object2.getField());
                        return true;
                    }
                    object4 = new PdfName((String)object);
                    serializable = new ArrayList();
                    pdfObject = object6.getValue(0).getAsArray(PdfName.OPT);
                    if (pdfObject == null) break block25;
                    break block26;
                    catch (Exception exception) {
                        return false;
                    }
                }
                for (n2 = 0; n2 < pdfObject.size(); ++n2) {
                    object3 = pdfObject.getAsString(n2);
                    object3 = object3 != null ? object3.toUnicodeString() : null;
                    serializable.add(object3);
                }
            }
            n2 = serializable.indexOf(object);
            object = object4;
            if (n2 >= 0) {
                object = new PdfName(String.valueOf(n2));
            }
            n2 = 0;
            while (n2 < object6.size()) {
                object3 = object6.getMerged(n2);
                object4 = object6.getWidget(n2);
                serializable = object6.getValue(n2);
                this.markUsed(object6.getValue(n2));
                serializable.put(PdfName.V, (PdfObject)object);
                object3.put(PdfName.V, (PdfObject)object);
                this.markUsed((PdfObject)object4);
                serializable = object4.getAsDict(PdfName.AP);
                if (serializable == null) {
                    return false;
                }
                pdfObject = serializable.getAsDict(PdfName.N);
                if (!this.isInAP((PdfDictionary)pdfObject, (PdfName)object) && pdfObject != null) {
                    object3.put(PdfName.AS, PdfName.Off);
                    object4.put(PdfName.AS, PdfName.Off);
                } else {
                    object3.put(PdfName.AS, (PdfObject)object);
                    object4.put(PdfName.AS, (PdfObject)object);
                }
                if (this.generateAppearances && !bl2) {
                    object4 = this.getAppearance((PdfDictionary)object3, (String)object2, (String)object5);
                    if (pdfObject != null) {
                        pdfObject.put(object3.getAsName(PdfName.AS), object4.getIndirectReference());
                    } else {
                        serializable.put(PdfName.N, object4.getIndirectReference());
                    }
                    this.writer.releaseTemplate((PdfTemplate)object4);
                }
                ++n2;
            }
            return true;
        }
        serializable = new PdfString((String)object, "UnicodeBig");
        n2 = n3;
        while (n2 < object6.size()) {
            object = object6.getValue(n2);
            object.put(PdfName.V, (PdfObject)serializable);
            object.remove(PdfName.I);
            this.markUsed((PdfObject)object);
            PdfDictionary pdfDictionary = object6.getMerged(n2);
            pdfDictionary.remove(PdfName.I);
            pdfDictionary.put(PdfName.V, (PdfObject)serializable);
            PdfDictionary pdfDictionary2 = object6.getWidget(n2);
            if (this.generateAppearances) {
                PdfAppearance pdfAppearance = this.getAppearance(pdfDictionary, (String)object2, (String)object5);
                if (PdfName.CH.equals(object4)) {
                    object = new PdfNumber(this.topFirst);
                    pdfDictionary2.put(PdfName.TI, (PdfObject)object);
                    pdfDictionary.put(PdfName.TI, (PdfObject)object);
                }
                object = object3 = pdfDictionary2.getAsDict(PdfName.AP);
                if (object3 == null) {
                    object = new PdfDictionary();
                    pdfDictionary2.put(PdfName.AP, (PdfObject)object);
                    pdfDictionary.put(PdfName.AP, (PdfObject)object);
                }
                object.put(PdfName.N, pdfAppearance.getIndirectReference());
                this.writer.releaseTemplate(pdfAppearance);
            } else {
                pdfDictionary2.remove(PdfName.AP);
                pdfDictionary.remove(PdfName.AP);
            }
            this.markUsed(pdfDictionary2);
            ++n2;
        }
        return true;
    }

    public boolean setField(String string2, String string3, boolean bl2) {
        return this.setField(string2, string3, null, bl2);
    }

    public void setFieldCache(Map<String, TextField> map) {
        this.fieldCache = map;
    }

    public boolean setFieldProperty(String object, String object2, int n2, int[] object3) {
        block8 : {
            block15 : {
                block10 : {
                    Object object4;
                    int n3;
                    int n4;
                    block14 : {
                        block13 : {
                            block12 : {
                                block11 : {
                                    block9 : {
                                        object4 = this.writer;
                                        n3 = 0;
                                        n4 = 0;
                                        if (object4 == null) break block8;
                                        if ((object = this.fields.get(object)) == null) {
                                            return false;
                                        }
                                        object3 = new InstHit((int[])object3);
                                        if (!object2.equalsIgnoreCase("flags")) break block9;
                                        object2 = new PdfNumber(n2);
                                        for (n2 = n4; n2 < object.size(); ++n2) {
                                            if (!object3.isHit(n2)) continue;
                                            object.getMerged(n2).put(PdfName.F, (PdfObject)object2);
                                            object.getWidget(n2).put(PdfName.F, (PdfObject)object2);
                                            this.markUsed(object.getWidget(n2));
                                        }
                                        break block10;
                                    }
                                    if (!object2.equalsIgnoreCase("setflags")) break block11;
                                    for (n4 = 0; n4 < object.size(); ++n4) {
                                        if (!object3.isHit(n4)) continue;
                                        object2 = object.getWidget(n4).getAsNumber(PdfName.F);
                                        n3 = object2 != null ? object2.intValue() : 0;
                                        object2 = new PdfNumber(n3 | n2);
                                        object.getMerged(n4).put(PdfName.F, (PdfObject)object2);
                                        object.getWidget(n4).put(PdfName.F, (PdfObject)object2);
                                        this.markUsed(object.getWidget(n4));
                                    }
                                    break block10;
                                }
                                if (!object2.equalsIgnoreCase("clrflags")) break block12;
                                for (n4 = 0; n4 < object.size(); ++n4) {
                                    if (!object3.isHit(n4)) continue;
                                    object2 = object.getWidget(n4);
                                    object4 = object2.getAsNumber(PdfName.F);
                                    n3 = object4 != null ? object4.intValue() : 0;
                                    object4 = new PdfNumber(n3 & n2);
                                    object.getMerged(n4).put(PdfName.F, (PdfObject)object4);
                                    object2.put(PdfName.F, (PdfObject)object4);
                                    this.markUsed((PdfObject)object2);
                                }
                                break block10;
                            }
                            if (!object2.equalsIgnoreCase("fflags")) break block13;
                            object2 = new PdfNumber(n2);
                            for (n2 = n3; n2 < object.size(); ++n2) {
                                if (!object3.isHit(n2)) continue;
                                object.getMerged(n2).put(PdfName.FF, (PdfObject)object2);
                                object.getValue(n2).put(PdfName.FF, (PdfObject)object2);
                                this.markUsed(object.getValue(n2));
                            }
                            break block10;
                        }
                        if (!object2.equalsIgnoreCase("setfflags")) break block14;
                        for (n4 = 0; n4 < object.size(); ++n4) {
                            if (!object3.isHit(n4)) continue;
                            object2 = object.getValue(n4);
                            object4 = object2.getAsNumber(PdfName.FF);
                            n3 = object4 != null ? object4.intValue() : 0;
                            object4 = new PdfNumber(n3 | n2);
                            object.getMerged(n4).put(PdfName.FF, (PdfObject)object4);
                            object2.put(PdfName.FF, (PdfObject)object4);
                            this.markUsed((PdfObject)object2);
                        }
                        break block10;
                    }
                    if (object2.equalsIgnoreCase("clrfflags")) {
                        for (n4 = 0; n4 < object.size(); ++n4) {
                            if (!object3.isHit(n4)) continue;
                            object2 = object.getValue(n4);
                            object4 = object2.getAsNumber(PdfName.FF);
                            n3 = object4 != null ? object4.intValue() : 0;
                            object4 = new PdfNumber(n3 & n2);
                            object.getMerged(n4).put(PdfName.FF, (PdfObject)object4);
                            object2.put(PdfName.FF, (PdfObject)object4);
                            this.markUsed((PdfObject)object2);
                        }
                    }
                    break block15;
                }
                return true;
            }
            return false;
        }
        throw new RuntimeException(MessageLocalization.getComposedMessage("this.acrofields.instance.is.read.only", new Object[0]));
    }

    /*
     * Exception decompiling
     */
    public boolean setFieldProperty(String var1_1, String var2_3, Object var3_4, int[] var4_5) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [0[TRYBLOCK]], but top level block is 7[WHILELOOP]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public boolean setFieldRichValue(String object, String string2) {
        if (this.writer != null) {
            Item item = this.getFieldItem((String)object);
            if (item == null) {
                return false;
            }
            if (this.getFieldType((String)object) != 4) {
                return false;
            }
            object = item.getMerged(0).getAsNumber(PdfName.FF);
            int n2 = object != null ? object.intValue() : 0;
            if ((n2 & 33554432) == 0) {
                return false;
            }
            object = new PdfString(string2);
            item.writeToAll(PdfName.RV, (PdfObject)object, 5);
            object = new PdfString(XmlToTxt.parse(new ByteArrayInputStream(string2.getBytes())));
            item.writeToAll(PdfName.V, (PdfObject)object, 5);
            return true;
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("this.acrofields.instance.is.read.only", new Object[0]));
    }

    public void setFields(FdfReader fdfReader) {
        for (String string2 : fdfReader.getFields().keySet()) {
            String string3 = fdfReader.getFieldValue(string2);
            if (string3 == null) continue;
            this.setField(string2, string3);
        }
    }

    public void setFields(XfdfReader xfdfReader) {
        for (String string2 : xfdfReader.getFields().keySet()) {
            List<String> object;
            String string22 = xfdfReader.getFieldValue(string2);
            if (string22 != null) {
                this.setField(string2, string22);
            }
            if ((object = xfdfReader.getListValues(string2)) == null) continue;
            this.setListSelection(string22, object.toArray(new String[object.size()]));
        }
    }

    public void setGenerateAppearances(boolean bl2) {
        this.generateAppearances = bl2;
        PdfDictionary pdfDictionary = this.reader.getCatalog().getAsDict(PdfName.ACROFORM);
        if (bl2) {
            pdfDictionary.remove(PdfName.NEEDAPPEARANCES);
            return;
        }
        pdfDictionary.put(PdfName.NEEDAPPEARANCES, PdfBoolean.PDFTRUE);
    }

    public boolean setListOption(String object, String[] arrstring, String[] arrstring2) {
        int n2 = 0;
        int n3 = 0;
        if (arrstring == null && arrstring2 == null) {
            return false;
        }
        if (arrstring != null && arrstring2 != null && arrstring.length != arrstring2.length) {
            throw new IllegalArgumentException(MessageLocalization.getComposedMessage("the.export.and.the.display.array.must.have.the.same.size", new Object[0]));
        }
        int n4 = this.getFieldType((String)object);
        if (n4 != 6 && n4 != 5) {
            return false;
        }
        Item item = this.fields.get(object);
        PdfArray pdfArray = null;
        if (arrstring == null && arrstring2 != null) {
            object = arrstring2;
        } else {
            object = pdfArray;
            if (arrstring != null) {
                object = pdfArray;
                if (arrstring2 == null) {
                    object = arrstring;
                }
            }
        }
        pdfArray = new PdfArray();
        if (object != null) {
            for (n2 = n3; n2 < ((String[])object).length; ++n2) {
                pdfArray.add(new PdfString(object[n2], "UnicodeBig"));
            }
        } else {
            while (n2 < arrstring.length) {
                object = new PdfArray();
                object.add(new PdfString(arrstring[n2], "UnicodeBig"));
                object.add(new PdfString(arrstring2[n2], "UnicodeBig"));
                pdfArray.add((PdfObject)object);
                ++n2;
            }
        }
        item.writeToAll(PdfName.OPT, pdfArray, 5);
        return true;
    }

    public boolean setListSelection(String object, String[] object2) {
        int n2;
        Item item = this.getFieldItem((String)object);
        int n3 = 0;
        if (item == null) {
            return false;
        }
        PdfDictionary pdfDictionary = item.getMerged(0);
        Object object3 = pdfDictionary.getAsName(PdfName.FT);
        if (!PdfName.CH.equals(object3)) {
            return false;
        }
        object3 = this.getListOptionExport((String)object);
        PdfArray pdfArray = new PdfArray();
        int n4 = ((String[])object2).length;
        block0 : for (n2 = 0; n2 < n4; ++n2) {
            String string2 = object2[n2];
            for (int i2 = 0; i2 < ((String[])object3).length; ++i2) {
                if (!object3[i2].equals(string2)) continue;
                pdfArray.add(new PdfNumber(i2));
                continue block0;
            }
        }
        item.writeToAll(PdfName.I, pdfArray, 5);
        object3 = new PdfArray();
        for (n2 = n3; n2 < ((String[])object2).length; ++n2) {
            object3.add(new PdfString(object2[n2]));
        }
        item.writeToAll(PdfName.V, (PdfObject)object3, 5);
        object = this.getAppearance(pdfDictionary, (String[])object2, (String)object);
        object2 = new PdfDictionary();
        object2.put(PdfName.N, object.getIndirectReference());
        item.writeToAll(PdfName.AP, (PdfObject)object2, 3);
        this.writer.releaseTemplate((PdfTemplate)object);
        item.markUsed(this, 6);
        return true;
    }

    public void setSubstitutionFonts(ArrayList<BaseFont> arrayList) {
        this.substitutionFonts = arrayList;
    }

    public boolean signatureCoversWholeDocument(String string2) {
        this.getSignatureNames();
        string2 = this.getTranslatedFieldName(string2);
        boolean bl2 = this.sigNames.containsKey(string2);
        boolean bl3 = false;
        if (!bl2) {
            return false;
        }
        if ((long)this.sigNames.get(string2)[0] == this.reader.getFileLength()) {
            bl3 = true;
        }
        return bl3;
    }

    public PdfPKCS7 verifySignature(String string2) {
        return this.verifySignature(string2, null);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public PdfPKCS7 verifySignature(String object, String object2) {
        PdfDictionary pdfDictionary = this.getSignatureDictionary((String)object);
        if (pdfDictionary == null) {
            return null;
        }
        try {
            block12 : {
                block14 : {
                    block13 : {
                        object = pdfDictionary.getAsName(PdfName.SUBFILTER);
                        PdfString pdfString = pdfDictionary.getAsString(PdfName.CONTENTS);
                        if (object.equals(PdfName.ADBE_X509_RSA_SHA1)) {
                            PdfString pdfString2 = pdfDictionary.getAsString(PdfName.CERT);
                            object = pdfString2;
                            if (pdfString2 == null) {
                                object = pdfDictionary.getAsArray(PdfName.CERT).getAsString(0);
                            }
                            object = new PdfPKCS7(pdfString.getOriginalBytes(), object.getBytes(), (String)object2);
                        } else {
                            object = new PdfPKCS7(pdfString.getOriginalBytes(), (PdfName)object, (String)object2);
                        }
                        this.updateByteRange((PdfPKCS7)object, pdfDictionary);
                        object2 = pdfDictionary.getAsString(PdfName.M);
                        if (object2 != null) {
                            object.setSignDate(PdfDate.decode(object2.toString()));
                        }
                        if ((object2 = PdfReader.getPdfObject(pdfDictionary.get(PdfName.NAME))) == null) break block12;
                        if (!object2.isString()) break block13;
                        object2 = ((PdfString)object2).toUnicodeString();
                        break block14;
                    }
                    if (!object2.isName()) break block12;
                    object2 = PdfName.decodeName(object2.toString());
                }
                object.setSignName((String)object2);
            }
            if ((object2 = pdfDictionary.getAsString(PdfName.REASON)) != null) {
                object.setReason(object2.toUnicodeString());
            }
            if ((object2 = pdfDictionary.getAsString(PdfName.LOCATION)) != null) {
                object.setLocation(object2.toUnicodeString());
            }
            return object;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public static class FieldPosition {
        public int page;
        public Rectangle position;
    }

    private static class InstHit {
        IntHashtable hits;

        public InstHit(int[] arrn) {
            if (arrn == null) {
                return;
            }
            this.hits = new IntHashtable();
            for (int i2 = 0; i2 < arrn.length; ++i2) {
                this.hits.put(arrn[i2], 1);
            }
        }

        public boolean isHit(int n2) {
            if (this.hits == null) {
                return true;
            }
            return this.hits.containsKey(n2);
        }
    }

    public static class Item {
        public static final int WRITE_MERGED = 1;
        public static final int WRITE_VALUE = 4;
        public static final int WRITE_WIDGET = 2;
        protected ArrayList<PdfDictionary> merged = new ArrayList();
        protected ArrayList<Integer> page = new ArrayList();
        protected ArrayList<Integer> tabOrder = new ArrayList();
        protected ArrayList<PdfDictionary> values = new ArrayList();
        protected ArrayList<PdfIndirectReference> widget_refs = new ArrayList();
        protected ArrayList<PdfDictionary> widgets = new ArrayList();

        void addMerged(PdfDictionary pdfDictionary) {
            this.merged.add(pdfDictionary);
        }

        void addPage(int n2) {
            this.page.add(n2);
        }

        void addTabOrder(int n2) {
            this.tabOrder.add(n2);
        }

        void addValue(PdfDictionary pdfDictionary) {
            this.values.add(pdfDictionary);
        }

        void addWidget(PdfDictionary pdfDictionary) {
            this.widgets.add(pdfDictionary);
        }

        void addWidgetRef(PdfIndirectReference pdfIndirectReference) {
            this.widget_refs.add(pdfIndirectReference);
        }

        void forcePage(int n2, int n3) {
            this.page.set(n2, n3);
        }

        public PdfDictionary getMerged(int n2) {
            return this.merged.get(n2);
        }

        public Integer getPage(int n2) {
            return this.page.get(n2);
        }

        public Integer getTabOrder(int n2) {
            return this.tabOrder.get(n2);
        }

        public PdfDictionary getValue(int n2) {
            return this.values.get(n2);
        }

        public PdfDictionary getWidget(int n2) {
            return this.widgets.get(n2);
        }

        public PdfIndirectReference getWidgetRef(int n2) {
            return this.widget_refs.get(n2);
        }

        public void markUsed(AcroFields acroFields, int n2) {
            int n3 = 0;
            if ((n2 & 4) != 0) {
                for (int i2 = 0; i2 < this.size(); ++i2) {
                    acroFields.markUsed(this.getValue(i2));
                }
            }
            if ((n2 & 2) != 0) {
                for (n2 = n3; n2 < this.size(); ++n2) {
                    acroFields.markUsed(this.getWidget(n2));
                }
            }
        }

        void remove(int n2) {
            this.values.remove(n2);
            this.widgets.remove(n2);
            this.widget_refs.remove(n2);
            this.merged.remove(n2);
            this.page.remove(n2);
            this.tabOrder.remove(n2);
        }

        public int size() {
            return this.values.size();
        }

        public void writeToAll(PdfName pdfName, PdfObject pdfObject, int n2) {
            int n3;
            int n4 = 0;
            if ((n2 & 1) != 0) {
                for (n3 = 0; n3 < this.merged.size(); ++n3) {
                    this.getMerged(n3).put(pdfName, pdfObject);
                }
            }
            if ((n2 & 2) != 0) {
                for (n3 = 0; n3 < this.widgets.size(); ++n3) {
                    this.getWidget(n3).put(pdfName, pdfObject);
                }
            }
            if ((n2 & 4) != 0) {
                for (n2 = n4; n2 < this.values.size(); ++n2) {
                    this.getValue(n2).put(pdfName, pdfObject);
                }
            }
        }
    }

    private static class SorterComparator
    implements Comparator<Object[]> {
        private SorterComparator() {
        }

        @Override
        public int compare(Object[] arrobject, Object[] arrobject2) {
            return ((int[])arrobject[1])[0] - ((int[])arrobject2[1])[0];
        }
    }

}

