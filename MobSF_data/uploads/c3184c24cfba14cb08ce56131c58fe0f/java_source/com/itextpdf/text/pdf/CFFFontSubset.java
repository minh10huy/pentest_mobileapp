/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.pdf.CFFFont;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Set;

public class CFFFontSubset
extends CFFFont {
    static final byte ENDCHAR_OP = 14;
    static final byte RETURN_OP = 11;
    static final String[] SubrsEscapeFuncs;
    static final String[] SubrsFunctions;
    HashSet<Integer> FDArrayUsed = new HashSet();
    int GBias = 0;
    HashMap<Integer, int[]> GlyphsUsed;
    byte[] NewCharStringsIndex;
    byte[] NewGSubrsIndex;
    byte[][] NewLSubrsIndex;
    byte[] NewSubrsIndexNonCID;
    int NumOfHints = 0;
    LinkedList<CFFFont.Item> OutputList;
    ArrayList<Integer> glyphsInList;
    HashMap<Integer, int[]> hGSubrsUsed = new HashMap();
    HashMap<Integer, int[]>[] hSubrsUsed;
    HashMap<Integer, int[]> hSubrsUsedNonCID = new HashMap();
    ArrayList<Integer> lGSubrsUsed = new ArrayList();
    ArrayList<Integer>[] lSubrsUsed;
    ArrayList<Integer> lSubrsUsedNonCID = new ArrayList();

    static {
        SubrsFunctions = new String[]{"RESERVED_0", "hstem", "RESERVED_2", "vstem", "vmoveto", "rlineto", "hlineto", "vlineto", "rrcurveto", "RESERVED_9", "callsubr", "return", "escape", "RESERVED_13", "endchar", "RESERVED_15", "RESERVED_16", "RESERVED_17", "hstemhm", "hintmask", "cntrmask", "rmoveto", "hmoveto", "vstemhm", "rcurveline", "rlinecurve", "vvcurveto", "hhcurveto", "shortint", "callgsubr", "vhcurveto", "hvcurveto"};
        SubrsEscapeFuncs = new String[]{"RESERVED_0", "RESERVED_1", "RESERVED_2", "and", "or", "not", "RESERVED_6", "RESERVED_7", "RESERVED_8", "abs", "add", "sub", "div", "RESERVED_13", "neg", "eq", "RESERVED_16", "RESERVED_17", "drop", "RESERVED_19", "put", "get", "ifelse", "random", "mul", "RESERVED_25", "sqrt", "dup", "exch", "index", "roll", "RESERVED_31", "RESERVED_32", "RESERVED_33", "hflex", "flex", "hflex1", "flex1", "RESERVED_REST"};
    }

    public CFFFontSubset(RandomAccessFileOrArray randomAccessFileOrArray, HashMap<Integer, int[]> hashMap) {
        super(randomAccessFileOrArray);
        this.GlyphsUsed = hashMap;
        this.glyphsInList = new ArrayList<Integer>(hashMap.keySet());
        for (int i2 = 0; i2 < this.fonts.length; ++i2) {
            this.seek(this.fonts[i2].charstringsOffset);
            this.fonts[i2].nglyphs = this.getCard16();
            this.seek(this.stringIndexOffset);
            this.fonts[i2].nstrings = this.getCard16() + standardStrings.length;
            this.fonts[i2].charstringsOffsets = this.getIndex(this.fonts[i2].charstringsOffset);
            if (this.fonts[i2].fdselectOffset >= 0) {
                this.readFDSelect(i2);
                this.BuildFDArrayUsed(i2);
            }
            if (this.fonts[i2].isCID) {
                this.ReadFDArray(i2);
            }
            this.fonts[i2].CharsetLength = this.CountCharset(this.fonts[i2].charsetOffset, this.fonts[i2].nglyphs);
        }
    }

    protected byte[] AssembleIndex(int[] arrn, byte[] arrby) {
        int n2 = arrn.length - 1;
        int n3 = arrn[arrn.length - 1];
        int n4 = 3;
        int n5 = n3 <= 255 ? 1 : (n3 <= 65535 ? 2 : (n3 <= 16777215 ? 3 : 4));
        byte[] arrby2 = new byte[(n2 + '\u0001') * n5 + 3 + arrby.length];
        byte by2 = (byte)(n2 >>> 8 & 255);
        int n6 = 0;
        arrby2[0] = by2;
        arrby2[1] = (byte)(n2 >>> 0 & 255);
        arrby2[2] = n5;
        int n7 = arrn.length;
        block6 : for (n2 = 0; n2 < n7; ++n2) {
            int n8 = arrn[n2] - arrn[0] + 1;
            n3 = n4;
            int n9 = n4;
            int n10 = n4;
            switch (n5) {
                default: {
                    continue block6;
                }
                case 4: {
                    arrby2[n4] = (byte)(n8 >>> 24 & 255);
                    n3 = n4 + 1;
                }
                case 3: {
                    arrby2[n3] = (byte)(n8 >>> 16 & 255);
                    n9 = n3 + 1;
                }
                case 2: {
                    arrby2[n9] = (byte)(n8 >>> 8 & 255);
                    n10 = n9 + 1;
                }
                case 1: {
                    arrby2[n10] = (byte)(n8 >>> 0 & 255);
                    n4 = n10 + 1;
                }
            }
        }
        n3 = arrby.length;
        n2 = n6;
        while (n2 < n3) {
            arrby2[n4] = arrby[n2];
            ++n2;
            ++n4;
        }
        return arrby2;
    }

    protected void BuildFDArrayUsed(int n2) {
        int[] arrn = this.fonts[n2].FDSelect;
        for (n2 = 0; n2 < this.glyphsInList.size(); ++n2) {
            int n3 = arrn[this.glyphsInList.get(n2)];
            this.FDArrayUsed.add(n3);
        }
    }

    protected void BuildFDSubrsOffsets(int n2, int n3) {
        this.fonts[n2].PrivateSubrsOffset[n3] = -1;
        this.seek(this.fonts[n2].fdprivateOffsets[n3]);
        while (this.getPosition() < this.fonts[n2].fdprivateOffsets[n3] + this.fonts[n2].fdprivateLengths[n3]) {
            this.getDictItem();
            if (this.key != "Subrs") continue;
            this.fonts[n2].PrivateSubrsOffset[n3] = (Integer)this.args[0] + this.fonts[n2].fdprivateOffsets[n3];
        }
        if (this.fonts[n2].PrivateSubrsOffset[n3] >= 0) {
            this.fonts[n2].PrivateSubrsOffsetsArray[n3] = this.getIndex(this.fonts[n2].PrivateSubrsOffset[n3]);
        }
    }

    protected void BuildGSubrsUsed(int n2) {
        int n3;
        int n4 = this.fonts[n2].privateSubrs;
        int n5 = 0;
        if (n4 >= 0) {
            n3 = this.CalcBias(this.fonts[n2].privateSubrs, n2);
            n4 = this.lSubrsUsedNonCID.size();
        } else {
            n3 = 0;
            n4 = 0;
        }
        while (n5 < this.lGSubrsUsed.size()) {
            int n6 = this.lGSubrsUsed.get(n5);
            int n7 = n4;
            if (n6 < this.gsubrOffsets.length - 1) {
                n7 = n4;
                if (n6 >= 0) {
                    n7 = this.gsubrOffsets[n6];
                    n6 = this.gsubrOffsets[n6 + 1];
                    if (this.fonts[n2].isCID) {
                        this.ReadASubr(n7, n6, this.GBias, 0, this.hGSubrsUsed, this.lGSubrsUsed, null);
                        n7 = n4;
                    } else {
                        this.ReadASubr(n7, n6, this.GBias, n3, this.hSubrsUsedNonCID, this.lSubrsUsedNonCID, this.fonts[n2].SubrsOffsets);
                        n7 = n4;
                        if (n4 < this.lSubrsUsedNonCID.size()) {
                            while (n4 < this.lSubrsUsedNonCID.size()) {
                                n7 = this.lSubrsUsedNonCID.get(n4);
                                if (n7 < this.fonts[n2].SubrsOffsets.length - 1 && n7 >= 0) {
                                    this.ReadASubr(this.fonts[n2].SubrsOffsets[n7], this.fonts[n2].SubrsOffsets[n7 + 1], this.GBias, n3, this.hSubrsUsedNonCID, this.lSubrsUsedNonCID, this.fonts[n2].SubrsOffsets);
                                }
                                ++n4;
                            }
                            n7 = this.lSubrsUsedNonCID.size();
                        }
                    }
                }
            }
            ++n5;
            n4 = n7;
        }
    }

    protected void BuildIndexHeader(int n2, int n3, int n4) {
        CFFFont.Item item;
        LinkedList<CFFFont.Item> linkedList;
        this.OutputList.addLast(new CFFFont.UInt16Item((char)n2));
        this.OutputList.addLast(new CFFFont.UInt8Item((char)n3));
        switch (n3) {
            default: {
                return;
            }
            case 4: {
                linkedList = this.OutputList;
                item = new CFFFont.UInt32Item((char)n4);
                break;
            }
            case 3: {
                linkedList = this.OutputList;
                item = new CFFFont.UInt24Item((char)n4);
                break;
            }
            case 2: {
                linkedList = this.OutputList;
                item = new CFFFont.UInt16Item((char)n4);
                break;
            }
            case 1: {
                linkedList = this.OutputList;
                item = new CFFFont.UInt8Item((char)n4);
            }
        }
        linkedList.addLast(item);
    }

    protected void BuildNewCharString(int n2) {
        this.NewCharStringsIndex = this.BuildNewIndex(this.fonts[n2].charstringsOffsets, this.GlyphsUsed, (byte)14);
    }

    protected byte[] BuildNewFile(int n2) {
        int[] arrn;
        Iterator<CFFFont.Item> iterator;
        CFFFont.Item item;
        block12 : {
            CFFFont.DictOffsetItem dictOffsetItem;
            block11 : {
                CFFFont.DictOffsetItem dictOffsetItem2;
                CFFFont.DictOffsetItem dictOffsetItem3;
                block10 : {
                    this.OutputList = new LinkedList();
                    this.CopyHeader();
                    this.BuildIndexHeader(1, 1, 1);
                    this.OutputList.addLast(new CFFFont.UInt8Item((char)(this.fonts[n2].name.length() + 1)));
                    this.OutputList.addLast(new CFFFont.StringItem(this.fonts[n2].name));
                    this.BuildIndexHeader(1, 2, 1);
                    item = new CFFFont.IndexOffsetItem(2);
                    this.OutputList.addLast(item);
                    CFFFont.IndexBaseItem indexBaseItem = new CFFFont.IndexBaseItem();
                    this.OutputList.addLast(indexBaseItem);
                    dictOffsetItem2 = new CFFFont.DictOffsetItem();
                    arrn = new int[]();
                    dictOffsetItem = new CFFFont.DictOffsetItem();
                    dictOffsetItem3 = new CFFFont.DictOffsetItem();
                    iterator = new CFFFont.DictOffsetItem();
                    if (!this.fonts[n2].isCID) {
                        this.OutputList.addLast(new CFFFont.DictNumberItem(this.fonts[n2].nstrings));
                        this.OutputList.addLast(new CFFFont.DictNumberItem(this.fonts[n2].nstrings + 1));
                        this.OutputList.addLast(new CFFFont.DictNumberItem(0));
                        this.OutputList.addLast(new CFFFont.UInt8Item('\f'));
                        this.OutputList.addLast(new CFFFont.UInt8Item('\u001e'));
                        this.OutputList.addLast(new CFFFont.DictNumberItem(this.fonts[n2].nglyphs));
                        this.OutputList.addLast(new CFFFont.UInt8Item('\f'));
                        this.OutputList.addLast(new CFFFont.UInt8Item('\"'));
                    }
                    this.seek(this.topdictOffsets[n2]);
                    while (this.getPosition() < this.topdictOffsets[n2 + 1]) {
                        int n3 = this.getPosition();
                        this.getDictItem();
                        int n4 = this.getPosition();
                        if (this.key == "Encoding" || this.key == "Private" || this.key == "FDSelect" || this.key == "FDArray" || this.key == "charset" || this.key == "CharStrings") continue;
                        this.OutputList.add(new CFFFont.RangeItem(this.buf, n3, n4 - n3));
                    }
                    this.CreateKeys(dictOffsetItem, dictOffsetItem3, dictOffsetItem2, (CFFFont.OffsetItem)arrn);
                    this.OutputList.addLast(new CFFFont.IndexMarkerItem((CFFFont.OffsetItem)item, indexBaseItem));
                    if (this.fonts[n2].isCID) {
                        this.OutputList.addLast(this.getEntireIndexRange(this.stringIndexOffset));
                    } else {
                        this.CreateNewStringIndex(n2);
                    }
                    this.OutputList.addLast(new CFFFont.RangeItem(new RandomAccessFileOrArray(this.NewGSubrsIndex), 0, this.NewGSubrsIndex.length));
                    if (!this.fonts[n2].isCID) break block10;
                    this.OutputList.addLast(new CFFFont.MarkerItem(dictOffsetItem3));
                    if (this.fonts[n2].fdselectOffset >= 0) {
                        this.OutputList.addLast(new CFFFont.RangeItem(this.buf, this.fonts[n2].fdselectOffset, this.fonts[n2].FDSelectLength));
                    } else {
                        this.CreateFDSelect(dictOffsetItem3, this.fonts[n2].nglyphs);
                    }
                    this.OutputList.addLast(new CFFFont.MarkerItem(dictOffsetItem2));
                    this.OutputList.addLast(new CFFFont.RangeItem(this.buf, this.fonts[n2].charsetOffset, this.fonts[n2].CharsetLength));
                    if (this.fonts[n2].fdarrayOffset < 0) break block11;
                    this.OutputList.addLast(new CFFFont.MarkerItem(dictOffsetItem));
                    this.Reconstruct(n2);
                    break block12;
                }
                this.CreateFDSelect(dictOffsetItem3, this.fonts[n2].nglyphs);
                this.CreateCharset(dictOffsetItem2, this.fonts[n2].nglyphs);
            }
            this.CreateFDArray(dictOffsetItem, (CFFFont.OffsetItem)((Object)iterator), n2);
        }
        if (this.fonts[n2].privateOffset >= 0) {
            item = new CFFFont.IndexBaseItem();
            this.OutputList.addLast(item);
            this.OutputList.addLast(new CFFFont.MarkerItem((CFFFont.OffsetItem)((Object)iterator)));
            iterator = new CFFFont.DictOffsetItem();
            this.CreateNonCIDPrivate(n2, (CFFFont.OffsetItem)((Object)iterator));
            this.CreateNonCIDSubrs(n2, (CFFFont.IndexBaseItem)item, (CFFFont.OffsetItem)((Object)iterator));
        }
        this.OutputList.addLast(new CFFFont.MarkerItem((CFFFont.OffsetItem)arrn));
        this.OutputList.addLast(new CFFFont.RangeItem(new RandomAccessFileOrArray(this.NewCharStringsIndex), 0, this.NewCharStringsIndex.length));
        arrn = new int[]{0};
        iterator = this.OutputList.iterator();
        while (iterator.hasNext()) {
            ((CFFFont.Item)iterator.next()).increment(arrn);
        }
        iterator = this.OutputList.iterator();
        while (iterator.hasNext()) {
            iterator.next().xref();
        }
        arrn = new byte[arrn[0]];
        iterator = this.OutputList.iterator();
        while (iterator.hasNext()) {
            iterator.next().emit((byte[])arrn);
        }
        return arrn;
    }

    protected byte[] BuildNewIndex(int[] arrn, HashMap<Integer, int[]> arrby, byte by2) {
        int n2;
        int[] arrn2 = new int[arrn.length];
        int n3 = 0;
        int n4 = 0;
        int n5 = 0;
        for (n2 = 0; n2 < arrn.length; ++n2) {
            arrn2[n2] = n4;
            if (arrby.containsKey(n2)) {
                n4 += arrn[n2 + 1] - arrn[n2];
                continue;
            }
            ++n5;
        }
        arrby = new byte[n4 + n5];
        n2 = 0;
        n5 = n3;
        while (n5 < arrn.length - 1) {
            int n6;
            n3 = arrn2[n5];
            n4 = n5 + 1;
            int n7 = arrn2[n4];
            arrn2[n5] = n6 = n3 + n2;
            if (n3 != n7) {
                this.buf.seek(arrn[n5]);
                this.buf.readFully(arrby, n6, n7 - n3);
            } else {
                arrby[n6] = by2;
                ++n2;
            }
            n5 = n4;
        }
        n5 = arrn.length - 1;
        arrn2[n5] = arrn2[n5] + n2;
        return this.AssembleIndex(arrn2, arrby);
    }

    protected void BuildNewLGSubrs(int n2) {
        if (this.fonts[n2].isCID) {
            this.hSubrsUsed = new HashMap[this.fonts[n2].fdprivateOffsets.length];
            this.lSubrsUsed = new ArrayList[this.fonts[n2].fdprivateOffsets.length];
            this.NewLSubrsIndex = new byte[this.fonts[n2].fdprivateOffsets.length][];
            this.fonts[n2].PrivateSubrsOffset = new int[this.fonts[n2].fdprivateOffsets.length];
            this.fonts[n2].PrivateSubrsOffsetsArray = new int[this.fonts[n2].fdprivateOffsets.length][];
            ArrayList<Integer> arrayList = new ArrayList<Integer>(this.FDArrayUsed);
            for (int i2 = 0; i2 < arrayList.size(); ++i2) {
                int n3 = arrayList.get(i2);
                this.hSubrsUsed[n3] = new HashMap();
                this.lSubrsUsed[n3] = new ArrayList();
                this.BuildFDSubrsOffsets(n2, n3);
                if (this.fonts[n2].PrivateSubrsOffset[n3] < 0) continue;
                this.BuildSubrUsed(n2, n3, this.fonts[n2].PrivateSubrsOffset[n3], this.fonts[n2].PrivateSubrsOffsetsArray[n3], this.hSubrsUsed[n3], this.lSubrsUsed[n3]);
                this.NewLSubrsIndex[n3] = this.BuildNewIndex(this.fonts[n2].PrivateSubrsOffsetsArray[n3], this.hSubrsUsed[n3], (byte)11);
            }
        } else if (this.fonts[n2].privateSubrs >= 0) {
            this.fonts[n2].SubrsOffsets = this.getIndex(this.fonts[n2].privateSubrs);
            this.BuildSubrUsed(n2, -1, this.fonts[n2].privateSubrs, this.fonts[n2].SubrsOffsets, this.hSubrsUsedNonCID, this.lSubrsUsedNonCID);
        }
        this.BuildGSubrsUsed(n2);
        if (this.fonts[n2].privateSubrs >= 0) {
            this.NewSubrsIndexNonCID = this.BuildNewIndex(this.fonts[n2].SubrsOffsets, this.hSubrsUsedNonCID, (byte)11);
        }
        this.NewGSubrsIndex = this.BuildNewIndex(this.gsubrOffsets, this.hGSubrsUsed, (byte)11);
    }

    protected void BuildSubrUsed(int n2, int n3, int n4, int[] arrn, HashMap<Integer, int[]> hashMap, ArrayList<Integer> arrayList) {
        int n5;
        int n6 = this.CalcBias(n4, n2);
        int n7 = 0;
        n4 = 0;
        do {
            block5 : {
                int n8;
                int n9;
                block4 : {
                    if (n4 >= this.glyphsInList.size()) break;
                    n5 = this.glyphsInList.get(n4);
                    n8 = this.fonts[n2].charstringsOffsets[n5];
                    n9 = this.fonts[n2].charstringsOffsets[n5 + 1];
                    if (n3 < 0) break block4;
                    this.EmptyStack();
                    this.NumOfHints = 0;
                    if (this.fonts[n2].FDSelect[n5] != n3) break block5;
                }
                this.ReadASubr(n8, n9, this.GBias, n6, hashMap, arrayList, arrn);
            }
            ++n4;
        } while (true);
        for (n5 = n7; n5 < arrayList.size(); ++n5) {
            n2 = arrayList.get(n5);
            if (n2 >= arrn.length - 1 || n2 < 0) continue;
            this.ReadASubr(arrn[n2], arrn[n2 + 1], this.GBias, n6, hashMap, arrayList, arrn);
        }
    }

    protected int CalcBias(int n2, int n3) {
        this.seek(n2);
        n2 = this.getCard16();
        if (this.fonts[n3].CharstringType == 1) {
            return 0;
        }
        if (n2 < 1240) {
            return 107;
        }
        if (n2 < 33900) {
            return 1131;
        }
        return 32768;
    }

    /*
     * Enabled aggressive block sorting
     */
    protected int CalcHints(int n2, int n3, int n4, int n5, int[] arrn) {
        block0 : do {
            this.seek(n2);
            block1 : do {
                int n6;
                block10 : {
                    block12 : {
                        block11 : {
                            if (this.getPosition() >= n3) {
                                return this.NumOfHints;
                            }
                            this.ReadCommand();
                            n2 = this.getPosition();
                            Object object = null;
                            if (this.arg_count > 0) {
                                object = this.args[this.arg_count - 1];
                            }
                            n6 = this.arg_count;
                            this.HandelStack();
                            if (this.key == "callsubr") {
                                if (n6 <= 0) continue;
                                n6 = (Integer)object + n4;
                                this.CalcHints(arrn[n6], arrn[n6 + 1], n4, n5, arrn);
                                continue block0;
                            }
                            if (this.key == "callgsubr") {
                                if (n6 <= 0) continue;
                                n6 = (Integer)object + n5;
                                this.CalcHints(this.gsubrOffsets[n6], this.gsubrOffsets[n6 + 1], n4, n5, arrn);
                                continue block0;
                            }
                            if (this.key == "hstem" || this.key == "vstem" || this.key == "hstemhm" || this.key == "vstemhm") break block10;
                            if (this.key != "hintmask" && this.key != "cntrmask") continue;
                            n6 = this.NumOfHints / 8;
                            if (this.NumOfHints % 8 != 0) break block11;
                            n2 = n6;
                            if (n6 != 0) break block12;
                        }
                        n2 = n6 + 1;
                    }
                    n6 = 0;
                    do {
                        if (n6 >= n2) continue block1;
                        this.getCard8();
                        ++n6;
                    } while (true);
                }
                this.NumOfHints += n6 / 2;
            } while (true);
            break;
        } while (true);
    }

    int CalcSubrOffsetSize(int n2, int n3) {
        this.seek(n2);
        int n4 = 0;
        while (this.getPosition() < n2 + n3) {
            int n5 = this.getPosition();
            this.getDictItem();
            int n6 = this.getPosition();
            if (this.key != "Subrs") continue;
            n4 = n6 - n5 - 1;
        }
        return n4;
    }

    protected void CopyHeader() {
        this.seek(0);
        this.getCard8();
        this.getCard8();
        char c2 = this.getCard8();
        this.getCard8();
        this.nextIndexOffset = c2;
        this.OutputList.addLast(new CFFFont.RangeItem(this.buf, 0, c2));
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    int CountCharset(int n2, int n3) {
        this.seek(n2);
        switch (this.getCard8()) {
            default: {
                return 0;
            }
            case '\u0002': {
                n2 = this.CountRange(n3, 2) * 4;
                return n2 + 1;
            }
            case '\u0001': {
                n2 = this.CountRange(n3, 1) * 3;
                return n2 + 1;
            }
            case '\u0000': 
        }
        return n3 * 2 + 1;
    }

    int CountRange(int n2, int n3) {
        int n4 = 0;
        for (int i2 = 1; i2 < n2; i2 += n4 + 1) {
            int n5 = n4 + 1;
            this.getCard16();
            n4 = n3 == 1 ? (int)this.getCard8() : (int)this.getCard16();
            n4 = n5;
        }
        return n4;
    }

    protected void CreateCharset(CFFFont.OffsetItem offsetItem, int n2) {
        this.OutputList.addLast(new CFFFont.MarkerItem(offsetItem));
        this.OutputList.addLast(new CFFFont.UInt8Item('\u0002'));
        this.OutputList.addLast(new CFFFont.UInt16Item('\u0001'));
        this.OutputList.addLast(new CFFFont.UInt16Item((char)(n2 - 1)));
    }

    protected void CreateFDArray(CFFFont.OffsetItem offsetItem, CFFFont.OffsetItem offsetItem2, int n2) {
        this.OutputList.addLast(new CFFFont.MarkerItem(offsetItem));
        this.BuildIndexHeader(1, 1, 1);
        offsetItem = new CFFFont.IndexOffsetItem(1);
        this.OutputList.addLast(offsetItem);
        CFFFont.IndexBaseItem indexBaseItem = new CFFFont.IndexBaseItem();
        this.OutputList.addLast(indexBaseItem);
        int n3 = this.fonts[n2].privateLength;
        int n4 = this.CalcSubrOffsetSize(this.fonts[n2].privateOffset, this.fonts[n2].privateLength);
        n2 = n3;
        if (n4 != 0) {
            n2 = n3 + (5 - n4);
        }
        this.OutputList.addLast(new CFFFont.DictNumberItem(n2));
        this.OutputList.addLast(offsetItem2);
        this.OutputList.addLast(new CFFFont.UInt8Item('\u0012'));
        this.OutputList.addLast(new CFFFont.IndexMarkerItem(offsetItem, indexBaseItem));
    }

    protected void CreateFDSelect(CFFFont.OffsetItem offsetItem, int n2) {
        this.OutputList.addLast(new CFFFont.MarkerItem(offsetItem));
        this.OutputList.addLast(new CFFFont.UInt8Item('\u0003'));
        this.OutputList.addLast(new CFFFont.UInt16Item('\u0001'));
        this.OutputList.addLast(new CFFFont.UInt16Item('\u0000'));
        this.OutputList.addLast(new CFFFont.UInt8Item('\u0000'));
        this.OutputList.addLast(new CFFFont.UInt16Item((char)n2));
    }

    protected void CreateKeys(CFFFont.OffsetItem offsetItem, CFFFont.OffsetItem offsetItem2, CFFFont.OffsetItem offsetItem3, CFFFont.OffsetItem offsetItem4) {
        this.OutputList.addLast(offsetItem);
        this.OutputList.addLast(new CFFFont.UInt8Item('\f'));
        this.OutputList.addLast(new CFFFont.UInt8Item('$'));
        this.OutputList.addLast(offsetItem2);
        this.OutputList.addLast(new CFFFont.UInt8Item('\f'));
        this.OutputList.addLast(new CFFFont.UInt8Item('%'));
        this.OutputList.addLast(offsetItem3);
        this.OutputList.addLast(new CFFFont.UInt8Item('\u000f'));
        this.OutputList.addLast(offsetItem4);
        this.OutputList.addLast(new CFFFont.UInt8Item('\u0011'));
    }

    protected void CreateNewStringIndex(int n2) {
        CharSequence charSequence = new StringBuilder();
        charSequence.append(this.fonts[n2].name);
        charSequence.append("-OneRange");
        CharSequence charSequence2 = charSequence.toString();
        charSequence = charSequence2;
        if (charSequence2.length() > 127) {
            charSequence = charSequence2.substring(0, 127);
        }
        charSequence2 = new StringBuilder();
        charSequence2.append("AdobeIdentity");
        charSequence2.append((String)charSequence);
        charSequence2 = charSequence2.toString();
        int n3 = this.stringOffsets[this.stringOffsets.length - 1] - this.stringOffsets[0];
        int n4 = this.stringOffsets[0] - 1;
        n2 = charSequence2.length() + n3 <= 255 ? 1 : (charSequence2.length() + n3 <= 65535 ? 2 : (charSequence2.length() + n3 <= 16777215 ? 3 : 4));
        this.OutputList.addLast(new CFFFont.UInt16Item((char)(this.stringOffsets.length - 1 + 3)));
        this.OutputList.addLast(new CFFFont.UInt8Item((char)n2));
        for (int n5 : this.stringOffsets) {
            this.OutputList.addLast(new CFFFont.IndexOffsetItem(n2, n5 - n4));
        }
        int n6 = this.stringOffsets[this.stringOffsets.length - 1] - n4 + "Adobe".length();
        this.OutputList.addLast(new CFFFont.IndexOffsetItem(n2, n6));
        this.OutputList.addLast(new CFFFont.IndexOffsetItem(n2, n6 += "Identity".length()));
        n4 = charSequence.length();
        this.OutputList.addLast(new CFFFont.IndexOffsetItem(n2, n6 + n4));
        this.OutputList.addLast(new CFFFont.RangeItem(this.buf, this.stringOffsets[0], n3));
        this.OutputList.addLast(new CFFFont.StringItem((String)charSequence2));
    }

    void CreateNonCIDPrivate(int n2, CFFFont.OffsetItem offsetItem) {
        this.seek(this.fonts[n2].privateOffset);
        while (this.getPosition() < this.fonts[n2].privateOffset + this.fonts[n2].privateLength) {
            int n3 = this.getPosition();
            this.getDictItem();
            int n4 = this.getPosition();
            if (this.key == "Subrs") {
                this.OutputList.addLast(offsetItem);
                this.OutputList.addLast(new CFFFont.UInt8Item('\u0013'));
                continue;
            }
            this.OutputList.addLast(new CFFFont.RangeItem(this.buf, n3, n4 - n3));
        }
    }

    void CreateNonCIDSubrs(int n2, CFFFont.IndexBaseItem indexBaseItem, CFFFont.OffsetItem offsetItem) {
        this.OutputList.addLast(new CFFFont.SubrMarkerItem(offsetItem, indexBaseItem));
        if (this.NewSubrsIndexNonCID != null) {
            this.OutputList.addLast(new CFFFont.RangeItem(new RandomAccessFileOrArray(this.NewSubrsIndexNonCID), 0, this.NewSubrsIndexNonCID.length));
        }
    }

    protected void EmptyStack() {
        for (int i2 = 0; i2 < this.arg_count; ++i2) {
            this.args[i2] = null;
        }
        this.arg_count = 0;
    }

    protected void HandelStack() {
        int n2 = this.StackOpp();
        if (n2 < 2) {
            if (n2 == 1) {
                this.PushStack();
                return;
            }
            for (int i2 = 0; i2 < n2 * -1; ++i2) {
                this.PopStack();
            }
        } else {
            this.EmptyStack();
        }
    }

    protected void PopStack() {
        if (this.arg_count > 0) {
            this.args[this.arg_count - 1] = null;
            --this.arg_count;
        }
    }

    public byte[] Process(String arrby) {
        this.buf.reOpen();
        int n2 = 0;
        do {
            block13 : {
                block14 : {
                    if (n2 < this.fonts.length && !arrby.equals(this.fonts[n2].name)) break block13;
                    int n3 = this.fonts.length;
                    if (n2 != n3) break block14;
                    try {
                        this.buf.close();
                        return null;
                    }
                    catch (Exception exception) {
                        return null;
                    }
                }
                try {
                    if (this.gsubrIndexOffset >= 0) {
                        this.GBias = this.CalcBias(this.gsubrIndexOffset, n2);
                    }
                    this.BuildNewCharString(n2);
                    this.BuildNewLGSubrs(n2);
                    arrby = this.BuildNewFile(n2);
                    return arrby;
                }
                finally {
                    this.buf.close();
                }
            }
            ++n2;
        } while (true);
    }

    protected void PushStack() {
        ++this.arg_count;
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void ReadASubr(int n2, int n3, int n4, int n5, HashMap<Integer, int[]> hashMap, ArrayList<Integer> arrayList, int[] arrn) {
        this.EmptyStack();
        this.NumOfHints = 0;
        this.seek(n2);
        block0 : do {
            block14 : {
                int n6;
                block16 : {
                    block15 : {
                        block13 : {
                            int n7;
                            block12 : {
                                Object object;
                                block11 : {
                                    if (this.getPosition() >= n3) {
                                        return;
                                    }
                                    this.ReadCommand();
                                    n7 = this.getPosition();
                                    object = this.arg_count > 0 ? this.args[this.arg_count - 1] : null;
                                    n2 = this.arg_count;
                                    this.HandelStack();
                                    if (this.key != "callsubr") break block11;
                                    if (n2 <= 0) continue;
                                    n6 = (Integer)object + n5;
                                    if (!hashMap.containsKey(n6)) {
                                        hashMap.put(n6, null);
                                        arrayList.add(n6);
                                    }
                                    n2 = arrn[n6];
                                    n6 = arrn[n6 + 1];
                                    break block12;
                                }
                                if (this.key != "callgsubr") break block13;
                                if (n2 <= 0) continue;
                                n6 = (Integer)object + n4;
                                if (!this.hGSubrsUsed.containsKey(n6)) {
                                    this.hGSubrsUsed.put(n6, null);
                                    this.lGSubrsUsed.add(n6);
                                }
                                n2 = this.gsubrOffsets[n6];
                                n6 = this.gsubrOffsets[n6 + 1];
                            }
                            this.CalcHints(n2, n6, n5, n4, arrn);
                            this.seek(n7);
                            continue;
                        }
                        if (this.key == "hstem" || this.key == "vstem" || this.key == "hstemhm" || this.key == "vstemhm") break block14;
                        if (this.key != "hintmask" && this.key != "cntrmask") continue;
                        this.NumOfHints += n2 / 2;
                        n6 = this.NumOfHints / 8;
                        if (this.NumOfHints % 8 != 0) break block15;
                        n2 = n6;
                        if (n6 != 0) break block16;
                    }
                    n2 = n6 + 1;
                }
                n6 = 0;
                do {
                    if (n6 >= n2) continue block0;
                    this.getCard8();
                    ++n6;
                } while (true);
            }
            this.NumOfHints += n2 / 2;
        } while (true);
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void ReadCommand() {
        String string2;
        int n2;
        this.key = null;
        int n3 = 0;
        do {
            block13 : {
                block9 : {
                    char c2;
                    block12 : {
                        block11 : {
                            block10 : {
                                block8 : {
                                    if (n3 != 0) {
                                        return;
                                    }
                                    n2 = this.getCard8();
                                    if (n2 != 28) break block8;
                                    n2 = this.getCard8();
                                    c2 = this.getCard8();
                                    this.args[this.arg_count] = n2 << 8 | c2;
                                    break block9;
                                }
                                if (n2 < 32 || n2 > 246) break block10;
                                this.args[this.arg_count] = n2 - 139;
                                break block9;
                            }
                            if (n2 < 247 || n2 > 250) break block11;
                            c2 = this.getCard8();
                            this.args[this.arg_count] = (n2 - 247) * 256 + c2 + 108;
                            break block9;
                        }
                        if (n2 < 251 || n2 > 254) break block12;
                        c2 = this.getCard8();
                        this.args[this.arg_count] = (- n2 - 251) * 256 - c2 - 108;
                        break block9;
                    }
                    if (n2 != 255) break block13;
                    n2 = this.getCard8();
                    c2 = this.getCard8();
                    char c3 = this.getCard8();
                    char c4 = this.getCard8();
                    this.args[this.arg_count] = n2 << 24 | c2 << 16 | c3 << 8 | c4;
                }
                ++this.arg_count;
                continue;
            }
            if (n2 <= 31 && n2 != 28) break;
        } while (true);
        if (n2 == 12) {
            n3 = n2 = this.getCard8();
            if (n2 > SubrsEscapeFuncs.length - 1) {
                n3 = SubrsEscapeFuncs.length - 1;
            }
            string2 = SubrsEscapeFuncs[n3];
        } else {
            string2 = SubrsFunctions[n2];
        }
        this.key = string2;
    }

    protected void ReadFDArray(int n2) {
        this.seek(this.fonts[n2].fdarrayOffset);
        this.fonts[n2].FDArrayCount = this.getCard16();
        this.fonts[n2].FDArrayOffsize = this.getCard8();
        if (this.fonts[n2].FDArrayOffsize < 4) {
            CFFFont.Font font = this.fonts[n2];
            ++font.FDArrayOffsize;
        }
        this.fonts[n2].FDArrayOffsets = this.getIndex(this.fonts[n2].fdarrayOffset);
    }

    void Reconstruct(int n2) {
        CFFFont.OffsetItem[] arroffsetItem = new CFFFont.DictOffsetItem[this.fonts[n2].FDArrayOffsets.length - 1];
        CFFFont.IndexBaseItem[] arrindexBaseItem = new CFFFont.IndexBaseItem[this.fonts[n2].fdprivateOffsets.length];
        CFFFont.OffsetItem[] arroffsetItem2 = new CFFFont.DictOffsetItem[this.fonts[n2].fdprivateOffsets.length];
        this.ReconstructFDArray(n2, arroffsetItem);
        this.ReconstructPrivateDict(n2, arroffsetItem, arrindexBaseItem, arroffsetItem2);
        this.ReconstructPrivateSubrs(n2, arrindexBaseItem, arroffsetItem2);
    }

    void ReconstructFDArray(int n2, CFFFont.OffsetItem[] arroffsetItem) {
        int n3;
        this.BuildIndexHeader(this.fonts[n2].FDArrayCount, this.fonts[n2].FDArrayOffsize, 1);
        CFFFont.IndexOffsetItem[] arrindexOffsetItem = new CFFFont.IndexOffsetItem[this.fonts[n2].FDArrayOffsets.length - 1];
        for (n3 = 0; n3 < this.fonts[n2].FDArrayOffsets.length - 1; ++n3) {
            arrindexOffsetItem[n3] = new CFFFont.IndexOffsetItem(this.fonts[n2].FDArrayOffsize);
            this.OutputList.addLast(arrindexOffsetItem[n3]);
        }
        CFFFont.IndexBaseItem indexBaseItem = new CFFFont.IndexBaseItem();
        this.OutputList.addLast(indexBaseItem);
        n3 = 0;
        while (n3 < this.fonts[n2].FDArrayOffsets.length - 1) {
            int[] arrn;
            int n4;
            int n5;
            this.seek(this.fonts[n2].FDArrayOffsets[n3]);
            while ((n5 = this.getPosition()) < (arrn = this.fonts[n2].FDArrayOffsets)[n4 = n3 + 1]) {
                n4 = this.getPosition();
                this.getDictItem();
                int n6 = this.getPosition();
                if (this.key == "Private") {
                    n5 = (Integer)this.args[0];
                    int n7 = this.CalcSubrOffsetSize(this.fonts[n2].fdprivateOffsets[n3], this.fonts[n2].fdprivateLengths[n3]);
                    n4 = n5;
                    if (n7 != 0) {
                        n4 = n5 + (5 - n7);
                    }
                    this.OutputList.addLast(new CFFFont.DictNumberItem(n4));
                    arroffsetItem[n3] = new CFFFont.DictOffsetItem();
                    this.OutputList.addLast(arroffsetItem[n3]);
                    this.OutputList.addLast(new CFFFont.UInt8Item('\u0012'));
                    this.seek(n6);
                    continue;
                }
                this.OutputList.addLast(new CFFFont.RangeItem(this.buf, n4, n6 - n4));
            }
            this.OutputList.addLast(new CFFFont.IndexMarkerItem(arrindexOffsetItem[n3], indexBaseItem));
            n3 = n4;
        }
    }

    void ReconstructPrivateDict(int n2, CFFFont.OffsetItem[] arroffsetItem, CFFFont.IndexBaseItem[] arrindexBaseItem, CFFFont.OffsetItem[] arroffsetItem2) {
        for (int i2 = 0; i2 < this.fonts[n2].fdprivateOffsets.length; ++i2) {
            this.OutputList.addLast(new CFFFont.MarkerItem(arroffsetItem[i2]));
            arrindexBaseItem[i2] = new CFFFont.IndexBaseItem();
            this.OutputList.addLast(arrindexBaseItem[i2]);
            this.seek(this.fonts[n2].fdprivateOffsets[i2]);
            while (this.getPosition() < this.fonts[n2].fdprivateOffsets[i2] + this.fonts[n2].fdprivateLengths[i2]) {
                int n3 = this.getPosition();
                this.getDictItem();
                int n4 = this.getPosition();
                if (this.key == "Subrs") {
                    arroffsetItem2[i2] = new CFFFont.DictOffsetItem();
                    this.OutputList.addLast(arroffsetItem2[i2]);
                    this.OutputList.addLast(new CFFFont.UInt8Item('\u0013'));
                    continue;
                }
                this.OutputList.addLast(new CFFFont.RangeItem(this.buf, n3, n4 - n3));
            }
        }
    }

    void ReconstructPrivateSubrs(int n2, CFFFont.IndexBaseItem[] arrindexBaseItem, CFFFont.OffsetItem[] arroffsetItem) {
        for (int i2 = 0; i2 < this.fonts[n2].fdprivateLengths.length; ++i2) {
            if (arroffsetItem[i2] == null || this.fonts[n2].PrivateSubrsOffset[i2] < 0) continue;
            this.OutputList.addLast(new CFFFont.SubrMarkerItem(arroffsetItem[i2], arrindexBaseItem[i2]));
            if (this.NewLSubrsIndex[i2] == null) continue;
            this.OutputList.addLast(new CFFFont.RangeItem(new RandomAccessFileOrArray(this.NewLSubrsIndex[i2]), 0, this.NewLSubrsIndex[i2].length));
        }
    }

    protected int StackOpp() {
        if (this.key == "ifelse") {
            return -3;
        }
        if (this.key != "roll" && this.key != "put") {
            if (this.key != "callsubr" && this.key != "callgsubr" && this.key != "add" && this.key != "sub" && this.key != "div" && this.key != "mul" && this.key != "drop" && this.key != "and" && this.key != "or" && this.key != "eq") {
                if (this.key != "abs" && this.key != "neg" && this.key != "sqrt" && this.key != "exch" && this.key != "index" && this.key != "get" && this.key != "not" && this.key != "return") {
                    if (this.key != "random" && this.key != "dup") {
                        return 2;
                    }
                    return 1;
                }
                return 0;
            }
            return -1;
        }
        return -2;
    }

    protected int countEntireIndexRange(int n2) {
        this.seek(n2);
        char c2 = this.getCard16();
        if (c2 == '\u0000') {
            return 2;
        }
        char c3 = this.getCard8();
        this.seek(n2 + 2 + 1 + c2 * c3);
        return (c2 + '\u0001') * c3 + 3 + (this.getOffset(c3) - 1);
    }

    protected void readFDSelect(int n2) {
        int n3;
        int n4 = this.fonts[n2].nglyphs;
        int[] arrn = new int[n4];
        this.seek(this.fonts[n2].fdselectOffset);
        int n5 = this.fonts[n2].FDSelectFormat = (int)this.getCard8();
        if (n5 != 0) {
            if (n5 == 3) {
                int n6 = this.getCard16();
                n5 = this.getCard16();
                n3 = 0;
                for (n4 = 0; n4 < n6; ++n4) {
                    char c2 = this.getCard8();
                    char c3 = this.getCard16();
                    for (int i2 = 0; i2 < c3 - n5; ++i2) {
                        arrn[n3] = c2;
                        ++n3;
                    }
                    n5 = c3;
                }
                this.fonts[n2].FDSelectLength = n6 * 3 + 3 + 2;
            }
        } else {
            for (n3 = 0; n3 < n4; ++n3) {
                arrn[n3] = this.getCard8();
            }
            this.fonts[n2].FDSelectLength = this.fonts[n2].nglyphs + 1;
        }
        this.fonts[n2].FDSelect = arrn;
    }
}

