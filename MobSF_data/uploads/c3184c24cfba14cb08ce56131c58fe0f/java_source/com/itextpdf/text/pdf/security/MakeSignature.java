/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  org.spongycastle.asn1.esf.SignaturePolicyIdentifier
 */
package com.itextpdf.text.pdf.security;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.io.RASInputStream;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.io.StreamUtil;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.AcroFields;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDate;
import com.itextpdf.text.pdf.PdfDeveloperExtension;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfSignature;
import com.itextpdf.text.pdf.PdfSignatureAppearance;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.security.CrlClient;
import com.itextpdf.text.pdf.security.DigestAlgorithms;
import com.itextpdf.text.pdf.security.ExternalDigest;
import com.itextpdf.text.pdf.security.ExternalSignature;
import com.itextpdf.text.pdf.security.ExternalSignatureContainer;
import com.itextpdf.text.pdf.security.OcspClient;
import com.itextpdf.text.pdf.security.PdfPKCS7;
import com.itextpdf.text.pdf.security.SignaturePolicyInfo;
import com.itextpdf.text.pdf.security.TSAClient;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.security.MessageDigest;
import java.security.PrivateKey;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import org.spongycastle.asn1.esf.SignaturePolicyIdentifier;

public class MakeSignature {
    private static final Logger LOGGER = LoggerFactory.getLogger(MakeSignature.class);

    public static Collection<byte[]> processCrl(Certificate certificate, Collection<CrlClient> object) {
        if (object == null) {
            return null;
        }
        ArrayList<byte[]> arrayList = new ArrayList<byte[]>();
        object = object.iterator();
        while (object.hasNext()) {
            Object object2 = (CrlClient)object.next();
            if (object2 == null) continue;
            Logger logger = LOGGER;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Processing ");
            stringBuilder.append(object2.getClass().getName());
            logger.info(stringBuilder.toString());
            object2 = object2.getEncoded((X509Certificate)certificate, null);
            if (object2 == null) continue;
            arrayList.addAll((Collection<byte[]>)object2);
        }
        if (arrayList.isEmpty()) {
            return null;
        }
        return arrayList;
    }

    public static void signDeferred(PdfReader object, String arrl, OutputStream outputStream, ExternalSignatureContainer arrby) {
        Object object2 = object.getAcroFields();
        PdfDictionary pdfDictionary = object2.getSignatureDictionary((String)arrl);
        if (pdfDictionary != null) {
            if (object2.signatureCoversWholeDocument((String)arrl)) {
                object2 = pdfDictionary.getAsArray(PdfName.BYTERANGE);
                arrl = object2.asLongArray();
                if (object2.size() == 4) {
                    int n2 = 0;
                    if (arrl[0] == 0L) {
                        object = object.getSafeFile().createSourceView();
                        arrby = arrby.sign(new RASInputStream(new RandomAccessSourceFactory().createRanged((RandomAccessSource)object, arrl)));
                        int n3 = (int)(arrl[2] - arrl[1]) - 2;
                        if ((n3 & 1) == 0) {
                            int n4 = n3 / 2;
                            if (n4 >= arrby.length) {
                                StreamUtil.CopyBytes((RandomAccessSource)object, 0L, arrl[1] + 1L, outputStream);
                                object2 = new ByteBuffer(n4 * 2);
                                int n5 = arrby.length;
                                for (n3 = 0; n3 < n5; ++n3) {
                                    object2.appendHex(arrby[n3]);
                                }
                                n5 = arrby.length;
                                for (n3 = n2; n3 < (n4 - n5) * 2; ++n3) {
                                    object2.append((byte)48);
                                }
                                object2.writeTo(outputStream);
                                StreamUtil.CopyBytes((RandomAccessSource)object, arrl[2] - 1L, arrl[3] + 1L, outputStream);
                                return;
                            }
                            throw new DocumentException("Not enough space");
                        }
                        throw new DocumentException("Gap is not a multiple of 2");
                    }
                }
                throw new DocumentException("Single exclusion space supported");
            }
            throw new DocumentException("Not the last signature");
        }
        throw new DocumentException("No field");
    }

    public static void signDetached(PdfSignatureAppearance pdfSignatureAppearance, ExternalDigest externalDigest, ExternalSignature externalSignature, Certificate[] arrcertificate, Collection<CrlClient> collection, OcspClient ocspClient, TSAClient tSAClient, int n2, CryptoStandard cryptoStandard) {
        MakeSignature.signDetached(pdfSignatureAppearance, externalDigest, externalSignature, arrcertificate, collection, ocspClient, tSAClient, n2, cryptoStandard, (SignaturePolicyIdentifier)null);
    }

    public static void signDetached(PdfSignatureAppearance pdfSignatureAppearance, ExternalDigest externalDigest, ExternalSignature externalSignature, Certificate[] arrcertificate, Collection<CrlClient> collection, OcspClient ocspClient, TSAClient tSAClient, int n2, CryptoStandard cryptoStandard, SignaturePolicyInfo signaturePolicyInfo) {
        MakeSignature.signDetached(pdfSignatureAppearance, externalDigest, externalSignature, arrcertificate, collection, ocspClient, tSAClient, n2, cryptoStandard, signaturePolicyInfo.toSignaturePolicyIdentifier());
    }

    public static void signDetached(PdfSignatureAppearance pdfSignatureAppearance, ExternalDigest object, ExternalSignature object2, Certificate[] arrcertificate, Collection<CrlClient> object3, OcspClient ocspClient, TSAClient tSAClient, int n2, CryptoStandard cryptoStandard, SignaturePolicyIdentifier arrby) {
        int n3;
        Collection<byte[]> collection = null;
        for (n3 = 0; collection == null && n3 < arrcertificate.length; ++n3) {
            collection = MakeSignature.processCrl(arrcertificate[n3], object3);
        }
        if (n2 == 0) {
            n2 = n3 = 8192;
            if (collection != null) {
                object3 = collection.iterator();
                do {
                    n2 = n3;
                    if (!object3.hasNext()) break;
                    n3 += ((byte[])object3.next()).length + 10;
                } while (true);
            }
            n3 = n2;
            if (ocspClient != null) {
                n3 = n2 + 4192;
            }
            n2 = n3;
            if (tSAClient != null) {
                n2 = n3 + 4192;
            }
        }
        pdfSignatureAppearance.setCertificate(arrcertificate[0]);
        if (cryptoStandard == CryptoStandard.CADES) {
            pdfSignatureAppearance.addDeveloperExtension(PdfDeveloperExtension.ESIC_1_7_EXTENSIONLEVEL2);
        }
        Object object4 = PdfName.ADOBE_PPKLITE;
        object3 = cryptoStandard == CryptoStandard.CADES ? PdfName.ETSI_CADES_DETACHED : PdfName.ADBE_PKCS7_DETACHED;
        object3 = new PdfSignature((PdfName)object4, (PdfName)object3);
        object3.setReason(pdfSignatureAppearance.getReason());
        object3.setLocation(pdfSignatureAppearance.getLocation());
        object3.setSignatureCreator(pdfSignatureAppearance.getSignatureCreator());
        object3.setContact(pdfSignatureAppearance.getContact());
        object3.setDate(new PdfDate(pdfSignatureAppearance.getSignDate()));
        pdfSignatureAppearance.setCryptoDictionary((PdfDictionary)object3);
        object3 = new HashMap<PdfName, Integer>();
        object3.put(PdfName.CONTENTS, new Integer(n2 * 2 + 2));
        pdfSignatureAppearance.preClose((HashMap<PdfName, Integer>)object3);
        object4 = object2.getHashAlgorithm();
        object3 = new PdfPKCS7(null, arrcertificate, (String)object4, null, (ExternalDigest)object, false);
        if (arrby != null) {
            object3.setSignaturePolicy((SignaturePolicyIdentifier)arrby);
        }
        arrby = DigestAlgorithms.digest(pdfSignatureAppearance.getRangeStream(), object.getMessageDigest((String)object4));
        object = arrcertificate.length >= 2 && ocspClient != null ? ocspClient.getEncoded((X509Certificate)arrcertificate[0], (X509Certificate)arrcertificate[1], null) : null;
        object3.setExternalDigest(object2.sign(object3.getAuthenticatedAttributeBytes(arrby, (byte[])object, collection, cryptoStandard)), null, object2.getEncryptionAlgorithm());
        object2 = object3.getEncodedPKCS7(arrby, tSAClient, (byte[])object, collection, cryptoStandard);
        if (n2 >= ((byte[])object2).length) {
            object = new byte[n2];
            System.arraycopy(object2, 0, object, 0, ((byte[])object2).length);
            object2 = new PdfDictionary();
            object2.put(PdfName.CONTENTS, new PdfString((byte[])object).setHexWriting(true));
            pdfSignatureAppearance.close((PdfDictionary)object2);
            return;
        }
        throw new IOException("Not enough space");
    }

    public static void signExternalContainer(PdfSignatureAppearance pdfSignatureAppearance, ExternalSignatureContainer arrby, int n2) {
        Serializable serializable = new PdfSignature(null, null);
        serializable.setReason(pdfSignatureAppearance.getReason());
        serializable.setLocation(pdfSignatureAppearance.getLocation());
        serializable.setSignatureCreator(pdfSignatureAppearance.getSignatureCreator());
        serializable.setContact(pdfSignatureAppearance.getContact());
        serializable.setDate(new PdfDate(pdfSignatureAppearance.getSignDate()));
        arrby.modifySigningDictionary((PdfDictionary)serializable);
        pdfSignatureAppearance.setCryptoDictionary((PdfDictionary)serializable);
        serializable = new HashMap();
        serializable.put(PdfName.CONTENTS, new Integer(n2 * 2 + 2));
        pdfSignatureAppearance.preClose((HashMap<PdfName, Integer>)serializable);
        serializable = arrby.sign(pdfSignatureAppearance.getRangeStream());
        if (n2 >= ((Serializable)serializable).length) {
            arrby = new byte[n2];
            System.arraycopy(serializable, 0, arrby, 0, ((Serializable)serializable).length);
            serializable = new PdfDictionary();
            serializable.put(PdfName.CONTENTS, new PdfString(arrby).setHexWriting(true));
            pdfSignatureAppearance.close((PdfDictionary)serializable);
            return;
        }
        throw new IOException("Not enough space");
    }

    public static enum CryptoStandard {
        CMS,
        CADES;
        

        private CryptoStandard() {
        }
    }

}

