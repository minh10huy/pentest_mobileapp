/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.languages;

import com.itextpdf.text.pdf.BidiLine;
import com.itextpdf.text.pdf.BidiOrder;
import com.itextpdf.text.pdf.languages.LanguageProcessor;
import java.util.HashMap;

public class ArabicLigaturizer
implements LanguageProcessor {
    private static final char ALEF = '\u0627';
    private static final char ALEFHAMZA = '\u0623';
    private static final char ALEFHAMZABELOW = '\u0625';
    private static final char ALEFMADDA = '\u0622';
    private static final char ALEFMAKSURA = '\u0649';
    private static final char DAMMA = '\u064f';
    public static final int DIGITS_AN2EN = 64;
    public static final int DIGITS_EN2AN = 32;
    public static final int DIGITS_EN2AN_INIT_AL = 128;
    public static final int DIGITS_EN2AN_INIT_LR = 96;
    public static final int DIGITS_MASK = 224;
    private static final int DIGITS_RESERVED = 160;
    public static final int DIGIT_TYPE_AN = 0;
    public static final int DIGIT_TYPE_AN_EXTENDED = 256;
    public static final int DIGIT_TYPE_MASK = 256;
    private static final char FARSIYEH = '\u06cc';
    private static final char FATHA = '\u064e';
    private static final char HAMZA = '\u0621';
    private static final char HAMZAABOVE = '\u0654';
    private static final char HAMZABELOW = '\u0655';
    private static final char KASRA = '\u0650';
    private static final char LAM = '\u0644';
    private static final char LAM_ALEF = '\ufefb';
    private static final char LAM_ALEFHAMZA = '\ufef7';
    private static final char LAM_ALEFHAMZABELOW = '\ufef9';
    private static final char LAM_ALEFMADDA = '\ufef5';
    private static final char MADDA = '\u0653';
    private static final char SHADDA = '\u0651';
    private static final char TATWEEL = '\u0640';
    private static final char WAW = '\u0648';
    private static final char WAWHAMZA = '\u0624';
    private static final char YEH = '\u064a';
    private static final char YEHHAMZA = '\u0626';
    private static final char ZWJ = '\u200d';
    public static final int ar_composedtashkeel = 4;
    public static final int ar_lig = 8;
    public static final int ar_nothing = 0;
    public static final int ar_novowel = 1;
    private static final char[][] chartable;
    private static final HashMap<Character, char[]> maptable;
    private static final HashMap<Character, Character> reverseLigatureMapTable;
    protected int options = 0;
    protected int runDirection = 3;

    static {
        maptable = new HashMap();
        reverseLigatureMapTable = new HashMap();
        char[] arrc = new char[]{'\u0625', '\ufffffe87', '\ufffffe88'};
        Object object = new char[]{'\u0628', '\ufffffe8f', '\ufffffe90', '\ufffffe91', '\ufffffe92'};
        char[] arrc2 = new char[]{'\u062d', '\ufffffea1', '\ufffffea2', '\ufffffea3', '\ufffffea4'};
        char[] arrc3 = new char[]{'\u0630', '\ufffffeab', '\ufffffeac'};
        char[] arrc4 = new char[]{'\u0632', '\ufffffeaf', '\ufffffeb0'};
        char[] arrc5 = new char[]{'\u0633', '\ufffffeb1', '\ufffffeb2', '\ufffffeb3', '\ufffffeb4'};
        char[] arrc6 = new char[]{'\u0636', '\ufffffebd', '\ufffffebe', '\ufffffebf', '\ufffffec0'};
        char[] arrc7 = new char[]{'\u0637', '\ufffffec1', '\ufffffec2', '\ufffffec3', '\ufffffec4'};
        char[] arrc8 = new char[]{'\u0638', '\ufffffec5', '\ufffffec6', '\ufffffec7', '\ufffffec8'};
        char[] arrc9 = new char[]{'\u0640', '\u0640', '\u0640', '\u0640', '\u0640'};
        char[] arrc10 = new char[]{'\u0641', '\ufffffed1', '\ufffffed2', '\ufffffed3', '\ufffffed4'};
        char[] arrc11 = new char[]{'\u0642', '\ufffffed5', '\ufffffed6', '\ufffffed7', '\ufffffed8'};
        char[] arrc12 = new char[]{'\u0646', '\ufffffee5', '\ufffffee6', '\ufffffee7', '\ufffffee8'};
        char[] arrc13 = new char[]{'\u067b', '\ufffffb52', '\ufffffb53', '\ufffffb54', '\ufffffb55'};
        char[] arrc14 = new char[]{'\u067f', '\ufffffb62', '\ufffffb63', '\ufffffb64', '\ufffffb65'};
        char[] arrc15 = new char[]{'\u0680', '\ufffffb5a', '\ufffffb5b', '\ufffffb5c', '\ufffffb5d'};
        char[] arrc16 = new char[]{'\u0683', '\ufffffb76', '\ufffffb77', '\ufffffb78', '\ufffffb79'};
        char[] arrc17 = new char[]{'\u068e', '\ufffffb86', '\ufffffb87'};
        char[] arrc18 = new char[]{'\u0698', '\ufffffb8a', '\ufffffb8b'};
        char[] arrc19 = new char[]{'\u06a9', '\ufffffb8e', '\ufffffb8f', '\ufffffb90', '\ufffffb91'};
        char[] arrc20 = new char[]{'\u06b1', '\ufffffb9a', '\ufffffb9b', '\ufffffb9c', '\ufffffb9d'};
        char[] arrc21 = new char[]{'\u06b3', '\ufffffb96', '\ufffffb97', '\ufffffb98', '\ufffffb99'};
        char[] arrc22 = new char[]{'\u06c5', '\ufffffbe0', '\ufffffbe1'};
        char[] arrc23 = new char[]{'\u06cc', '\ufffffbfc', '\ufffffbfd', '\ufffffbfe', '\ufffffbff'};
        chartable = new char[][]{{'\u0621', '\ufffffe80'}, {'\u0622', '\ufffffe81', '\ufffffe82'}, {'\u0623', '\ufffffe83', '\ufffffe84'}, {'\u0624', '\ufffffe85', '\ufffffe86'}, arrc, {'\u0626', '\ufffffe89', '\ufffffe8a', '\ufffffe8b', '\ufffffe8c'}, {'\u0627', '\ufffffe8d', '\ufffffe8e'}, object, {'\u0629', '\ufffffe93', '\ufffffe94'}, {'\u062a', '\ufffffe95', '\ufffffe96', '\ufffffe97', '\ufffffe98'}, {'\u062b', '\ufffffe99', '\ufffffe9a', '\ufffffe9b', '\ufffffe9c'}, {'\u062c', '\ufffffe9d', '\ufffffe9e', '\ufffffe9f', '\ufffffea0'}, arrc2, {'\u062e', '\ufffffea5', '\ufffffea6', '\ufffffea7', '\ufffffea8'}, {'\u062f', '\ufffffea9', '\ufffffeaa'}, arrc3, {'\u0631', '\ufffffead', '\ufffffeae'}, arrc4, arrc5, {'\u0634', '\ufffffeb5', '\ufffffeb6', '\ufffffeb7', '\ufffffeb8'}, {'\u0635', '\ufffffeb9', '\ufffffeba', '\ufffffebb', '\ufffffebc'}, arrc6, arrc7, arrc8, {'\u0639', '\ufffffec9', '\ufffffeca', '\ufffffecb', '\ufffffecc'}, {'\u063a', '\ufffffecd', '\ufffffece', '\ufffffecf', '\ufffffed0'}, arrc9, arrc10, arrc11, {'\u0643', '\ufffffed9', '\ufffffeda', '\ufffffedb', '\ufffffedc'}, {'\u0644', '\ufffffedd', '\ufffffede', '\ufffffedf', '\ufffffee0'}, {'\u0645', '\ufffffee1', '\ufffffee2', '\ufffffee3', '\ufffffee4'}, arrc12, {'\u0647', '\ufffffee9', '\ufffffeea', '\ufffffeeb', '\ufffffeec'}, {'\u0648', '\ufffffeed', '\ufffffeee'}, {'\u0649', '\ufffffeef', '\ufffffef0', '\ufffffbe8', '\ufffffbe9'}, {'\u064a', '\ufffffef1', '\ufffffef2', '\ufffffef3', '\ufffffef4'}, {'\u0671', '\ufffffb50', '\ufffffb51'}, {'\u0679', '\ufffffb66', '\ufffffb67', '\ufffffb68', '\ufffffb69'}, {'\u067a', '\ufffffb5e', '\ufffffb5f', '\ufffffb60', '\ufffffb61'}, arrc13, {'\u067e', '\ufffffb56', '\ufffffb57', '\ufffffb58', '\ufffffb59'}, arrc14, arrc15, arrc16, {'\u0684', '\ufffffb72', '\ufffffb73', '\ufffffb74', '\ufffffb75'}, {'\u0686', '\ufffffb7a', '\ufffffb7b', '\ufffffb7c', '\ufffffb7d'}, {'\u0687', '\ufffffb7e', '\ufffffb7f', '\ufffffb80', '\ufffffb81'}, {'\u0688', '\ufffffb88', '\ufffffb89'}, {'\u068c', '\ufffffb84', '\ufffffb85'}, {'\u068d', '\ufffffb82', '\ufffffb83'}, arrc17, {'\u0691', '\ufffffb8c', '\ufffffb8d'}, arrc18, {'\u06a4', '\ufffffb6a', '\ufffffb6b', '\ufffffb6c', '\ufffffb6d'}, {'\u06a6', '\ufffffb6e', '\ufffffb6f', '\ufffffb70', '\ufffffb71'}, arrc19, {'\u06ad', '\ufffffbd3', '\ufffffbd4', '\ufffffbd5', '\ufffffbd6'}, {'\u06af', '\ufffffb92', '\ufffffb93', '\ufffffb94', '\ufffffb95'}, arrc20, arrc21, {'\u06ba', '\ufffffb9e', '\ufffffb9f'}, {'\u06bb', '\ufffffba0', '\ufffffba1', '\ufffffba2', '\ufffffba3'}, {'\u06be', '\ufffffbaa', '\ufffffbab', '\ufffffbac', '\ufffffbad'}, {'\u06c0', '\ufffffba4', '\ufffffba5'}, {'\u06c1', '\ufffffba6', '\ufffffba7', '\ufffffba8', '\ufffffba9'}, arrc22, {'\u06c6', '\ufffffbd9', '\ufffffbda'}, {'\u06c7', '\ufffffbd7', '\ufffffbd8'}, {'\u06c8', '\ufffffbdb', '\ufffffbdc'}, {'\u06c9', '\ufffffbe2', '\ufffffbe3'}, {'\u06cb', '\ufffffbde', '\ufffffbdf'}, arrc23, {'\u06d0', '\ufffffbe4', '\ufffffbe5', '\ufffffbe6', '\ufffffbe7'}, {'\u06d2', '\ufffffbae', '\ufffffbaf'}, {'\u06d3', '\ufffffbb0', '\ufffffbb1'}};
        arrc = chartable;
        int n2 = arrc.length;
        for (int i2 = 0; i2 < n2; ++i2) {
            block4 : {
                block3 : {
                    object = arrc[i2];
                    maptable.put(Character.valueOf(object[0]), (char[])object);
                    int n3 = ((char[])object).length;
                    if (n3 == 3) break block3;
                    if (n3 != 5) break block4;
                    reverseLigatureMapTable.put(Character.valueOf(object[4]), Character.valueOf(object[3]));
                }
                reverseLigatureMapTable.put(Character.valueOf(object[2]), Character.valueOf(object[1]));
                reverseLigatureMapTable.put(Character.valueOf(object[1]), Character.valueOf(object[0]));
            }
            if (object[0] != '\u0637' && object[0] != '\u0638') continue;
            reverseLigatureMapTable.put(Character.valueOf(object[4]), Character.valueOf(object[1]));
            reverseLigatureMapTable.put(Character.valueOf(object[3]), Character.valueOf(object[1]));
        }
    }

    public ArabicLigaturizer() {
    }

    public ArabicLigaturizer(int n2, int n3) {
        this.runDirection = n2;
        this.options = n3;
    }

    public static int arabic_shape(char[] object, int n2, int n3, char[] arrc, int n4, int n5, int n6) {
        char[] arrc2 = new char[n3];
        for (n5 = n3 + n2 - 1; n5 >= n2; --n5) {
            arrc2[n5 - n2] = object[n5];
        }
        object = new StringBuffer(n3);
        ArabicLigaturizer.shape(arrc2, (StringBuffer)object, n6);
        if ((n6 & 12) != 0) {
            ArabicLigaturizer.doublelig((StringBuffer)object, n6);
        }
        System.arraycopy(object.toString().toCharArray(), 0, arrc, n4, object.length());
        return object.length();
    }

    static char charshape(char c2, int n2) {
        char c3;
        if (c2 >= '\u0621' && c2 <= '\u06d3') {
            char[] arrc = maptable.get(Character.valueOf(c2));
            c3 = c2;
            if (arrc != null) {
                return arrc[n2 + 1];
            }
        } else {
            c3 = c2;
            if (c2 >= '\ufef5') {
                c3 = c2;
                if (c2 <= '\ufefb') {
                    c3 = (char)(c2 + n2);
                }
            }
        }
        return c3;
    }

    static boolean connects_to_left(charstruct charstruct2) {
        if (charstruct2.numshapes > 2) {
            return true;
        }
        return false;
    }

    static void copycstostring(StringBuffer stringBuffer, charstruct charstruct2, int n2) {
        if (charstruct2.basechar == '\u0000') {
            return;
        }
        stringBuffer.append(charstruct2.basechar);
        --charstruct2.lignum;
        if (charstruct2.mark1 != '\u0000') {
            if ((n2 & 1) == 0) {
                stringBuffer.append(charstruct2.mark1);
            }
            --charstruct2.lignum;
        }
        if (charstruct2.vowel != '\u0000') {
            if ((n2 & 1) == 0) {
                stringBuffer.append(charstruct2.vowel);
            }
            --charstruct2.lignum;
        }
    }

    /*
     * Exception decompiling
     */
    static void doublelig(StringBuffer var0, int var1_1) {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Extractable last case doesn't follow previous
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:486)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.rebuildSwitches(SwitchReplacer.java:334)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:517)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    public static Character getReverseMapping(char c2) {
        return reverseLigatureMapTable.get(Character.valueOf(c2));
    }

    static boolean isVowel(char c2) {
        if (c2 >= '\u064b' && c2 <= '\u0655' || c2 == '\u0670') {
            return true;
        }
        return false;
    }

    /*
     * Unable to fully structure code
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    static int ligature(char var0, charstruct var1_1) {
        block23 : {
            block22 : {
                if (var1_1.basechar == '\u0000') {
                    return 0;
                }
                var5_2 = ArabicLigaturizer.isVowel(var0);
                var3_3 = 2;
                if (!var5_2) break block23;
                var2_4 = var1_1.vowel != '\u0000' && var0 != '\u0651' ? 2 : 1;
                switch (var0) {
                    default: {
                        var1_1.vowel = var0;
                        break block22;
                    }
                    case '\u0655': {
                        var4_6 = var1_1.basechar;
                        if (var4_6 == '\u0627') ** GOTO lbl20
                        if (var4_6 == '\ufefb') ** GOTO lbl17
                        var0 = (char)1621;
                        ** GOTO lbl30
lbl17: // 1 sources:
                        var1_1.basechar = (char)65273;
                        var2_4 = var3_3;
                        break block22;
lbl20: // 1 sources:
                        var0 = (char)1573;
                        ** GOTO lbl43
                    }
                    case '\u0654': {
                        var4_7 = var1_1.basechar;
                        if (var4_7 == '\u0627') ** GOTO lbl42
                        if (var4_7 == '\u06cc') ** GOTO lbl-1000
                        if (var4_7 == '\ufefb') ** GOTO lbl35
                        switch (var4_7) {
                            default: {
                                var0 = (char)1620;
lbl30: // 2 sources:
                                var1_1.mark1 = var0;
                                break block22;
                            }
                            case '\u0648': {
                                var0 = (char)1572;
                                break;
                            }
lbl35: // 1 sources:
                            var1_1.basechar = (char)65271;
                            var2_4 = var3_3;
                            break block22;
                            case '\u0649': 
                            case '\u064a': lbl-1000: // 2 sources:
                            {
                                var0 = (char)1574;
                                break;
                            }
                        }
                        ** GOTO lbl43
lbl42: // 1 sources:
                        var0 = (char)1571;
lbl43: // 4 sources:
                        do {
                            var1_1.basechar = var0;
                            var2_4 = var3_3;
                            break block22;
                            break;
                        } while (true);
                    }
                    case '\u0653': {
                        if (var1_1.basechar == '\u0627') {
                            var0 = (char)1570;
                            ** continue;
                        }
                        break block22;
                    }
                    case '\u0651': 
                }
                if (var1_1.mark1 != '\u0000') return 0;
                var1_1.mark1 = (char)1617;
            }
            if (var2_4 != 1) return var2_4;
            ++var1_1.lignum;
            return var2_4;
        }
        if (var1_1.vowel != '\u0000') {
            return 0;
        }
        var2_5 = var1_1.basechar;
        if (var2_5 != '\u0000') {
            if (var2_5 != '\u0644') {
                return 0;
            }
            switch (var0) {
                default: {
                    return 0;
                }
                case '\u0627': {
                    var1_1.basechar = (char)65275;
                    break;
                }
                case '\u0625': {
                    var1_1.basechar = (char)65273;
                    break;
                }
                case '\u0623': {
                    var1_1.basechar = (char)65271;
                    break;
                }
                case '\u0622': {
                    var1_1.basechar = (char)65269;
                }
            }
            var1_1.numshapes = 2;
            return 3;
        }
        var1_1.basechar = var0;
        var1_1.numshapes = ArabicLigaturizer.shapecount(var0);
        return 1;
    }

    public static void processNumbers(char[] arrc, int n2, int n3, int n4) {
        block9 : {
            int n5 = n2 + n3;
            int n6 = n4 & 224;
            if (n6 == 0) break block9;
            int n7 = (n4 &= 256) != 0 ? (n4 != 256 ? 48 : 1776) : 1632;
            if (n6 != 32) {
                if (n6 != 64) {
                    if (n6 != 96) {
                        if (n6 != 128) {
                            return;
                        }
                        ArabicLigaturizer.shapeToArabicDigitsWithContext(arrc, 0, n3, (char)n7, true);
                        return;
                    }
                    ArabicLigaturizer.shapeToArabicDigitsWithContext(arrc, 0, n3, (char)n7, false);
                    return;
                }
                n3 = (char)(n7 + 9);
                while (n2 < n5) {
                    n4 = arrc[n2];
                    if (n4 <= n3 && n4 >= n7) {
                        arrc[n2] = (char)(arrc[n2] + (48 - n7));
                    }
                    ++n2;
                }
            } else {
                while (n2 < n5) {
                    n3 = arrc[n2];
                    if (n3 <= 57 && n3 >= 48) {
                        arrc[n2] = (char)(arrc[n2] + (n7 - 48));
                    }
                    ++n2;
                }
            }
        }
    }

    static void shape(char[] arrc, StringBuffer stringBuffer, int n2) {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:311)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    /*
     * Unable to fully structure code
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    static void shapeToArabicDigitsWithContext(char[] var0, int var1_1, int var2_2, char var3_3, boolean var4_4) {
        var6_5 = (char)(var3_3 - 48);
        var8_6 = var4_4;
        for (var3_3 = (char)var1_1; var3_3 < var2_2 + var1_1; var3_3 = (char)(var3_3 + '\u0001')) {
            var5_7 = var0[var3_3];
            var7_8 = BidiOrder.getDirection(var5_7);
            if (var7_8 == 0) ** GOTO lbl-1000
            if (var7_8 == 8) ** GOTO lbl15
            switch (var7_8) {
                default: {
                    var4_4 = var8_6;
                    break;
                }
                case 4: {
                    var4_4 = true;
                    break;
                }
lbl15: // 1 sources:
                var4_4 = var8_6;
                if (!var8_6) break;
                var4_4 = var8_6;
                if (var5_7 > '9') break;
                var0[var3_3] = (char)(var5_7 + var6_5);
                var4_4 = var8_6;
                break;
                case 3: lbl-1000: // 2 sources:
                {
                    var4_4 = false;
                }
            }
            var8_6 = var4_4;
        }
    }

    static int shapecount(char c2) {
        if (c2 >= '\u0621' && c2 <= '\u06d3' && !ArabicLigaturizer.isVowel(c2)) {
            char[] arrc = maptable.get(Character.valueOf(c2));
            if (arrc != null) {
                return arrc.length - 1;
            }
        } else if (c2 == '\u200d') {
            return 4;
        }
        return 1;
    }

    @Override
    public boolean isRTL() {
        return true;
    }

    @Override
    public String process(String string2) {
        return BidiLine.processLTR(string2, this.runDirection, this.options);
    }

    static class charstruct {
        char basechar;
        int lignum;
        char mark1;
        int numshapes = 1;
        char vowel;

        charstruct() {
        }
    }

}

