/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.DocumentException;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.Glyph;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.TrueTypeFont;
import com.itextpdf.text.pdf.TtfUnicodeWriter;
import com.itextpdf.text.pdf.fonts.otf.GlyphSubstitutionTableReader;
import com.itextpdf.text.pdf.fonts.otf.Language;
import com.itextpdf.text.pdf.languages.ArabicLigaturizer;
import java.io.Serializable;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

class TrueTypeFontUnicode
extends TrueTypeFont
implements Comparator<int[]> {
    private static final List<Language> SUPPORTED_LANGUAGES_FOR_OTF = Arrays.asList(new Language[]{Language.BENGALI});
    private static final byte[] rotbits = new byte[]{-128, 64, 32, 16, 8, 4, 2, 1};
    private Map<String, Glyph> glyphSubstitutionMap;
    private Language supportedLanguage;

    TrueTypeFontUnicode(String charSequence, String string2, boolean bl2, byte[] arrby, boolean bl3) {
        String string3 = TrueTypeFontUnicode.getBaseName((String)charSequence);
        String string4 = TrueTypeFontUnicode.getTTCName(string3);
        if (string3.length() < charSequence.length()) {
            this.style = charSequence.substring(string3.length());
        }
        this.encoding = string2;
        this.embedded = bl2;
        this.fileName = string4;
        this.ttcIndex = "";
        if (string4.length() < string3.length()) {
            this.ttcIndex = string3.substring(string4.length() + 1);
        }
        this.fontType = 3;
        if ((this.fileName.toLowerCase().endsWith(".ttf") || this.fileName.toLowerCase().endsWith(".otf") || this.fileName.toLowerCase().endsWith(".ttc")) && (string2.equals("Identity-H") || string2.equals("Identity-V")) && bl2) {
            this.process(arrby, bl3);
            if (this.os_2.fsType != 2) {
                if (this.cmap31 == null && !this.fontSpecific || this.cmap10 == null && this.fontSpecific) {
                    this.directTextToByte = true;
                }
                if (this.fontSpecific) {
                    this.fontSpecific = false;
                    charSequence = this.encoding;
                    this.encoding = "";
                    this.createEncoding();
                    this.encoding = charSequence;
                    this.fontSpecific = true;
                }
                this.vertical = string2.endsWith("V");
                return;
            }
            charSequence = new StringBuilder();
            charSequence.append(this.fileName);
            charSequence.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("1.cannot.be.embedded.due.to.licensing.restrictions", charSequence.toString()));
        }
        throw new DocumentException(MessageLocalization.getComposedMessage("1.2.is.not.a.ttf.font.file", this.fileName, this.style));
    }

    private void readGsubTable() {
        if (this.tables.get("GSUB") != null) {
            Object object = new HashMap<Integer, Character>(this.cmap31.size());
            for (Integer n2 : this.cmap31.keySet()) {
                char c2 = (char)n2.intValue();
                object.put(((int[])this.cmap31.get(n2))[0], (Character)Character.valueOf(c2));
            }
            object = new GlyphSubstitutionTableReader(this.rf, ((int[])this.tables.get("GSUB"))[0], (Map<Integer, Character>)object, this.glyphWidthsByIndex);
            try {
                object.read();
                this.supportedLanguage = object.getSupportedLanguage();
                if (SUPPORTED_LANGUAGES_FOR_OTF.contains((Object)this.supportedLanguage)) {
                    this.glyphSubstitutionMap = object.getGlyphSubstitutionMap();
                    return;
                }
            }
            catch (Exception exception) {
                exception.printStackTrace();
            }
        }
    }

    static String toHex(int n2) {
        if (n2 < 65536) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("<");
            stringBuilder.append(TrueTypeFontUnicode.toHex4(n2));
            stringBuilder.append(">");
            return stringBuilder.toString();
        }
        int n3 = (n2 -= 65536) / 1024;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("[<");
        stringBuilder.append(TrueTypeFontUnicode.toHex4(n3 + 55296));
        stringBuilder.append(TrueTypeFontUnicode.toHex4(n2 % 1024 + 56320));
        stringBuilder.append(">]");
        return stringBuilder.toString();
    }

    private static String toHex4(int n2) {
        CharSequence charSequence = new StringBuilder();
        charSequence.append("0000");
        charSequence.append(Integer.toHexString(n2));
        charSequence = charSequence.toString();
        return charSequence.substring(charSequence.length() - 4);
    }

    public int GetCharFromGlyphId(int n2) {
        if (this.glyphIdToChar == null) {
            int[] arrn = new int[this.maxGlyphId];
            Object object = null;
            if (this.cmapExt != null) {
                object = this.cmapExt;
            } else if (this.cmap31 != null) {
                object = this.cmap31;
            }
            if (object != null) {
                for (Map.Entry entry : object.entrySet()) {
                    arrn[((int[])entry.getValue())[0]] = (Integer)entry.getKey();
                }
            }
            this.glyphIdToChar = arrn;
        }
        return this.glyphIdToChar[n2];
    }

    @Override
    public boolean charExists(int n2) {
        if (this.getMetricsTT(n2) != null) {
            return true;
        }
        return false;
    }

    @Override
    public int compare(int[] arrn, int[] arrn2) {
        int n2 = arrn[0];
        int n3 = arrn2[0];
        if (n2 < n3) {
            return -1;
        }
        if (n2 == n3) {
            return 0;
        }
        return 1;
    }

    @Override
    byte[] convertToBytes(int n2) {
        return null;
    }

    @Override
    public byte[] convertToBytes(String string2) {
        return null;
    }

    /*
     * Enabled aggressive block sorting
     */
    public PdfDictionary getCIDFontType2(PdfIndirectReference serializable, String object, Object[] arrobject) {
        Serializable serializable2;
        Serializable serializable3;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        if (this.cff) {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.CIDFONTTYPE0);
            serializable3 = PdfName.BASEFONT;
            serializable2 = new StringBuilder();
            serializable2.append((String)object);
            serializable2.append(this.fontName);
            serializable2.append("-");
            serializable2.append(this.encoding);
            serializable2 = new PdfName(serializable2.toString());
            object = serializable3;
        } else {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.CIDFONTTYPE2);
            serializable2 = PdfName.BASEFONT;
            serializable3 = new StringBuilder();
            serializable3.append((String)object);
            serializable3.append(this.fontName);
            serializable3 = new PdfName(serializable3.toString());
            object = serializable2;
            serializable2 = serializable3;
        }
        pdfDictionary.put((PdfName)object, (PdfObject)serializable2);
        pdfDictionary.put(PdfName.FONTDESCRIPTOR, (PdfObject)serializable);
        if (!this.cff) {
            pdfDictionary.put(PdfName.CIDTOGIDMAP, PdfName.IDENTITY);
        }
        serializable = new PdfDictionary();
        serializable.put(PdfName.REGISTRY, new PdfString("Adobe"));
        serializable.put(PdfName.ORDERING, new PdfString("Identity"));
        serializable.put(PdfName.SUPPLEMENT, new PdfNumber(0));
        pdfDictionary.put(PdfName.CIDSYSTEMINFO, (PdfObject)serializable);
        if (!this.vertical) {
            pdfDictionary.put(PdfName.DW, new PdfNumber(1000));
            serializable = new StringBuffer("[");
            int n2 = -10;
            boolean bl2 = true;
            for (int i2 = 0; i2 < arrobject.length; ++i2) {
                object = (int[])arrobject[i2];
                if (object[1] == 1000) continue;
                int n3 = object[0];
                if (n3 == n2 + 1) {
                    serializable.append(' ');
                    serializable.append(object[1]);
                } else {
                    if (!bl2) {
                        serializable.append(']');
                    }
                    serializable.append(n3);
                    serializable.append('[');
                    serializable.append(object[1]);
                    bl2 = false;
                }
                n2 = n3;
            }
            if (serializable.length() > 1) {
                serializable.append("]]");
                pdfDictionary.put(PdfName.W, new PdfLiteral(serializable.toString()));
            }
        }
        return pdfDictionary;
    }

    @Override
    public int[] getCharBBox(int n2) {
        if (this.bboxes == null) {
            return null;
        }
        int[] arrn = this.getMetricsTT(n2);
        if (arrn == null) {
            return null;
        }
        return this.bboxes[arrn[0]];
    }

    /*
     * Enabled aggressive block sorting
     */
    public PdfDictionary getFontBaseType(PdfIndirectReference pdfIndirectReference, String object, PdfIndirectReference pdfIndirectReference2) {
        Serializable serializable;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        pdfDictionary.put(PdfName.SUBTYPE, PdfName.TYPE0);
        if (this.cff) {
            PdfName pdfName = PdfName.BASEFONT;
            serializable = new StringBuilder();
            serializable.append((String)object);
            serializable.append(this.fontName);
            serializable.append("-");
            serializable.append(this.encoding);
            serializable = new PdfName(serializable.toString());
            object = pdfName;
        } else {
            serializable = PdfName.BASEFONT;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append((String)object);
            stringBuilder.append(this.fontName);
            PdfName pdfName = new PdfName(stringBuilder.toString());
            object = serializable;
            serializable = pdfName;
        }
        pdfDictionary.put((PdfName)object, (PdfObject)serializable);
        pdfDictionary.put(PdfName.ENCODING, new PdfName(this.encoding));
        pdfDictionary.put(PdfName.DESCENDANTFONTS, new PdfArray(pdfIndirectReference));
        if (pdfIndirectReference2 != null) {
            pdfDictionary.put(PdfName.TOUNICODE, pdfIndirectReference2);
        }
        return pdfDictionary;
    }

    @Override
    public PdfStream getFullFontStream() {
        if (this.cff) {
            return new BaseFont.StreamFont(this.readCffFont(), "CIDFontType0C", this.compressionLevel);
        }
        return super.getFullFontStream();
    }

    protected Map<String, Glyph> getGlyphSubstitutionMap() {
        return this.glyphSubstitutionMap;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public int[] getMetricsTT(int n2) {
        int[] arrn;
        HashMap hashMap;
        if (this.cmapExt != null) {
            hashMap = this.cmapExt;
            do {
                return (int[])hashMap.get(n2);
                break;
            } while (true);
        }
        hashMap = this.fontSpecific ? this.cmap10 : this.cmap31;
        if (hashMap == null) {
            return null;
        }
        if (this.fontSpecific) {
            int n3 = n2 & -256;
            if (n3 != 0) {
                if (n3 != 61440) return null;
            }
            n2 &= 255;
            return (int[])hashMap.get(n2);
        }
        int[] arrn2 = arrn = (int[])hashMap.get(n2);
        if (arrn != null) return arrn2;
        Character c2 = ArabicLigaturizer.getReverseMapping((char)n2);
        arrn2 = arrn;
        if (c2 == null) return arrn2;
        return (int[])hashMap.get(Integer.valueOf(c2.charValue()));
    }

    Language getSupportedLanguage() {
        return this.supportedLanguage;
    }

    public PdfStream getToUnicode(Object[] object) {
        if (((Object[])object).length == 0) {
            return null;
        }
        StringBuffer stringBuffer = new StringBuffer("/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo\n<< /Registry (TTX+0)\n/Ordering (T42UV)\n/Supplement 0\n>> def\n/CMapName /TTX+0 def\n/CMapType 2 def\n1 begincodespacerange\n<0000><FFFF>\nendcodespacerange\n");
        int n2 = 0;
        for (int i2 = 0; i2 < ((Object[])object).length; ++i2) {
            int n3 = n2;
            if (n2 == 0) {
                if (i2 != 0) {
                    stringBuffer.append("endbfrange\n");
                }
                n3 = Math.min(100, ((Object[])object).length - i2);
                stringBuffer.append(n3);
                stringBuffer.append(" beginbfrange\n");
            }
            n2 = n3 - 1;
            int[] arrn = (int[])object[i2];
            String string2 = TrueTypeFontUnicode.toHex(arrn[0]);
            stringBuffer.append(string2);
            stringBuffer.append(string2);
            stringBuffer.append(TrueTypeFontUnicode.toHex(arrn[2]));
            stringBuffer.append('\n');
        }
        stringBuffer.append("endbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend end\n");
        object = new PdfStream(PdfEncodings.convertToBytes(stringBuffer.toString(), null));
        object.flateCompress(this.compressionLevel);
        return object;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public int getWidth(int n2) {
        String string2;
        if (this.vertical) {
            return 1000;
        }
        if (this.fontSpecific) {
            int n3 = 65280 & n2;
            if (n3 != 0 && n3 != 61440) {
                return 0;
            }
            n2 &= 255;
            string2 = null;
            do {
                return this.getRawWidth(n2, string2);
                break;
            } while (true);
        }
        string2 = this.encoding;
        return this.getRawWidth(n2, string2);
    }

    @Override
    public int getWidth(String arrc) {
        int n2;
        block8 : {
            int n3;
            int n4;
            block9 : {
                if (this.vertical) {
                    return arrc.length() * 1000;
                }
                boolean bl2 = this.fontSpecific;
                n3 = 0;
                n4 = 0;
                if (!bl2) break block9;
                arrc = arrc.toCharArray();
                int n5 = arrc.length;
                n3 = 0;
                do {
                    block11 : {
                        char c2;
                        block10 : {
                            n2 = n3;
                            if (n4 >= n5) break block8;
                            c2 = arrc[n4];
                            int n6 = 65280 & c2;
                            if (n6 == 0) break block10;
                            n2 = n3;
                            if (n6 != 61440) break block11;
                        }
                        n2 = n3 + this.getRawWidth(c2 & 255, null);
                    }
                    ++n4;
                    n3 = n2;
                } while (true);
            }
            int n7 = arrc.length();
            n4 = 0;
            do {
                n2 = n4;
                if (n3 >= n7) break;
                if (Utilities.isSurrogatePair((String)arrc, n3)) {
                    n4 += this.getRawWidth(Utilities.convertToUtf32((String)arrc, n3), this.encoding);
                    ++n3;
                } else {
                    n4 += this.getRawWidth(arrc.charAt(n3), this.encoding);
                }
                ++n3;
            } while (true);
        }
        return n2;
    }

    @Override
    void process(byte[] arrby, boolean bl2) {
        super.process(arrby, bl2);
    }

    @Override
    public boolean setCharAdvance(int n2, int n3) {
        int[] arrn = this.getMetricsTT(n2);
        if (arrn == null) {
            return false;
        }
        arrn[1] = n3;
        return true;
    }

    @Override
    void writeFont(PdfWriter pdfWriter, PdfIndirectReference pdfIndirectReference, Object[] arrobject) {
        pdfWriter.getTtfUnicodeWriter().writeFont(this, pdfIndirectReference, arrobject, rotbits);
    }
}

