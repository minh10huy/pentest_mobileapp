/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.Chunk;
import com.itextpdf.text.Image;
import com.itextpdf.text.ListItem;
import com.itextpdf.text.TabStop;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.PdfChunk;
import com.itextpdf.text.pdf.PdfFont;
import java.util.ArrayList;
import java.util.Iterator;

public class PdfLine {
    protected int alignment;
    protected float height;
    protected boolean isRTL = false;
    protected float left;
    protected ArrayList<PdfChunk> line;
    protected ListItem listItem = null;
    protected boolean newlineSplit = false;
    protected float originalWidth;
    protected float tabPosition = Float.NaN;
    protected TabStop tabStop = null;
    protected float tabStopAnchorPosition = Float.NaN;
    protected float width;

    PdfLine(float f2, float f3, float f4, int n2, boolean bl2, ArrayList<PdfChunk> arrayList, boolean bl3) {
        this.left = f2;
        this.originalWidth = f3;
        this.width = f4;
        this.alignment = n2;
        this.line = arrayList;
        this.newlineSplit = bl2;
        this.isRTL = bl3;
    }

    PdfLine(float f2, float f3, int n2, float f4) {
        this.left = f2;
        this.originalWidth = this.width = f3 - f2;
        this.alignment = n2;
        this.height = f4;
        this.line = new ArrayList();
    }

    private void addToLine(PdfChunk pdfChunk) {
        float f2;
        int n2;
        Object object;
        if (pdfChunk.changeLeading) {
            if (pdfChunk.isImage()) {
                object = pdfChunk.getImage();
                f2 = pdfChunk.getImageHeight() + pdfChunk.getImageOffsetY() + object.getBorderWidthTop() + object.getSpacingBefore();
            } else {
                f2 = pdfChunk.getLeading();
            }
            if (f2 > this.height) {
                this.height = f2;
            }
        }
        if (this.tabStop != null && this.tabStop.getAlignment() == TabStop.Alignment.ANCHOR && Float.isNaN(this.tabStopAnchorPosition) && (n2 = (object = pdfChunk.toString()).indexOf(this.tabStop.getAnchorChar())) != -1) {
            f2 = pdfChunk.width(object.substring(n2, object.length()));
            this.tabStopAnchorPosition = this.originalWidth - this.width - f2;
        }
        this.line.add(pdfChunk);
    }

    /*
     * Enabled aggressive block sorting
     */
    PdfChunk add(PdfChunk pdfChunk) {
        PdfChunk pdfChunk2;
        block22 : {
            block23 : {
                float f2;
                block21 : {
                    block16 : {
                        Object[] arrobject;
                        block17 : {
                            block18 : {
                                block20 : {
                                    block19 : {
                                        if (pdfChunk == null) {
                                            return null;
                                        }
                                        if (pdfChunk.toString().equals("")) {
                                            return null;
                                        }
                                        pdfChunk2 = pdfChunk.split(this.width);
                                        boolean bl2 = pdfChunk.isNewlineSplit() || pdfChunk2 == null;
                                        this.newlineSplit = bl2;
                                        if (!pdfChunk.isTab()) break block16;
                                        arrobject = (Object[])pdfChunk.getAttribute("TAB");
                                        if (!pdfChunk.isAttribute("TABSETTINGS")) break block17;
                                        bl2 = (Boolean)arrobject[1];
                                        if (bl2 && this.line.isEmpty()) {
                                            return null;
                                        }
                                        this.flush();
                                        this.tabStopAnchorPosition = Float.NaN;
                                        this.tabStop = PdfChunk.getTabStop(pdfChunk, this.originalWidth - this.width);
                                        if (this.tabStop.getPosition() <= this.originalWidth) break block18;
                                        if (bl2) break block19;
                                        if ((double)Math.abs(this.originalWidth - this.width) >= 0.001) break block20;
                                        this.addToLine(pdfChunk);
                                    }
                                    pdfChunk = null;
                                }
                                f2 = 0.0f;
                                break block21;
                            }
                            pdfChunk.setTabStop(this.tabStop);
                            if (!this.isRTL && this.tabStop.getAlignment() == TabStop.Alignment.LEFT) {
                                this.width = this.originalWidth - this.tabStop.getPosition();
                                this.tabStop = null;
                                this.tabPosition = Float.NaN;
                            } else {
                                this.tabPosition = this.originalWidth - this.width;
                            }
                            break block22;
                        }
                        Float f3 = Float.valueOf(((Float)arrobject[1]).floatValue());
                        if (((Boolean)arrobject[2]).booleanValue() && f3.floatValue() < this.originalWidth - this.width) {
                            return pdfChunk;
                        }
                        pdfChunk.adjustLeft(this.left);
                        this.width = this.originalWidth - f3.floatValue();
                        break block22;
                    }
                    if (pdfChunk.length() > 0 || pdfChunk.isImage()) break block23;
                    if (this.line.size() < 1) {
                        pdfChunk = pdfChunk2.truncate(this.width);
                        this.width -= pdfChunk2.width();
                        if (pdfChunk2.length() > 0) {
                            this.addToLine(pdfChunk2);
                            return pdfChunk;
                        }
                        if (pdfChunk != null) {
                            this.addToLine(pdfChunk);
                        }
                        return null;
                    }
                    f2 = this.width + this.line.get(this.line.size() - 1).trimLastSpace();
                    pdfChunk = pdfChunk2;
                }
                this.width = f2;
                return pdfChunk;
            }
            if (pdfChunk2 != null) {
                pdfChunk.trimLastSpace();
            }
            this.width -= pdfChunk.width();
        }
        this.addToLine(pdfChunk);
        return pdfChunk2;
    }

    PdfChunk add(PdfChunk pdfChunk, float f2) {
        if (!(pdfChunk == null || pdfChunk.toString().equals("") || pdfChunk.toString().equals(" ") || this.height >= f2 && !this.line.isEmpty())) {
            this.height = f2;
        }
        return this.add(pdfChunk);
    }

    /*
     * Enabled aggressive block sorting
     */
    public void flush() {
        if (this.tabStop != null) {
            TabStop tabStop;
            float f2 = this.originalWidth;
            float f3 = this.width;
            float f4 = this.tabPosition;
            float f5 = this.tabStop.getPosition(this.tabPosition, this.originalWidth - this.width, this.tabStopAnchorPosition);
            this.width = this.originalWidth - f5 - (f2 - f3 - f4);
            f2 = f5;
            if (this.width < 0.0f) {
                f2 = f5 + this.width;
            }
            if (!this.isRTL) {
                tabStop = this.tabStop;
            } else {
                tabStop = this.tabStop;
                f2 = this.originalWidth - this.width - this.tabPosition;
            }
            tabStop.setPosition(f2);
            this.tabStop = null;
            this.tabPosition = Float.NaN;
        }
    }

    public float getAscender() {
        float f2 = 0.0f;
        for (int i2 = 0; i2 < this.line.size(); ++i2) {
            PdfChunk pdfChunk = this.line.get(i2);
            if (pdfChunk.isImage()) {
                f2 = Math.max(f2, pdfChunk.getImageHeight() + pdfChunk.getImageOffsetY());
                continue;
            }
            PdfFont pdfFont = pdfChunk.font();
            float f3 = pdfChunk.getTextRise();
            if (f3 <= 0.0f) {
                f3 = 0.0f;
            }
            f2 = Math.max(f2, f3 + pdfFont.getFont().getFontDescriptor(1, pdfFont.size()));
        }
        return f2;
    }

    public PdfChunk getChunk(int n2) {
        if (n2 >= 0 && n2 < this.line.size()) {
            return this.line.get(n2);
        }
        return null;
    }

    /*
     * Enabled aggressive block sorting
     */
    public float getDescender() {
        int n2 = 0;
        float f2 = 0.0f;
        while (n2 < this.line.size()) {
            float f3;
            PdfChunk pdfChunk = this.line.get(n2);
            if (pdfChunk.isImage()) {
                f3 = pdfChunk.getImageOffsetY();
            } else {
                PdfFont pdfFont = pdfChunk.font();
                f3 = pdfChunk.getTextRise();
                if (f3 >= 0.0f) {
                    f3 = 0.0f;
                }
                f3 += pdfFont.getFont().getFontDescriptor(3, pdfFont.size());
            }
            f2 = Math.min(f2, f3);
            ++n2;
        }
        return f2;
    }

    public int getLastStrokeChunk() {
        int n2;
        for (n2 = this.line.size() - 1; n2 >= 0; --n2) {
            if (!this.line.get(n2).isStroked()) continue;
            return n2;
        }
        return n2;
    }

    public int getLineLengthUtf32() {
        Iterator<PdfChunk> iterator = this.line.iterator();
        int n2 = 0;
        while (iterator.hasNext()) {
            n2 += iterator.next().lengthUtf32();
        }
        return n2;
    }

    /*
     * Enabled aggressive block sorting
     */
    float[] getMaxSize(float f2, float f3) {
        float f4 = 0.0f;
        float f5 = -10000.0f;
        for (int i2 = 0; i2 < this.line.size(); ++i2) {
            float f6;
            float f7;
            PdfChunk pdfChunk = this.line.get(i2);
            if (pdfChunk.isImage()) {
                Image image = pdfChunk.getImage();
                f7 = f4;
                f6 = f5;
                if (pdfChunk.changeLeading()) {
                    f6 = Math.max(pdfChunk.getImageHeight() + pdfChunk.getImageOffsetY() + image.getSpacingBefore(), f5);
                    f7 = f4;
                }
            } else {
                f7 = pdfChunk.changeLeading() ? pdfChunk.getLeading() : pdfChunk.font().size() * f3 + f2;
                f7 = Math.max(f7, f4);
                f6 = f5;
            }
            f4 = f7;
            f5 = f6;
        }
        if (f4 > 0.0f) {
            f2 = f4;
        }
        return new float[]{f2, f5};
    }

    public float getOriginalWidth() {
        return this.originalWidth;
    }

    int getSeparatorCount() {
        Iterator<PdfChunk> iterator = this.line.iterator();
        int n2 = 0;
        while (iterator.hasNext()) {
            PdfChunk pdfChunk = iterator.next();
            if (pdfChunk.isTab()) {
                if (pdfChunk.isAttribute("TABSETTINGS")) continue;
                return -1;
            }
            if (!pdfChunk.isHorizontalSeparator()) continue;
            ++n2;
        }
        return n2;
    }

    public float getWidthCorrected(float f2, float f3) {
        float f4 = 0.0f;
        for (int i2 = 0; i2 < this.line.size(); ++i2) {
            f4 += this.line.get(i2).getWidthCorrected(f2, f3);
        }
        return f4;
    }

    public boolean hasToBeJustified() {
        if ((this.alignment == 3 && !this.newlineSplit || this.alignment == 8) && this.width != 0.0f) {
            return true;
        }
        return false;
    }

    float height() {
        return this.height;
    }

    float indentLeft() {
        if (this.isRTL) {
            switch (this.alignment) {
                default: {
                    return this.left + this.width;
                }
                case 3: {
                    float f2 = this.left;
                    float f3 = this.hasToBeJustified() ? 0.0f : this.width;
                    return f2 + f3;
                }
                case 2: {
                    return this.left;
                }
                case 1: 
            }
            return this.left + this.width / 2.0f;
        }
        if (this.getSeparatorCount() <= 0) {
            switch (this.alignment) {
                default: {
                    break;
                }
                case 2: {
                    return this.left + this.width;
                }
                case 1: {
                    return this.left + this.width / 2.0f;
                }
            }
        }
        return this.left;
    }

    public boolean isNewlineSplit() {
        if (this.newlineSplit && this.alignment != 8) {
            return true;
        }
        return false;
    }

    boolean isRTL() {
        return this.isRTL;
    }

    public Iterator<PdfChunk> iterator() {
        return this.line.iterator();
    }

    public float listIndent() {
        if (this.listItem != null) {
            return this.listItem.getIndentationLeft();
        }
        return 0.0f;
    }

    public ListItem listItem() {
        return this.listItem;
    }

    public Chunk listSymbol() {
        if (this.listItem != null) {
            return this.listItem.getListSymbol();
        }
        return null;
    }

    int numberOfSpaces() {
        Iterator<PdfChunk> iterator = this.line.iterator();
        int n2 = 0;
        while (iterator.hasNext()) {
            String string2 = iterator.next().toString();
            int n3 = string2.length();
            for (int i2 = 0; i2 < n3; ++i2) {
                int n4 = n2;
                if (string2.charAt(i2) == ' ') {
                    n4 = n2 + 1;
                }
                n2 = n4;
            }
        }
        return n2;
    }

    public void resetAlignment() {
        if (this.alignment == 3) {
            this.alignment = 0;
        }
    }

    void setExtraIndent(float f2) {
        this.left += f2;
        this.width -= f2;
        this.originalWidth -= f2;
    }

    public void setListItem(ListItem listItem) {
        this.listItem = listItem;
    }

    public int size() {
        return this.line.size();
    }

    public String toString() {
        StringBuffer stringBuffer = new StringBuffer();
        Iterator<PdfChunk> iterator = this.line.iterator();
        while (iterator.hasNext()) {
            stringBuffer.append(iterator.next().toString());
        }
        return stringBuffer.toString();
    }

    float widthLeft() {
        return this.width;
    }
}

