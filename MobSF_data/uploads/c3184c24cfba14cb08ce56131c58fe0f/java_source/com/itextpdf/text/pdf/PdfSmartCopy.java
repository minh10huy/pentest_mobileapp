/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.Document;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.log.Counter;
import com.itextpdf.text.log.CounterFactory;
import com.itextpdf.text.log.Logger;
import com.itextpdf.text.log.LoggerFactory;
import com.itextpdf.text.pdf.ByteBuffer;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfCopy;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfImportedPage;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfReaderInstance;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RefKey;
import java.io.OutputStream;
import java.security.MessageDigest;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Set;

public class PdfSmartCopy
extends PdfCopy {
    private static final Logger LOGGER = LoggerFactory.getLogger(PdfSmartCopy.class);
    protected Counter COUNTER = CounterFactory.getCounter(PdfSmartCopy.class);
    private final HashMap<RefKey, Integer> serialized = new HashMap();
    private HashMap<ByteStore, PdfIndirectReference> streamMap = new HashMap();

    public PdfSmartCopy(Document document, OutputStream outputStream) {
        super(document, outputStream);
    }

    @Override
    public void addPage(PdfImportedPage pdfImportedPage) {
        if (this.currentPdfReaderInstance.getReader() != this.reader) {
            this.serialized.clear();
        }
        super.addPage(pdfImportedPage);
    }

    @Override
    protected PdfIndirectReference copyIndirect(PRIndirectReference object) {
        ByteStore byteStore;
        PdfIndirectReference pdfIndirectReference;
        PdfObject pdfObject = PdfReader.getPdfObjectRelease((PdfObject)object);
        boolean bl2 = pdfObject.isStream();
        boolean bl3 = true;
        if (bl2) {
            byteStore = new ByteStore((PRStream)pdfObject, this.serialized);
            pdfIndirectReference = this.streamMap.get(byteStore);
            if (pdfIndirectReference != null) {
                return pdfIndirectReference;
            }
        } else if (pdfObject.isDictionary()) {
            byteStore = new ByteStore((PdfDictionary)pdfObject, this.serialized);
            pdfIndirectReference = this.streamMap.get(byteStore);
            if (pdfIndirectReference != null) {
                return pdfIndirectReference;
            }
        } else {
            byteStore = null;
            bl3 = false;
        }
        Object object2 = new RefKey((PRIndirectReference)object);
        object = (PdfCopy.IndirectReferences)this.indirects.get(object2);
        if (object != null) {
            pdfIndirectReference = object.getRef();
            if (object.getCopied()) {
                return pdfIndirectReference;
            }
        } else {
            pdfIndirectReference = this.body.getPdfIndirectReference();
            object = new PdfCopy.IndirectReferences(pdfIndirectReference);
            this.indirects.put(object2, object);
        }
        if (pdfObject.isDictionary() && (object2 = PdfReader.getPdfObjectRelease(((PdfDictionary)pdfObject).get(PdfName.TYPE))) != null) {
            if (PdfName.PAGE.equals(object2)) {
                return pdfIndirectReference;
            }
            if (PdfName.CATALOG.equals(object2)) {
                LOGGER.warn(MessageLocalization.getComposedMessage("make.copy.of.catalog.dictionary.is.forbidden", new Object[0]));
                return null;
            }
        }
        object.setCopied();
        if (bl3) {
            this.streamMap.put(byteStore, pdfIndirectReference);
        }
        this.addToBody(this.copyObject(pdfObject), pdfIndirectReference);
        return pdfIndirectReference;
    }

    @Override
    public void freeReader(PdfReader pdfReader) {
        this.serialized.clear();
        super.freeReader(pdfReader);
    }

    @Override
    protected Counter getCounter() {
        return this.COUNTER;
    }

    static class ByteStore {
        private final byte[] b;
        private final int hash;
        private MessageDigest md5;

        ByteStore(PRStream pRStream, HashMap<RefKey, Integer> hashMap) {
            try {
                this.md5 = MessageDigest.getInstance("MD5");
                ByteBuffer byteBuffer = new ByteBuffer();
                this.serObject(pRStream, 100, byteBuffer, hashMap);
                this.b = byteBuffer.toByteArray();
            }
            catch (Exception exception) {
                throw new ExceptionConverter(exception);
            }
            this.hash = ByteStore.calculateHash(this.b);
            this.md5 = null;
        }

        ByteStore(PdfDictionary pdfDictionary, HashMap<RefKey, Integer> hashMap) {
            try {
                this.md5 = MessageDigest.getInstance("MD5");
                ByteBuffer byteBuffer = new ByteBuffer();
                this.serObject(pdfDictionary, 100, byteBuffer, hashMap);
                this.b = byteBuffer.toByteArray();
            }
            catch (Exception exception) {
                throw new ExceptionConverter(exception);
            }
            this.hash = ByteStore.calculateHash(this.b);
            this.md5 = null;
        }

        private static int calculateHash(byte[] arrby) {
            int n2 = arrby.length;
            int n3 = 0;
            for (int i2 = 0; i2 < n2; ++i2) {
                n3 = n3 * 31 + (arrby[i2] & 255);
            }
            return n3;
        }

        private void serArray(PdfArray pdfArray, int n2, ByteBuffer byteBuffer, HashMap<RefKey, Integer> hashMap) {
            byteBuffer.append("$A");
            if (n2 <= 0) {
                return;
            }
            for (int i2 = 0; i2 < pdfArray.size(); ++i2) {
                this.serObject(pdfArray.getPdfObject(i2), n2, byteBuffer, hashMap);
            }
        }

        private void serDic(PdfDictionary pdfDictionary, int n2, ByteBuffer byteBuffer, HashMap<RefKey, Integer> hashMap) {
            byteBuffer.append("$D");
            if (n2 <= 0) {
                return;
            }
            Object[] arrobject = pdfDictionary.getKeys().toArray();
            Arrays.sort(arrobject);
            for (int i2 = 0; i2 < arrobject.length; ++i2) {
                if (arrobject[i2].equals(PdfName.P) && (pdfDictionary.get((PdfName)arrobject[i2]).isIndirect() || pdfDictionary.get((PdfName)arrobject[i2]).isDictionary())) continue;
                this.serObject((PdfObject)arrobject[i2], n2, byteBuffer, hashMap);
                this.serObject(pdfDictionary.get((PdfName)arrobject[i2]), n2, byteBuffer, hashMap);
            }
        }

        /*
         * Enabled aggressive block sorting
         */
        private void serObject(PdfObject object, int n2, ByteBuffer byteBuffer, HashMap<RefKey, Integer> hashMap) {
            PdfObject pdfObject;
            Object object2;
            if (n2 <= 0) {
                return;
            }
            if (object == null) {
                byteBuffer.append("$Lnull");
                return;
            }
            boolean bl2 = object.isIndirect();
            PdfIndirectReference pdfIndirectReference = null;
            if (bl2) {
                pdfIndirectReference = (PdfIndirectReference)object;
                object2 = new RefKey(pdfIndirectReference);
                if (hashMap.containsKey(object2)) {
                    byteBuffer.append(hashMap.get(object2));
                    return;
                }
                object2 = new ByteBuffer();
            } else {
                pdfObject = null;
                object2 = byteBuffer;
                byteBuffer = pdfObject;
            }
            pdfObject = PdfReader.getPdfObject((PdfObject)object);
            if (pdfObject.isStream()) {
                object2.append("$B");
                this.serDic((PdfDictionary)pdfObject, n2 - 1, (ByteBuffer)object2, hashMap);
                if (n2 > 0) {
                    this.md5.reset();
                    object2.append(this.md5.digest(PdfReader.getStreamBytesRaw((PRStream)pdfObject)));
                }
            } else if (pdfObject.isDictionary()) {
                this.serDic((PdfDictionary)pdfObject, n2 - 1, (ByteBuffer)object2, hashMap);
            } else if (pdfObject.isArray()) {
                this.serArray((PdfArray)pdfObject, n2 - 1, (ByteBuffer)object2, hashMap);
            } else {
                object = pdfObject.isString() ? "$S" : (pdfObject.isName() ? "$N" : "$L");
                object2.append((String)object).append(pdfObject.toString());
            }
            if (byteBuffer != null) {
                object = new RefKey(pdfIndirectReference);
                if (!hashMap.containsKey(object)) {
                    hashMap.put((RefKey)object, ByteStore.calculateHash(object2.getBuffer()));
                }
                byteBuffer.append((ByteBuffer)object2);
            }
        }

        public boolean equals(Object object) {
            if (!(object instanceof ByteStore)) {
                return false;
            }
            if (this.hashCode() != object.hashCode()) {
                return false;
            }
            return Arrays.equals(this.b, ((ByteStore)object).b);
        }

        public int hashCode() {
            return this.hash;
        }
    }

}

