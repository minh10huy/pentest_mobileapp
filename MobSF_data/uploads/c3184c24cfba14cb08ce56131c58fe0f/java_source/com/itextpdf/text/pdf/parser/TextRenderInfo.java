/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.pdf.CMapAwareDocumentFont;
import com.itextpdf.text.pdf.DocumentFont;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.parser.GraphicsState;
import com.itextpdf.text.pdf.parser.LineSegment;
import com.itextpdf.text.pdf.parser.MarkedContentInfo;
import com.itextpdf.text.pdf.parser.Matrix;
import com.itextpdf.text.pdf.parser.Vector;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

public class TextRenderInfo {
    private double[] fontMatrix = null;
    private final GraphicsState gs;
    private final Collection<MarkedContentInfo> markedContentInfos;
    private final PdfString string;
    private String text = null;
    private final Matrix textToUserSpaceTransformMatrix;
    private Float unscaledWidth = null;

    TextRenderInfo(PdfString pdfString, GraphicsState graphicsState, Matrix matrix, Collection<MarkedContentInfo> collection) {
        this.string = pdfString;
        this.textToUserSpaceTransformMatrix = matrix.multiply(graphicsState.ctm);
        this.gs = graphicsState;
        this.markedContentInfos = new ArrayList<MarkedContentInfo>(collection);
        this.fontMatrix = graphicsState.font.getFontMatrix();
    }

    private TextRenderInfo(TextRenderInfo textRenderInfo, PdfString pdfString, float f2) {
        this.string = pdfString;
        this.textToUserSpaceTransformMatrix = new Matrix(f2, 0.0f).multiply(textRenderInfo.textToUserSpaceTransformMatrix);
        this.gs = textRenderInfo.gs;
        this.markedContentInfos = textRenderInfo.markedContentInfos;
        this.fontMatrix = this.gs.font.getFontMatrix();
    }

    private float convertHeightFromTextSpaceToUserSpace(float f2) {
        return new LineSegment(new Vector(0.0f, 0.0f, 1.0f), new Vector(0.0f, f2, 1.0f)).transformBy(this.textToUserSpaceTransformMatrix).getLength();
    }

    private float convertWidthFromTextSpaceToUserSpace(float f2) {
        return new LineSegment(new Vector(0.0f, 0.0f, 1.0f), new Vector(f2, 0.0f, 1.0f)).transformBy(this.textToUserSpaceTransformMatrix).getLength();
    }

    private String decode(PdfString arrby) {
        arrby = arrby.getBytes();
        return this.gs.font.decode(arrby, 0, arrby.length);
    }

    private int getCharCode(String arrby) {
        arrby = arrby.getBytes("UTF-16BE");
        int n2 = 0;
        int n3 = 0;
        do {
            if (n2 >= arrby.length - 1) break;
            n3 = n3 + (arrby[n2] & 255) << 8;
            ++n2;
        } while (true);
        n2 = n3;
        try {
            if (arrby.length > 0) {
                n2 = arrby[arrby.length - 1];
                n2 = n3 + (n2 & 255);
            }
            return n2;
        }
        catch (UnsupportedEncodingException unsupportedEncodingException) {
            return 0;
        }
    }

    private float getPdfStringWidth(PdfString arrobject, boolean bl2) {
        if (bl2) {
            arrobject = this.getWidthAndWordSpacing((PdfString)arrobject, bl2);
            return (arrobject[0] * this.gs.fontSize + this.gs.characterSpacing + arrobject[1]) * this.gs.horizontalScaling;
        }
        float f2 = 0.0f;
        arrobject = this.splitString((PdfString)arrobject);
        int n2 = arrobject.length;
        for (int i2 = 0; i2 < n2; ++i2) {
            f2 += this.getPdfStringWidth((PdfString)arrobject[i2], true);
        }
        return f2;
    }

    private float getStringWidth(String string2) {
        float f2 = 0.0f;
        for (int i2 = 0; i2 < string2.length(); ++i2) {
            char c2 = string2.charAt(i2);
            float f3 = (float)this.gs.font.getWidth(c2) / 1000.0f;
            float f4 = c2 == ' ' ? this.gs.wordSpacing : 0.0f;
            f2 += (f3 * this.gs.fontSize + this.gs.characterSpacing + f4) * this.gs.horizontalScaling;
        }
        return f2;
    }

    private LineSegment getUnscaledBaselineWithOffset(float f2) {
        String string2 = this.string.toUnicodeString();
        float f3 = this.getUnscaledWidth();
        float f4 = this.gs.characterSpacing;
        float f5 = string2.length() > 0 && string2.charAt(string2.length() - 1) == ' ' ? this.gs.wordSpacing : 0.0f;
        float f6 = this.gs.horizontalScaling;
        return new LineSegment(new Vector(0.0f, f2, 1.0f), new Vector(f3 - (f4 + f5) * f6, f2, 1.0f));
    }

    private float getUnscaledFontSpaceWidth() {
        CMapAwareDocumentFont cMapAwareDocumentFont = this.gs.font;
        char c2 = ' ';
        if (cMapAwareDocumentFont.getWidth(32) == 0) {
            c2 = '\u00a0';
        }
        return this.getStringWidth(String.valueOf(c2));
    }

    private float[] getWidthAndWordSpacing(PdfString object, boolean bl2) {
        if (bl2) {
            object = this.decode((PdfString)object);
            float f2 = (float)((double)this.gs.font.getWidth(this.getCharCode((String)object)) * this.fontMatrix[0]);
            float f3 = object.equals(" ") ? this.gs.wordSpacing : 0.0f;
            return new float[]{f2, f3};
        }
        throw new UnsupportedOperationException();
    }

    private PdfString[] splitString(PdfString pdfString) {
        ArrayList<PdfString> arrayList = new ArrayList<PdfString>();
        String string2 = pdfString.toString();
        int n2 = 0;
        while (n2 < string2.length()) {
            int n3 = n2 + 1;
            PdfString pdfString2 = new PdfString(string2.substring(n2, n3), pdfString.getEncoding());
            int n4 = n2;
            PdfString pdfString3 = pdfString2;
            if (this.decode(pdfString2).length() == 0) {
                n4 = n2;
                pdfString3 = pdfString2;
                if (n2 < string2.length() - 1) {
                    pdfString3 = new PdfString(string2.substring(n2, n2 + 2), pdfString.getEncoding());
                    n4 = n3;
                }
            }
            arrayList.add(pdfString3);
            n2 = n4 + 1;
        }
        return arrayList.toArray(new PdfString[arrayList.size()]);
    }

    public LineSegment getAscentLine() {
        return this.getUnscaledBaselineWithOffset(this.gs.getFont().getFontDescriptor(1, this.gs.getFontSize()) + this.gs.rise).transformBy(this.textToUserSpaceTransformMatrix);
    }

    public LineSegment getBaseline() {
        return this.getUnscaledBaselineWithOffset(this.gs.rise + 0.0f).transformBy(this.textToUserSpaceTransformMatrix);
    }

    public List<TextRenderInfo> getCharacterRenderInfos() {
        ArrayList<TextRenderInfo> arrayList = new ArrayList<TextRenderInfo>(this.string.length());
        Object object = this.splitString(this.string);
        float f2 = 0.0f;
        for (int i2 = 0; i2 < ((PdfString[])object).length; ++i2) {
            float[] arrf = this.getWidthAndWordSpacing(object[i2], true);
            arrayList.add(new TextRenderInfo(this, (PdfString)object[i2], f2));
            f2 += (arrf[0] * this.gs.fontSize + this.gs.characterSpacing + arrf[1]) * this.gs.horizontalScaling;
        }
        object = arrayList.iterator();
        while (object.hasNext()) {
            ((TextRenderInfo)object.next()).getUnscaledWidth();
        }
        return arrayList;
    }

    public LineSegment getDescentLine() {
        return this.getUnscaledBaselineWithOffset(this.gs.getFont().getFontDescriptor(3, this.gs.getFontSize()) + this.gs.rise).transformBy(this.textToUserSpaceTransformMatrix);
    }

    public BaseColor getFillColor() {
        return this.gs.fillColor;
    }

    public DocumentFont getFont() {
        return this.gs.getFont();
    }

    public Integer getMcid() {
        Integer n2;
        boolean bl2 = this.markedContentInfos instanceof ArrayList;
        Integer n3 = n2 = null;
        if (bl2) {
            Object object = (ArrayList)this.markedContentInfos;
            object = object.size() > 0 ? (MarkedContentInfo)object.get(object.size() - 1) : null;
            n3 = n2;
            if (object != null) {
                n3 = n2;
                if (object.hasMcid()) {
                    n3 = object.getMcid();
                }
            }
        }
        return n3;
    }

    public PdfString getPdfString() {
        return this.string;
    }

    public float getRise() {
        if (this.gs.rise == 0.0f) {
            return 0.0f;
        }
        return this.convertHeightFromTextSpaceToUserSpace(this.gs.rise);
    }

    public float getSingleSpaceWidth() {
        return this.convertWidthFromTextSpaceToUserSpace(this.getUnscaledFontSpaceWidth());
    }

    public BaseColor getStrokeColor() {
        return this.gs.strokeColor;
    }

    public String getText() {
        if (this.text == null) {
            this.text = this.decode(this.string);
        }
        return this.text;
    }

    public int getTextRenderMode() {
        return this.gs.renderMode;
    }

    public LineSegment getUnscaledBaseline() {
        return this.getUnscaledBaselineWithOffset(this.gs.rise + 0.0f);
    }

    float getUnscaledWidth() {
        if (this.unscaledWidth == null) {
            this.unscaledWidth = Float.valueOf(this.getPdfStringWidth(this.string, false));
        }
        return this.unscaledWidth.floatValue();
    }

    public boolean hasMcid(int n2) {
        return this.hasMcid(n2, false);
    }

    public boolean hasMcid(int n2, boolean bl2) {
        boolean bl3 = false;
        if (bl2) {
            if (this.markedContentInfos instanceof ArrayList) {
                Integer n3 = this.getMcid();
                bl2 = bl3;
                if (n3 != null) {
                    bl2 = bl3;
                    if (n3 == n2) {
                        bl2 = true;
                    }
                }
                return bl2;
            }
        } else {
            for (MarkedContentInfo markedContentInfo : this.markedContentInfos) {
                if (!markedContentInfo.hasMcid() || markedContentInfo.getMcid() != n2) continue;
                return true;
            }
        }
        return false;
    }
}

