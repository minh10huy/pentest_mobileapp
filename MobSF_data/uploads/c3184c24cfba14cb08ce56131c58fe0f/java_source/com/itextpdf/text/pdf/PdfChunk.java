/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Chunk;
import com.itextpdf.text.Font;
import com.itextpdf.text.Image;
import com.itextpdf.text.SplitCharacter;
import com.itextpdf.text.TabSettings;
import com.itextpdf.text.TabStop;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.DefaultSplitCharacter;
import com.itextpdf.text.pdf.HyphenationEvent;
import com.itextpdf.text.pdf.PdfAction;
import com.itextpdf.text.pdf.PdfFont;
import com.itextpdf.text.pdf.interfaces.IAccessibleElement;
import java.io.Serializable;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class PdfChunk {
    private static final float ITALIC_ANGLE = 0.21256f;
    private static final String TABSTOP = "TABSTOP";
    public static final float UNDERLINE_OFFSET = -0.33333334f;
    public static final float UNDERLINE_THICKNESS = 0.06666667f;
    private static final HashSet<String> keysAttributes;
    private static final HashSet<String> keysNoStroke;
    private static final char[] singleSpace;
    protected IAccessibleElement accessibleElement = null;
    protected HashMap<String, Object> attributes = new HashMap();
    protected BaseFont baseFont;
    protected boolean changeLeading = false;
    protected String encoding = "Cp1252";
    protected PdfFont font;
    protected Image image;
    protected float imageScalePercentage = 1.0f;
    protected float leading = 0.0f;
    protected boolean newlineSplit;
    protected HashMap<String, Object> noStroke = new HashMap();
    protected float offsetX;
    protected float offsetY;
    protected SplitCharacter splitCharacter;
    protected String value = "";

    static {
        singleSpace = new char[]{' '};
        keysAttributes = new HashSet();
        keysNoStroke = new HashSet();
        keysAttributes.add("ACTION");
        keysAttributes.add("UNDERLINE");
        keysAttributes.add("REMOTEGOTO");
        keysAttributes.add("LOCALGOTO");
        keysAttributes.add("LOCALDESTINATION");
        keysAttributes.add("GENERICTAG");
        keysAttributes.add("NEWPAGE");
        keysAttributes.add("IMAGE");
        keysAttributes.add("BACKGROUND");
        keysAttributes.add("PDFANNOTATION");
        keysAttributes.add("SKEW");
        keysAttributes.add("HSCALE");
        keysAttributes.add("SEPARATOR");
        keysAttributes.add("TAB");
        keysAttributes.add("TABSETTINGS");
        keysAttributes.add("CHAR_SPACING");
        keysAttributes.add("WORD_SPACING");
        keysAttributes.add("LINEHEIGHT");
        keysNoStroke.add("SUBSUPSCRIPT");
        keysNoStroke.add("SPLITCHARACTER");
        keysNoStroke.add("HYPHENATION");
        keysNoStroke.add("TEXTRENDERMODE");
    }

    /*
     * Enabled aggressive block sorting
     */
    PdfChunk(Chunk chunk, PdfAction serializable) {
        float[] arrf;
        int n2;
        float f2;
        this.value = chunk.getContent();
        Font font = chunk.getFont();
        float f3 = f2 = font.getSize();
        if (f2 == -1.0f) {
            f3 = 12.0f;
        }
        this.baseFont = font.getBaseFont();
        int n3 = n2 = font.getStyle();
        if (n2 == -1) {
            n3 = 0;
        }
        if (this.baseFont == null) {
            this.baseFont = font.getCalculatedBaseFont(false);
        } else {
            if ((n3 & 1) != 0) {
                this.attributes.put("TEXTRENDERMODE", new Object[]{2, new Float(f3 / 30.0f), null});
            }
            if ((n3 & 2) != 0) {
                this.attributes.put("SKEW", new float[]{0.0f, 0.21256f});
            }
        }
        this.font = new PdfFont(this.baseFont, f3);
        HashMap<String, Object> hashMap = chunk.getAttributes();
        if (hashMap != null) {
            for (Map.Entry<String, Object> entry : hashMap.entrySet()) {
                String string2 = entry.getKey();
                if (keysAttributes.contains(string2)) {
                    arrf = this.attributes;
                } else {
                    if (!keysNoStroke.contains(string2)) continue;
                    arrf = this.noStroke;
                }
                arrf.put(string2, entry.getValue());
            }
            if ("".equals(hashMap.get("GENERICTAG"))) {
                this.attributes.put("GENERICTAG", chunk.getContent());
            }
        }
        if (font.isUnderlined()) {
            arrf = new float[]{0.0f, 0.06666667f, 0.0f, -0.33333334f, 0.0f};
            arrf = Utilities.addToArray((Object[][])this.attributes.get("UNDERLINE"), new Object[]{null, arrf});
            this.attributes.put("UNDERLINE", arrf);
        }
        if (font.isStrikethru()) {
            arrf = new float[]{0.0f, 0.06666667f, 0.0f, 0.33333334f, 0.0f};
            arrf = Utilities.addToArray((Object[][])this.attributes.get("UNDERLINE"), new Object[]{null, arrf});
            this.attributes.put("UNDERLINE", arrf);
        }
        if (serializable != null) {
            this.attributes.put("ACTION", serializable);
        }
        this.noStroke.put("COLOR", font.getColor());
        this.noStroke.put("ENCODING", this.font.getFont().getEncoding());
        serializable = (Float)this.attributes.get("LINEHEIGHT");
        if (serializable != null) {
            this.changeLeading = true;
            this.leading = serializable.floatValue();
        }
        if ((serializable = (Object[])this.attributes.get("IMAGE")) == null) {
            this.image = null;
        } else {
            this.attributes.remove("HSCALE");
            this.image = (Image)((Object)serializable[0]);
            this.offsetX = ((Float)serializable[1]).floatValue();
            this.offsetY = ((Float)serializable[2]).floatValue();
            this.changeLeading = (Boolean)serializable[3];
        }
        serializable = (Float)this.attributes.get("HSCALE");
        if (serializable != null) {
            this.font.setHorizontalScaling(serializable.floatValue());
        }
        this.encoding = this.font.getFont().getEncoding();
        this.splitCharacter = (SplitCharacter)this.noStroke.get("SPLITCHARACTER");
        if (this.splitCharacter == null) {
            this.splitCharacter = DefaultSplitCharacter.DEFAULT;
        }
        this.accessibleElement = chunk;
    }

    PdfChunk(Chunk chunk, PdfAction pdfAction, TabSettings tabSettings) {
        this(chunk, pdfAction);
        if (tabSettings != null && this.attributes.get("TABSETTINGS") == null) {
            this.attributes.put("TABSETTINGS", tabSettings);
        }
    }

    PdfChunk(String arrobject, PdfChunk pdfChunk) {
        this.value = arrobject;
        this.font = pdfChunk.font;
        this.attributes = pdfChunk.attributes;
        this.noStroke = pdfChunk.noStroke;
        this.baseFont = pdfChunk.baseFont;
        this.changeLeading = pdfChunk.changeLeading;
        this.leading = pdfChunk.leading;
        arrobject = (Object[])this.attributes.get("IMAGE");
        if (arrobject == null) {
            this.image = null;
        } else {
            this.image = (Image)arrobject[0];
            this.offsetX = ((Float)arrobject[1]).floatValue();
            this.offsetY = ((Float)arrobject[2]).floatValue();
            this.changeLeading = (Boolean)arrobject[3];
        }
        this.encoding = this.font.getFont().getEncoding();
        this.splitCharacter = (SplitCharacter)this.noStroke.get("SPLITCHARACTER");
        if (this.splitCharacter == null) {
            this.splitCharacter = DefaultSplitCharacter.DEFAULT;
        }
        this.accessibleElement = pdfChunk.accessibleElement;
    }

    static TabStop getTabStop(PdfChunk pdfChunk, float f2) {
        Object object = (Object[])pdfChunk.attributes.get("TAB");
        if (object != null) {
            if (Float.isNaN((object = (Float)object[0]).floatValue())) {
                return TabSettings.getTabStopNewInstance(f2, (TabSettings)pdfChunk.attributes.get("TABSETTINGS"));
            }
            return TabStop.newInstance(f2, object.floatValue());
        }
        return null;
    }

    public static boolean noPrint(int n2) {
        if (n2 >= 8203 && n2 <= 8207 || n2 >= 8234 && n2 <= 8238 || n2 == 173) {
            return true;
        }
        return false;
    }

    @Deprecated
    void adjustLeft(float f2) {
        Object[] arrobject = (Object[])this.attributes.get("TAB");
        if (arrobject != null) {
            this.attributes.put("TAB", new Object[]{arrobject[0], arrobject[1], arrobject[2], new Float(f2)});
        }
    }

    public boolean changeLeading() {
        return this.changeLeading;
    }

    BaseColor color() {
        return (BaseColor)this.noStroke.get("COLOR");
    }

    PdfFont font() {
        return this.font;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    Object getAttribute(String string2) {
        HashMap<String, Object> hashMap;
        if (this.attributes.containsKey(string2)) {
            hashMap = this.attributes;
            do {
                return hashMap.get(string2);
                break;
            } while (true);
        }
        hashMap = this.noStroke;
        return hashMap.get(string2);
    }

    float getCharWidth(int n2) {
        if (PdfChunk.noPrint(n2)) {
            return 0.0f;
        }
        if (this.isAttribute("CHAR_SPACING")) {
            Float f2 = (Float)this.getAttribute("CHAR_SPACING");
            return this.font.width(n2) + f2.floatValue() * this.font.getHorizontalScaling();
        }
        if (this.isImage()) {
            return this.getImageWidth();
        }
        return this.font.width(n2);
    }

    String getEncoding() {
        return this.encoding;
    }

    Image getImage() {
        return this.image;
    }

    float getImageHeight() {
        return this.image.getScaledHeight() * this.imageScalePercentage;
    }

    float getImageOffsetX() {
        return this.offsetX;
    }

    float getImageOffsetY() {
        return this.offsetY;
    }

    public float getImageScalePercentage() {
        return this.imageScalePercentage;
    }

    float getImageWidth() {
        return this.image.getScaledWidth() * this.imageScalePercentage;
    }

    public float getLeading() {
        return this.leading;
    }

    TabStop getTabStop() {
        return (TabStop)this.attributes.get(TABSTOP);
    }

    public float getTextRise() {
        Float f2 = (Float)this.getAttribute("SUBSUPSCRIPT");
        if (f2 != null) {
            return f2.floatValue();
        }
        return 0.0f;
    }

    public int getUnicodeEquivalent(int n2) {
        return this.baseFont.getUnicodeEquivalent(n2);
    }

    public float getWidthCorrected(float f2, float f3) {
        if (this.image != null) {
            return this.image.getScaledWidth() + f2;
        }
        int n2 = 0;
        int n3 = -1;
        while ((n3 = this.value.indexOf(32, n3 + 1)) >= 0) {
            ++n2;
        }
        return this.font.width(this.value) + (float)this.value.length() * f2 + (float)n2 * f3;
    }

    protected int getWord(String string2, int n2) {
        int n3 = string2.length();
        while (n2 < n3) {
            if (!Character.isLetter(string2.charAt(n2))) {
                return n2;
            }
            ++n2;
        }
        return n2;
    }

    float height() {
        if (this.isImage()) {
            return this.getImageHeight();
        }
        return this.font.size();
    }

    boolean isAttribute(String string2) {
        if (this.attributes.containsKey(string2)) {
            return true;
        }
        return this.noStroke.containsKey(string2);
    }

    boolean isExtSplitCharacter(int n2, int n3, int n4, char[] arrc, PdfChunk[] arrpdfChunk) {
        return this.splitCharacter.isSplitCharacter(n2, n3, n4, arrc, arrpdfChunk);
    }

    boolean isHorizontalSeparator() {
        if (this.isAttribute("SEPARATOR")) {
            return (Boolean)((Object[])this.getAttribute("SEPARATOR"))[1] ^ true;
        }
        return false;
    }

    boolean isImage() {
        if (this.image != null) {
            return true;
        }
        return false;
    }

    public boolean isNewlineSplit() {
        return this.newlineSplit;
    }

    boolean isSeparator() {
        return this.isAttribute("SEPARATOR");
    }

    boolean isSpecialEncoding() {
        if (!this.encoding.equals("UnicodeBigUnmarked") && !this.encoding.equals("Identity-H")) {
            return false;
        }
        return true;
    }

    boolean isStroked() {
        return this.attributes.isEmpty() ^ true;
    }

    boolean isTab() {
        return this.isAttribute("TAB");
    }

    int length() {
        return this.value.length();
    }

    int lengthUtf32() {
        if (!"Identity-H".equals(this.encoding)) {
            return this.value.length();
        }
        int n2 = this.value.length();
        int n3 = 0;
        int n4 = 0;
        while (n3 < n2) {
            int n5 = n3;
            if (Utilities.isSurrogateHigh(this.value.charAt(n3))) {
                n5 = n3 + 1;
            }
            ++n4;
            n3 = n5 + 1;
        }
        return n4;
    }

    void setImageOffsetX(float f2) {
        this.offsetX = f2;
    }

    void setImageOffsetY(float f2) {
        this.offsetY = f2;
    }

    public void setImageScalePercentage(float f2) {
        this.imageScalePercentage = f2;
    }

    void setTabStop(TabStop tabStop) {
        this.attributes.put(TABSTOP, tabStop);
    }

    void setValue(String string2) {
        this.value = string2;
    }

    /*
     * Enabled aggressive block sorting
     */
    PdfChunk split(float f2) {
        Object object;
        float f3;
        int n2;
        Object object2;
        int n3;
        int n4;
        Object object3;
        int n5;
        int n6;
        block25 : {
            block24 : {
                float f4;
                int n7;
                int n8;
                block23 : {
                    this.newlineSplit = false;
                    if (this.image != null) {
                        if (this.image.getScaledWidth() > f2) {
                            PdfChunk pdfChunk = new PdfChunk("\ufffc", this);
                            this.value = "";
                            this.attributes = new HashMap();
                            this.image = null;
                            this.font = PdfFont.getDefaultFont();
                            return pdfChunk;
                        }
                        return null;
                    }
                    object = (HyphenationEvent)this.noStroke.get("HYPHENATION");
                    n6 = this.value.length();
                    object2 = this.value.toCharArray();
                    object3 = this.font.getFont();
                    n2 = object3.getFontType();
                    n7 = 2;
                    f4 = 0.0f;
                    float f5 = 0.0f;
                    n4 = -1;
                    if (n2 != 2 || object3.getUnicodeEquivalent(32) == 32) {
                        n2 = 0;
                        f3 = 0.0f;
                        n5 = -1;
                    } else {
                        f3 = 0.0f;
                        n2 = 0;
                        n5 = -1;
                        do {
                            f4 = f3;
                            n3 = n4;
                            n7 = n2;
                            n8 = n5;
                            if (n2 >= n6) break block23;
                            n3 = object2[n2];
                            n7 = (char)object3.getUnicodeEquivalent(n3);
                            if (n7 == 10) {
                                this.newlineSplit = true;
                                object2 = this.value.substring(n2 + 1);
                                this.value = this.value.substring(0, n2);
                                if (this.value.length() < 1) {
                                    this.value = "\u0001";
                                }
                                return new PdfChunk((String)object2, this);
                            }
                            f4 = f5 + this.getCharWidth(n3);
                            if (n7 == 32) {
                                n4 = n2 + 1;
                                f3 = f4;
                            }
                            if (f4 > f2) {
                                n3 = n4;
                                break block24;
                            }
                            if (this.splitCharacter.isSplitCharacter(0, n2, n6, (char[])object2, new PdfChunk[]{this})) {
                                n5 = n2 + 1;
                            }
                            ++n2;
                            f5 = f4;
                        } while (true);
                    }
                    while (n2 < n6) {
                        n3 = object2[n2];
                        if (n3 != 13 && n3 != 10) {
                            boolean bl2 = Utilities.isSurrogatePair((char[])object2, n2);
                            f5 = bl2 ? this.getCharWidth(Utilities.convertToUtf32(object2[n2], object2[n2 + 1])) : this.getCharWidth(n3);
                            f4 += f5;
                            if (n3 == 32) {
                                n4 = n2 + 1;
                                f3 = f4;
                            }
                            n3 = n2;
                            if (bl2) {
                                n3 = n2 + 1;
                            }
                            if (f4 > f2) {
                                n2 = n4;
                                n4 = n3;
                                break block25;
                            }
                            if (this.splitCharacter.isSplitCharacter(0, n3, n6, (char[])object2, null)) {
                                n5 = n3 + 1;
                            }
                            n2 = n3 + 1;
                            continue;
                        }
                        this.newlineSplit = true;
                        n5 = n3 == 13 && (n5 = n2 + 1) < n6 && object2[n5] == '\n' ? n7 : 1;
                        object2 = this.value.substring(n5 + n2);
                        this.value = this.value.substring(0, n2);
                        if (this.value.length() < 1) {
                            this.value = " ";
                        }
                        return new PdfChunk((String)object2, this);
                    }
                    n8 = n5;
                    n7 = n2;
                    n3 = n4;
                    f4 = f3;
                }
                f3 = f4;
                n5 = n8;
                n2 = n7;
            }
            n4 = n2;
            n2 = n3;
        }
        if (n4 == n6) {
            return null;
        }
        if (n5 < 0) {
            object2 = this.value;
            this.value = "";
            return new PdfChunk((String)object2, this);
        }
        n3 = n5;
        if (n2 > n5) {
            n3 = n5;
            if (this.splitCharacter.isSplitCharacter(0, 0, 1, singleSpace, null)) {
                n3 = n2;
            }
        }
        if (object != null && n2 >= 0 && n2 < n4 && (n5 = this.getWord(this.value, n2)) > n2) {
            object2 = object.getHyphenatedWordPre(this.value.substring(n2, n5), this.font.getFont(), this.font.size(), f2 - f3);
            object = object.getHyphenatedWordPost();
            if (object2.length() > 0) {
                object3 = new StringBuilder();
                object3.append((String)object);
                object3.append(this.value.substring(n5));
                object = object3.toString();
                object3 = new StringBuilder();
                object3.append(this.value.substring(0, n2));
                object3.append((String)object2);
                this.value = this.trim(object3.toString());
                return new PdfChunk((String)object, this);
            }
        }
        object2 = this.value.substring(n3);
        this.value = this.trim(this.value.substring(0, n3));
        return new PdfChunk((String)object2, this);
    }

    public String toString() {
        return this.value;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    String trim(String string2) {
        Object object = this.font.getFont();
        String string3 = string2;
        if (object.getFontType() == 2) {
            string3 = string2;
            if (object.getUnicodeEquivalent(32) != 32) {
                do {
                    object = string2;
                    if (!string2.endsWith("\u0001")) return object;
                    string2 = string2.substring(0, string2.length() - 1);
                } while (true);
            }
        }
        do {
            if (!string3.endsWith(" ")) {
                object = string3;
                if (!string3.endsWith("\t")) {
                    return object;
                }
            }
            string3 = string3.substring(0, string3.length() - 1);
        } while (true);
    }

    public float trimFirstSpace() {
        BaseFont baseFont = this.font.getFont();
        if (baseFont.getFontType() == 2 && baseFont.getUnicodeEquivalent(32) != 32) {
            if (this.value.length() > 1 && this.value.startsWith("\u0001")) {
                this.value = this.value.substring(1);
                return this.font.width(1);
            }
        } else if (this.value.length() > 1 && this.value.startsWith(" ")) {
            this.value = this.value.substring(1);
            return this.font.width(32);
        }
        return 0.0f;
    }

    public float trimLastSpace() {
        BaseFont baseFont = this.font.getFont();
        if (baseFont.getFontType() == 2 && baseFont.getUnicodeEquivalent(32) != 32) {
            if (this.value.length() > 1 && this.value.endsWith("\u0001")) {
                this.value = this.value.substring(0, this.value.length() - 1);
                return this.font.width(1);
            }
        } else if (this.value.length() > 1 && this.value.endsWith(" ")) {
            this.value = this.value.substring(0, this.value.length() - 1);
            return this.font.width(32);
        }
        return 0.0f;
    }

    /*
     * Enabled aggressive block sorting
     */
    PdfChunk truncate(float f2) {
        if (this.image != null) {
            if (this.image.getScaledWidth() <= f2) {
                return null;
            }
            if (this.image.isScaleToFitLineWhenOverflow()) {
                this.setImageScalePercentage(f2 / this.image.getWidth());
                return null;
            }
            PdfChunk pdfChunk = new PdfChunk("", this);
            this.value = "";
            this.attributes.remove("IMAGE");
            this.image = null;
            this.font = PdfFont.getDefaultFont();
            return pdfChunk;
        }
        float f3 = this.font.width();
        int n2 = 1;
        if (f2 < f3) {
            String string2 = this.value.substring(1);
            this.value = this.value.substring(0, 1);
            return new PdfChunk(string2, this);
        }
        int n3 = this.value.length();
        int n4 = 0;
        f3 = 0.0f;
        boolean bl2 = false;
        while (n4 < n3) {
            bl2 = Utilities.isSurrogatePair(this.value, n4);
            int n5 = bl2 ? Utilities.convertToUtf32(this.value, n4) : (int)this.value.charAt(n4);
            if ((f3 += this.getCharWidth(n5)) > f2) break;
            n5 = n4;
            if (bl2) {
                n5 = n4 + 1;
            }
            n4 = n5 + 1;
        }
        if (n4 == n3) {
            return null;
        }
        if (n4 == 0) {
            n4 = n2;
            if (bl2) {
                n4 = 2;
            }
        }
        String string3 = this.value.substring(n4);
        this.value = this.value.substring(0, n4);
        return new PdfChunk(string3, this);
    }

    float width() {
        return this.width(this.value);
    }

    float width(String object) {
        float f2;
        if (this.isAttribute("SEPARATOR")) {
            return 0.0f;
        }
        if (this.isImage()) {
            return this.getImageWidth();
        }
        float f3 = f2 = this.font.width((String)object);
        if (this.isAttribute("CHAR_SPACING")) {
            Float f4 = (Float)this.getAttribute("CHAR_SPACING");
            f3 = f2 + (float)object.length() * f4.floatValue();
        }
        f2 = f3;
        if (this.isAttribute("WORD_SPACING")) {
            int n2 = 0;
            int n3 = -1;
            while ((n3 = object.indexOf(32, n3 + 1)) >= 0) {
                ++n2;
            }
            object = (Float)this.getAttribute("WORD_SPACING");
            f2 = f3 + (float)n2 * object.floatValue();
        }
        return f2;
    }
}

