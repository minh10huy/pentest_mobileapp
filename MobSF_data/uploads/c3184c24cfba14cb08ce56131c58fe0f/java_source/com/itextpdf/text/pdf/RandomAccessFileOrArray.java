/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.Document;
import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.io.IndependentRandomAccessSource;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import java.io.DataInput;
import java.io.DataInputStream;
import java.io.EOFException;
import java.io.InputStream;
import java.net.URL;

public class RandomAccessFileOrArray
implements DataInput {
    private byte back;
    private final RandomAccessSource byteSource;
    private long byteSourcePosition;
    private boolean isBack = false;

    public RandomAccessFileOrArray(RandomAccessSource randomAccessSource) {
        this.byteSource = randomAccessSource;
    }

    @Deprecated
    public RandomAccessFileOrArray(RandomAccessFileOrArray randomAccessFileOrArray) {
        this(new IndependentRandomAccessSource(randomAccessFileOrArray.byteSource));
    }

    @Deprecated
    public RandomAccessFileOrArray(InputStream inputStream) {
        this(new RandomAccessSourceFactory().createSource(inputStream));
    }

    @Deprecated
    public RandomAccessFileOrArray(String string2) {
        this(new RandomAccessSourceFactory().setForceRead(false).setUsePlainRandomAccess(Document.plainRandomAccess).createBestSource(string2));
    }

    @Deprecated
    public RandomAccessFileOrArray(String string2, boolean bl2, boolean bl3) {
        this(new RandomAccessSourceFactory().setForceRead(bl2).setUsePlainRandomAccess(bl3).createBestSource(string2));
    }

    @Deprecated
    public RandomAccessFileOrArray(URL uRL) {
        this(new RandomAccessSourceFactory().createSource(uRL));
    }

    @Deprecated
    public RandomAccessFileOrArray(byte[] arrby) {
        this(new RandomAccessSourceFactory().createSource(arrby));
    }

    public void close() {
        this.isBack = false;
        this.byteSource.close();
    }

    public RandomAccessSource createSourceView() {
        return new IndependentRandomAccessSource(this.byteSource);
    }

    public RandomAccessFileOrArray createView() {
        return new RandomAccessFileOrArray(new IndependentRandomAccessSource(this.byteSource));
    }

    @Deprecated
    protected RandomAccessSource getByteSource() {
        return this.byteSource;
    }

    public long getFilePointer() {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge I and Z\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.provideAs(TypeTransformer.java:780)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.e1expr(TypeTransformer.java:496)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:713)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:703)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.e1expr(TypeTransformer.java:539)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:713)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:703)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.e2expr(TypeTransformer.java:632)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:716)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.exExpr(TypeTransformer.java:703)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.s1stmt(TypeTransformer.java:810)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.sxStmt(TypeTransformer.java:840)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:206)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    public long length() {
        return this.byteSource.length();
    }

    public void pushBack(byte by2) {
        this.back = by2;
        this.isBack = true;
    }

    @Deprecated
    public void reOpen() {
        this.seek(0L);
    }

    public int read() {
        if (this.isBack) {
            this.isBack = false;
            return this.back & 255;
        }
        RandomAccessSource randomAccessSource = this.byteSource;
        long l2 = this.byteSourcePosition;
        this.byteSourcePosition = 1L + l2;
        return randomAccessSource.get(l2);
    }

    public int read(byte[] arrby) {
        return this.read(arrby, 0, arrby.length);
    }

    public int read(byte[] arrby, int n2, int n3) {
        int n4;
        int n5;
        if (n3 == 0) {
            return 0;
        }
        if (this.isBack && n3 > 0) {
            this.isBack = false;
            arrby[n2] = this.back;
            n5 = 1;
            --n3;
            n4 = n2 + 1;
            n2 = n5;
        } else {
            n4 = n2;
            n2 = 0;
        }
        n5 = n2;
        if (n3 > 0) {
            n3 = this.byteSource.get(this.byteSourcePosition, arrby, n4, n3);
            n5 = n2;
            if (n3 > 0) {
                n5 = n2 + n3;
                this.byteSourcePosition += (long)n3;
            }
        }
        if (n5 == 0) {
            return -1;
        }
        return n5;
    }

    @Override
    public boolean readBoolean() {
        int n2 = this.read();
        if (n2 >= 0) {
            if (n2 != 0) {
                return true;
            }
            return false;
        }
        throw new EOFException();
    }

    @Override
    public byte readByte() {
        int n2 = this.read();
        if (n2 >= 0) {
            return (byte)n2;
        }
        throw new EOFException();
    }

    @Override
    public char readChar() {
        int n2;
        int n3 = this.read();
        if ((n3 | (n2 = this.read())) >= 0) {
            return (char)((n3 << 8) + n2);
        }
        throw new EOFException();
    }

    public final char readCharLE() {
        int n2;
        int n3 = this.read();
        if ((n3 | (n2 = this.read())) >= 0) {
            return (char)((n2 << 8) + (n3 << 0));
        }
        throw new EOFException();
    }

    @Override
    public double readDouble() {
        return Double.longBitsToDouble(this.readLong());
    }

    public final double readDoubleLE() {
        return Double.longBitsToDouble(this.readLongLE());
    }

    @Override
    public float readFloat() {
        return Float.intBitsToFloat(this.readInt());
    }

    public final float readFloatLE() {
        return Float.intBitsToFloat(this.readIntLE());
    }

    @Override
    public void readFully(byte[] arrby) {
        this.readFully(arrby, 0, arrby.length);
    }

    @Override
    public void readFully(byte[] arrby, int n2, int n3) {
        int n4;
        int n5 = 0;
        while ((n4 = this.read(arrby, n2 + n5, n3 - n5)) >= 0) {
            n5 = n4 = n5 + n4;
            if (n4 < n3) continue;
            return;
        }
        throw new EOFException();
    }

    @Override
    public int readInt() {
        int n2;
        int n3;
        int n4;
        int n5 = this.read();
        if ((n5 | (n3 = this.read()) | (n4 = this.read()) | (n2 = this.read())) >= 0) {
            return (n5 << 24) + (n3 << 16) + (n4 << 8) + n2;
        }
        throw new EOFException();
    }

    public final int readIntLE() {
        int n2;
        int n3;
        int n4;
        int n5 = this.read();
        if ((n5 | (n3 = this.read()) | (n4 = this.read()) | (n2 = this.read())) >= 0) {
            return (n2 << 24) + (n4 << 16) + (n3 << 8) + (n5 << 0);
        }
        throw new EOFException();
    }

    @Override
    public String readLine() {
        StringBuilder stringBuilder = new StringBuilder();
        boolean bl2 = false;
        int n2 = -1;
        while (!bl2) {
            n2 = this.read();
            if (n2 != -1 && n2 != 10) {
                if (n2 != 13) {
                    stringBuilder.append((char)n2);
                    continue;
                }
                long l2 = this.getFilePointer();
                if (this.read() != 10) {
                    this.seek(l2);
                }
            }
            bl2 = true;
        }
        if (n2 == -1 && stringBuilder.length() == 0) {
            return null;
        }
        return stringBuilder.toString();
    }

    @Override
    public long readLong() {
        return ((long)this.readInt() << 32) + ((long)this.readInt() & 0xFFFFFFFFL);
    }

    public final long readLongLE() {
        int n2 = this.readIntLE();
        return ((long)this.readIntLE() << 32) + ((long)n2 & 0xFFFFFFFFL);
    }

    @Override
    public short readShort() {
        int n2;
        int n3 = this.read();
        if ((n3 | (n2 = this.read())) >= 0) {
            return (short)((n3 << 8) + n2);
        }
        throw new EOFException();
    }

    public final short readShortLE() {
        int n2;
        int n3 = this.read();
        if ((n3 | (n2 = this.read())) >= 0) {
            return (short)((n2 << 8) + (n3 << 0));
        }
        throw new EOFException();
    }

    public String readString(int n2, String string2) {
        byte[] arrby = new byte[n2];
        this.readFully(arrby);
        try {
            string2 = new String(arrby, string2);
            return string2;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    @Override
    public String readUTF() {
        return DataInputStream.readUTF(this);
    }

    @Override
    public int readUnsignedByte() {
        int n2 = this.read();
        if (n2 >= 0) {
            return n2;
        }
        throw new EOFException();
    }

    public final long readUnsignedInt() {
        long l2;
        long l3;
        long l4;
        long l5 = this.read();
        if ((l5 | (l3 = (long)this.read()) | (l2 = (long)this.read()) | (l4 = (long)this.read())) >= 0L) {
            return (l5 << 24) + (l3 << 16) + (l2 << 8) + (l4 << 0);
        }
        throw new EOFException();
    }

    public final long readUnsignedIntLE() {
        long l2;
        long l3;
        long l4;
        long l5 = this.read();
        if ((l5 | (l3 = (long)this.read()) | (l2 = (long)this.read()) | (l4 = (long)this.read())) >= 0L) {
            return (l4 << 24) + (l2 << 16) + (l3 << 8) + (l5 << 0);
        }
        throw new EOFException();
    }

    @Override
    public int readUnsignedShort() {
        int n2;
        int n3 = this.read();
        if ((n3 | (n2 = this.read())) >= 0) {
            return (n3 << 8) + n2;
        }
        throw new EOFException();
    }

    public final int readUnsignedShortLE() {
        int n2;
        int n3 = this.read();
        if ((n3 | (n2 = this.read())) >= 0) {
            return (n2 << 8) + (n3 << 0);
        }
        throw new EOFException();
    }

    public void seek(long l2) {
        this.byteSourcePosition = l2;
        this.isBack = false;
    }

    public long skip(long l2) {
        if (l2 <= 0L) {
            return 0L;
        }
        boolean bl2 = this.isBack;
        int n2 = 0;
        long l3 = l2;
        if (bl2) {
            this.isBack = false;
            if (l2 == 1L) {
                return 1L;
            }
            l3 = l2 - 1L;
            n2 = 1;
        }
        long l4 = this.getFilePointer();
        long l5 = this.length();
        l2 = l3 += l4;
        if (l3 > l5) {
            l2 = l5;
        }
        this.seek(l2);
        return l2 - l4 + (long)n2;
    }

    @Override
    public int skipBytes(int n2) {
        return (int)this.skip(n2);
    }
}

