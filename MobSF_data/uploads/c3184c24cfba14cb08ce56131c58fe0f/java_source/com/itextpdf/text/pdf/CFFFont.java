/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import java.util.Iterator;
import java.util.LinkedList;

public class CFFFont {
    static final String[] operatorNames = new String[]{"version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "UNKNOWN_12", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX", "UNKNOWN_22", "UNKNOWN_23", "UNKNOWN_24", "UNKNOWN_25", "UNKNOWN_26", "UNKNOWN_27", "UNKNOWN_28", "UNKNOWN_29", "UNKNOWN_30", "UNKNOWN_31", "Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", "UNKNOWN_12_15", "UNKNOWN_12_16", "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", "UNKNOWN_12_24", "UNKNOWN_12_25", "UNKNOWN_12_26", "UNKNOWN_12_27", "UNKNOWN_12_28", "UNKNOWN_12_29", "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"};
    static final String[] standardStrings = new String[]{".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar", "percent", "ampersand", "quoteright", "parenleft", "parenright", "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon", "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash", "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright", "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen", "florin", "section", "currency", "quotesingle", "quotedblleft", "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash", "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet", "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright", "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex", "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla", "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash", "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe", "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth", "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar", "degree", "thorn", "threequarters", "twosuperior", "registered", "minus", "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex", "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute", "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis", "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve", "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave", "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis", "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex", "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave", "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde", "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute", "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall", "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall", "parenleftsuperior", "parenrightsuperior", "twodotenleader", "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle", "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle", "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior", "threequartersemdash", "periodsuperior", "questionsmall", "asuperior", "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior", "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior", "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior", "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall", "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall", "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall", "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall", "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary", "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle", "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall", "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash", "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall", "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths", "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior", "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior", "ninesuperior", "zeroinferior", "oneinferior", "twoinferior", "threeinferior", "fourinferior", "fiveinferior", "sixinferior", "seveninferior", "eightinferior", "nineinferior", "centinferior", "dollarinferior", "periodinferior", "commainferior", "Agravesmall", "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall", "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall", "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall", "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall", "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall", "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall", "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall", "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black", "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"};
    protected int arg_count = 0;
    protected Object[] args = new Object[48];
    protected RandomAccessFileOrArray buf;
    protected Font[] fonts;
    protected int gsubrIndexOffset;
    protected int[] gsubrOffsets;
    protected String key;
    protected int nameIndexOffset;
    protected int[] nameOffsets;
    int nextIndexOffset;
    private int offSize;
    protected int stringIndexOffset;
    protected int[] stringOffsets;
    protected int topdictIndexOffset;
    protected int[] topdictOffsets;

    public CFFFont(RandomAccessFileOrArray object) {
        int n2;
        int n3;
        this.buf = object;
        this.seek(0);
        this.getCard8();
        this.getCard8();
        int n4 = this.getCard8();
        this.offSize = this.getCard8();
        this.nameIndexOffset = n4;
        this.nameOffsets = this.getIndex(this.nameIndexOffset);
        this.topdictIndexOffset = this.nameOffsets[this.nameOffsets.length - 1];
        this.topdictOffsets = this.getIndex(this.topdictIndexOffset);
        this.stringIndexOffset = this.topdictOffsets[this.topdictOffsets.length - 1];
        this.stringOffsets = this.getIndex(this.stringIndexOffset);
        this.gsubrIndexOffset = this.stringOffsets[this.stringOffsets.length - 1];
        this.gsubrOffsets = this.getIndex(this.gsubrIndexOffset);
        this.fonts = new Font[this.nameOffsets.length - 1];
        n4 = 0;
        while (n4 < this.nameOffsets.length - 1) {
            this.fonts[n4] = new Font();
            this.seek(this.nameOffsets[n4]);
            this.fonts[n4].name = "";
            for (n3 = this.nameOffsets[n4]; n3 < (object = this.nameOffsets)[n2 = n4 + '\u0001']; ++n3) {
                object = new StringBuilder();
                Font font = this.fonts[n4];
                object.append(font.name);
                object.append(this.getCard8());
                font.name = object.toString();
            }
            n4 = n2;
        }
        n4 = 0;
        while (n4 < this.topdictOffsets.length - 1) {
            n3 = this.topdictOffsets[n4];
            block3 : do {
                this.seek(n3);
                while ((n3 = this.getPosition()) < (object = this.topdictOffsets)[n2 = n4 + '\u0001']) {
                    this.getDictItem();
                    if (this.key == "FullName") {
                        this.fonts[n4].fullName = this.getString((char)((Integer)this.args[0]).intValue());
                        continue;
                    }
                    if (this.key == "ROS") {
                        this.fonts[n4].isCID = true;
                        continue;
                    }
                    if (this.key == "Private") {
                        this.fonts[n4].privateLength = (Integer)this.args[0];
                        this.fonts[n4].privateOffset = (Integer)this.args[1];
                        continue;
                    }
                    if (this.key == "charset") {
                        this.fonts[n4].charsetOffset = (Integer)this.args[0];
                        continue;
                    }
                    if (this.key == "CharStrings") {
                        this.fonts[n4].charstringsOffset = (Integer)this.args[0];
                        n3 = this.getPosition();
                        this.fonts[n4].charstringsOffsets = this.getIndex(this.fonts[n4].charstringsOffset);
                        continue block3;
                    }
                    if (this.key == "FDArray") {
                        this.fonts[n4].fdarrayOffset = (Integer)this.args[0];
                        continue;
                    }
                    if (this.key == "FDSelect") {
                        this.fonts[n4].fdselectOffset = (Integer)this.args[0];
                        continue;
                    }
                    if (this.key != "CharstringType") continue;
                    this.fonts[n4].CharstringType = (Integer)this.args[0];
                }
                break;
            } while (true);
            if (this.fonts[n4].privateOffset >= 0) {
                this.seek(this.fonts[n4].privateOffset);
                while (this.getPosition() < this.fonts[n4].privateOffset + this.fonts[n4].privateLength) {
                    this.getDictItem();
                    if (this.key != "Subrs") continue;
                    this.fonts[n4].privateSubrs = (Integer)this.args[0] + this.fonts[n4].privateOffset;
                }
            }
            if (this.fonts[n4].fdarrayOffset >= 0) {
                object = this.getIndex(this.fonts[n4].fdarrayOffset);
                this.fonts[n4].fdprivateOffsets = new int[((Object)object).length - 1];
                this.fonts[n4].fdprivateLengths = new int[((Object)object).length - 1];
                n3 = 0;
                while (n3 < ((Object)object).length - 1) {
                    int n5;
                    int n6;
                    this.seek((int)object[n3]);
                    while ((n6 = this.getPosition()) < object[n5 = n3 + 1]) {
                        this.getDictItem();
                        if (this.key != "Private") continue;
                        this.fonts[n4].fdprivateLengths[n3] = (Integer)this.args[0];
                        this.fonts[n4].fdprivateOffsets[n3] = (Integer)this.args[1];
                    }
                    n3 = n5;
                }
            }
            n4 = n2;
        }
    }

    void ReadEncoding(int n2) {
        this.seek(n2);
        this.getCard8();
    }

    public boolean exists(String string2) {
        for (int i2 = 0; i2 < this.fonts.length; ++i2) {
            if (!string2.equals(this.fonts[i2].name)) continue;
            return true;
        }
        return false;
    }

    public byte[] getCID(String object) {
        int n2;
        int n3;
        for (n3 = 0; n3 < this.fonts.length && !object.equals(this.fonts[n3].name); ++n3) {
        }
        if (n3 == this.fonts.length) {
            return null;
        }
        LinkedList<Object> linkedList = new LinkedList<Object>();
        this.seek(0);
        this.getCard8();
        this.getCard8();
        int n4 = this.getCard8();
        this.getCard8();
        this.nextIndexOffset = n4;
        linkedList.addLast(new RangeItem(this.buf, 0, n4));
        boolean bl2 = this.fonts[n3].isCID;
        int n5 = -1;
        if (!bl2) {
            this.seek(this.fonts[n3].charstringsOffset);
            n5 = this.getCard16();
            this.seek(this.stringIndexOffset);
            n4 = this.getCard16() + standardStrings.length;
        } else {
            n4 = -1;
        }
        linkedList.addLast(new UInt16Item('\u0001'));
        linkedList.addLast(new UInt8Item('\u0001'));
        linkedList.addLast(new UInt8Item('\u0001'));
        linkedList.addLast(new UInt8Item((char)(this.fonts[n3].name.length() + 1)));
        linkedList.addLast(new StringItem(this.fonts[n3].name));
        linkedList.addLast(new UInt16Item('\u0001'));
        linkedList.addLast(new UInt8Item('\u0002'));
        linkedList.addLast(new UInt16Item('\u0001'));
        object = new IndexOffsetItem(2);
        linkedList.addLast(object);
        Object object2 = new IndexBaseItem();
        linkedList.addLast(object2);
        DictOffsetItem dictOffsetItem = new DictOffsetItem();
        DictOffsetItem dictOffsetItem2 = new DictOffsetItem();
        DictOffsetItem dictOffsetItem3 = new DictOffsetItem();
        DictOffsetItem dictOffsetItem4 = new DictOffsetItem();
        if (!this.fonts[n3].isCID) {
            linkedList.addLast(new DictNumberItem(n4));
            linkedList.addLast(new DictNumberItem(n4 + 1));
            linkedList.addLast(new DictNumberItem(0));
            linkedList.addLast(new UInt8Item('\f'));
            linkedList.addLast(new UInt8Item('\u001e'));
            linkedList.addLast(new DictNumberItem(n5));
            linkedList.addLast(new UInt8Item('\f'));
            linkedList.addLast(new UInt8Item('\"'));
        }
        linkedList.addLast(dictOffsetItem3);
        linkedList.addLast(new UInt8Item('\f'));
        linkedList.addLast(new UInt8Item('$'));
        linkedList.addLast(dictOffsetItem4);
        linkedList.addLast(new UInt8Item('\f'));
        linkedList.addLast(new UInt8Item('%'));
        linkedList.addLast(dictOffsetItem);
        linkedList.addLast(new UInt8Item('\u000f'));
        linkedList.addLast(dictOffsetItem2);
        linkedList.addLast(new UInt8Item('\u0011'));
        this.seek(this.topdictOffsets[n3]);
        while (this.getPosition() < this.topdictOffsets[n3 + 1]) {
            n4 = this.getPosition();
            this.getDictItem();
            n2 = this.getPosition();
            if (this.key == "Encoding" || this.key == "Private" || this.key == "FDSelect" || this.key == "FDArray" || this.key == "charset" || this.key == "CharStrings") continue;
            linkedList.add(new RangeItem(this.buf, n4, n2 - n4));
        }
        linkedList.addLast(new IndexMarkerItem((OffsetItem)object, (IndexBaseItem)object2));
        if (this.fonts[n3].isCID) {
            linkedList.addLast(this.getEntireIndexRange(this.stringIndexOffset));
        } else {
            object = new StringBuilder();
            object.append(this.fonts[n3].name);
            object.append("-OneRange");
            object2 = object.toString();
            object = object2;
            if (object2.length() > 127) {
                object = object2.substring(0, 127);
            }
            object2 = new StringBuilder();
            object2.append("AdobeIdentity");
            object2.append((String)object);
            String string2 = object2.toString();
            int n6 = this.stringOffsets[this.stringOffsets.length - 1] - this.stringOffsets[0];
            int n7 = this.stringOffsets[0] - 1;
            n4 = string2.length() + n6 <= 255 ? 1 : (string2.length() + n6 <= 65535 ? 2 : (string2.length() + n6 <= 16777215 ? 3 : 4));
            linkedList.addLast(new UInt16Item((char)(this.stringOffsets.length - 1 + 3)));
            linkedList.addLast(new UInt8Item((char)n4));
            object2 = this.stringOffsets;
            n2 = ((int[])object2).length;
            for (int i2 = 0; i2 < n2; ++i2) {
                linkedList.addLast(new IndexOffsetItem(n4, object2[i2] - n7));
            }
            n2 = this.stringOffsets[this.stringOffsets.length - 1] - n7 + "Adobe".length();
            linkedList.addLast(new IndexOffsetItem(n4, n2));
            linkedList.addLast(new IndexOffsetItem(n4, n2 += "Identity".length()));
            linkedList.addLast(new IndexOffsetItem(n4, n2 + object.length()));
            linkedList.addLast(new RangeItem(this.buf, this.stringOffsets[0], n6));
            linkedList.addLast(new StringItem(string2));
        }
        linkedList.addLast(this.getEntireIndexRange(this.gsubrIndexOffset));
        if (!this.fonts[n3].isCID) {
            linkedList.addLast(new MarkerItem(dictOffsetItem4));
            linkedList.addLast(new UInt8Item('\u0003'));
            linkedList.addLast(new UInt16Item('\u0001'));
            linkedList.addLast(new UInt16Item('\u0000'));
            linkedList.addLast(new UInt8Item('\u0000'));
            linkedList.addLast(new UInt16Item((char)n5));
            linkedList.addLast(new MarkerItem(dictOffsetItem));
            linkedList.addLast(new UInt8Item('\u0002'));
            linkedList.addLast(new UInt16Item('\u0001'));
            linkedList.addLast(new UInt16Item((char)(n5 - 1)));
            linkedList.addLast(new MarkerItem(dictOffsetItem3));
            linkedList.addLast(new UInt16Item('\u0001'));
            linkedList.addLast(new UInt8Item('\u0001'));
            linkedList.addLast(new UInt8Item('\u0001'));
            object = new IndexOffsetItem(1);
            linkedList.addLast(object);
            object2 = new IndexBaseItem();
            linkedList.addLast(object2);
            linkedList.addLast(new DictNumberItem(this.fonts[n3].privateLength));
            dictOffsetItem = new DictOffsetItem();
            linkedList.addLast(dictOffsetItem);
            linkedList.addLast(new UInt8Item('\u0012'));
            linkedList.addLast(new IndexMarkerItem((OffsetItem)object, (IndexBaseItem)object2));
            linkedList.addLast(new MarkerItem(dictOffsetItem));
            linkedList.addLast(new RangeItem(this.buf, this.fonts[n3].privateOffset, this.fonts[n3].privateLength));
            if (this.fonts[n3].privateSubrs >= 0) {
                linkedList.addLast(this.getEntireIndexRange(this.fonts[n3].privateSubrs));
            }
        }
        linkedList.addLast(new MarkerItem(dictOffsetItem2));
        linkedList.addLast(this.getEntireIndexRange(this.fonts[n3].charstringsOffset));
        object = new int[]{0};
        object2 = linkedList.iterator();
        while (object2.hasNext()) {
            ((Item)object2.next()).increment((int[])object);
        }
        object2 = linkedList.iterator();
        while (object2.hasNext()) {
            ((Item)object2.next()).xref();
        }
        object = new byte[object[0]];
        object2 = linkedList.iterator();
        while (object2.hasNext()) {
            ((Item)object2.next()).emit((byte[])object);
        }
        return object;
    }

    char getCard16() {
        try {
            char c2 = this.buf.readChar();
            return c2;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    char getCard8() {
        byte by2;
        try {
            by2 = this.buf.readByte();
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
        return (char)(by2 & 255);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    protected void getDictItem() {
        block25 : {
            for (var1_1 = 0; var1_1 < this.arg_count; ++var1_1) {
                this.args[var1_1] = null;
            }
            this.arg_count = 0;
            this.key = null;
            var4_2 = false;
            block8 : while (var4_2 == false) {
                var1_1 = this.getCard8();
                if (var1_1 == 29) {
                    var1_1 = this.getInt();
                    this.args[this.arg_count] = var1_1;
                } else if (var1_1 == 28) {
                    var1_1 = this.getShort();
                    this.args[this.arg_count] = var1_1;
                } else if (var1_1 >= 32 && var1_1 <= 246) {
                    var1_1 = (byte)(var1_1 - 139);
                    this.args[this.arg_count] = var1_1;
                } else if (var1_1 >= 247 && var1_1 <= 250) {
                    var1_1 = (short)((var1_1 - 247) * 256 + this.getCard8() + 108);
                    this.args[this.arg_count] = var1_1;
                } else if (var1_1 >= 251 && var1_1 <= 254) {
                    var2_3 = this.getCard8();
                    var1_1 = (short)((- var1_1 - 251) * 256 - var2_3 - 108);
                    this.args[this.arg_count] = var1_1;
                } else {
                    if (var1_1 == 30) {
                        var8_8 = new StringBuilder("");
                        var5_5 = false;
                        var3_4 = 0;
                        var6_6 = '\u0000';
                        var1_1 = 0;
                        break block25;
                    }
                    if (var1_1 > 21) continue;
                    var7_7 = var1_1 != 12 ? CFFFont.operatorNames[var1_1] : CFFFont.operatorNames[this.getCard8() + 32];
                    this.key = var7_7;
                    return;
                }
lbl41: // 6 sources:
                do {
                    ++this.arg_count;
                    continue block8;
                    break;
                } while (true);
            }
            return;
        }
        block10 : while (!var5_5) {
            block26 : {
                var2_3 = var3_4;
                if (var3_4 == 0) {
                    var6_6 = this.getCard8();
                    var2_3 = 2;
                }
                var3_4 = var2_3;
                if (var2_3 == 1) {
                    var1_1 = var6_6 / 16;
                    var3_4 = (byte)(var2_3 - 1);
                }
                var2_3 = var3_4;
                if (var3_4 == 2) {
                    var1_1 = var6_6 % 16;
                    var2_3 = (byte)(var3_4 - 1);
                }
                switch (var1_1) {
                    default: {
                        if (var1_1 < 0 || var1_1 > 9) break;
                        var7_7 = String.valueOf(var1_1);
                        ** break;
                    }
                    case 15: {
                        break block26;
                    }
                    case 14: {
                        var7_7 = "-";
                        ** break;
                    }
                    case 12: {
                        var7_7 = "E-";
                        ** break;
                    }
                    case 11: {
                        var7_7 = "E";
                        ** break;
                    }
                    case 10: {
                        var7_7 = ".";
lbl77: // 5 sources:
                        var8_8.append(var7_7);
                        var3_4 = var2_3;
                        continue block10;
                    }
                }
                var8_8.append("<NIBBLE ERROR: ");
                var8_8.append(var1_1);
                var8_8.append('>');
            }
            var5_5 = true;
            var3_4 = var2_3;
        }
        this.args[this.arg_count] = var8_8.toString();
        ** while (true)
    }

    protected RangeItem getEntireIndexRange(int n2) {
        this.seek(n2);
        char c2 = this.getCard16();
        if (c2 == '\u0000') {
            return new RangeItem(this.buf, n2, 2);
        }
        char c3 = this.getCard8();
        this.seek(n2 + 2 + 1 + c2 * c3);
        int n3 = this.getOffset(c3);
        return new RangeItem(this.buf, n2, (c2 + '\u0001') * c3 + 3 + (n3 - 1));
    }

    int[] getIndex(int n2) {
        this.seek(n2);
        int n3 = this.getCard16();
        int n4 = n3 + '\u0001';
        int[] arrn = new int[n4];
        if (n3 == 0) {
            arrn[0] = -1;
            return arrn;
        }
        char c2 = this.getCard8();
        for (int i2 = 0; i2 <= n3; ++i2) {
            arrn[i2] = n2 + 2 + 1 + n4 * c2 - 1 + this.getOffset(c2);
        }
        return arrn;
    }

    int getInt() {
        try {
            int n2 = this.buf.readInt();
            return n2;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public String[] getNames() {
        String[] arrstring = new String[this.fonts.length];
        for (int i2 = 0; i2 < this.fonts.length; ++i2) {
            arrstring[i2] = this.fonts[i2].name;
        }
        return arrstring;
    }

    int getOffset(int n2) {
        int n3 = 0;
        for (int i2 = 0; i2 < n2; ++i2) {
            n3 = n3 * 256 + this.getCard8();
        }
        return n3;
    }

    int getPosition() {
        long l2;
        try {
            l2 = this.buf.getFilePointer();
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
        return (int)l2;
    }

    short getShort() {
        try {
            short s2 = this.buf.readShort();
            return s2;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public String getString(char c2) {
        if (c2 < standardStrings.length) {
            return standardStrings[c2];
        }
        if (c2 >= standardStrings.length + this.stringOffsets.length - 1) {
            return null;
        }
        int n2 = c2 - standardStrings.length;
        int n3 = this.getPosition();
        this.seek(this.stringOffsets[n2]);
        StringBuffer stringBuffer = new StringBuffer();
        for (c2 = (char)this.stringOffsets[n2]; c2 < this.stringOffsets[n2 + 1]; c2 = (char)(c2 + '\u0001')) {
            stringBuffer.append(this.getCard8());
        }
        this.seek(n3);
        return stringBuffer.toString();
    }

    public boolean isCID(String string2) {
        for (int i2 = 0; i2 < this.fonts.length; ++i2) {
            if (!string2.equals(this.fonts[i2].name)) continue;
            return this.fonts[i2].isCID;
        }
        return false;
    }

    void seek(int n2) {
        try {
            this.buf.seek(n2);
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    protected static final class DictNumberItem
    extends Item {
        public int size = 5;
        public final int value;

        public DictNumberItem(int n2) {
            this.value = n2;
        }

        @Override
        public void emit(byte[] arrby) {
            if (this.size == 5) {
                arrby[this.myOffset] = 29;
                arrby[this.myOffset + 1] = (byte)(this.value >>> 24 & 255);
                arrby[this.myOffset + 2] = (byte)(this.value >>> 16 & 255);
                arrby[this.myOffset + 3] = (byte)(this.value >>> 8 & 255);
                arrby[this.myOffset + 4] = (byte)(this.value >>> 0 & 255);
            }
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + this.size;
        }
    }

    protected static final class DictOffsetItem
    extends OffsetItem {
        public final int size = 5;

        @Override
        public void emit(byte[] arrby) {
            if (this.size == 5) {
                arrby[this.myOffset] = 29;
                arrby[this.myOffset + 1] = (byte)(this.value >>> 24 & 255);
                arrby[this.myOffset + 2] = (byte)(this.value >>> 16 & 255);
                arrby[this.myOffset + 3] = (byte)(this.value >>> 8 & 255);
                arrby[this.myOffset + 4] = (byte)(this.value >>> 0 & 255);
            }
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + this.size;
        }
    }

    protected final class Font {
        public int CharsetLength;
        public int CharstringType = 2;
        public int FDArrayCount;
        public int[] FDArrayOffsets;
        public int FDArrayOffsize;
        public int[] FDSelect;
        public int FDSelectFormat;
        public int FDSelectLength;
        public int[] PrivateSubrsOffset;
        public int[][] PrivateSubrsOffsetsArray;
        public int[] SubrsOffsets;
        public int[] charset;
        public int charsetOffset = -1;
        public int charstringsOffset = -1;
        public int[] charstringsOffsets;
        public int encodingOffset = -1;
        public int fdarrayOffset = -1;
        public int[] fdprivateLengths;
        public int[] fdprivateOffsets;
        public int[] fdprivateSubrs;
        public int fdselectOffset = -1;
        public String fullName;
        public boolean isCID = false;
        public String name;
        public int nglyphs;
        public int nstrings;
        public int privateLength = -1;
        public int privateOffset = -1;
        public int privateSubrs = -1;

        protected Font() {
        }
    }

    protected static final class IndexBaseItem
    extends Item {
    }

    protected static final class IndexMarkerItem
    extends Item {
        private IndexBaseItem indexBase;
        private OffsetItem offItem;

        public IndexMarkerItem(OffsetItem offsetItem, IndexBaseItem indexBaseItem) {
            this.offItem = offsetItem;
            this.indexBase = indexBaseItem;
        }

        @Override
        public void xref() {
            this.offItem.set(this.myOffset - this.indexBase.myOffset + 1);
        }
    }

    protected static final class IndexOffsetItem
    extends OffsetItem {
        public final int size;

        public IndexOffsetItem(int n2) {
            this.size = n2;
        }

        public IndexOffsetItem(int n2, int n3) {
            this.size = n2;
            this.value = n3;
        }

        /*
         * Unable to fully structure code
         * Enabled aggressive block sorting
         * Lifted jumps to return sites
         */
        @Override
        public void emit(byte[] var1_1) {
            block6 : {
                switch (this.size) {
                    default: {
                        return;
                    }
                    case 4: {
                        var1_1[this.myOffset + 0] = (byte)(this.value >>> 24 & 255);
                        var2_2 = 1;
                        ** GOTO lbl10
                    }
                    case 3: {
                        var2_2 = 0;
lbl10: // 2 sources:
                        var1_1[this.myOffset + var2_2] = (byte)(this.value >>> 16 & 255);
                        ++var2_2;
                        ** GOTO lbl15
                    }
                    case 2: {
                        var2_2 = 0;
lbl15: // 2 sources:
                        var1_1[this.myOffset + var2_2] = (byte)(this.value >>> 8 & 255);
                        ++var2_2;
                        break block6;
                    }
                    case 1: 
                }
                var2_2 = 0;
            }
            var1_1[this.myOffset + var2_2] = (byte)(this.value >>> 0 & 255);
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + this.size;
        }
    }

    protected static abstract class Item {
        protected int myOffset = -1;

        protected Item() {
        }

        public void emit(byte[] arrby) {
        }

        public void increment(int[] arrn) {
            this.myOffset = arrn[0];
        }

        public void xref() {
        }
    }

    protected static final class MarkerItem
    extends Item {
        OffsetItem p;

        public MarkerItem(OffsetItem offsetItem) {
            this.p = offsetItem;
        }

        @Override
        public void xref() {
            this.p.set(this.myOffset);
        }
    }

    protected static abstract class OffsetItem
    extends Item {
        public int value;

        protected OffsetItem() {
        }

        public void set(int n2) {
            this.value = n2;
        }
    }

    protected static final class RangeItem
    extends Item {
        private RandomAccessFileOrArray buf;
        public int length;
        public int offset;

        public RangeItem(RandomAccessFileOrArray randomAccessFileOrArray, int n2, int n3) {
            this.offset = n2;
            this.length = n3;
            this.buf = randomAccessFileOrArray;
        }

        @Override
        public void emit(byte[] arrby) {
            try {
                this.buf.seek(this.offset);
                for (int i2 = this.myOffset; i2 < this.myOffset + this.length; ++i2) {
                    arrby[i2] = this.buf.readByte();
                }
            }
            catch (Exception exception) {
                throw new ExceptionConverter(exception);
            }
            {
                continue;
            }
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + this.length;
        }
    }

    protected static final class StringItem
    extends Item {
        public String s;

        public StringItem(String string2) {
            this.s = string2;
        }

        @Override
        public void emit(byte[] arrby) {
            for (int i2 = 0; i2 < this.s.length(); ++i2) {
                arrby[this.myOffset + i2] = (byte)(this.s.charAt(i2) & 255);
            }
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + this.s.length();
        }
    }

    protected static final class SubrMarkerItem
    extends Item {
        private IndexBaseItem indexBase;
        private OffsetItem offItem;

        public SubrMarkerItem(OffsetItem offsetItem, IndexBaseItem indexBaseItem) {
            this.offItem = offsetItem;
            this.indexBase = indexBaseItem;
        }

        @Override
        public void xref() {
            this.offItem.set(this.myOffset - this.indexBase.myOffset);
        }
    }

    protected static final class UInt16Item
    extends Item {
        public char value;

        public UInt16Item(char c2) {
            this.value = c2;
        }

        @Override
        public void emit(byte[] arrby) {
            arrby[this.myOffset + 0] = (byte)(this.value >>> 8 & 255);
            arrby[this.myOffset + 1] = (byte)(this.value >>> 0 & 255);
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + 2;
        }
    }

    protected static final class UInt24Item
    extends Item {
        public int value;

        public UInt24Item(int n2) {
            this.value = n2;
        }

        @Override
        public void emit(byte[] arrby) {
            arrby[this.myOffset + 0] = (byte)(this.value >>> 16 & 255);
            arrby[this.myOffset + 1] = (byte)(this.value >>> 8 & 255);
            arrby[this.myOffset + 2] = (byte)(this.value >>> 0 & 255);
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + 3;
        }
    }

    protected static final class UInt32Item
    extends Item {
        public int value;

        public UInt32Item(int n2) {
            this.value = n2;
        }

        @Override
        public void emit(byte[] arrby) {
            arrby[this.myOffset + 0] = (byte)(this.value >>> 24 & 255);
            arrby[this.myOffset + 1] = (byte)(this.value >>> 16 & 255);
            arrby[this.myOffset + 2] = (byte)(this.value >>> 8 & 255);
            arrby[this.myOffset + 3] = (byte)(this.value >>> 0 & 255);
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + 4;
        }
    }

    protected static final class UInt8Item
    extends Item {
        public char value;

        public UInt8Item(char c2) {
            this.value = c2;
        }

        @Override
        public void emit(byte[] arrby) {
            arrby[this.myOffset + 0] = (byte)(this.value >>> 0 & 255);
        }

        @Override
        public void increment(int[] arrn) {
            super.increment(arrn);
            arrn[0] = arrn[0] + 1;
        }
    }

}

