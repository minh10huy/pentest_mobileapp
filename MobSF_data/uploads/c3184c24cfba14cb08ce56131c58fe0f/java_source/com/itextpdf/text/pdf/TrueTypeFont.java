/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.BaseFont;
import com.itextpdf.text.pdf.GlyphList;
import com.itextpdf.text.pdf.IntHashtable;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfEncodings;
import com.itextpdf.text.pdf.PdfIndirectObject;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfRectangle;
import com.itextpdf.text.pdf.PdfStream;
import com.itextpdf.text.pdf.PdfWriter;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.TrueTypeFontSubSet;
import java.io.File;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

class TrueTypeFont
extends BaseFont {
    static final String[] codePages = new String[]{"1252 Latin 1", "1250 Latin 2: Eastern Europe", "1251 Cyrillic", "1253 Greek", "1254 Turkish", "1255 Hebrew", "1256 Arabic", "1257 Windows Baltic", "1258 Vietnamese", null, null, null, null, null, null, null, "874 Thai", "932 JIS/Japan", "936 Chinese: Simplified chars--PRC and Singapore", "949 Korean Wansung", "950 Chinese: Traditional chars--Taiwan and Hong Kong", "1361 Korean Johab", null, null, null, null, null, null, null, "Macintosh Character Set (US Roman)", "OEM Character Set", "Symbol Character Set", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "869 IBM Greek", "866 MS-DOS Russian", "865 MS-DOS Nordic", "864 Arabic", "863 MS-DOS Canadian French", "862 Hebrew", "861 MS-DOS Icelandic", "860 MS-DOS Portuguese", "857 IBM Turkish", "855 IBM Cyrillic; primarily Russian", "852 Latin 2", "775 MS-DOS Baltic", "737 Greek; former 437 G", "708 Arabic; ASMO 708", "850 WE/Latin 1", "437 US"};
    protected String[][] allNameEntries;
    protected int[][] bboxes;
    protected boolean cff = false;
    protected int cffLength;
    protected int cffOffset;
    protected HashMap<Integer, int[]> cmap10;
    protected HashMap<Integer, int[]> cmap31;
    protected HashMap<Integer, int[]> cmapExt;
    protected int directoryOffset;
    protected String[][] familyName;
    protected String fileName;
    protected String fontName;
    protected String[][] fullName;
    protected int[] glyphIdToChar;
    protected int[] glyphWidthsByIndex;
    protected FontHeader head = new FontHeader();
    protected HorizontalHeader hhea = new HorizontalHeader();
    protected boolean isFixedPitch = false;
    protected double italicAngle;
    protected boolean justNames = false;
    protected IntHashtable kerning = new IntHashtable();
    protected int maxGlyphId;
    protected WindowsMetrics os_2 = new WindowsMetrics();
    protected RandomAccessFileOrArray rf;
    protected String style = "";
    protected String[][] subFamily;
    protected HashMap<String, int[]> tables;
    protected String ttcIndex;
    protected int underlinePosition;
    protected int underlineThickness;

    protected TrueTypeFont() {
    }

    TrueTypeFont(String charSequence, String string2, boolean bl2, byte[] arrby, boolean bl3, boolean bl4) {
        this.justNames = bl3;
        String string3 = TrueTypeFont.getBaseName((String)charSequence);
        String string4 = TrueTypeFont.getTTCName(string3);
        if (string3.length() < charSequence.length()) {
            this.style = charSequence.substring(string3.length());
        }
        this.encoding = string2;
        this.embedded = bl2;
        this.fileName = string4;
        this.fontType = 1;
        this.ttcIndex = "";
        if (string4.length() < string3.length()) {
            this.ttcIndex = string3.substring(string4.length() + 1);
        }
        if (!(this.fileName.toLowerCase().endsWith(".ttf") || this.fileName.toLowerCase().endsWith(".otf") || this.fileName.toLowerCase().endsWith(".ttc"))) {
            charSequence = new StringBuilder();
            charSequence.append(this.fileName);
            charSequence.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.ttf.otf.or.ttc.font.file", charSequence.toString()));
        }
        this.process(arrby, bl4);
        if (!bl3 && this.embedded && this.os_2.fsType == 2) {
            charSequence = new StringBuilder();
            charSequence.append(this.fileName);
            charSequence.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("1.cannot.be.embedded.due.to.licensing.restrictions", charSequence.toString()));
        }
        if (!this.encoding.startsWith("#")) {
            PdfEncodings.convertToBytes(" ", string2);
        }
        this.createEncoding();
    }

    protected static int[] compactRanges(ArrayList<int[]> arrn) {
        int n2;
        int n3;
        int n4;
        int n5;
        int[] arrn2;
        ArrayList<int[]> arrayList = new ArrayList<int[]>();
        for (n2 = 0; n2 < arrn.size(); ++n2) {
            arrn2 = arrn.get(n2);
            for (n4 = 0; n4 < arrn2.length; n4 += 2) {
                n5 = arrn2[n4];
                n3 = n4 + 1;
                arrayList.add(new int[]{Math.max(0, Math.min(n5, arrn2[n3])), Math.min(65535, Math.max(arrn2[n4], arrn2[n3]))});
            }
        }
        n4 = 0;
        while (n4 < arrayList.size() - 1) {
            n2 = n5 = n4 + 1;
            while (n2 < arrayList.size()) {
                block8 : {
                    block7 : {
                        arrn = (int[])arrayList.get(n4);
                        if (arrn[0] >= (arrn2 = (int[])arrayList.get(n2))[0] && arrn[0] <= arrn2[1]) break block7;
                        n3 = n2;
                        if (arrn[1] < arrn2[0]) break block8;
                        n3 = n2;
                        if (arrn[0] > arrn2[1]) break block8;
                    }
                    arrn[0] = Math.min(arrn[0], arrn2[0]);
                    arrn[1] = Math.max(arrn[1], arrn2[1]);
                    arrayList.remove(n2);
                    n3 = n2 - 1;
                }
                n2 = n3 + 1;
            }
            n4 = n5;
        }
        arrn = new int[arrayList.size() * 2];
        for (n2 = 0; n2 < arrayList.size(); ++n2) {
            arrn2 = (int[])arrayList.get(n2);
            n4 = n2 * 2;
            arrn[n4] = arrn2[0];
            arrn[n4 + 1] = arrn2[1];
        }
        return arrn;
    }

    protected static String getTTCName(String string2) {
        int n2 = string2.toLowerCase().indexOf(".ttc,");
        if (n2 < 0) {
            return string2;
        }
        return string2.substring(0, n2 + 4);
    }

    private void readBbox() {
        Object object = this.tables.get("head");
        if (object != null) {
            int[] arrn;
            Object object2;
            this.rf.seek(object[0] + 51);
            Object object3 = this.rf.readUnsignedShort() == 0 ? 1 : 0;
            object = this.tables.get("loca");
            if (object == null) {
                return;
            }
            this.rf.seek((long)object[0]);
            if (object3 != 0) {
                object2 = object[1] / 2;
                arrn = new int[object2];
                object3 = 0;
                do {
                    object = arrn;
                    if (object3 < object2) {
                        arrn[object3] = this.rf.readUnsignedShort() * 2;
                        ++object3;
                        continue;
                    }
                    break;
                } while (true);
            } else {
                object2 = object[1] / 4;
                arrn = new int[object2];
                object3 = 0;
                do {
                    object = arrn;
                    if (object3 >= object2) break;
                    arrn[object3] = this.rf.readInt();
                    ++object3;
                } while (true);
            }
            if ((arrn = this.tables.get("glyf")) != null) {
                int n2 = arrn[0];
                this.bboxes = new int[((Object)object).length - 1][];
                object3 = 0;
                while (object3 < ((Object)object).length - 1) {
                    Object object4 = object[object3];
                    object2 = object3 + 1;
                    if (object4 != object[object2]) {
                        this.rf.seek((long)(object4 + n2 + 2));
                        this.bboxes[object3] = new int[]{this.rf.readShort() * 1000 / this.head.unitsPerEm, this.rf.readShort() * 1000 / this.head.unitsPerEm, this.rf.readShort() * 1000 / this.head.unitsPerEm, this.rf.readShort() * 1000 / this.head.unitsPerEm};
                    }
                    object3 = object2;
                }
                return;
            }
            object = new StringBuilder();
            object.append(this.fileName);
            object.append(this.style);
            throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "glyf", object.toString()));
        }
        object = new StringBuilder();
        object.append(this.fileName);
        object.append(this.style);
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "head", object.toString()));
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void addRangeUni(HashMap<Integer, int[]> hashMap, boolean bl2, boolean bl3) {
        void var7_7;
        int[] arrn;
        if (!(bl3 || this.subsetRanges == null && this.directoryOffset <= 0)) {
            if (this.subsetRanges == null && this.directoryOffset > 0) {
                int[] arrn2 = arrn = new int[2];
                arrn2[0] = 0;
                arrn2[1] = 65535;
            } else {
                arrn = TrueTypeFont.compactRanges(this.subsetRanges);
            }
            if (!this.fontSpecific && this.cmap31 != null || (!this.fontSpecific || this.cmap10 == null) && this.cmap31 != null) {
                HashMap<Integer, int[]> hashMap2 = this.cmap31;
            } else {
                HashMap<Integer, int[]> hashMap3 = this.cmap10;
            }
        } else {
            return;
        }
        Iterator iterator = var7_7.entrySet().iterator();
        while (iterator.hasNext()) {
            Integer n2;
            int n3;
            void var7_12;
            int n4;
            int[] arrn3;
            block10 : {
                Map.Entry entry = iterator.next();
                arrn3 = (int[])entry.getValue();
                n2 = arrn3[0];
                if (hashMap.containsKey(n2)) continue;
                n4 = (Integer)entry.getKey();
                for (n3 = 0; n3 < arrn.length; n3 += 2) {
                    if (n4 < arrn[n3] || n4 > arrn[n3 + 1]) continue;
                    n3 = 0;
                    break block10;
                }
                n3 = 1;
            }
            if (n3 != 0) continue;
            if (bl2) {
                int[] arrn4 = new int[]{arrn3[0], arrn3[1], n4};
            } else {
                Object var7_11 = null;
            }
            hashMap.put(n2, (int[])var7_12);
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    protected void addRangeUni(HashSet<Integer> hashSet, boolean bl2) {
        int[] arrn;
        if (!(bl2 || this.subsetRanges == null && this.directoryOffset <= 0)) {
            if (this.subsetRanges == null && this.directoryOffset > 0) {
                int[] arrn2 = arrn = new int[2];
                arrn2[0] = 0;
                arrn2[1] = 65535;
            } else {
                arrn = TrueTypeFont.compactRanges(this.subsetRanges);
            }
        } else {
            return;
        }
        HashMap<Integer, int[]> hashMap = !this.fontSpecific && this.cmap31 != null || (!this.fontSpecific || this.cmap10 == null) && this.cmap31 != null ? this.cmap31 : this.cmap10;
        hashMap = hashMap.entrySet().iterator();
        while (hashMap.hasNext()) {
            int n2;
            Integer n3;
            block6 : {
                Map.Entry entry = (Map.Entry)hashMap.next();
                int[] arrn3 = (int[])entry.getValue();
                int n4 = 0;
                n3 = arrn3[0];
                if (hashSet.contains(n3)) continue;
                int n5 = (Integer)entry.getKey();
                for (n2 = 0; n2 < arrn.length; n2 += 2) {
                    if (n5 < arrn[n2] || n5 > arrn[n2 + 1]) continue;
                    n2 = n4;
                    break block6;
                }
                n2 = 1;
            }
            if (n2 != 0) continue;
            hashSet.add(n3);
        }
    }

    void checkCff() {
        int[] arrn = this.tables.get("CFF ");
        if (arrn != null) {
            this.cff = true;
            this.cffOffset = arrn[0];
            this.cffLength = arrn[1];
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    void fillTables() {
        block16 : {
            block15 : {
                block14 : {
                    block17 : {
                        block13 : {
                            var5_1 = this.tables.get("head");
                            var4_2 = true;
                            if (var5_1 == null) {
                                var5_1 = new StringBuilder();
                                var5_1.append(this.fileName);
                                var5_1.append(this.style);
                                throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", new Object[]{"head", var5_1.toString()}));
                            }
                            this.rf.seek(var5_1[0] + 16);
                            this.head.flags = this.rf.readUnsignedShort();
                            this.head.unitsPerEm = this.rf.readUnsignedShort();
                            this.rf.skipBytes(16);
                            this.head.xMin = this.rf.readShort();
                            this.head.yMin = this.rf.readShort();
                            this.head.xMax = this.rf.readShort();
                            this.head.yMax = this.rf.readShort();
                            this.head.macStyle = this.rf.readUnsignedShort();
                            var5_1 = this.tables.get("hhea");
                            if (var5_1 == null) {
                                var5_1 = new StringBuilder();
                                var5_1.append(this.fileName);
                                var5_1.append(this.style);
                                throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", new Object[]{"hhea", var5_1.toString()}));
                            }
                            this.rf.seek((long)(var5_1[0] + 4));
                            this.hhea.Ascender = this.rf.readShort();
                            this.hhea.Descender = this.rf.readShort();
                            this.hhea.LineGap = this.rf.readShort();
                            this.hhea.advanceWidthMax = this.rf.readUnsignedShort();
                            this.hhea.minLeftSideBearing = this.rf.readShort();
                            this.hhea.minRightSideBearing = this.rf.readShort();
                            this.hhea.xMaxExtent = this.rf.readShort();
                            this.hhea.caretSlopeRise = this.rf.readShort();
                            this.hhea.caretSlopeRun = this.rf.readShort();
                            this.rf.skipBytes(12);
                            this.hhea.numberOfHMetrics = this.rf.readUnsignedShort();
                            var5_1 = this.tables.get("OS/2");
                            if (var5_1 == null) break block13;
                            this.rf.seek((long)var5_1[0]);
                            var1_3 = this.rf.readUnsignedShort();
                            this.os_2.xAvgCharWidth = this.rf.readShort();
                            this.os_2.usWeightClass = this.rf.readUnsignedShort();
                            this.os_2.usWidthClass = this.rf.readUnsignedShort();
                            this.os_2.fsType = this.rf.readShort();
                            this.os_2.ySubscriptXSize = this.rf.readShort();
                            this.os_2.ySubscriptYSize = this.rf.readShort();
                            this.os_2.ySubscriptXOffset = this.rf.readShort();
                            this.os_2.ySubscriptYOffset = this.rf.readShort();
                            this.os_2.ySuperscriptXSize = this.rf.readShort();
                            this.os_2.ySuperscriptYSize = this.rf.readShort();
                            this.os_2.ySuperscriptXOffset = this.rf.readShort();
                            this.os_2.ySuperscriptYOffset = this.rf.readShort();
                            this.os_2.yStrikeoutSize = this.rf.readShort();
                            this.os_2.yStrikeoutPosition = this.rf.readShort();
                            this.os_2.sFamilyClass = this.rf.readShort();
                            this.rf.readFully(this.os_2.panose);
                            this.rf.skipBytes(16);
                            this.rf.readFully(this.os_2.achVendID);
                            this.os_2.fsSelection = this.rf.readUnsignedShort();
                            this.os_2.usFirstCharIndex = this.rf.readUnsignedShort();
                            this.os_2.usLastCharIndex = this.rf.readUnsignedShort();
                            this.os_2.sTypoAscender = this.rf.readShort();
                            this.os_2.sTypoDescender = this.rf.readShort();
                            if (this.os_2.sTypoDescender > 0) {
                                this.os_2.sTypoDescender = - this.os_2.sTypoDescender;
                            }
                            this.os_2.sTypoLineGap = this.rf.readShort();
                            this.os_2.usWinAscent = this.rf.readUnsignedShort();
                            this.os_2.usWinDescent = this.rf.readUnsignedShort();
                            this.os_2.ulCodePageRange1 = 0;
                            this.os_2.ulCodePageRange2 = 0;
                            if (var1_3 > 0) {
                                this.os_2.ulCodePageRange1 = this.rf.readInt();
                                this.os_2.ulCodePageRange2 = this.rf.readInt();
                            }
                            if (var1_3 <= 1) break block14;
                            this.rf.skipBytes(2);
                            var5_1 = this.os_2;
                            var1_3 = this.rf.readShort();
                            break block15;
                        }
                        if (this.tables.get("hhea") == null || this.tables.get("head") == null) break block16;
                        var1_3 = this.head.macStyle;
                        var2_4 = 5;
                        if (var1_3 != 0) break block17;
                        var5_1 = this.os_2;
                        var1_3 = 700;
                        ** GOTO lbl99
                    }
                    var3_5 = this.head.macStyle;
                    var1_3 = 400;
                    if (var3_5 == 5) {
                        this.os_2.usWeightClass = 400;
                        var5_1 = this.os_2;
                        var1_3 = 3;
                    } else if (this.head.macStyle == 6) {
                        this.os_2.usWeightClass = 400;
                        var5_1 = this.os_2;
                        var1_3 = 7;
                    } else {
                        var5_1 = this.os_2;
lbl99: // 2 sources:
                        var5_1.usWeightClass = var1_3;
                        var5_1 = this.os_2;
                        var1_3 = var2_4;
                    }
                    var5_1.usWidthClass = var1_3;
                    this.os_2.fsType = 0;
                    this.os_2.ySubscriptYSize = 0;
                    this.os_2.ySubscriptYOffset = 0;
                    this.os_2.ySuperscriptYSize = 0;
                    this.os_2.ySuperscriptYOffset = 0;
                    this.os_2.yStrikeoutSize = 0;
                    this.os_2.yStrikeoutPosition = 0;
                    this.os_2.sTypoAscender = (short)((double)this.hhea.Ascender - (double)this.hhea.Ascender * 0.21);
                    this.os_2.sTypoDescender = (short)(- (double)Math.abs(this.hhea.Descender) - (double)Math.abs(this.hhea.Descender) * 0.07);
                    this.os_2.sTypoLineGap = (short)(this.hhea.LineGap * 2);
                    this.os_2.usWinAscent = this.hhea.Ascender;
                    this.os_2.usWinDescent = this.hhea.Descender;
                    this.os_2.ulCodePageRange1 = 0;
                    this.os_2.ulCodePageRange2 = 0;
                }
                var5_1 = this.os_2;
                var1_3 = (int)((double)this.head.unitsPerEm * 0.7);
            }
            var5_1.sCapHeight = var1_3;
        }
        if ((var5_1 = this.tables.get("post")) == null) {
            this.italicAngle = (- Math.atan2(this.hhea.caretSlopeRun, this.hhea.caretSlopeRise)) * 180.0 / 3.141592653589793;
        } else {
            this.rf.seek((long)(var5_1[0] + 4));
            var1_3 = this.rf.readShort();
            var2_4 = this.rf.readUnsignedShort();
            this.italicAngle = (double)var1_3 + (double)var2_4 / 16384.0;
            this.underlinePosition = this.rf.readShort();
            this.underlineThickness = this.rf.readShort();
            if (this.rf.readInt() == 0) {
                var4_2 = false;
            }
            this.isFixedPitch = var4_2;
        }
        var5_1 = this.tables.get("maxp");
        if (var5_1 == null) {
            var1_3 = 65536;
        } else {
            this.rf.seek((long)(var5_1[0] + 4));
            var1_3 = this.rf.readUnsignedShort();
        }
        this.maxGlyphId = var1_3;
    }

    @Override
    public String[][] getAllNameEntries() {
        return this.allNameEntries;
    }

    String[][] getAllNames() {
        int[] arrn = this.tables.get("name");
        int n2 = 0;
        if (arrn != null) {
            Object object;
            int n3;
            this.rf.seek(arrn[0] + 2);
            int n4 = this.rf.readUnsignedShort();
            int n5 = this.rf.readUnsignedShort();
            ArrayList<String[]> arrayList = new ArrayList<String[]>();
            for (n3 = 0; n3 < n4; ++n3) {
                int n6 = this.rf.readUnsignedShort();
                int n7 = this.rf.readUnsignedShort();
                int n8 = this.rf.readUnsignedShort();
                int n9 = this.rf.readUnsignedShort();
                int n10 = this.rf.readUnsignedShort();
                int n11 = this.rf.readUnsignedShort();
                int n12 = (int)this.rf.getFilePointer();
                this.rf.seek(arrn[0] + n5 + n11);
                object = n6 != 0 && n6 != 3 && (n6 != 2 || n7 != 1) ? this.readStandardString(n10) : this.readUnicodeString(n10);
                arrayList.add(new String[]{String.valueOf(n9), String.valueOf(n6), String.valueOf(n7), String.valueOf(n8), object});
                this.rf.seek(n12);
            }
            object = new String[arrayList.size()][];
            for (n3 = n2; n3 < arrayList.size(); ++n3) {
                object[n3] = (String[])arrayList.get(n3);
            }
            return object;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(this.fileName);
        stringBuilder.append(this.style);
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "name", stringBuilder.toString()));
    }

    String getBaseFont() {
        Object object = this.tables.get("name");
        if (object != null) {
            this.rf.seek(object[0] + 2);
            int n2 = this.rf.readUnsignedShort();
            int n3 = this.rf.readUnsignedShort();
            for (int i2 = 0; i2 < n2; ++i2) {
                int n4 = this.rf.readUnsignedShort();
                this.rf.readUnsignedShort();
                this.rf.readUnsignedShort();
                int n5 = this.rf.readUnsignedShort();
                int n6 = this.rf.readUnsignedShort();
                int n7 = this.rf.readUnsignedShort();
                if (n5 != 6) continue;
                this.rf.seek((long)(object[0] + n3 + n7));
                if (n4 != 0 && n4 != 3) {
                    return this.readStandardString(n6);
                }
                return this.readUnicodeString(n6);
            }
            return new File(this.fileName).getName().replace(' ', '-');
        }
        object = new StringBuilder();
        object.append(this.fileName);
        object.append(this.style);
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "name", object.toString()));
    }

    @Override
    public String[] getCodePagesSupported() {
        int n2;
        int n3;
        long l2 = ((long)this.os_2.ulCodePageRange2 << 32) + ((long)this.os_2.ulCodePageRange1 & 0xFFFFFFFFL);
        long l3 = 1L;
        int n4 = 0;
        long l4 = 1L;
        int n5 = 0;
        for (n3 = 0; n3 < 64; ++n3) {
            n2 = n5;
            if ((l2 & l4) != 0L) {
                n2 = n5;
                if (codePages[n3] != null) {
                    n2 = n5 + 1;
                }
            }
            l4 <<= 1;
            n5 = n2;
        }
        String[] arrstring = new String[n5];
        n5 = 0;
        l4 = l3;
        for (n3 = n4; n3 < 64; ++n3) {
            n2 = n5;
            if ((l2 & l4) != 0L) {
                n2 = n5;
                if (codePages[n3] != null) {
                    arrstring[n5] = codePages[n3];
                    n2 = n5 + 1;
                }
            }
            l4 <<= 1;
            n5 = n2;
        }
        return arrstring;
    }

    @Override
    public String[][] getFamilyFontName() {
        return this.familyName;
    }

    /*
     * Enabled aggressive block sorting
     */
    protected PdfDictionary getFontBaseType(PdfIndirectReference pdfIndirectReference, String object, int n2, int n3, byte[] arrby) {
        Serializable serializable;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONT);
        if (this.cff) {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.TYPE1);
            object = PdfName.BASEFONT;
            serializable = new StringBuilder();
            serializable.append(this.fontName);
            serializable.append(this.style);
            pdfDictionary.put((PdfName)object, new PdfName(serializable.toString()));
        } else {
            pdfDictionary.put(PdfName.SUBTYPE, PdfName.TRUETYPE);
            serializable = PdfName.BASEFONT;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append((String)object);
            stringBuilder.append(this.fontName);
            stringBuilder.append(this.style);
            pdfDictionary.put((PdfName)serializable, new PdfName(stringBuilder.toString()));
        }
        int n4 = n2;
        if (!this.fontSpecific) {
            int n5 = n2;
            do {
                n4 = n2;
                if (n5 > n3) break;
                if (!this.differences[n5].equals(".notdef")) {
                    n4 = n5;
                    break;
                }
                ++n5;
            } while (true);
            if (this.encoding.equals("Cp1252") || this.encoding.equals("MacRoman")) {
                serializable = PdfName.ENCODING;
                object = this.encoding.equals("Cp1252") ? PdfName.WIN_ANSI_ENCODING : PdfName.MAC_ROMAN_ENCODING;
                pdfDictionary.put((PdfName)serializable, (PdfObject)object);
            } else {
                object = new PdfDictionary(PdfName.ENCODING);
                serializable = new PdfArray();
                n2 = 1;
                for (int i2 = n4; i2 <= n3; ++i2) {
                    if (arrby[i2] != 0) {
                        n5 = n2;
                        if (n2 != 0) {
                            serializable.add(new PdfNumber(i2));
                            n5 = 0;
                        }
                        serializable.add(new PdfName(this.differences[i2]));
                        n2 = n5;
                        continue;
                    }
                    n2 = 1;
                }
                object.put(PdfName.DIFFERENCES, (PdfObject)serializable);
                pdfDictionary.put(PdfName.ENCODING, (PdfObject)object);
            }
        }
        pdfDictionary.put(PdfName.FIRSTCHAR, new PdfNumber(n4));
        pdfDictionary.put(PdfName.LASTCHAR, new PdfNumber(n3));
        serializable = new PdfArray();
        while (n4 <= n3) {
            object = arrby[n4] == 0 ? new PdfNumber(0) : new PdfNumber(this.widths[n4]);
            serializable.add((PdfObject)object);
            ++n4;
        }
        pdfDictionary.put(PdfName.WIDTHS, (PdfObject)serializable);
        if (pdfIndirectReference != null) {
            pdfDictionary.put(PdfName.FONTDESCRIPTOR, pdfIndirectReference);
        }
        return pdfDictionary;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    @Override
    public float getFontDescriptor(int n2, float f2) {
        switch (n2) {
            default: {
                return 0.0f;
            }
            case 22: {
                return this.os_2.usWidthClass;
            }
            case 21: {
                return this.os_2.usWeightClass;
            }
            case 20: {
                return (float)this.os_2.ySuperscriptYOffset * f2 / (float)this.head.unitsPerEm;
            }
            case 19: {
                return (float)this.os_2.ySuperscriptYSize * f2 / (float)this.head.unitsPerEm;
            }
            case 18: {
                return (float)(- this.os_2.ySubscriptYOffset) * f2 / (float)this.head.unitsPerEm;
            }
            case 17: {
                return (float)this.os_2.ySubscriptYSize * f2 / (float)this.head.unitsPerEm;
            }
            case 16: {
                return (float)this.os_2.yStrikeoutSize * f2 / (float)this.head.unitsPerEm;
            }
            case 15: {
                return (float)this.os_2.yStrikeoutPosition * f2 / (float)this.head.unitsPerEm;
            }
            case 14: {
                return (float)this.underlineThickness * f2 / (float)this.head.unitsPerEm;
            }
            case 13: {
                return (float)(this.underlinePosition - this.underlineThickness / 2) * f2 / (float)this.head.unitsPerEm;
            }
            case 12: {
                n2 = this.hhea.advanceWidthMax;
                do {
                    return f2 * (float)n2 / (float)this.head.unitsPerEm;
                    break;
                } while (true);
            }
            case 11: {
                n2 = this.hhea.LineGap;
                return f2 * (float)n2 / (float)this.head.unitsPerEm;
            }
            case 10: {
                n2 = this.hhea.Descender;
                return f2 * (float)n2 / (float)this.head.unitsPerEm;
            }
            case 9: {
                n2 = this.hhea.Ascender;
                return f2 * (float)n2 / (float)this.head.unitsPerEm;
            }
            case 8: {
                n2 = this.head.yMax;
                return f2 * (float)n2 / (float)this.head.unitsPerEm;
            }
            case 7: {
                n2 = this.head.xMax;
                return f2 * (float)n2 / (float)this.head.unitsPerEm;
            }
            case 6: {
                n2 = this.head.yMin;
                return f2 * (float)n2 / (float)this.head.unitsPerEm;
            }
            case 5: {
                n2 = this.head.xMin;
                return f2 * (float)n2 / (float)this.head.unitsPerEm;
            }
            case 4: {
                return (float)this.italicAngle;
            }
            case 3: {
                return (float)this.os_2.sTypoDescender * f2 / (float)this.head.unitsPerEm;
            }
            case 2: {
                return (float)this.os_2.sCapHeight * f2 / (float)this.head.unitsPerEm;
            }
            case 1: 
        }
        return (float)this.os_2.sTypoAscender * f2 / (float)this.head.unitsPerEm;
    }

    /*
     * Enabled aggressive block sorting
     */
    protected PdfDictionary getFontDescriptor(PdfIndirectReference pdfIndirectReference, String object, PdfIndirectReference pdfObject) {
        void var3_7;
        PdfDictionary pdfDictionary = new PdfDictionary(PdfName.FONTDESCRIPTOR);
        pdfDictionary.put(PdfName.ASCENT, new PdfNumber(this.os_2.sTypoAscender * 1000 / this.head.unitsPerEm));
        pdfDictionary.put(PdfName.CAPHEIGHT, new PdfNumber(this.os_2.sCapHeight * 1000 / this.head.unitsPerEm));
        pdfDictionary.put(PdfName.DESCENT, new PdfNumber(this.os_2.sTypoDescender * 1000 / this.head.unitsPerEm));
        pdfDictionary.put(PdfName.FONTBBOX, new PdfRectangle(this.head.xMin * 1000 / this.head.unitsPerEm, this.head.yMin * 1000 / this.head.unitsPerEm, this.head.xMax * 1000 / this.head.unitsPerEm, this.head.yMax * 1000 / this.head.unitsPerEm));
        if (pdfObject != null) {
            pdfDictionary.put(PdfName.CIDSET, pdfObject);
        }
        if (this.cff) {
            if (this.encoding.startsWith("Identity-")) {
                PdfName pdfName = PdfName.FONTNAME;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append((String)object);
                stringBuilder.append(this.fontName);
                stringBuilder.append("-");
                stringBuilder.append(this.encoding);
                object = new PdfName(stringBuilder.toString());
            } else {
                PdfName pdfName = PdfName.FONTNAME;
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append((String)object);
                stringBuilder.append(this.fontName);
                stringBuilder.append(this.style);
                object = new PdfName(stringBuilder.toString());
            }
        } else {
            PdfName pdfName = PdfName.FONTNAME;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append((String)object);
            stringBuilder.append(this.fontName);
            stringBuilder.append(this.style);
            object = new PdfName(stringBuilder.toString());
        }
        pdfDictionary.put((PdfName)var3_7, (PdfObject)object);
        pdfDictionary.put(PdfName.ITALICANGLE, new PdfNumber(this.italicAngle));
        pdfDictionary.put(PdfName.STEMV, new PdfNumber(80));
        if (pdfIndirectReference != null) {
            object = this.cff ? PdfName.FONTFILE3 : PdfName.FONTFILE2;
            pdfDictionary.put((PdfName)object, pdfIndirectReference);
        }
        int n2 = 0;
        if (this.isFixedPitch) {
            n2 = 1;
        }
        int n3 = this.fontSpecific ? 4 : 32;
        n2 = n3 = n2 | n3;
        if ((this.head.macStyle & 2) != 0) {
            n2 = n3 | 64;
        }
        n3 = n2;
        if ((this.head.macStyle & 1) != 0) {
            n3 = n2 | 262144;
        }
        pdfDictionary.put(PdfName.FLAGS, new PdfNumber(n3));
        return pdfDictionary;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    protected byte[] getFullFont() {
        void var1_7;
        RandomAccessFileOrArray randomAccessFileOrArray;
        block8 : {
            byte[] arrby;
            randomAccessFileOrArray = new RandomAccessFileOrArray(this.rf);
            try {
                randomAccessFileOrArray.reOpen();
                arrby = new byte[(int)randomAccessFileOrArray.length()];
                randomAccessFileOrArray.readFully(arrby);
            }
            catch (Throwable throwable) {}
            try {
                randomAccessFileOrArray.close();
                return arrby;
            }
            catch (Exception exception) {
                return arrby;
            }
            break block8;
            catch (Throwable throwable) {
                randomAccessFileOrArray = null;
            }
        }
        if (randomAccessFileOrArray == null) throw var1_7;
        try {
            randomAccessFileOrArray.close();
        }
        catch (Exception exception) {
            throw var1_7;
        }
        throw var1_7;
    }

    @Override
    public String[][] getFullFontName() {
        return this.fullName;
    }

    @Override
    public PdfStream getFullFontStream() {
        if (this.cff) {
            return new BaseFont.StreamFont(this.readCffFont(), "Type1C", this.compressionLevel);
        }
        byte[] arrby = this.getFullFont();
        int n2 = arrby.length;
        int n3 = this.compressionLevel;
        return new BaseFont.StreamFont(arrby, new int[]{n2}, n3);
    }

    protected int getGlyphWidth(int n2) {
        int n3 = n2;
        if (n2 >= this.glyphWidthsByIndex.length) {
            n3 = this.glyphWidthsByIndex.length - 1;
        }
        return this.glyphWidthsByIndex[n3];
    }

    @Override
    public int getKerning(int n2, int n3) {
        int[] arrn = this.getMetricsTT(n2);
        if (arrn == null) {
            return 0;
        }
        n2 = arrn[0];
        arrn = this.getMetricsTT(n3);
        if (arrn == null) {
            return 0;
        }
        n3 = arrn[0];
        return this.kerning.get((n2 << 16) + n3);
    }

    /*
     * Enabled aggressive block sorting
     */
    public int[] getMetricsTT(int n2) {
        HashMap<Integer, int[]> hashMap;
        block5 : {
            block6 : {
                block4 : {
                    if (this.cmapExt != null) {
                        hashMap = this.cmapExt;
                        return hashMap.get(n2);
                    }
                    if (!this.fontSpecific && this.cmap31 != null) break block4;
                    if (this.fontSpecific && this.cmap10 != null) break block5;
                    if (this.cmap31 == null) break block6;
                }
                hashMap = this.cmap31;
                return hashMap.get(n2);
            }
            if (this.cmap10 == null) return null;
        }
        hashMap = this.cmap10;
        return hashMap.get(n2);
    }

    String[][] getNames(int n2) {
        int[] arrn = this.tables.get("name");
        if (arrn != null) {
            Object object;
            this.rf.seek(arrn[0] + 2);
            int n3 = this.rf.readUnsignedShort();
            int n4 = this.rf.readUnsignedShort();
            ArrayList<String[]> arrayList = new ArrayList<String[]>();
            for (int i2 = 0; i2 < n3; ++i2) {
                int n5 = this.rf.readUnsignedShort();
                int n6 = this.rf.readUnsignedShort();
                int n7 = this.rf.readUnsignedShort();
                int n8 = this.rf.readUnsignedShort();
                int n9 = this.rf.readUnsignedShort();
                int n10 = this.rf.readUnsignedShort();
                if (n8 != n2) continue;
                n8 = (int)this.rf.getFilePointer();
                this.rf.seek(arrn[0] + n4 + n10);
                object = n5 != 0 && n5 != 3 && (n5 != 2 || n6 != 1) ? this.readStandardString(n9) : this.readUnicodeString(n9);
                arrayList.add(new String[]{String.valueOf(n5), String.valueOf(n6), String.valueOf(n7), object});
                this.rf.seek(n8);
            }
            object = new String[arrayList.size()][];
            for (n2 = 0; n2 < arrayList.size(); ++n2) {
                object[n2] = (String[])arrayList.get(n2);
            }
            return object;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(this.fileName);
        stringBuilder.append(this.style);
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "name", stringBuilder.toString()));
    }

    @Override
    public String getPostscriptFontName() {
        return this.fontName;
    }

    @Override
    protected int[] getRawCharBBox(int n2, String object) {
        object = object != null && this.cmap31 != null ? this.cmap31 : this.cmap10;
        if (object == null) {
            return null;
        }
        if ((object = object.get(n2)) != null) {
            if (this.bboxes == null) {
                return null;
            }
            return this.bboxes[object[0]];
        }
        return null;
    }

    @Override
    int getRawWidth(int n2, String arrn) {
        arrn = this.getMetricsTT(n2);
        if (arrn == null) {
            return 0;
        }
        return arrn[1];
    }

    protected byte[] getSubSet(HashSet arrby, boolean bl2) {
        synchronized (this) {
            arrby = new TrueTypeFontSubSet(this.fileName, new RandomAccessFileOrArray(this.rf), (HashSet<Integer>)arrby, this.directoryOffset, true, bl2 ^ true).process();
            return arrby;
        }
    }

    @Override
    public String getSubfamily() {
        if (this.subFamily != null && this.subFamily.length > 0) {
            return this.subFamily[0][3];
        }
        return super.getSubfamily();
    }

    @Override
    public boolean hasKernPairs() {
        if (this.kerning.size() > 0) {
            return true;
        }
        return false;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    void process(byte[] var1_1, boolean var2_3) {
        block11 : {
            this.tables = new HashMap<K, V>();
            this.rf = var1_1 /* !! */  == null ? new RandomAccessFileOrArray(this.fileName, (boolean)var2_6, Document.plainRandomAccess) : new RandomAccessFileOrArray(var1_1 /* !! */ );
            try {
                if (this.ttcIndex.length() > 0) {
                    var3_7 = Integer.parseInt(this.ttcIndex);
                    if (var3_7 < 0) {
                        throw new DocumentException(MessageLocalization.getComposedMessage("the.font.index.for.1.must.be.positive", new Object[]{this.fileName}));
                    }
                    if (!this.readStandardString(4).equals("ttcf")) {
                        throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.valid.ttc.file", new Object[]{this.fileName}));
                    }
                    this.rf.skipBytes(4);
                    var4_8 = this.rf.readInt();
                    if (var3_7 >= var4_8) {
                        throw new DocumentException(MessageLocalization.getComposedMessage("the.font.index.for.1.must.be.between.0.and.2.it.was.3", new Object[]{this.fileName, String.valueOf(var4_8 - 1), String.valueOf(var3_7)}));
                    }
                    this.rf.skipBytes(var3_7 * 4);
                    this.directoryOffset = this.rf.readInt();
                }
                this.rf.seek(this.directoryOffset);
                var3_7 = this.rf.readInt();
                if (var3_7 != 65536 && var3_7 != 1330926671) {
                    throw new DocumentException(MessageLocalization.getComposedMessage("1.is.not.a.valid.ttf.or.otf.file", new Object[]{this.fileName}));
                }
                var4_8 = this.rf.readUnsignedShort();
                this.rf.skipBytes(6);
                break block11;
            }
            catch (Throwable var1_5) {}
            throw var1_5;
        }
        for (var3_7 = 0; var3_7 < var4_8; ++var3_7) {
            var1_3 = this.readStandardString(4);
            this.rf.skipBytes(4);
            var5_9 = this.rf.readInt();
            var6_10 = this.rf.readInt();
            this.tables.put(var1_3, new int[]{var5_9, var6_10});
        }
        ** try [egrp 1[TRYBLOCK] [10 : 377->493)] { 
lbl34: // 1 sources:
        this.checkCff();
        this.fontName = this.getBaseFont();
        this.fullName = this.getNames(4);
        var1_4 = this.getNames(16);
        this.familyName = var1_4.length > 0 ? var1_4 : this.getNames(1);
        var7_11 = this.getNames(17);
        this.subFamily = var1_4.length > 0 ? var7_11 : this.getNames(2);
        this.allNameEntries = this.getAllNames();
        if (this.justNames != false) return;
        this.fillTables();
        this.readGlyphWidths();
        this.readCMaps();
        this.readKerning();
        this.readBbox();
        return;
lbl49: // 1 sources:
        finally {
            if (!this.embedded) {
                this.rf.close();
                this.rf = null;
            }
        }
    }

    void readCMaps() {
        block21 : {
            int n2;
            int[] arrn;
            int n3;
            int n4;
            HashMap<Integer, int[]> hashMap;
            int n5;
            block22 : {
                block25 : {
                    block23 : {
                        block24 : {
                            arrn = this.tables.get("cmap");
                            if (arrn == null) break block21;
                            this.rf.seek(arrn[0]);
                            this.rf.skipBytes(2);
                            int n6 = this.rf.readUnsignedShort();
                            this.fontSpecific = false;
                            int n7 = 0;
                            n4 = 0;
                            n2 = 0;
                            n3 = 0;
                            for (int i2 = 0; i2 < n6; ++i2) {
                                int n8;
                                int n9;
                                int n10;
                                int n11 = this.rf.readUnsignedShort();
                                int n12 = this.rf.readUnsignedShort();
                                n5 = this.rf.readInt();
                                if (n11 == 3 && n12 == 0) {
                                    this.fontSpecific = true;
                                    n8 = n5;
                                    n9 = n4;
                                    n10 = n3;
                                } else if (n11 == 3 && n12 == 1) {
                                    n9 = n5;
                                    n8 = n2;
                                    n10 = n3;
                                } else {
                                    n9 = n4;
                                    n8 = n2;
                                    n10 = n3;
                                    if (n11 == 3) {
                                        n9 = n4;
                                        n8 = n2;
                                        n10 = n3;
                                        if (n12 == 10) {
                                            n10 = n5;
                                            n8 = n2;
                                            n9 = n4;
                                        }
                                    }
                                }
                                n3 = n7;
                                if (n11 == 1) {
                                    n3 = n7;
                                    if (n12 == 0) {
                                        n3 = n5;
                                    }
                                }
                                n7 = n3;
                                n4 = n9;
                                n2 = n8;
                                n3 = n10;
                            }
                            if (n7 <= 0) break block22;
                            this.rf.seek(arrn[0] + n7);
                            n5 = this.rf.readUnsignedShort();
                            if (n5 == 0) break block23;
                            if (n5 == 4) break block24;
                            if (n5 != 6) break block22;
                            hashMap = this.readFormat6();
                            break block25;
                        }
                        hashMap = this.readFormat4();
                        break block25;
                    }
                    hashMap = this.readFormat0();
                }
                this.cmap10 = hashMap;
            }
            if (n4 > 0) {
                this.rf.seek(arrn[0] + n4);
                if (this.rf.readUnsignedShort() == 4) {
                    this.cmap31 = this.readFormat4();
                }
            }
            if (n2 > 0) {
                this.rf.seek(arrn[0] + n2);
                if (this.rf.readUnsignedShort() == 4) {
                    this.cmap10 = this.readFormat4();
                }
            }
            if (n3 > 0) {
                this.rf.seek(arrn[0] + n3);
                n5 = this.rf.readUnsignedShort();
                if (n5 != 0) {
                    if (n5 != 4) {
                        if (n5 != 6) {
                            if (n5 != 12) {
                                return;
                            }
                            hashMap = this.readFormat12();
                        } else {
                            hashMap = this.readFormat6();
                        }
                    } else {
                        hashMap = this.readFormat4();
                    }
                } else {
                    hashMap = this.readFormat0();
                }
                this.cmapExt = hashMap;
            }
            return;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(this.fileName);
        stringBuilder.append(this.style);
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "cmap", stringBuilder.toString()));
    }

    protected byte[] readCffFont() {
        RandomAccessFileOrArray randomAccessFileOrArray = new RandomAccessFileOrArray(this.rf);
        byte[] arrby = new byte[this.cffLength];
        try {
            randomAccessFileOrArray.reOpen();
            randomAccessFileOrArray.seek(this.cffOffset);
            randomAccessFileOrArray.readFully(arrby);
            return arrby;
        }
        finally {
            randomAccessFileOrArray.close();
        }
    }

    HashMap<Integer, int[]> readFormat0() {
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        this.rf.skipBytes(4);
        for (int i2 = 0; i2 < 256; ++i2) {
            int[] arrn;
            arrn = new int[]{this.rf.readUnsignedByte(), this.getGlyphWidth(arrn[0])};
            hashMap.put(i2, arrn);
        }
        return hashMap;
    }

    HashMap<Integer, int[]> readFormat12() {
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        this.rf.skipBytes(2);
        this.rf.readInt();
        this.rf.skipBytes(4);
        int n2 = this.rf.readInt();
        for (int i2 = 0; i2 < n2; ++i2) {
            int n3 = this.rf.readInt();
            int n4 = this.rf.readInt();
            for (int i3 = this.rf.readInt(); i3 <= n3; ++i3) {
                int[] arrn;
                arrn = new int[]{n4++, this.getGlyphWidth(arrn[0])};
                hashMap.put(i3, arrn);
            }
        }
        return hashMap;
    }

    HashMap<Integer, int[]> readFormat4() {
        int n2;
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        int n3 = this.rf.readUnsignedShort();
        this.rf.skipBytes(2);
        int n4 = this.rf.readUnsignedShort() / 2;
        this.rf.skipBytes(6);
        int[] arrn = new int[n4];
        for (n2 = 0; n2 < n4; ++n2) {
            arrn[n2] = this.rf.readUnsignedShort();
        }
        this.rf.skipBytes(2);
        int[] arrn2 = new int[n4];
        for (n2 = 0; n2 < n4; ++n2) {
            arrn2[n2] = this.rf.readUnsignedShort();
        }
        int[] arrn3 = new int[n4];
        for (n2 = 0; n2 < n4; ++n2) {
            arrn3[n2] = this.rf.readUnsignedShort();
        }
        int[] arrn4 = new int[n4];
        for (n2 = 0; n2 < n4; ++n2) {
            arrn4[n2] = this.rf.readUnsignedShort();
        }
        int[] arrn5 = new int[n3 / 2 - 8 - n4 * 4];
        for (n2 = 0; n2 < arrn5.length; ++n2) {
            arrn5[n2] = this.rf.readUnsignedShort();
        }
        for (n3 = 0; n3 < n4; ++n3) {
            for (n2 = arrn2[n3]; n2 <= arrn[n3] && n2 != 65535; ++n2) {
                int[] arrn6;
                int n5;
                if (arrn4[n3] == 0) {
                    n5 = arrn3[n3] + n2;
                } else {
                    n5 = arrn4[n3] / 2 + n3 - n4 + n2 - arrn2[n3];
                    if (n5 >= arrn5.length) continue;
                    n5 = arrn5[n5] + arrn3[n3];
                }
                arrn6 = new int[]{65535 & n5, this.getGlyphWidth(arrn6[0])};
                n5 = this.fontSpecific && (65280 & n2) == 61440 ? n2 & 255 : n2;
                hashMap.put(n5, arrn6);
            }
        }
        return hashMap;
    }

    HashMap<Integer, int[]> readFormat6() {
        HashMap<Integer, int[]> hashMap = new HashMap<Integer, int[]>();
        this.rf.skipBytes(4);
        int n2 = this.rf.readUnsignedShort();
        int n3 = this.rf.readUnsignedShort();
        for (int i2 = 0; i2 < n3; ++i2) {
            int[] arrn;
            arrn = new int[]{this.rf.readUnsignedShort(), this.getGlyphWidth(arrn[0])};
            hashMap.put(i2 + n2, arrn);
        }
        return hashMap;
    }

    protected void readGlyphWidths() {
        Object object = this.tables.get("hmtx");
        if (object != null) {
            this.rf.seek(object[0]);
            this.glyphWidthsByIndex = new int[this.hhea.numberOfHMetrics];
            for (int i2 = 0; i2 < this.hhea.numberOfHMetrics; ++i2) {
                this.glyphWidthsByIndex[i2] = this.rf.readUnsignedShort() * 1000 / this.head.unitsPerEm;
                int n2 = this.rf.readShort() * 1000 / this.head.unitsPerEm;
            }
            return;
        }
        object = new StringBuilder();
        object.append(this.fileName);
        object.append(this.style);
        throw new DocumentException(MessageLocalization.getComposedMessage("table.1.does.not.exist.in.2", "hmtx", object.toString()));
    }

    void readKerning() {
        int[] arrn = this.tables.get("kern");
        if (arrn == null) {
            return;
        }
        this.rf.seek(arrn[0] + 2);
        int n2 = this.rf.readUnsignedShort();
        int n3 = arrn[0] + 4;
        int n4 = 0;
        for (int i2 = 0; i2 < n2; ++i2) {
            int n5 = n3 + n4;
            this.rf.seek(n5);
            this.rf.skipBytes(2);
            n4 = this.rf.readUnsignedShort();
            if ((this.rf.readUnsignedShort() & 65527) == 1) {
                int n6 = this.rf.readUnsignedShort();
                this.rf.skipBytes(6);
                for (n3 = 0; n3 < n6; ++n3) {
                    int n7 = this.rf.readInt();
                    int n8 = this.rf.readShort() * 1000 / this.head.unitsPerEm;
                    this.kerning.put(n7, n8);
                }
            }
            n3 = n5;
        }
    }

    protected String readStandardString(int n2) {
        return this.rf.readString(n2, "Cp1252");
    }

    protected String readUnicodeString(int n2) {
        StringBuffer stringBuffer = new StringBuffer();
        int n3 = n2 / 2;
        for (n2 = 0; n2 < n3; ++n2) {
            stringBuffer.append(this.rf.readChar());
        }
        return stringBuffer.toString();
    }

    @Override
    public boolean setKerning(int n2, int n3, int n4) {
        int[] arrn = this.getMetricsTT(n2);
        if (arrn == null) {
            return false;
        }
        n2 = arrn[0];
        arrn = this.getMetricsTT(n3);
        if (arrn == null) {
            return false;
        }
        n3 = arrn[0];
        this.kerning.put((n2 << 16) + n3, n4);
        return true;
    }

    @Override
    public void setPostscriptFontName(String string2) {
        this.fontName = string2;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    @Override
    void writeFont(PdfWriter var1_1, PdfIndirectReference var2_2, Object[] var3_3) {
        block13 : {
            block12 : {
                block10 : {
                    block11 : {
                        var4_12 = (Integer)var3_3 /* !! */ [0];
                        var5_13 = (Integer)var3_3 /* !! */ [1];
                        var11_14 = (byte[])var3_3 /* !! */ [2];
                        var8_15 = (Boolean)var3_3 /* !! */ [3] != false && this.subset != false;
                        if (!var8_15) {
                            var5_13 = var11_14.length;
                            for (var4_12 = 0; var4_12 < var11_14.length; ++var4_12) {
                                var11_14[var4_12] = 1;
                            }
                            --var5_13;
                            var4_12 = 0;
                        }
                        var3_4 = "";
                        if (!this.embedded) break block10;
                        if (!this.cff) break block11;
                        var9_16 = var1_1.addToBody(new BaseFont.StreamFont(this.readCffFont(), "Type1C", this.compressionLevel));
                        break block12;
                    }
                    if (var8_15) {
                        var3_7 = TrueTypeFont.createSubsetPrefix();
                    }
                    var10_31 = new HashSet<E>();
                    break block13;
                }
                var9_29 = "";
                var3_8 = null;
                ** GOTO lbl31
            }
lbl27: // 2 sources:
            do {
                var10_31 = var9_17.getIndirectReference();
                var9_18 = var3_5;
                var3_6 = var10_31;
lbl31: // 2 sources:
                var10_31 = this.getFontDescriptor((PdfIndirectReference)var3_9, (String)var9_30, null);
                if (var10_31 != null) {
                    var3_10 = var1_1.addToBody((PdfObject)var10_31).getIndirectReference();
                }
                var1_1.addToBody((PdfObject)this.getFontBaseType((PdfIndirectReference)var3_11, (String)var9_30, var4_12, var5_13, var11_14), var2_2);
                return;
                break;
            } while (true);
        }
        for (var6_32 = var4_12; var6_32 <= var5_13; ++var6_32) {
            block16 : {
                block14 : {
                    block15 : {
                        if (var11_14[var6_32] == 0) continue;
                        if (this.specialMap == null) break block14;
                        var9_20 = GlyphList.nameToUnicode(this.differences[var6_32]);
                        if (var9_20 == null) break block15;
                        var7_33 = var9_20[0];
                        ** GOTO lbl52
                    }
                    var9_21 = null;
                    break block16;
                }
                if (this.fontSpecific) {
                    var9_22 = this.getMetricsTT(var6_32);
                } else {
                    var7_33 = this.unicodeDifferences[var6_32];
lbl52: // 2 sources:
                    var9_24 = this.getMetricsTT(var7_33);
                }
            }
            if (var9_19 == null) continue;
            var10_31.add((int)var9_19[0]);
        }
        this.addRangeUni((HashSet<Integer>)var10_31, var8_15);
        if (!var8_15 && this.directoryOffset == 0 && this.subsetRanges == null) {
            var9_25 = this.getFullFont();
        } else {
            var9_26 = this.getSubSet(new HashSet<E>(var10_31), var8_15);
        }
        var6_32 = ((void)var9_27).length;
        var7_33 = this.compressionLevel;
        var9_28 = var1_1.addToBody(new BaseFont.StreamFont((byte[])var9_27, new int[]{var6_32}, var7_33));
        ** while (true)
    }

    protected static class FontHeader {
        int flags;
        int macStyle;
        int unitsPerEm;
        short xMax;
        short xMin;
        short yMax;
        short yMin;

        protected FontHeader() {
        }
    }

    protected static class HorizontalHeader {
        short Ascender;
        short Descender;
        short LineGap;
        int advanceWidthMax;
        short caretSlopeRise;
        short caretSlopeRun;
        short minLeftSideBearing;
        short minRightSideBearing;
        int numberOfHMetrics;
        short xMaxExtent;

        protected HorizontalHeader() {
        }
    }

    protected static class WindowsMetrics {
        byte[] achVendID = new byte[4];
        int fsSelection;
        short fsType;
        byte[] panose = new byte[10];
        int sCapHeight;
        short sFamilyClass;
        short sTypoAscender;
        short sTypoDescender;
        short sTypoLineGap;
        int ulCodePageRange1;
        int ulCodePageRange2;
        int usFirstCharIndex;
        int usLastCharIndex;
        int usWeightClass;
        int usWidthClass;
        int usWinAscent;
        int usWinDescent;
        short xAvgCharWidth;
        short yStrikeoutPosition;
        short yStrikeoutSize;
        short ySubscriptXOffset;
        short ySubscriptXSize;
        short ySubscriptYOffset;
        short ySubscriptYSize;
        short ySuperscriptXOffset;
        short ySuperscriptXSize;
        short ySuperscriptYOffset;
        short ySuperscriptYSize;

        protected WindowsMetrics() {
        }
    }

}

