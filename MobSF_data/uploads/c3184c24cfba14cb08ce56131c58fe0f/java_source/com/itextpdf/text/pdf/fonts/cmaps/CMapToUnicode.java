/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.fonts.cmaps;

import com.itextpdf.text.ExceptionConverter;
import com.itextpdf.text.Utilities;
import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.fonts.cmaps.AbstractCMap;
import java.io.IOException;
import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class CMapToUnicode
extends AbstractCMap {
    private Map<Integer, String> doubleByteMappings = new HashMap<Integer, String>();
    private Map<Integer, String> singleByteMappings = new HashMap<Integer, String>();

    private int convertToInt(String arrby) {
        arrby = arrby.getBytes("UTF-16BE");
        int n2 = 0;
        for (int i2 = 0; i2 < arrby.length - 1; ++i2) {
            n2 = n2 + (arrby[i2] & 255) << 8;
        }
        return n2 + (arrby[arrby.length - 1] & 255);
    }

    private String createStringFromBytes(byte[] arrby) {
        if (arrby.length == 1) {
            return new String(arrby);
        }
        return new String(arrby, "UTF-16BE");
    }

    public static CMapToUnicode getIdentity() {
        CMapToUnicode cMapToUnicode = new CMapToUnicode();
        for (int i2 = 0; i2 < 65537; ++i2) {
            cMapToUnicode.addChar(i2, Utilities.convertFromUtf32(i2));
        }
        return cMapToUnicode;
    }

    void addChar(int n2, String string2) {
        this.doubleByteMappings.put(n2, string2);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    @Override
    void addChar(PdfString map, PdfObject serializable) {
        try {
            void var2_5;
            byte[] arrby = map.getBytes();
            String string2 = this.createStringFromBytes(serializable.getBytes());
            if (arrby.length == 1) {
                map = this.singleByteMappings;
                Integer n2 = arrby[0] & 255;
            } else {
                if (arrby.length != 2) throw new IOException(MessageLocalization.getComposedMessage("mapping.code.should.be.1.or.two.bytes.and.not.1", arrby.length));
                byte by2 = arrby[0];
                byte by3 = arrby[1];
                map = this.doubleByteMappings;
                Integer n3 = by3 & 255 | (by2 & 255) << 8;
            }
            map.put((Integer)var2_5, string2);
            return;
        }
        catch (Exception exception) {
            throw new ExceptionConverter(exception);
        }
    }

    public Map<Integer, Integer> createDirectMapping() {
        HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();
        for (Map.Entry<Integer, String> entry : this.singleByteMappings.entrySet()) {
            hashMap.put(entry.getKey(), this.convertToInt(entry.getValue()));
        }
        for (Map.Entry<Integer, String> entry : this.doubleByteMappings.entrySet()) {
            hashMap.put(entry.getKey(), this.convertToInt(entry.getValue()));
        }
        return hashMap;
    }

    public Map<Integer, Integer> createReverseMapping() {
        HashMap<Integer, Integer> hashMap = new HashMap<Integer, Integer>();
        for (Map.Entry<Integer, String> entry : this.singleByteMappings.entrySet()) {
            hashMap.put(this.convertToInt(entry.getValue()), entry.getKey());
        }
        for (Map.Entry<Integer, String> entry : this.doubleByteMappings.entrySet()) {
            hashMap.put(this.convertToInt(entry.getValue()), entry.getKey());
        }
        return hashMap;
    }

    public boolean hasOneByteMappings() {
        return this.singleByteMappings.isEmpty() ^ true;
    }

    public boolean hasTwoByteMappings() {
        return this.doubleByteMappings.isEmpty() ^ true;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public String lookup(byte[] object, int n2, int n3) {
        void var1_3;
        Map<Integer, String> map;
        void var3_6;
        void var2_5;
        if (var3_6 == true) {
            Integer n4 = object[var2_5] & 255;
            map = this.singleByteMappings;
            do {
                return map.get(var1_3);
                break;
            } while (true);
        }
        if (var3_6 != 2) return null;
        Integer n5 = ((object[var2_5] & 255) << 8) + (object[var2_5 + true] & 255);
        map = this.doubleByteMappings;
        return map.get(var1_3);
    }
}

