/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf;

import com.itextpdf.text.error_messages.MessageLocalization;
import com.itextpdf.text.exceptions.UnsupportedPdfException;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.codec.TIFFFaxDecoder;
import com.itextpdf.text.pdf.codec.TIFFFaxDecompressor;
import java.io.ByteArrayOutputStream;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public final class FilterHandlers {
    private static final Map<PdfName, FilterHandler> defaults;

    static {
        HashMap<PdfName, FilterHandler> hashMap = new HashMap<PdfName, FilterHandler>();
        hashMap.put(PdfName.FLATEDECODE, new Filter_FLATEDECODE());
        hashMap.put(PdfName.FL, new Filter_FLATEDECODE());
        hashMap.put(PdfName.ASCIIHEXDECODE, new Filter_ASCIIHEXDECODE());
        hashMap.put(PdfName.AHX, new Filter_ASCIIHEXDECODE());
        hashMap.put(PdfName.ASCII85DECODE, new Filter_ASCII85DECODE());
        hashMap.put(PdfName.A85, new Filter_ASCII85DECODE());
        hashMap.put(PdfName.LZWDECODE, new Filter_LZWDECODE());
        hashMap.put(PdfName.CCITTFAXDECODE, new Filter_CCITTFAXDECODE());
        hashMap.put(PdfName.CRYPT, new Filter_DoNothing());
        hashMap.put(PdfName.RUNLENGTHDECODE, new Filter_RUNLENGTHDECODE());
        defaults = Collections.unmodifiableMap(hashMap);
    }

    public static Map<PdfName, FilterHandler> getDefaultFilterHandlers() {
        return defaults;
    }

    public static interface FilterHandler {
        public byte[] decode(byte[] var1, PdfName var2, PdfObject var3, PdfDictionary var4);
    }

    private static class Filter_ASCII85DECODE
    implements FilterHandler {
        private Filter_ASCII85DECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            return PdfReader.ASCII85Decode(arrby);
        }
    }

    private static class Filter_ASCIIHEXDECODE
    implements FilterHandler {
        private Filter_ASCIIHEXDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            return PdfReader.ASCIIHexDecode(arrby);
        }
    }

    private static class Filter_CCITTFAXDECODE
    implements FilterHandler {
        private Filter_CCITTFAXDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfObject, PdfObject object, PdfDictionary pdfObject2) {
            pdfObject = (PdfNumber)PdfReader.getPdfObjectRelease(pdfObject2.get(PdfName.WIDTH));
            pdfObject2 = (PdfNumber)PdfReader.getPdfObjectRelease(pdfObject2.get(PdfName.HEIGHT));
            int n2 = 0;
            if (pdfObject != null && pdfObject2 != null) {
                int n3;
                boolean bl2;
                boolean bl3;
                int n4;
                int n5 = pdfObject.intValue();
                int n6 = pdfObject2.intValue();
                pdfObject = object instanceof PdfDictionary ? (PdfDictionary)object : null;
                if (pdfObject != null) {
                    object = pdfObject.getAsNumber(PdfName.K);
                    n4 = object != null ? object.intValue() : 0;
                    object = pdfObject.getAsBoolean(PdfName.BLACKIS1);
                    bl3 = object != null ? object.booleanValue() : false;
                    bl2 = (pdfObject = pdfObject.getAsBoolean(PdfName.ENCODEDBYTEALIGN)) != null ? pdfObject.booleanValue() : false;
                } else {
                    bl2 = false;
                    n4 = 0;
                    bl3 = false;
                }
                int n7 = (n5 + 7) / 8 * n6;
                object = new byte[n7];
                TIFFFaxDecompressor tIFFFaxDecompressor = new TIFFFaxDecompressor();
                if (n4 != 0 && n4 <= 0) {
                    new TIFFFaxDecoder(1L, n5, n6).decodeT6((byte[])object, arrby, 0, n6, 0L);
                    pdfObject = object;
                } else {
                    n4 = n4 > 0 ? 1 : 0;
                    n3 = bl2 ? 4 : 0;
                    n4 = n3 | n4;
                    tIFFFaxDecompressor.SetOptions(1, 3, n4, 0);
                    tIFFFaxDecompressor.decodeRaw((byte[])object, arrby, n5, n6);
                    pdfObject = object;
                    if (tIFFFaxDecompressor.fails > 0) {
                        pdfObject2 = new byte[n7];
                        n3 = tIFFFaxDecompressor.fails;
                        tIFFFaxDecompressor.SetOptions(1, 2, n4, 0);
                        tIFFFaxDecompressor.decodeRaw((byte[])pdfObject2, arrby, n5, n6);
                        pdfObject = object;
                        if (tIFFFaxDecompressor.fails < n3) {
                            pdfObject = pdfObject2;
                        }
                    }
                }
                if (!bl3) {
                    n3 = ((PdfObject)pdfObject).length;
                    for (n4 = n2; n4 < n3; ++n4) {
                        pdfObject[n4] = (PdfObject)((byte)(pdfObject[n4] ^ 255));
                    }
                }
                return pdfObject;
            }
            throw new UnsupportedPdfException(MessageLocalization.getComposedMessage("filter.ccittfaxdecode.is.only.supported.for.images", new Object[0]));
        }
    }

    private static class Filter_DoNothing
    implements FilterHandler {
        private Filter_DoNothing() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            return arrby;
        }
    }

    private static class Filter_FLATEDECODE
    implements FilterHandler {
        private Filter_FLATEDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            return PdfReader.decodePredictor(PdfReader.FlateDecode(arrby), pdfObject);
        }
    }

    private static class Filter_LZWDECODE
    implements FilterHandler {
        private Filter_LZWDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName pdfName, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            return PdfReader.decodePredictor(PdfReader.LZWDecode(arrby), pdfObject);
        }
    }

    private static class Filter_RUNLENGTHDECODE
    implements FilterHandler {
        private Filter_RUNLENGTHDECODE() {
        }

        @Override
        public byte[] decode(byte[] arrby, PdfName object, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            byte by2;
            object = new ByteArrayOutputStream();
            int n2 = 0;
            while (n2 < arrby.length && (by2 = arrby[n2]) != -128) {
                int n3;
                if (by2 >= 0 && by2 <= 127) {
                    n3 = by2 + 1;
                    object.write(arrby, n2, n3);
                    n3 = n2 + n3;
                } else {
                    int n4 = n2 + 1;
                    n2 = 0;
                    do {
                        n3 = n4;
                        if (n2 >= 1 - by2) break;
                        object.write(arrby[n4]);
                        ++n2;
                    } while (true);
                }
                n2 = n3 + 1;
            }
            return object.toByteArray();
        }
    }

}

