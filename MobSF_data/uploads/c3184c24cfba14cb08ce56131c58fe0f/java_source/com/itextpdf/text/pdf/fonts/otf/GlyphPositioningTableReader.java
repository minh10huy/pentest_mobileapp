/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.fonts.otf;

import com.itextpdf.text.log.Logger;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.fonts.otf.OpenTypeFontTableReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

public class GlyphPositioningTableReader
extends OpenTypeFontTableReader {
    public GlyphPositioningTableReader(RandomAccessFileOrArray randomAccessFileOrArray, int n2) {
        super(randomAccessFileOrArray, n2);
    }

    private void readAnchorTable(int n2) {
        this.rf.seek(n2);
        n2 = this.rf.readShort();
        if (n2 != 1) {
            PrintStream printStream = System.err;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("The extra features of the AnchorFormat ");
            stringBuilder.append(n2);
            stringBuilder.append(" will not be used");
            printStream.println(stringBuilder.toString());
        }
        this.rf.readShort();
        this.rf.readShort();
    }

    private void readBaseArrayTable(int n2, int n3) {
        this.rf.seek(n2);
        int n4 = this.rf.readShort();
        Object object = new HashSet();
        for (int i2 = 0; i2 < n4; ++i2) {
            for (int i3 = 0; i3 < n3; ++i3) {
                object.add(Integer.valueOf(this.rf.readShort()));
            }
        }
        object = object.iterator();
        while (object.hasNext()) {
            this.readAnchorTable((Integer)object.next() + n2);
        }
    }

    private void readChainingContextPositioningFormat_3(int n2) {
        StringBuilder stringBuilder;
        int n3;
        int n4 = this.rf.readShort();
        Iterator<Integer> iterator = LOG;
        List<Integer> list = new StringBuilder();
        list.append("backtrackGlyphCount=");
        list.append(n4);
        iterator.debug(list.toString());
        Object object = new ArrayList<Integer>(n4);
        int n5 = 0;
        for (n3 = 0; n3 < n4; ++n3) {
            object.add(Integer.valueOf(this.rf.readShort()));
        }
        n4 = this.rf.readShort();
        iterator = LOG;
        list = new StringBuilder();
        list.append("inputGlyphCount=");
        list.append(n4);
        iterator.debug(list.toString());
        list = new ArrayList(n4);
        for (n3 = 0; n3 < n4; ++n3) {
            list.add(Integer.valueOf(this.rf.readShort()));
        }
        n4 = this.rf.readShort();
        iterator = LOG;
        Object object2 = new StringBuilder();
        object2.append("lookaheadGlyphCount=");
        object2.append(n4);
        iterator.debug(object2.toString());
        iterator = new ArrayList(n4);
        for (n3 = 0; n3 < n4; ++n3) {
            iterator.add(Integer.valueOf(this.rf.readShort()));
        }
        n4 = this.rf.readShort();
        object2 = LOG;
        Object object3 = new StringBuilder();
        object3.append("posCount=");
        object3.append(n4);
        object2.debug(object3.toString());
        object2 = new ArrayList(n4);
        for (n3 = n5; n3 < n4; ++n3) {
            n5 = this.rf.readShort();
            short s2 = this.rf.readShort();
            object3 = LOG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("sequenceIndex=");
            stringBuilder.append(n5);
            stringBuilder.append(", lookupListIndex=");
            stringBuilder.append(s2);
            object3.debug(stringBuilder.toString());
            object2.add(new PosLookupRecord(n5, s2));
        }
        object = object.iterator();
        while (object.hasNext()) {
            object2 = this.readCoverageFormat((Integer)object.next() + n2);
            object3 = LOG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("backtrackGlyphs=");
            stringBuilder.append(object2);
            object3.debug(stringBuilder.toString());
        }
        list = list.iterator();
        while (list.hasNext()) {
            object = this.readCoverageFormat((Integer)list.next() + n2);
            object2 = LOG;
            object3 = new StringBuilder();
            object3.append("inputGlyphs=");
            object3.append(object);
            object2.debug(object3.toString());
        }
        iterator = iterator.iterator();
        while (iterator.hasNext()) {
            list = this.readCoverageFormat((Integer)iterator.next() + n2);
            object = LOG;
            object2 = new StringBuilder();
            object2.append("lookaheadGlyphs=");
            object2.append(list);
            object.debug(object2.toString());
        }
    }

    private void readLookUpType_1(int n2) {
        this.rf.seek(n2);
        short s2 = this.rf.readShort();
        if (s2 == 1) {
            Object object;
            Object object2;
            LOG.debug("Reading `Look Up Type 1, Format 1` ....");
            s2 = this.rf.readShort();
            short s3 = this.rf.readShort();
            if ((s3 & 1) == 1) {
                short s4 = this.rf.readShort();
                object2 = LOG;
                object = new StringBuilder();
                object.append("xPlacement=");
                object.append(s4);
                object2.debug(object.toString());
            }
            if ((s3 & 2) == 2) {
                s3 = this.rf.readShort();
                object2 = LOG;
                object = new StringBuilder();
                object.append("yPlacement=");
                object.append(s3);
                object2.debug(object.toString());
            }
            object2 = this.readCoverageFormat(n2 + s2);
            object = LOG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("glyphCodes=");
            stringBuilder.append(object2);
            object.debug(stringBuilder.toString());
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The PosFormat ");
        stringBuilder.append(s2);
        stringBuilder.append(" for `LookupType 1` is not yet supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    private void readLookUpType_4(int n2) {
        this.rf.seek(n2);
        short s2 = this.rf.readShort();
        if (s2 == 1) {
            LOG.debug("Reading `Look Up Type 4, Format 1` ....");
            s2 = this.rf.readShort();
            short s3 = this.rf.readShort();
            short s4 = this.rf.readShort();
            short s5 = this.rf.readShort();
            short s6 = this.rf.readShort();
            List<Integer> list = this.readCoverageFormat(s2 + n2);
            Logger logger = LOG;
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("markCoverages=");
            stringBuilder.append(list);
            logger.debug(stringBuilder.toString());
            list = this.readCoverageFormat(s3 + n2);
            logger = LOG;
            stringBuilder = new StringBuilder();
            stringBuilder.append("baseCoverages=");
            stringBuilder.append(list);
            logger.debug(stringBuilder.toString());
            this.readMarkArrayTable(s5 + n2);
            this.readBaseArrayTable(n2 + s6, s4);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The posFormat ");
        stringBuilder.append(s2);
        stringBuilder.append(" is not supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    private void readLookUpType_8(int n2) {
        this.rf.seek(n2);
        short s2 = this.rf.readShort();
        if (s2 == 3) {
            LOG.debug("Reading `Look Up Type 8, Format 3` ....");
            this.readChainingContextPositioningFormat_3(n2);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The posFormat ");
        stringBuilder.append(s2);
        stringBuilder.append(" for `Look Up Type 8` is not supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    private void readMarkArrayTable(int n2) {
        this.rf.seek(n2);
        int n3 = this.rf.readShort();
        Object object = new ArrayList<MarkRecord>();
        for (int i2 = 0; i2 < n3; ++i2) {
            object.add(this.readMarkRecord());
        }
        object = object.iterator();
        while (object.hasNext()) {
            this.readAnchorTable(((MarkRecord)object.next()).markAnchorOffset + n2);
        }
    }

    private MarkRecord readMarkRecord() {
        return new MarkRecord(this.rf.readShort(), this.rf.readShort());
    }

    public void read() {
        this.startReadingTable();
    }

    @Override
    protected void readSubTable(int n2, int n3) {
        if (n2 == 1) {
            this.readLookUpType_1(n3);
            return;
        }
        if (n2 == 4) {
            this.readLookUpType_4(n3);
            return;
        }
        if (n2 == 8) {
            this.readLookUpType_8(n3);
            return;
        }
        PrintStream printStream = System.err;
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The lookupType ");
        stringBuilder.append(n2);
        stringBuilder.append(" is not yet supported by ");
        stringBuilder.append(GlyphPositioningTableReader.class.getSimpleName());
        printStream.println(stringBuilder.toString());
    }

    static class MarkRecord {
        final int markAnchorOffset;
        final int markClass;

        public MarkRecord(int n2, int n3) {
            this.markClass = n2;
            this.markAnchorOffset = n3;
        }
    }

    static class PosLookupRecord {
        final int lookupListIndex;
        final int sequenceIndex;

        public PosLookupRecord(int n2, int n3) {
            this.sequenceIndex = n2;
            this.lookupListIndex = n3;
        }
    }

}

