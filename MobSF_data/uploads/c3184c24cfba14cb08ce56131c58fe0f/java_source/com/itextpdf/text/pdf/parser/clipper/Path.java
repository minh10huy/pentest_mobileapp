/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.parser.clipper;

import com.itextpdf.text.pdf.parser.clipper.Point;
import com.itextpdf.text.pdf.parser.clipper.PolyNode;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;

public class Path
extends ArrayList<Point.LongPoint> {
    private static final long serialVersionUID = -7120161578077546673L;

    public Path() {
    }

    public Path(int n2) {
        super(n2);
    }

    public Path(Collection<? extends Point.LongPoint> collection) {
        super(collection);
    }

    public Path(Point.LongPoint[] arrlongPoint) {
        this();
        int n2 = arrlongPoint.length;
        for (int i2 = 0; i2 < n2; ++i2) {
            this.add(arrlongPoint[i2]);
        }
    }

    private static OutPt excludeOp(OutPt outPt) {
        OutPt outPt2 = outPt.prev;
        outPt2.next = outPt.next;
        outPt.next.prev = outPt2;
        outPt2.idx = 0;
        return outPt2;
    }

    public Path TranslatePath(Point.LongPoint longPoint) {
        Path path = new Path(this.size());
        for (int i2 = 0; i2 < this.size(); ++i2) {
            path.add(new Point.LongPoint(((Point.LongPoint)this.get(i2)).getX() + longPoint.getX(), ((Point.LongPoint)this.get(i2)).getY() + longPoint.getY()));
        }
        return path;
    }

    public double area() {
        int n2 = this.size();
        double d2 = 0.0;
        if (n2 < 3) {
            return 0.0;
        }
        int n3 = n2 - 1;
        int n4 = 0;
        while (n4 < n2) {
            d2 += ((double)((Point.LongPoint)this.get(n3)).getX() + (double)((Point.LongPoint)this.get(n4)).getX()) * ((double)((Point.LongPoint)this.get(n3)).getY() - (double)((Point.LongPoint)this.get(n4)).getY());
            int n5 = n4 + 1;
            n3 = n4;
            n4 = n5;
        }
        return (- d2) * 0.5;
    }

    public Path cleanPolygon() {
        return this.cleanPolygon(1.415);
    }

    /*
     * Enabled aggressive block sorting
     */
    public Path cleanPolygon(double d2) {
        Object object;
        int n2;
        int n3 = this.size();
        if (n3 == 0) {
            return new Path();
        }
        OutPt[] arroutPt = new OutPt[n3];
        int n4 = 0;
        for (n2 = 0; n2 < n3; ++n2) {
            arroutPt[n2] = new OutPt();
        }
        n2 = 0;
        while (n2 < n3) {
            arroutPt[n2].pt = (Point.LongPoint)this.get(n2);
            object = arroutPt[n2];
            int n5 = n2 + 1;
            object.next = arroutPt[n5 % n3];
            arroutPt[n2].next.prev = arroutPt[n2];
            arroutPt[n2].idx = 0;
            n2 = n5;
        }
        d2 *= d2;
        OutPt outPt = arroutPt[0];
        n2 = n3;
        while (var7_5.idx == 0 && var7_5.next != var7_5.prev) {
            block12 : {
                void var7_5;
                block11 : {
                    if (Point.arePointsClose(var7_5.pt, var7_5.prev.pt, d2)) break block11;
                    if (Point.arePointsClose(var7_5.prev.pt, var7_5.next.pt, d2)) {
                        Path.excludeOp(var7_5.next);
                        OutPt outPt2 = Path.excludeOp((OutPt)var7_5);
                        n2 -= 2;
                        continue;
                    }
                    if (!Point.slopesNearCollinear(var7_5.prev.pt, var7_5.pt, var7_5.next.pt, d2)) break block12;
                }
                OutPt outPt3 = Path.excludeOp((OutPt)var7_5);
                --n2;
                continue;
            }
            var7_5.idx = 1;
            OutPt outPt4 = var7_5.next;
        }
        n3 = n2;
        if (n2 < 3) {
            n3 = 0;
        }
        object = new Path(n3);
        n2 = n4;
        while (n2 < n3) {
            object.add(var7_9.pt);
            OutPt outPt5 = var7_9.next;
            ++n2;
        }
        return object;
    }

    /*
     * Enabled aggressive block sorting
     */
    public int isPointInPolygon(Point.LongPoint longPoint) {
        int n2 = this.size();
        if (n2 < 3) {
            return 0;
        }
        Object object = (Point.LongPoint)this.get(0);
        int n3 = 1;
        int n4 = 0;
        do {
            int n5;
            Object object2;
            int n6;
            block17 : {
                block18 : {
                    if (n3 > n2) {
                        return n4;
                    }
                    object2 = n3 == n2 ? this.get(0) : this.get(n3);
                    object2 = (Point.LongPoint)object2;
                    if (object2.getY() != longPoint.getY()) break block17;
                    if (object2.getX() == longPoint.getX()) break block18;
                    if (object.getY() != longPoint.getY()) break block17;
                    n5 = object2.getX() > longPoint.getX() ? 1 : 0;
                    if (object.getX() >= longPoint.getX()) return -1;
                    n6 = 1;
                    if (n5 != n6) break block17;
                }
                return -1;
            }
            n6 = object.getY() < longPoint.getY() ? 1 : 0;
            int n7 = object2.getY() < longPoint.getY() ? 1 : 0;
            n5 = n4;
            if (n6 != n7) {
                if (object.getX() >= longPoint.getX()) {
                    if (object2.getX() > longPoint.getX()) {
                        n5 = 1 - n4;
                    } else {
                        n5 = (int)((double)(object.getX() - longPoint.getX()) * (double)(object2.getY() - longPoint.getY()) - (double)(object2.getX() - longPoint.getX()) * (double)(object.getY() - longPoint.getY()) DCMPL 0.0);
                        if (n5 == 0) {
                            return -1;
                        }
                        n6 = n5 > 0 ? 1 : 0;
                        n7 = object2.getY() > object.getY() ? 1 : 0;
                        n5 = n4;
                        if (n6 == n7) {
                            n5 = 1 - n4;
                        }
                    }
                } else {
                    n5 = n4;
                    if (object2.getX() > longPoint.getX()) {
                        n5 = (int)((double)(object.getX() - longPoint.getX()) * (double)(object2.getY() - longPoint.getY()) - (double)(object2.getX() - longPoint.getX()) * (double)(object.getY() - longPoint.getY()) DCMPL 0.0);
                        if (n5 == 0) {
                            return -1;
                        }
                        n6 = n5 > 0 ? 1 : 0;
                        n7 = object2.getY() > object.getY() ? 1 : 0;
                        n5 = n4;
                        if (n6 == n7) {
                            n5 = 1 - n4;
                        }
                    }
                }
            }
            ++n3;
            object = object2;
            n4 = n5;
        } while (true);
    }

    public boolean orientation() {
        if (this.area() >= 0.0) {
            return true;
        }
        return false;
    }

    public void reverse() {
        Collections.reverse(this);
    }

    static class Join {
        private Point.LongPoint offPt;
        OutPt outPt1;
        OutPt outPt2;

        Join() {
        }

        public Point.LongPoint getOffPt() {
            return this.offPt;
        }

        public void setOffPt(Point.LongPoint longPoint) {
            this.offPt = longPoint;
        }
    }

    protected static class Maxima {
        protected Maxima Next;
        protected Maxima Prev;
        protected long X;

        protected Maxima() {
        }
    }

    static class OutPt {
        int idx;
        OutPt next;
        OutPt prev;
        protected Point.LongPoint pt;

        OutPt() {
        }

        public static OutRec getLowerMostRec(OutRec outRec, OutRec outRec2) {
            if (outRec.bottomPt == null) {
                outRec.bottomPt = outRec.pts.getBottomPt();
            }
            if (outRec2.bottomPt == null) {
                outRec2.bottomPt = outRec2.pts.getBottomPt();
            }
            OutPt outPt = outRec.bottomPt;
            OutPt outPt2 = outRec2.bottomPt;
            if (outPt.getPt().getY() > outPt2.getPt().getY()) {
                return outRec;
            }
            if (outPt.getPt().getY() < outPt2.getPt().getY()) {
                return outRec2;
            }
            if (outPt.getPt().getX() < outPt2.getPt().getX()) {
                return outRec;
            }
            if (outPt.getPt().getX() > outPt2.getPt().getX()) {
                return outRec2;
            }
            if (outPt.next == outPt) {
                return outRec2;
            }
            if (outPt2.next == outPt2) {
                return outRec;
            }
            if (OutPt.isFirstBottomPt(outPt, outPt2)) {
                return outRec;
            }
            return outRec2;
        }

        private static boolean isFirstBottomPt(OutPt outPt, OutPt outPt2) {
            OutPt outPt3 = outPt.prev;
            while (outPt3.getPt().equals(outPt.getPt()) && !outPt3.equals(outPt)) {
                outPt3 = outPt3.prev;
            }
            double d2 = Math.abs(Point.LongPoint.getDeltaX(outPt.getPt(), outPt3.getPt()));
            outPt3 = outPt.next;
            while (outPt3.getPt().equals(outPt.getPt()) && !outPt3.equals(outPt)) {
                outPt3 = outPt3.next;
            }
            double d3 = Math.abs(Point.LongPoint.getDeltaX(outPt.getPt(), outPt3.getPt()));
            outPt = outPt2.prev;
            while (outPt.getPt().equals(outPt2.getPt()) && !outPt.equals(outPt2)) {
                outPt = outPt.prev;
            }
            double d4 = Math.abs(Point.LongPoint.getDeltaX(outPt2.getPt(), outPt.getPt()));
            outPt = outPt2.next;
            while (outPt.getPt().equals(outPt2.getPt()) && outPt.equals(outPt2)) {
                outPt = outPt.next;
            }
            double d5 = Math.abs(Point.LongPoint.getDeltaX(outPt2.getPt(), outPt.getPt()));
            if (d2 >= d4 && d2 >= d5 || d3 >= d4 && d3 >= d5) {
                return true;
            }
            return false;
        }

        public OutPt duplicate(boolean bl2) {
            OutPt outPt = new OutPt();
            outPt.setPt(new Point.LongPoint(this.getPt()));
            outPt.idx = this.idx;
            if (bl2) {
                outPt.next = this.next;
                outPt.prev = this;
                this.next.prev = outPt;
                this.next = outPt;
                return outPt;
            }
            outPt.prev = this.prev;
            outPt.next = this;
            this.prev.next = outPt;
            this.prev = outPt;
            return outPt;
        }

        /*
         * Unable to fully structure code
         * Enabled force condition propagation
         * Lifted jumps to return sites
         */
        OutPt getBottomPt() {
            var1_1 = this.next;
            var2_2 = this;
            var3_3 = null;
            while (var1_1 != var2_2) {
                if (var1_1.getPt().getY() > var2_2.getPt().getY()) {
                    do {
                        var5_5 = var1_1;
                        var4_4 = null;
                        break;
                    } while (true);
                } else {
                    var5_5 = var2_2;
                    var4_4 = var3_3;
                    if (var1_1.getPt().getY() == var2_2.getPt().getY()) {
                        var5_5 = var2_2;
                        var4_4 = var3_3;
                        if (var1_1.getPt().getX() <= var2_2.getPt().getX()) {
                            if (var1_1.getPt().getX() < var2_2.getPt().getX()) ** continue;
                            var5_5 = var2_2;
                            var4_4 = var3_3;
                            if (var1_1.next != var2_2) {
                                var5_5 = var2_2;
                                var4_4 = var3_3;
                                if (var1_1.prev != var2_2) {
                                    var4_4 = var1_1;
                                    var5_5 = var2_2;
                                }
                            }
                        }
                    }
                }
                var1_1 = var1_1.next;
                var2_2 = var5_5;
                var3_3 = var4_4;
            }
            var4_4 = var2_2;
            if (var3_3 == null) return var4_4;
            block2 : do {
                var4_4 = var2_2;
                if (var3_3 == var1_1) return var4_4;
                var5_5 = var2_2;
                if (!OutPt.isFirstBottomPt(var1_1, var3_3)) {
                    var5_5 = var3_3;
                }
                var4_4 = var3_3.next;
                do {
                    var2_2 = var5_5;
                    var3_3 = var4_4;
                    if (var4_4.getPt().equals(var5_5.getPt())) continue block2;
                    var4_4 = var4_4.next;
                } while (true);
                break;
            } while (true);
        }

        public int getPointCount() {
            int n2;
            OutPt outPt;
            int n3 = 0;
            OutPt outPt2 = this;
            do {
                n2 = n3 + 1;
                outPt = outPt2.next;
                if (outPt == this) break;
                n3 = n2;
                outPt2 = outPt;
            } while (outPt != null);
            return n2;
        }

        public Point.LongPoint getPt() {
            return this.pt;
        }

        public void reversePolyPtLinks() {
            OutPt outPt = this;
            do {
                OutPt outPt2 = outPt.next;
                outPt.next = outPt.prev;
                outPt.prev = outPt2;
                if (outPt2 == this) {
                    return;
                }
                outPt = outPt2;
            } while (true);
        }

        public void setPt(Point.LongPoint longPoint) {
            this.pt = longPoint;
        }
    }

    static class OutRec {
        int Idx;
        OutPt bottomPt;
        OutRec firstLeft;
        boolean isHole;
        boolean isOpen;
        PolyNode polyNode;
        protected OutPt pts;

        OutRec() {
        }

        public double area() {
            double d2;
            OutPt outPt = this.pts;
            double d3 = 0.0;
            OutPt outPt2 = outPt;
            if (outPt == null) {
                return 0.0;
            }
            do {
                d2 = d3 + (double)(outPt2.prev.getPt().getX() + outPt2.getPt().getX()) * (double)(outPt2.prev.getPt().getY() - outPt2.getPt().getY());
                outPt2 = outPt = outPt2.next;
                d3 = d2;
            } while (outPt != this.pts);
            return d2 * 0.5;
        }

        public void fixHoleLinkage() {
            if (this.firstLeft != null) {
                if (this.isHole != this.firstLeft.isHole && this.firstLeft.pts != null) {
                    return;
                }
                OutRec outRec = this.firstLeft;
                while (outRec != null && (outRec.isHole == this.isHole || outRec.pts == null)) {
                    outRec = outRec.firstLeft;
                }
                this.firstLeft = outRec;
            }
        }

        public OutPt getPoints() {
            return this.pts;
        }

        public void setPoints(OutPt outPt) {
            this.pts = outPt;
        }
    }

}

