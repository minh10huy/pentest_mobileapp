/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.text.pdf.qrcode;

import com.itextpdf.text.pdf.qrcode.ErrorCorrectionLevel;

final class FormatInformation {
    private static final int[] BITS_SET_IN_HALF_BYTE;
    private static final int[][] FORMAT_INFO_DECODE_LOOKUP;
    private static final int FORMAT_INFO_MASK_QR = 21522;
    private final byte dataMask;
    private final ErrorCorrectionLevel errorCorrectionLevel;

    static {
        FORMAT_INFO_DECODE_LOOKUP = new int[][]{{21522, 0}, {20773, 1}, {24188, 2}, {23371, 3}, {17913, 4}, {16590, 5}, {20375, 6}, {19104, 7}, {30660, 8}, {29427, 9}, {32170, 10}, {30877, 11}, {26159, 12}, {25368, 13}, {27713, 14}, {26998, 15}, {5769, 16}, {5054, 17}, {7399, 18}, {6608, 19}, {1890, 20}, {597, 21}, {3340, 22}, {2107, 23}, {13663, 24}, {12392, 25}, {16177, 26}, {14854, 27}, {9396, 28}, {8579, 29}, {11994, 30}, {11245, 31}};
        BITS_SET_IN_HALF_BYTE = new int[]{0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4};
    }

    private FormatInformation(int n2) {
        this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(n2 >> 3 & 3);
        this.dataMask = (byte)(n2 & 7);
    }

    static FormatInformation decodeFormatInformation(int n2, int n3) {
        FormatInformation formatInformation = FormatInformation.doDecodeFormatInformation(n2, n3);
        if (formatInformation != null) {
            return formatInformation;
        }
        return FormatInformation.doDecodeFormatInformation(n2 ^ 21522, n3 ^ 21522);
    }

    private static FormatInformation doDecodeFormatInformation(int n2, int n3) {
        int n4 = Integer.MAX_VALUE;
        int n5 = 0;
        for (int i2 = 0; i2 < FORMAT_INFO_DECODE_LOOKUP.length; ++i2) {
            int[] arrn = FORMAT_INFO_DECODE_LOOKUP[i2];
            int n6 = arrn[0];
            if (n6 != n2 && n6 != n3) {
                int n7 = FormatInformation.numBitsDiffering(n2, n6);
                int n8 = n4;
                if (n7 < n4) {
                    n5 = arrn[1];
                    n8 = n7;
                }
                n4 = n8;
                n7 = n5;
                if (n2 != n3) {
                    n6 = FormatInformation.numBitsDiffering(n3, n6);
                    n4 = n8;
                    n7 = n5;
                    if (n6 < n8) {
                        n7 = arrn[1];
                        n4 = n6;
                    }
                }
                n5 = n7;
                continue;
            }
            return new FormatInformation(arrn[1]);
        }
        if (n4 <= 3) {
            return new FormatInformation(n5);
        }
        return null;
    }

    static int numBitsDiffering(int n2, int n3) {
        return BITS_SET_IN_HALF_BYTE[n2 & 15] + BITS_SET_IN_HALF_BYTE[n2 >>> 4 & 15] + BITS_SET_IN_HALF_BYTE[n2 >>> 8 & 15] + BITS_SET_IN_HALF_BYTE[n2 >>> 12 & 15] + BITS_SET_IN_HALF_BYTE[n2 >>> 16 & 15] + BITS_SET_IN_HALF_BYTE[n2 >>> 20 & 15] + BITS_SET_IN_HALF_BYTE[n2 >>> 24 & 15] + BITS_SET_IN_HALF_BYTE[(n2 ^= n3) >>> 28 & 15];
    }

    public boolean equals(Object object) {
        boolean bl2 = object instanceof FormatInformation;
        boolean bl3 = false;
        if (!bl2) {
            return false;
        }
        object = (FormatInformation)object;
        bl2 = bl3;
        if (this.errorCorrectionLevel == object.errorCorrectionLevel) {
            bl2 = bl3;
            if (this.dataMask == object.dataMask) {
                bl2 = true;
            }
        }
        return bl2;
    }

    byte getDataMask() {
        return this.dataMask;
    }

    ErrorCorrectionLevel getErrorCorrectionLevel() {
        return this.errorCorrectionLevel;
    }

    public int hashCode() {
        return this.errorCorrectionLevel.ordinal() << 3 | this.dataMask;
    }
}

