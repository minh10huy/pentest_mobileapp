/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.testutils;

import com.itextpdf.text.BaseColor;
import com.itextpdf.text.Rectangle;
import com.itextpdf.text.io.RandomAccessSource;
import com.itextpdf.text.io.RandomAccessSourceFactory;
import com.itextpdf.text.pdf.PRIndirectReference;
import com.itextpdf.text.pdf.PRStream;
import com.itextpdf.text.pdf.PRTokeniser;
import com.itextpdf.text.pdf.PdfAnnotation;
import com.itextpdf.text.pdf.PdfArray;
import com.itextpdf.text.pdf.PdfBoolean;
import com.itextpdf.text.pdf.PdfContentByte;
import com.itextpdf.text.pdf.PdfContentParser;
import com.itextpdf.text.pdf.PdfDictionary;
import com.itextpdf.text.pdf.PdfIndirectReference;
import com.itextpdf.text.pdf.PdfLiteral;
import com.itextpdf.text.pdf.PdfName;
import com.itextpdf.text.pdf.PdfNumber;
import com.itextpdf.text.pdf.PdfObject;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfStamper;
import com.itextpdf.text.pdf.PdfString;
import com.itextpdf.text.pdf.RandomAccessFileOrArray;
import com.itextpdf.text.pdf.RefKey;
import com.itextpdf.text.pdf.parser.ContentByteUtils;
import com.itextpdf.text.pdf.parser.ImageRenderInfo;
import com.itextpdf.text.pdf.parser.InlineImageUtils;
import com.itextpdf.text.pdf.parser.PdfContentStreamProcessor;
import com.itextpdf.text.pdf.parser.RenderListener;
import com.itextpdf.text.pdf.parser.SimpleTextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TaggedPdfReaderTool;
import com.itextpdf.text.pdf.parser.TextExtractionStrategy;
import com.itextpdf.text.pdf.parser.TextRenderInfo;
import com.itextpdf.text.xml.XMLUtil;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.XMPUtils;
import com.itextpdf.xmp.options.SerializeOptions;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.TreeSet;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.xml.sax.SAXException;

public class CompareTool {
    private static final String cannotOpenTargetDirectory = "Cannot open target directory for <filename>.";
    private static final String differentPages = "File <filename> differs on page <pagenumber>.";
    private static final String gsFailed = "GhostScript failed for <filename>.";
    private static final String ignoredAreasPrefix = "ignored_areas_";
    private static final String undefinedGsPath = "Path to GhostScript is not specified. Please use -DgsExec=<path_to_ghostscript> (e.g. -DgsExec=\"C:/Program Files/gs/gs9.14/bin/gswin32c.exe\")";
    private static final String unexpectedNumberOfPages = "Unexpected number of pages for <filename>.";
    private boolean absoluteError = true;
    private String cmpImage;
    List<PdfDictionary> cmpPages;
    List<RefKey> cmpPagesRef;
    private String cmpPdf;
    private String cmpPdfName;
    private int compareByContentErrorsLimit = 1;
    private String compareExec;
    private final String compareParams = " \"<image1>\" \"<image2>\" \"<difference>\"";
    private double floatComparisonError = 0.0;
    private boolean generateCompareByContentXmlReport = false;
    private String gsExec = System.getProperty("gsExec");
    private final String gsParams = " -dNOPAUSE -dBATCH -sDEVICE=png16m -r150 -sOutputFile=<outputfile> <inputfile>";
    private String outImage;
    List<PdfDictionary> outPages;
    List<RefKey> outPagesRef;
    private String outPdf;
    private String outPdfName;
    private String xmlReportName = "report";

    public CompareTool() {
        if (this.gsExec == null) {
            this.gsExec = System.getenv("gsExec");
        }
        this.compareExec = System.getProperty("compareExec");
        if (this.compareExec == null) {
            this.compareExec = System.getenv("compareExec");
        }
    }

    private void addPagesFromDict(PdfObject object, List<PdfDictionary> list, List<RefKey> list2) {
        PdfDictionary pdfDictionary = (PdfDictionary)PdfReader.getPdfObject((PdfObject)object);
        if (pdfDictionary.isPages()) {
            object = pdfDictionary.getAsArray(PdfName.KIDS);
            if (object == null) {
                return;
            }
            object = object.iterator();
            while (object.hasNext()) {
                this.addPagesFromDict((PdfObject)object.next(), list, list2);
            }
        } else if (pdfDictionary.isPage()) {
            list.add(pdfDictionary);
            list2.add(new RefKey((PdfIndirectReference)((PRIndirectReference)object)));
        }
    }

    private String compare(String string2, String string3, Map<Integer, List<Rectangle>> map) {
        return this.compare(string2, string3, map, null);
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private String compare(String object, String charSequence, Map<Integer, List<Rectangle>> object2, List<Integer> list) {
        int n2;
        block26 : {
            Object object3;
            int n3;
            Object object4;
            Object object5;
            File[] arrfile;
            int n4;
            if (this.gsExec == null) {
                return undefinedGsPath;
            }
            if (!new File(this.gsExec).exists()) {
                object = new StringBuilder();
                object.append(new File(this.gsExec).getAbsolutePath());
                object.append(" does not exist");
                return object.toString();
            }
            Object object6 = object;
            if (!object.endsWith("/")) {
                object6 = new StringBuilder();
                object6.append((String)object);
                object6.append("/");
                object6 = object6.toString();
            }
            object = new File((String)object6);
            boolean bl2 = object.exists();
            int n5 = 0;
            if (!bl2) {
                object.mkdirs();
            } else {
                object3 = object.listFiles(new PngFileFilter());
                n4 = ((File[])object3).length;
                for (n2 = 0; n2 < n4; ++n2) {
                    object3[n2].delete();
                }
                object3 = object.listFiles(new CmpPngFileFilter());
                n4 = ((Object)object3).length;
                for (n2 = 0; n2 < n4; ++n2) {
                    object3[n2].delete();
                }
            }
            object3 = new StringBuilder();
            object3.append((String)object6);
            object3.append((String)charSequence);
            object3 = new File(object3.toString());
            if (object3.exists()) {
                object3.delete();
            }
            if (object2 != null && !object2.isEmpty()) {
                object3 = new PdfReader(this.cmpPdf);
                arrfile = new PdfReader(this.outPdf);
                object4 = new StringBuilder();
                object4.append((String)object6);
                object4.append(ignoredAreasPrefix);
                object4.append(this.outPdfName);
                object4 = new PdfStamper((PdfReader)arrfile, new FileOutputStream(object4.toString()));
                object5 = new StringBuilder();
                object5.append((String)object6);
                object5.append(ignoredAreasPrefix);
                object5.append(this.cmpPdfName);
                object5 = new PdfStamper((PdfReader)object3, new FileOutputStream(object5.toString()));
                for (Map.Entry entry : object2.entrySet()) {
                    n2 = (Integer)entry.getKey();
                    Object object7 = (List)entry.getValue();
                    if (object7 == null || object7.isEmpty()) continue;
                    PdfContentByte pdfContentByte = object4.getOverContent(n2);
                    PdfContentByte pdfContentByte2 = object5.getOverContent(n2);
                    object7 = object7.iterator();
                    while (object7.hasNext()) {
                        Rectangle rectangle = (Rectangle)object7.next();
                        rectangle.setBackgroundColor(BaseColor.BLACK);
                        pdfContentByte.rectangle(rectangle);
                        pdfContentByte2.rectangle(rectangle);
                    }
                }
                object4.close();
                object5.close();
                arrfile.close();
                object3.close();
                object2 = new StringBuilder();
                object2.append((String)object6);
                object2.append(ignoredAreasPrefix);
                object2.append(this.outPdfName);
                object2 = object2.toString();
                object3 = new StringBuilder();
                object3.append((String)object6);
                object3.append(ignoredAreasPrefix);
                object3.append(this.cmpPdfName);
                this.init((String)object2, object3.toString());
            }
            if (!object.exists()) return cannotOpenTargetDirectory.replace("<filename>", this.outPdf);
            this.getClass();
            object2 = new StringBuilder();
            object2.append((String)object6);
            object2.append(this.cmpImage);
            object2 = " -dNOPAUSE -dBATCH -sDEVICE=png16m -r150 -sOutputFile=<outputfile> <inputfile>".replace("<outputfile>", object2.toString()).replace("<inputfile>", this.cmpPdf);
            object2 = this.runProcess(this.gsExec, (String)object2);
            arrfile = new BufferedReader(new InputStreamReader(object2.getInputStream()));
            object3 = new BufferedReader(new InputStreamReader(object2.getErrorStream()));
            while ((object4 = arrfile.readLine()) != null) {
                System.out.println((String)object4);
            }
            arrfile.close();
            while ((arrfile = object3.readLine()) != null) {
                System.out.println((String)arrfile);
            }
            object3.close();
            if (object2.waitFor() != 0) return gsFailed.replace("<filename>", this.cmpPdf);
            this.getClass();
            object2 = new StringBuilder();
            object2.append((String)object6);
            object2.append(this.outImage);
            object2 = " -dNOPAUSE -dBATCH -sDEVICE=png16m -r150 -sOutputFile=<outputfile> <inputfile>".replace("<outputfile>", object2.toString()).replace("<inputfile>", this.outPdf);
            object2 = this.runProcess(this.gsExec, (String)object2);
            arrfile = new BufferedReader(new InputStreamReader(object2.getInputStream()));
            object3 = new BufferedReader(new InputStreamReader(object2.getErrorStream()));
            while ((object4 = arrfile.readLine()) != null) {
                System.out.println((String)object4);
            }
            arrfile.close();
            while ((arrfile = object3.readLine()) != null) {
                System.out.println((String)arrfile);
            }
            object3.close();
            if (object2.waitFor() != 0) return gsFailed.replace("<filename>", this.outPdf);
            object3 = object.listFiles(new PngFileFilter());
            n2 = ((Object)object3).length != (arrfile = object.listFiles(new CmpPngFileFilter())).length ? 1 : 0;
            n4 = Math.min(((Object)object3).length, arrfile.length);
            if (n4 < 1) {
                return "No files for comparing!!!\nThe result or sample pdf file is not processed by GhostScript.";
            }
            Arrays.sort(object3, new ImageNameComparator());
            Arrays.sort(arrfile, new ImageNameComparator());
            object = null;
            do {
                object2 = object;
                if (n5 >= n4) break block26;
                if (list == null || !list.contains(n5)) {
                    object2 = System.out;
                    object4 = new StringBuilder();
                    object4.append("Comparing page ");
                    n3 = n5 + 1;
                    object4.append(Integer.toString(n3));
                    object4.append(" (");
                    object4.append(object3[n5].getAbsolutePath());
                    object4.append(")...");
                    object2.print(object4.toString());
                    object2 = new FileInputStream((File)object3[n5]);
                    object4 = new FileInputStream(arrfile[n5]);
                    bl2 = this.compareStreams((InputStream)object2, (InputStream)object4);
                    object2.close();
                    object4.close();
                    if (!bl2) {
                        if (this.compareExec == null || !new File(this.compareExec).exists()) break;
                        this.getClass();
                        object2 = " \"<image1>\" \"<image2>\" \"<difference>\"".replace("<image1>", object3[n5].getAbsolutePath()).replace("<image2>", arrfile[n5].getAbsolutePath());
                        object4 = new StringBuilder();
                        object4.append((String)object6);
                        object4.append((String)charSequence);
                        object4.append(Integer.toString(n3));
                        object4.append(".png");
                        object2 = object2.replace("<difference>", object4.toString());
                        object2 = this.runProcess(this.compareExec, (String)object2);
                        object4 = new BufferedReader(new InputStreamReader(object2.getErrorStream()));
                        while ((object5 = object4.readLine()) != null) {
                            System.out.println((String)object5);
                        }
                        object4.close();
                        if (object2.waitFor() == 0) {
                            if (object == null) {
                                object = differentPages.replace("<filename>", this.outPdf).replace("<pagenumber>", Integer.toString(n3));
                                object2 = new StringBuilder();
                                object2.append((String)object);
                                object2.append("\nPlease, examine ");
                                object2.append((String)object6);
                                object2.append((String)charSequence);
                                object2.append(Integer.toString(n3));
                                object2.append(".png for more details.");
                                object = object2.toString();
                            } else {
                                object = new StringBuilder();
                                object.append("File ");
                                object.append(this.outPdf);
                                object.append(" differs.\nPlease, examine difference images for more details.");
                                object = object.toString();
                            }
                        } else {
                            object = differentPages.replace("<filename>", this.outPdf).replace("<pagenumber>", Integer.toString(n3));
                        }
                        System.out.println((String)object);
                    } else {
                        System.out.println("done.");
                    }
                }
                ++n5;
            } while (true);
            object = differentPages.replace("<filename>", this.outPdf).replace("<pagenumber>", Integer.toString(n3));
            charSequence = new StringBuilder();
            charSequence.append((String)object);
            charSequence.append("\nYou can optionally specify path to ImageMagick compare tool (e.g. -DcompareExec=\"C:/Program Files/ImageMagick-6.5.4-2/compare.exe\") to visualize differences.");
            object2 = charSequence.toString();
            if (object2 != null) {
                return object2;
            }
        }
        if (n2 == 0) return null;
        return unexpectedNumberOfPages.replace("<filename>", this.outPdf);
    }

    private boolean compareArraysExtended(PdfArray pdfArray, PdfArray pdfArray2, ObjectPath objectPath, CompareResult compareResult) {
        if (pdfArray == null) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, "Found null. Expected PdfArray.");
            }
            return false;
        }
        if (pdfArray.size() != pdfArray2.size()) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, String.format("PdfArrays. Lengths are different. Expected: %s. Found: %s.", pdfArray2.size(), pdfArray.size()));
            }
            return false;
        }
        boolean bl2 = true;
        for (int i2 = 0; i2 < pdfArray2.size(); ++i2) {
            if (objectPath != null) {
                objectPath.pushArrayItemToPath(i2);
            }
            bl2 = this.compareObjects(pdfArray.getPdfObject(i2), pdfArray2.getPdfObject(i2), objectPath, compareResult) && bl2;
            if (objectPath != null) {
                objectPath.pop();
            }
            if (bl2 || objectPath != null && compareResult != null && !compareResult.isMessageLimitReached()) continue;
            return false;
        }
        return bl2;
    }

    private boolean compareBooleansExtended(PdfBoolean pdfBoolean, PdfBoolean pdfBoolean2, ObjectPath objectPath, CompareResult compareResult) {
        if (pdfBoolean2.booleanValue() == pdfBoolean.booleanValue()) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfBoolean. Expected: %s. Found: %s.", pdfBoolean2.booleanValue(), pdfBoolean.booleanValue()));
        }
        return false;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private boolean compareContentStreamsByParsingExtended(PdfObject var1_1, PdfObject var2_2, PdfDictionary var3_3, PdfDictionary var4_4, ObjectPath var5_5, CompareResult var6_6) {
        block13 : {
            block14 : {
                block12 : {
                    block11 : {
                        if (var1_1.type() == var1_1.type()) break block11;
                        var3_3 = "PdfObject. Types are different. Expected: %s. Found: %s";
                        var4_5 = new Object[]{var2_2.type(), var1_1.type()};
                        var2_2 = var4_5;
                        var1_1 = var3_3;
                        break block12;
                    }
                    if (!var1_1.isArray()) break block13;
                    var9_11 = (PdfArray)var1_1;
                    var8_19 = (PdfArray)var2_2;
                    if (var8_19.size() != var9_11.size()) {
                        var1_1 = "PdfArray. Sizes are different. Expected: %s. Found: %s";
                        var2_2 = new Object[]{var8_19.size(), var9_11.size()};
                    }
                    break block14;
                }
lbl16: // 2 sources:
                do {
                    var6_10.addError((ObjectPath)var5_9, String.format((String)var1_1, var2_2));
                    return false;
                    break;
                } while (true);
            }
            for (var7_25 = 0; var7_25 < var8_19.size(); ++var7_25) {
                if (this.compareContentStreamsByParsingExtended(var9_11.getPdfObject(var7_25), var8_19.getPdfObject(var7_25), (PdfDictionary)var3_3, (PdfDictionary)var4_4 /* !! */ , (ObjectPath)var5_9, (CompareResult)var6_10)) continue;
                return false;
            }
        }
        var9_12 = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(ContentByteUtils.getContentBytesFromContentObject((PdfObject)var2_2))));
        var8_20 = new PRTokeniser(new RandomAccessFileOrArray(new RandomAccessSourceFactory().createSource(ContentByteUtils.getContentBytesFromContentObject((PdfObject)var1_1))));
        var13_26 = new PdfContentParser(var9_12);
        var12_27 = new PdfContentParser(var8_20);
        var8_21 = new ArrayList<E>();
        var11_28 = new ArrayList<PdfObject>();
        var9_13 = var3_3;
        var3_3 = var8_21;
        var8_22 /* !! */  = var4_4 /* !! */ ;
        var4_6 = var9_13;
        block2 : do {
            if (var13_26.parse((ArrayList<PdfObject>)var3_3).size() <= 0) return true;
            var12_27.parse(var11_28);
            if (var3_3.size() != var11_28.size()) {
                var1_1 = "PdfObject. Different commands lengths. Expected: %s. Found: %s";
                var2_2 = new Object[]{var3_3.size(), var11_28.size()};
                ** continue;
            }
            if (var3_3.size() == 1 && this.compareLiterals((PdfLiteral)var3_3.get(0), new PdfLiteral("BI")) && this.compareLiterals((PdfLiteral)var11_28.get(0), new PdfLiteral("BI"))) {
                var14_33 = (PRStream)var2_2;
                var15_34 = (PRStream)var1_1;
                var10_30 = var4_7;
                var9_15 = var8_23;
                if (var15_34.getDirectObject(PdfName.RESOURCES) != null) {
                    var10_31 = var4_7;
                    var9_16 = var8_23;
                    if (var14_33.getDirectObject(PdfName.RESOURCES) != null) {
                        var10_32 = (PdfDictionary)var15_34.getDirectObject(PdfName.RESOURCES);
                        var9_17 = (PdfDictionary)var14_33.getDirectObject(PdfName.RESOURCES);
                    }
                }
                if (!this.compareInlineImagesExtended(var12_27, var13_26, (PdfDictionary)var10_29, (PdfDictionary)var9_18, (ObjectPath)var5_9, (CompareResult)var6_10)) {
                    return false;
                }
                var4_8 = var10_29;
                var8_24 = var9_18;
                continue;
            }
            var7_25 = 0;
            do {
                if (var7_25 < var3_3.size()) ** break;
                continue block2;
                if (!this.compareObjects(var11_28.get(var7_25), (PdfObject)var3_3.get(var7_25), (ObjectPath)var5_9, (CompareResult)var6_10)) {
                    return false;
                }
                ++var7_25;
            } while (true);
            break;
        } while (true);
    }

    private boolean compareDictionariesExtended(PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2, ObjectPath objectPath, CompareResult compareResult) {
        if (pdfDictionary2 != null && pdfDictionary == null || pdfDictionary != null && pdfDictionary2 == null) {
            compareResult.addError(objectPath, "One of the dictionaries is null, the other is not.");
            return false;
        }
        Object object = new TreeSet<PdfName>(pdfDictionary2.getKeys());
        object.addAll(pdfDictionary.getKeys());
        object = object.iterator();
        int n2 = 1;
        boolean bl2 = true;
        while (object.hasNext()) {
            Object object2;
            block13 : {
                block12 : {
                    block10 : {
                        block11 : {
                            Object object3;
                            object2 = (PdfName)object.next();
                            if (object2.compareTo(PdfName.PARENT) == 0 || object2.compareTo(PdfName.P) == 0 || pdfDictionary.isStream() && pdfDictionary2.isStream() && (object2.equals(PdfName.FILTER) || object2.equals(PdfName.LENGTH))) continue;
                            if (object2.compareTo(PdfName.BASEFONT) != 0 && object2.compareTo(PdfName.FONTNAME) != 0 || !(object3 = pdfDictionary2.getDirectObject((PdfName)object2)).isName() || object3.toString().indexOf(43) <= 0) break block10;
                            PdfObject pdfObject = pdfDictionary.getDirectObject((PdfName)object2);
                            if (!pdfObject.isName() || pdfObject.toString().indexOf(43) == -1) {
                                if (compareResult != null && objectPath != null) {
                                    Object[] arrobject = new Object[3];
                                    arrobject[0] = object2.toString();
                                    arrobject[n2] = object3.toString();
                                    arrobject[2] = pdfObject.toString();
                                    compareResult.addError(objectPath, String.format("PdfDictionary %s entry: Expected: %s. Found: %s", arrobject));
                                }
                                bl2 = false;
                            }
                            if (object3.toString().substring(object3.toString().indexOf(43)).equals(pdfObject.toString().substring(pdfObject.toString().indexOf(43)))) break block11;
                            if (compareResult != null && objectPath != null) {
                                object2 = object2.toString();
                                object3 = object3.toString();
                                n2 = 1;
                                compareResult.addError(objectPath, String.format("PdfDictionary %s entry: Expected: %s. Found: %s", object2, object3, pdfObject.toString()));
                            } else {
                                n2 = 1;
                            }
                            break block12;
                        }
                        n2 = 1;
                        continue;
                    }
                    if (this.floatComparisonError != 0.0 && pdfDictionary2.isPage() && pdfDictionary.isPage() && object2.equals(PdfName.CONTENTS)) {
                        if (this.compareContentStreamsByParsingExtended(pdfDictionary.getDirectObject((PdfName)object2), pdfDictionary2.getDirectObject((PdfName)object2), (PdfDictionary)pdfDictionary.getDirectObject(PdfName.RESOURCES), (PdfDictionary)pdfDictionary2.getDirectObject(PdfName.RESOURCES), objectPath, compareResult)) continue;
                    }
                    break block13;
                }
                bl2 = false;
                continue;
            }
            if (objectPath != null) {
                objectPath.pushDictItemToPath(object2.toString());
            }
            boolean bl3 = this.compareObjects(pdfDictionary.get((PdfName)object2), pdfDictionary2.get((PdfName)object2), objectPath, compareResult) && bl2;
            if (objectPath != null) {
                objectPath.pop();
            }
            bl2 = bl3;
            if (bl3) continue;
            if (objectPath != null && compareResult != null) {
                bl2 = bl3;
                if (!compareResult.isMessageLimitReached()) continue;
            }
            return false;
        }
        return bl2;
    }

    private boolean compareInlineImagesExtended(PdfContentParser object, PdfContentParser object2, PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2, ObjectPath objectPath, CompareResult compareResult) {
        object2 = InlineImageUtils.parseInlineImage((PdfContentParser)object2, pdfDictionary2);
        if (this.compareObjects((object = InlineImageUtils.parseInlineImage((PdfContentParser)object, pdfDictionary)).getImageDictionary(), object2.getImageDictionary(), objectPath, compareResult) && Arrays.equals(object.getSamples(), object2.getSamples())) {
            return true;
        }
        return false;
    }

    private boolean compareLiteralsExtended(PdfLiteral pdfLiteral, PdfLiteral pdfLiteral2, ObjectPath objectPath, CompareResult compareResult) {
        if (this.compareLiterals(pdfLiteral, pdfLiteral2)) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfLiteral. Expected: %s. Found: %s", pdfLiteral2, pdfLiteral));
        }
        return false;
    }

    private boolean compareNamesExtended(PdfName pdfName, PdfName pdfName2, ObjectPath objectPath, CompareResult compareResult) {
        if (pdfName2.compareTo(pdfName) == 0) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfName. Expected: %s. Found: %s", pdfName2.toString(), pdfName.toString()));
        }
        return false;
    }

    private boolean compareNumbersExtended(PdfNumber pdfNumber, PdfNumber pdfNumber2, ObjectPath objectPath, CompareResult compareResult) {
        if (this.compareNumbers(pdfNumber, pdfNumber2)) {
            return true;
        }
        if (compareResult != null && objectPath != null) {
            compareResult.addError(objectPath, String.format("PdfNumber. Expected: %s. Found: %s", pdfNumber2, pdfNumber));
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     */
    private boolean compareObjects(PdfObject object, PdfObject object2, ObjectPath objectPath, CompareResult compareResult) {
        PdfObject pdfObject;
        PdfObject pdfObject2;
        block36 : {
            block34 : {
                block35 : {
                    block33 : {
                        pdfObject2 = PdfReader.getPdfObject((PdfObject)object);
                        pdfObject = PdfReader.getPdfObject((PdfObject)object2);
                        if (pdfObject == null && pdfObject2 == null) {
                            return true;
                        }
                        if (pdfObject2 != null) break block33;
                        object = "Expected object was not found.";
                        break block34;
                    }
                    if (pdfObject != null) break block35;
                    object = "Found object which was not expected to be found.";
                    break block34;
                }
                if (pdfObject.type() == pdfObject2.type()) break block36;
                object = String.format("Types do not match. Expected: %s. Found: %s.", pdfObject.getClass().getSimpleName(), pdfObject2.getClass().getSimpleName());
            }
            compareResult.addError(objectPath, (String)object);
            return false;
        }
        Object object3 = objectPath;
        if (object2.isIndirect()) {
            object3 = objectPath;
            if (object.isIndirect()) {
                PdfIndirectReference pdfIndirectReference = (PdfIndirectReference)object2;
                object3 = new RefKey(pdfIndirectReference);
                PdfIndirectReference pdfIndirectReference2 = (PdfIndirectReference)object;
                if (objectPath.isComparing((RefKey)object3, new RefKey(pdfIndirectReference2))) {
                    return true;
                }
                object3 = objectPath.resetDirectPath(new RefKey(pdfIndirectReference), new RefKey(pdfIndirectReference2));
            }
        }
        if (pdfObject.isDictionary() && ((PdfDictionary)pdfObject).isPage()) {
            if (pdfObject2.isDictionary() && ((PdfDictionary)pdfObject2).isPage()) {
                object2 = new RefKey((PdfIndirectReference)((PRIndirectReference)object2));
                object = new RefKey((PdfIndirectReference)((PRIndirectReference)object));
                if (this.cmpPagesRef.contains(object2) && this.cmpPagesRef.indexOf(object2) == this.outPagesRef.indexOf(object)) {
                    return true;
                }
                if (compareResult == null || object3 == null) return false;
                {
                    compareResult.addError((ObjectPath)object3, String.format("The dictionaries refer to different pages. Expected page number: %s. Found: %s", this.cmpPagesRef.indexOf(object2), this.outPagesRef.indexOf(object)));
                }
                return false;
            }
            if (compareResult == null || object3 == null) return false;
            {
                compareResult.addError((ObjectPath)object3, "Expected a page. Found not a page.");
            }
            return false;
        }
        if (pdfObject.isDictionary()) {
            if (this.compareDictionariesExtended((PdfDictionary)pdfObject2, (PdfDictionary)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (pdfObject.isStream()) {
            if (this.compareStreamsExtended((PRStream)pdfObject2, (PRStream)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (pdfObject.isArray()) {
            if (this.compareArraysExtended((PdfArray)pdfObject2, (PdfArray)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (pdfObject.isName()) {
            if (this.compareNamesExtended((PdfName)pdfObject2, (PdfName)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (pdfObject.isNumber()) {
            if (this.compareNumbersExtended((PdfNumber)pdfObject2, (PdfNumber)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (pdfObject.isString()) {
            if (this.compareStringsExtended((PdfString)pdfObject2, (PdfString)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (pdfObject.isBoolean()) {
            if (this.compareBooleansExtended((PdfBoolean)pdfObject2, (PdfBoolean)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (pdfObject instanceof PdfLiteral) {
            if (this.compareLiteralsExtended((PdfLiteral)pdfObject2, (PdfLiteral)pdfObject, (ObjectPath)object3, compareResult)) return true;
            return false;
        }
        if (!pdfObject2.isNull() || !pdfObject.isNull()) throw new UnsupportedOperationException();
        return true;
    }

    private boolean compareStreams(InputStream inputStream, InputStream inputStream2) {
        int n2;
        byte[] arrby = new byte[65536];
        byte[] arrby2 = new byte[65536];
        do {
            if ((n2 = inputStream.read(arrby)) != inputStream2.read(arrby2)) {
                return false;
            }
            if (Arrays.equals(arrby, arrby2)) continue;
            return false;
        } while (n2 != -1);
        return true;
    }

    private boolean compareStreamsExtended(PRStream object, PRStream pRStream, ObjectPath objectPath, CompareResult compareResult) {
        boolean bl2 = PdfName.FLATEDECODE.equals(object.get(PdfName.FILTER));
        byte[] arrby = PdfReader.getStreamBytesRaw((PRStream)object);
        byte[] arrby2 = PdfReader.getStreamBytesRaw(pRStream);
        byte[] arrby3 = arrby;
        byte[] arrby4 = arrby2;
        if (bl2) {
            arrby3 = PdfReader.decodeBytes(arrby, (PdfDictionary)object);
            arrby4 = PdfReader.decodeBytes(arrby2, pRStream);
        }
        if (this.floatComparisonError != 0.0 && PdfName.XOBJECT.equals(pRStream.getDirectObject(PdfName.TYPE)) && PdfName.XOBJECT.equals(object.getDirectObject(PdfName.TYPE)) && PdfName.FORM.equals(pRStream.getDirectObject(PdfName.SUBTYPE)) && PdfName.FORM.equals(object.getDirectObject(PdfName.SUBTYPE))) {
            if (this.compareContentStreamsByParsingExtended((PdfObject)object, pRStream, object.getAsDict(PdfName.RESOURCES), pRStream.getAsDict(PdfName.RESOURCES), objectPath, compareResult) && this.compareDictionariesExtended((PdfDictionary)object, pRStream, objectPath, compareResult)) {
                return true;
            }
            return false;
        }
        if (Arrays.equals(arrby3, arrby4)) {
            return this.compareDictionariesExtended((PdfDictionary)object, pRStream, objectPath, compareResult);
        }
        if (arrby4.length != arrby3.length) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, String.format("PRStream. Lengths are different. Expected: %s. Found: %s", arrby4.length, arrby3.length));
                return false;
            }
        } else {
            for (int i2 = 0; i2 < arrby4.length; ++i2) {
                if (arrby4[i2] == arrby3[i2]) continue;
                int n2 = Math.max(0, i2 - 10);
                int n3 = Math.min(arrby4.length, i2 + 10);
                if (compareResult == null || objectPath == null) continue;
                objectPath.pushOffsetToPath(i2);
                object = new String(new byte[]{arrby4[i2]});
                compareResult.addError(objectPath, String.format("PRStream. The bytes differ at index %s. Expected: %s (%s). Found: %s (%s)", i2, object, new String(arrby4, n2, n3 -= n2).replaceAll("\\n", "\\\\n"), new String(new byte[]{arrby3[i2]}), new String(arrby3, n2, n3).replaceAll("\\n", "\\\\n")));
                objectPath.pop();
            }
        }
        return false;
    }

    private boolean compareStringsExtended(PdfString object, PdfString object2, ObjectPath objectPath, CompareResult compareResult) {
        if (Arrays.equals(object2.getBytes(), object.getBytes())) {
            return true;
        }
        object2 = object2.toUnicodeString();
        object = object.toUnicodeString();
        if (object2.length() != object.length()) {
            if (compareResult != null && objectPath != null) {
                compareResult.addError(objectPath, String.format("PdfString. Lengths are different. Expected: %s. Found: %s", object2.length(), object.length()));
                return false;
            }
        } else {
            for (int i2 = 0; i2 < object2.length(); ++i2) {
                if (object2.charAt(i2) == object.charAt(i2)) continue;
                int n2 = Math.max(0, i2 - 10);
                int n3 = Math.min(object2.length(), i2 + 10);
                if (compareResult == null || objectPath == null) break;
                objectPath.pushOffsetToPath(i2);
                compareResult.addError(objectPath, String.format("PdfString. Characters differ at position %s. Expected: %s (%s). Found: %s (%s).", i2, Character.toString(object2.charAt(i2)), object2.substring(n2, n3).replace("\n", "\\n"), Character.toString(object.charAt(i2)), object.substring(n2, n3).replace("\n", "\\n")));
                objectPath.pop();
                return false;
            }
        }
        return false;
    }

    private String[] convertInfo(HashMap<String, String> object) {
        String[] arrstring = new String[]{"", "", "", ""};
        for (Map.Entry entry : object.entrySet()) {
            if ("title".equalsIgnoreCase((String)entry.getKey())) {
                arrstring[0] = (String)entry.getValue();
                continue;
            }
            if ("author".equalsIgnoreCase((String)entry.getKey())) {
                arrstring[1] = (String)entry.getValue();
                continue;
            }
            if ("subject".equalsIgnoreCase((String)entry.getKey())) {
                arrstring[2] = (String)entry.getValue();
                continue;
            }
            if (!"keywords".equalsIgnoreCase((String)entry.getKey())) continue;
            arrstring[3] = (String)entry.getValue();
        }
        return arrstring;
    }

    /*
     * Enabled aggressive block sorting
     */
    private void init(String charSequence, String string2) {
        this.outPdf = charSequence;
        this.cmpPdf = string2;
        this.outPdfName = new File((String)charSequence).getName();
        this.cmpPdfName = new File(string2).getName();
        charSequence = new StringBuilder();
        charSequence.append(this.outPdfName);
        charSequence.append("-%03d.png");
        this.outImage = charSequence.toString();
        if (this.cmpPdfName.startsWith("cmp_")) {
            charSequence = new StringBuilder();
        } else {
            charSequence = new StringBuilder();
            charSequence.append("cmp_");
        }
        charSequence.append(this.cmpPdfName);
        charSequence.append("-%03d.png");
        this.cmpImage = charSequence.toString();
    }

    private boolean linksAreSame(PdfAnnotation.PdfImportedLink object, PdfAnnotation.PdfImportedLink object2) {
        if (object.getDestinationPage() != object2.getDestinationPage()) {
            return false;
        }
        if (!object.getRect().toString().equals(object2.getRect().toString())) {
            return false;
        }
        Object object3 = object.getParameters();
        object = object2.getParameters();
        if (object3.size() != object.size()) {
            return false;
        }
        block3 : for (Map.Entry<PdfName, PdfObject> entry : object3.entrySet()) {
            object3 = entry.getValue();
            if (!object.containsKey(entry.getKey())) {
                return false;
            }
            PdfObject object4 = object.get(entry.getKey());
            if (object3.type() != object4.type()) {
                return false;
            }
            int n2 = object3.type();
            if (n2 != 8) {
                switch (n2) {
                    default: {
                        continue block3;
                    }
                    case 1: 
                    case 2: 
                    case 3: 
                    case 4: 
                }
            }
            if (object3.toString().equals(object4.toString())) continue;
            return false;
        }
        return true;
    }

    private void loadPagesFromReader(PdfReader pdfReader, List<PdfDictionary> list, List<RefKey> list2) {
        this.addPagesFromDict(pdfReader.getCatalog().get(PdfName.PAGES), list, list2);
    }

    private Process runProcess(String string2, String object) {
        object = new StringTokenizer((String)object);
        String[] arrstring = new String[object.countTokens() + 1];
        arrstring[0] = string2;
        int n2 = 1;
        while (object.hasMoreTokens()) {
            arrstring[n2] = object.nextToken();
            ++n2;
        }
        return Runtime.getRuntime().exec(arrstring);
    }

    public String compare(String string2, String string3, String string4, String string5) {
        return this.compare(string2, string3, string4, string5, null);
    }

    public String compare(String string2, String string3, String string4, String string5, Map<Integer, List<Rectangle>> map) {
        this.init(string2, string3);
        return this.compare(string4, string5, map);
    }

    public boolean compareArrays(PdfArray pdfArray, PdfArray pdfArray2) {
        return this.compareArraysExtended(pdfArray, pdfArray2, null, null);
    }

    public boolean compareBooleans(PdfBoolean pdfBoolean, PdfBoolean pdfBoolean2) {
        return Arrays.equals(pdfBoolean2.getBytes(), pdfBoolean.getBytes());
    }

    public String compareByContent(String string2, String string3, String string4, String string5) {
        return this.compareByContent(string2, string3, string4, string5, null);
    }

    public String compareByContent(String string2, String string3, String string4, String string5, Map<Integer, List<Rectangle>> map) {
        this.init(string2, string3);
        return this.compareByContent(string4, string5, map);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    protected String compareByContent(String string2, String string3, Map<Integer, List<Rectangle>> map) {
        CompareResult compareResult;
        ArrayList<Integer> arrayList;
        Object object;
        System.out.print("[itext] INFO  Comparing by content..........");
        PdfReader pdfReader = new PdfReader(this.outPdf);
        this.outPages = new ArrayList<PdfDictionary>();
        this.outPagesRef = new ArrayList<RefKey>();
        this.loadPagesFromReader(pdfReader, this.outPages, this.outPagesRef);
        PdfReader pdfReader2 = new PdfReader(this.cmpPdf);
        this.cmpPages = new ArrayList<PdfDictionary>();
        this.cmpPagesRef = new ArrayList<RefKey>();
        this.loadPagesFromReader(pdfReader2, this.cmpPages, this.cmpPagesRef);
        if (this.outPages.size() != this.cmpPages.size()) {
            return this.compare(string2, string3, map);
        }
        compareResult = new CompareResult(this.compareByContentErrorsLimit);
        arrayList = new ArrayList<Integer>(this.cmpPages.size());
        for (int i2 = 0; i2 < this.cmpPages.size(); ++i2) {
            object = new ObjectPath(this.cmpPagesRef.get(i2), this.outPagesRef.get(i2));
            if (!this.compareDictionariesExtended(this.outPages.get(i2), this.cmpPages.get(i2), (ObjectPath)object, compareResult)) continue;
            arrayList.add(i2);
        }
        PdfObject pdfObject = pdfReader.getCatalog().get(PdfName.STRUCTTREEROOT);
        PdfObject pdfObject2 = pdfReader2.getCatalog().get(PdfName.STRUCTTREEROOT);
        object = pdfObject == null ? null : new RefKey((PdfIndirectReference)pdfObject);
        RefKey refKey = pdfObject2 == null ? null : new RefKey((PdfIndirectReference)pdfObject2);
        this.compareObjects(pdfObject, pdfObject2, new ObjectPath((RefKey)object, refKey), compareResult);
        pdfObject = pdfReader.getCatalog().get(PdfName.OCPROPERTIES);
        pdfObject2 = pdfReader2.getCatalog().get(PdfName.OCPROPERTIES);
        object = pdfObject instanceof PdfIndirectReference ? new RefKey((PdfIndirectReference)pdfObject) : null;
        refKey = pdfObject2 instanceof PdfIndirectReference ? new RefKey((PdfIndirectReference)pdfObject2) : null;
        this.compareObjects(pdfObject, pdfObject2, new ObjectPath((RefKey)object, refKey), compareResult);
        pdfReader.close();
        pdfReader2.close();
        if (this.generateCompareByContentXmlReport) {
            try {
                object = new StringBuilder();
                object.append(string2);
                object.append("/");
                object.append(this.xmlReportName);
                object.append(".xml");
                compareResult.writeReportToXml(new FileOutputStream(object.toString()));
            }
            catch (Exception exception) {}
        }
        if (arrayList.size() == this.cmpPages.size() && compareResult.isOk()) {
            System.out.println("OK");
            System.out.flush();
            return null;
        }
        System.out.println("Fail");
        System.out.flush();
        object = new StringBuilder();
        object.append("Compare by content report:\n");
        object.append(compareResult.getReport());
        object = object.toString();
        System.out.println((String)object);
        System.out.flush();
        string2 = this.compare(string2, string3, map, arrayList);
        if (string2 == null) return "Compare by content fails. No visual differences";
        if (string2.length() != 0) return string2;
        return "Compare by content fails. No visual differences";
    }

    public boolean compareContentStreamsByParsing(PdfObject pdfObject, PdfObject pdfObject2) {
        return this.compareContentStreamsByParsingExtended(pdfObject, pdfObject2, null, null, null, null);
    }

    public boolean compareContentStreamsByParsing(PdfObject pdfObject, PdfObject pdfObject2, PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2) {
        return this.compareContentStreamsByParsingExtended(pdfObject, pdfObject2, pdfDictionary, pdfDictionary2, null, null);
    }

    public boolean compareDictionaries(PdfDictionary pdfDictionary, PdfDictionary pdfDictionary2) {
        return this.compareDictionariesExtended(pdfDictionary, pdfDictionary2, null, null);
    }

    /*
     * Enabled aggressive block sorting
     */
    public String compareDocumentInfo(String object, String object2) {
        void var1_5;
        Object object3;
        Object object4;
        block3 : {
            System.out.print("[itext] INFO  Comparing document info.......");
            object4 = new PdfReader((String)object);
            object3 = new PdfReader((String)object3);
            String[] arrstring = this.convertInfo(object3.getInfo());
            String[] arrstring2 = this.convertInfo(object4.getInfo());
            for (int i2 = 0; i2 < arrstring.length; ++i2) {
                if (arrstring[i2].equals(arrstring2[i2])) continue;
                String string2 = "Document info fail";
                break block3;
            }
            Object var1_4 = null;
        }
        object4.close();
        object3.close();
        if (var1_5 == null) {
            object4 = System.out;
            object3 = "OK";
        } else {
            object4 = System.out;
            object3 = "Fail";
        }
        object4.println((String)object3);
        System.out.flush();
        return var1_5;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public String compareLinks(String var1_1, String var2_2) {
        System.out.print("[itext] INFO  Comparing link annotations....");
        var6_3 = new PdfReader((String)var1_1);
        var7_4 = new PdfReader((String)var2_2);
        var1_1 = null;
        var3_5 = 0;
        block0 : do {
            var2_2 = var1_1;
            if (var3_5 >= var6_3.getNumberOfPages()) ** GOTO lbl-1000
            var2_2 = var1_1;
            if (var3_5 < var7_4.getNumberOfPages()) {
                var5_7 = var3_5 + 1;
                var2_2 = var6_3.getLinks(var5_7);
                var8_8 = var7_4.getLinks(var5_7);
                if (var8_8.size() != var2_2.size()) {
                    var2_2 = String.format("Different number of links on page %d.", new Object[]{var5_7});
                }
            } else lbl-1000: // 3 sources:
            {
                var6_3.close();
                var7_4.close();
                if (var2_2 == null) {
                    var1_1 = System.out;
                    var6_3 = "OK";
                } else {
                    var1_1 = System.out;
                    var6_3 = "Fail";
                }
                var1_1.println((String)var6_3);
                System.out.flush();
                return var2_2;
            }
            var4_6 = 0;
            do {
                var3_5 = var5_7;
                if (var4_6 >= var8_8.size()) continue block0;
                if (!this.linksAreSame(var8_8.get(var4_6), (PdfAnnotation.PdfImportedLink)var2_2.get(var4_6))) {
                    var1_1 = String.format("Different links on page %d.\n%s\n%s", new Object[]{var5_7, var8_8.get(var4_6).toString(), ((PdfAnnotation.PdfImportedLink)var2_2.get(var4_6)).toString()});
                    var3_5 = var5_7;
                    continue block0;
                }
                ++var4_6;
            } while (true);
            break;
        } while (true);
    }

    public boolean compareLiterals(PdfLiteral pdfLiteral, PdfLiteral pdfLiteral2) {
        return Arrays.equals(pdfLiteral2.getBytes(), pdfLiteral.getBytes());
    }

    public boolean compareNames(PdfName pdfName, PdfName pdfName2) {
        if (pdfName2.compareTo(pdfName) == 0) {
            return true;
        }
        return false;
    }

    public boolean compareNumbers(PdfNumber pdfNumber, PdfNumber pdfNumber2) {
        double d2;
        double d3 = d2 = Math.abs(pdfNumber.doubleValue() - pdfNumber2.doubleValue());
        if (!this.absoluteError) {
            d3 = d2;
            if (pdfNumber2.doubleValue() != 0.0) {
                d3 = d2 / pdfNumber2.doubleValue();
            }
        }
        if (d3 <= this.floatComparisonError) {
            return true;
        }
        return false;
    }

    public boolean compareStreams(PRStream pRStream, PRStream pRStream2) {
        return this.compareStreamsExtended(pRStream, pRStream2, null, null);
    }

    public boolean compareStrings(PdfString pdfString, PdfString pdfString2) {
        return Arrays.equals(pdfString2.getBytes(), pdfString.getBytes());
    }

    /*
     * Enabled aggressive block sorting
     */
    public String compareTagStructures(String object, String object2) {
        System.out.print("[itext] INFO  Comparing tag structures......");
        String string2 = object.replace(".pdf", ".xml");
        String string3 = object.replace(".pdf", ".cmp.xml");
        object = new PdfReader((String)object);
        Object object3 = new FileOutputStream(string2);
        new CmpTaggedPdfReaderTool().convertToXml((PdfReader)object, (OutputStream)object3);
        object.close();
        object = new PdfReader((String)object2);
        object2 = new FileOutputStream(string3);
        new CmpTaggedPdfReaderTool().convertToXml((PdfReader)object, (OutputStream)object2);
        object.close();
        object = !this.compareXmls(string2, string3) ? "The tag structures are different." : null;
        object3.close();
        object2.close();
        if (object == null) {
            object2 = System.out;
            object3 = "OK";
        } else {
            object2 = System.out;
            object3 = "Fail";
        }
        object2.println((String)object3);
        System.out.flush();
        return object;
    }

    public boolean compareXmls(String object, String object2) {
        Object object3 = DocumentBuilderFactory.newInstance();
        object3.setNamespaceAware(true);
        object3.setCoalescing(true);
        object3.setIgnoringElementContentWhitespace(true);
        object3.setIgnoringComments(true);
        object3 = object3.newDocumentBuilder();
        object = object3.parse(new File((String)object));
        object.normalizeDocument();
        object2 = object3.parse(new File((String)object2));
        object2.normalizeDocument();
        return object2.isEqualNode((Node)object);
    }

    public boolean compareXmls(byte[] object, byte[] object2) {
        Object object3 = DocumentBuilderFactory.newInstance();
        object3.setNamespaceAware(true);
        object3.setCoalescing(true);
        object3.setIgnoringElementContentWhitespace(true);
        object3.setIgnoringComments(true);
        object3 = object3.newDocumentBuilder();
        object = object3.parse(new ByteArrayInputStream((byte[])object));
        object.normalizeDocument();
        object2 = object3.parse(new ByteArrayInputStream((byte[])object2));
        object2.normalizeDocument();
        return object2.isEqualNode((Node)object);
    }

    public String compareXmp(String string2, String string3) {
        return this.compareXmp(string2, string3, false);
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public String compareXmp(String object, String object2, boolean bl2) {
        block11 : {
            String string2;
            void var4_10;
            block10 : {
                this.init((String)object, (String)object2);
                object2 = null;
                string2 = null;
                object = new PdfReader(this.cmpPdf);
                object2 = new PdfReader(this.outPdf);
                try {
                    string2 = this.compareXmp(object.getMetadata(), object2.getMetadata(), bl2);
                    object.close();
                    object2.close();
                    return string2;
                }
                catch (Throwable throwable) {
                    Object object3 = object;
                    object = object2;
                    object2 = object3;
                    break block10;
                }
                catch (Throwable throwable) {
                    Object var5_13 = null;
                    object2 = object;
                    object = var5_13;
                    break block10;
                }
                catch (Throwable throwable) {
                    object = null;
                }
            }
            if (object2 != null) {
                object2.close();
            }
            if (object == null) throw var4_10;
            object.close();
            throw var4_10;
            catch (IOException iOException) {}
            object2 = null;
            object = string2;
            break block11;
            catch (IOException iOException) {}
            object2 = null;
            break block11;
            catch (IOException iOException) {}
        }
        if (object == null) return "XMP parsing failure!";
        object.close();
        if (object2 == null) return "XMP parsing failure!";
        object2.close();
        return "XMP parsing failure!";
    }

    public String compareXmp(byte[] arrby, byte[] arrby2) {
        return this.compareXmp(arrby, arrby2, false);
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    public String compareXmp(byte[] var1_1, byte[] var2_6, boolean var3_7) {
        var5_10 /* !! */  = var1_1 /* !! */ ;
        var4_11 = var2_8;
        if (var3_9 == false) ** GOTO lbl17
        try {
            var1_2 = XMPMetaFactory.parseFromBuffer(var1_1 /* !! */ );
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/xap/1.0/", "CreateDate", true, true);
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/xap/1.0/", "ModifyDate", true, true);
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/xap/1.0/", "MetadataDate", true, true);
            XMPUtils.removeProperties(var1_2, "http://ns.adobe.com/pdf/1.3/", "Producer", true, true);
            var5_10 /* !! */  = XMPMetaFactory.serializeToBuffer(var1_2, new SerializeOptions(8192));
            var1_3 = XMPMetaFactory.parseFromBuffer((byte[])var2_8);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/xap/1.0/", "CreateDate", true, true);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/xap/1.0/", "ModifyDate", true, true);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/xap/1.0/", "MetadataDate", true, true);
            XMPUtils.removeProperties(var1_3, "http://ns.adobe.com/pdf/1.3/", "Producer", true, true);
            var4_11 = XMPMetaFactory.serializeToBuffer(var1_3, new SerializeOptions(8192));
lbl17: // 2 sources:
            if (this.compareXmls(var5_10 /* !! */ , var4_11) != false) return null;
            return "The XMP packages different!";
        }
        catch (XMPException var1_4) {
            return "XMP parsing failure!";
        }
        catch (IOException var1_5) {
            return "XMP parsing failure!";
        }
        catch (ParserConfigurationException var1_6) {
            return "XMP parsing failure!";
        }
        catch (SAXException var1_7) {
            return "XMP parsing failure!";
        }
    }

    public String getXmlReportName() {
        return this.xmlReportName;
    }

    public CompareTool setCompareByContentErrorsLimit(int n2) {
        this.compareByContentErrorsLimit = n2;
        return this;
    }

    public CompareTool setFloatAbsoluteError(float f2) {
        this.floatComparisonError = f2;
        this.absoluteError = true;
        return this;
    }

    public CompareTool setFloatRelativeError(float f2) {
        this.floatComparisonError = f2;
        this.absoluteError = false;
        return this;
    }

    public void setGenerateCompareByContentXmlReport(boolean bl2) {
        this.generateCompareByContentXmlReport = bl2;
    }

    public void setXmlReportName(String string2) {
        this.xmlReportName = string2;
    }

    class CmpMarkedContentRenderFilter
    implements RenderListener {
        Map<Integer, TextExtractionStrategy> tagsByMcid = new HashMap<Integer, TextExtractionStrategy>();

        CmpMarkedContentRenderFilter() {
        }

        @Override
        public void beginTextBlock() {
            Iterator<Integer> iterator = this.tagsByMcid.keySet().iterator();
            while (iterator.hasNext()) {
                int n2 = iterator.next();
                this.tagsByMcid.get(n2).beginTextBlock();
            }
        }

        @Override
        public void endTextBlock() {
            Iterator<Integer> iterator = this.tagsByMcid.keySet().iterator();
            while (iterator.hasNext()) {
                int n2 = iterator.next();
                this.tagsByMcid.get(n2).endTextBlock();
            }
        }

        public Map<Integer, String> getParsedTagContent() {
            HashMap<Integer, String> hashMap = new HashMap<Integer, String>();
            Iterator<Integer> iterator = this.tagsByMcid.keySet().iterator();
            while (iterator.hasNext()) {
                int n2 = iterator.next();
                hashMap.put(n2, this.tagsByMcid.get(n2).getResultantText());
            }
            return hashMap;
        }

        @Override
        public void renderImage(ImageRenderInfo imageRenderInfo) {
        }

        /*
         * Enabled aggressive block sorting
         */
        @Override
        public void renderText(TextRenderInfo textRenderInfo) {
            Integer n2 = textRenderInfo.getMcid();
            if (n2 == null || !this.tagsByMcid.containsKey(n2)) {
                if (n2 == null) {
                    return;
                }
                this.tagsByMcid.put(n2, new SimpleTextExtractionStrategy());
            }
            this.tagsByMcid.get(n2).renderText(textRenderInfo);
        }
    }

    class CmpPngFileFilter
    implements FileFilter {
        CmpPngFileFilter() {
        }

        @Override
        public boolean accept(File object) {
            object = object.getAbsolutePath();
            boolean bl2 = object.endsWith(".png");
            boolean bl3 = object.contains("cmp_");
            if (bl2 && bl3 && object.contains(CompareTool.this.cmpPdfName)) {
                return true;
            }
            return false;
        }
    }

    class CmpTaggedPdfReaderTool
    extends TaggedPdfReaderTool {
        Map<PdfDictionary, Map<Integer, String>> parsedTags = new HashMap<PdfDictionary, Map<Integer, String>>();

        CmpTaggedPdfReaderTool() {
        }

        @Override
        public void inspectChildDictionary(PdfDictionary pdfDictionary) {
            this.inspectChildDictionary(pdfDictionary, true);
        }

        @Override
        public void parseTag(String object, PdfObject pdfObject, PdfDictionary pdfDictionary) {
            if (pdfObject instanceof PdfNumber) {
                if (!this.parsedTags.containsKey(pdfDictionary)) {
                    object = new CmpMarkedContentRenderFilter();
                    new PdfContentStreamProcessor((RenderListener)object).processContent(PdfReader.getPageContent(pdfDictionary), pdfDictionary.getAsDict(PdfName.RESOURCES));
                    this.parsedTags.put(pdfDictionary, object.getParsedTagContent());
                }
                object = "";
                Map<Integer, String> map = this.parsedTags.get(pdfDictionary);
                if (map.containsKey((pdfObject = (PdfNumber)pdfObject).intValue())) {
                    object = this.parsedTags.get(pdfDictionary).get(pdfObject.intValue());
                }
                this.out.print(XMLUtil.escapeXML((String)object, true));
                return;
            }
            super.parseTag((String)object, pdfObject, pdfDictionary);
        }
    }

    protected class CompareResult {
        protected Map<ObjectPath, String> differences = new LinkedHashMap<ObjectPath, String>();
        protected int messageLimit = 1;

        public CompareResult(int n2) {
            this.messageLimit = n2;
        }

        protected void addError(ObjectPath objectPath, String string2) {
            if (this.differences.size() < this.messageLimit) {
                this.differences.put((ObjectPath)objectPath.clone(), string2);
            }
        }

        public int getErrorCount() {
            return this.differences.size();
        }

        public String getReport() {
            StringBuilder stringBuilder = new StringBuilder();
            Iterator<Map.Entry<ObjectPath, String>> iterator = this.differences.entrySet().iterator();
            boolean bl2 = true;
            while (iterator.hasNext()) {
                Map.Entry<ObjectPath, String> entry = iterator.next();
                if (!bl2) {
                    stringBuilder.append("-----------------------------");
                    stringBuilder.append("\n");
                }
                ObjectPath objectPath = entry.getKey();
                stringBuilder.append(entry.getValue());
                stringBuilder.append("\n");
                stringBuilder.append(objectPath.toString());
                stringBuilder.append("\n");
                bl2 = false;
            }
            return stringBuilder.toString();
        }

        protected boolean isMessageLimitReached() {
            if (this.differences.size() >= this.messageLimit) {
                return true;
            }
            return false;
        }

        public boolean isOk() {
            if (this.differences.size() == 0) {
                return true;
            }
            return false;
        }

        public void writeReportToXml(OutputStream outputStream) {
            Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
            Object object = document.createElement("report");
            Element element = document.createElement("errors");
            element.setAttribute("count", String.valueOf(this.differences.size()));
            object.appendChild(element);
            for (Map.Entry<ObjectPath, String> entry : this.differences.entrySet()) {
                Element element2 = document.createElement("error");
                Element element3 = document.createElement("message");
                element3.appendChild(document.createTextNode(entry.getValue()));
                Node object2 = entry.getKey().toXmlNode(document);
                element2.appendChild(element3);
                element2.appendChild(object2);
                element.appendChild(element2);
            }
            document.appendChild((Node)object);
            object = TransformerFactory.newInstance().newTransformer();
            object.setOutputProperty("indent", "yes");
            object.transform(new DOMSource(document), new StreamResult(outputStream));
        }
    }

    class ImageNameComparator
    implements Comparator<File> {
        ImageNameComparator() {
        }

        @Override
        public int compare(File file, File file2) {
            return file.getAbsolutePath().compareTo(file2.getAbsolutePath());
        }
    }

    private class ObjectPath {
        protected RefKey baseCmpObject;
        protected RefKey baseOutObject;
        protected Stack<Pair<RefKey>> indirects = new Stack();
        protected Stack<PathItem> path = new Stack();

        public ObjectPath() {
        }

        protected ObjectPath(RefKey refKey, RefKey refKey2) {
            this.baseCmpObject = refKey;
            this.baseOutObject = refKey2;
        }

        private ObjectPath(RefKey refKey, RefKey refKey2, Stack<PathItem> stack) {
            this.baseCmpObject = refKey;
            this.baseOutObject = refKey2;
            this.path = stack;
        }

        protected Object clone() {
            return new ObjectPath(this.baseCmpObject, this.baseOutObject, (Stack)this.path.clone());
        }

        public boolean equals(Object object) {
            if (object instanceof ObjectPath) {
                RefKey refKey = this.baseCmpObject;
                object = (ObjectPath)object;
                if (refKey.equals(object.baseCmpObject) && this.baseOutObject.equals(object.baseOutObject) && this.path.equals(object.path)) {
                    return true;
                }
            }
            return false;
        }

        public int hashCode() {
            Object object = this.baseCmpObject;
            int n2 = 1;
            int n3 = object != null ? this.baseCmpObject.hashCode() : 1;
            if (this.baseOutObject != null) {
                n2 = this.baseOutObject.hashCode();
            }
            n3 = n3 * 31 + n2;
            object = this.path.iterator();
            while (object.hasNext()) {
                n3 = n3 * 31 + ((PathItem)object.next()).hashCode();
            }
            return n3;
        }

        public boolean isComparing(RefKey refKey, RefKey refKey2) {
            return this.indirects.contains(new Pair<RefKey>(refKey, refKey2));
        }

        public void pop() {
            this.path.pop();
        }

        public void pushArrayItemToPath(int n2) {
            this.path.add(new ArrayPathItem(n2));
        }

        public void pushDictItemToPath(String string2) {
            this.path.add(new DictPathItem(string2));
        }

        public void pushOffsetToPath(int n2) {
            this.path.add(new OffsetPathItem(n2));
        }

        public ObjectPath resetDirectPath(RefKey refKey, RefKey refKey2) {
            ObjectPath objectPath = new ObjectPath(refKey, refKey2);
            objectPath.indirects = (Stack)this.indirects.clone();
            objectPath.indirects.add(new Pair<RefKey>(refKey, refKey2));
            return objectPath;
        }

        public String toString() {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(String.format("Base cmp object: %s obj. Base out object: %s obj", this.baseCmpObject, this.baseOutObject));
            for (PathItem pathItem : this.path) {
                stringBuilder.append("\n");
                stringBuilder.append(pathItem.toString());
            }
            return stringBuilder.toString();
        }

        public Node toXmlNode(Document document) {
            Element element = document.createElement("path");
            Object object = document.createElement("base");
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(this.baseCmpObject.toString());
            stringBuilder.append(" obj");
            object.setAttribute("cmp", stringBuilder.toString());
            stringBuilder = new StringBuilder();
            stringBuilder.append(this.baseOutObject.toString());
            stringBuilder.append(" obj");
            object.setAttribute("out", stringBuilder.toString());
            element.appendChild((Node)object);
            object = this.path.iterator();
            while (object.hasNext()) {
                element.appendChild(((PathItem)object.next()).toXmlNode(document));
            }
            return element;
        }

        private class ArrayPathItem
        extends PathItem {
            int index;

            public ArrayPathItem(int n2) {
                super();
                this.index = n2;
            }

            public boolean equals(Object object) {
                if (object instanceof ArrayPathItem && this.index == ((ArrayPathItem)object).index) {
                    return true;
                }
                return false;
            }

            public int hashCode() {
                return this.index;
            }

            public String toString() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Array index: ");
                stringBuilder.append(String.valueOf(this.index));
                return stringBuilder.toString();
            }

            @Override
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("arrayIndex");
                element.appendChild(document.createTextNode(String.valueOf(this.index)));
                return element;
            }
        }

        private class DictPathItem
        extends PathItem {
            String key;

            public DictPathItem(String string2) {
                super();
                this.key = string2;
            }

            public boolean equals(Object object) {
                if (object instanceof DictPathItem && this.key.equals(((DictPathItem)object).key)) {
                    return true;
                }
                return false;
            }

            public int hashCode() {
                return this.key.hashCode();
            }

            public String toString() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Dict key: ");
                stringBuilder.append(this.key);
                return stringBuilder.toString();
            }

            @Override
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("dictKey");
                element.appendChild(document.createTextNode(this.key));
                return element;
            }
        }

        private class OffsetPathItem
        extends PathItem {
            int offset;

            public OffsetPathItem(int n2) {
                super();
                this.offset = n2;
            }

            public boolean equals(Object object) {
                if (object instanceof OffsetPathItem && this.offset == ((OffsetPathItem)object).offset) {
                    return true;
                }
                return false;
            }

            public int hashCode() {
                return this.offset;
            }

            public String toString() {
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append("Offset: ");
                stringBuilder.append(String.valueOf(this.offset));
                return stringBuilder.toString();
            }

            @Override
            protected Node toXmlNode(Document document) {
                Element element = document.createElement("offset");
                element.appendChild(document.createTextNode(String.valueOf(this.offset)));
                return element;
            }
        }

        private class Pair<T> {
            private T first;
            private T second;

            public Pair(T t2, T t3) {
                this.first = t2;
                this.second = t3;
            }

            public boolean equals(Object object) {
                if (object instanceof Pair) {
                    T t2 = this.first;
                    object = (Pair)object;
                    if (t2.equals(object.first) && this.second.equals(object.second)) {
                        return true;
                    }
                }
                return false;
            }

            public int hashCode() {
                return this.first.hashCode() * 31 + this.second.hashCode();
            }
        }

        private abstract class PathItem {
            private PathItem() {
            }

            protected abstract Node toXmlNode(Document var1);
        }

    }

    class PngFileFilter
    implements FileFilter {
        PngFileFilter() {
        }

        @Override
        public boolean accept(File object) {
            object = object.getAbsolutePath();
            boolean bl2 = object.endsWith(".png");
            boolean bl3 = object.contains("cmp_");
            if (bl2 && !bl3 && object.contains(CompareTool.this.outPdfName)) {
                return true;
            }
            return false;
        }
    }

}

