/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl;

import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.options.PropertyOptions;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

class XMPNode
implements Comparable {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    private boolean alias;
    private List children = null;
    private boolean hasAliases;
    private boolean hasValueChild;
    private boolean implicit;
    private String name;
    private PropertyOptions options = null;
    private XMPNode parent;
    private List qualifier = null;
    private String value;

    public XMPNode(String string2, PropertyOptions propertyOptions) {
        this(string2, null, propertyOptions);
    }

    public XMPNode(String string2, String string3, PropertyOptions propertyOptions) {
        this.name = string2;
        this.value = string3;
        this.options = propertyOptions;
    }

    private void assertChildNotExisting(String string2) {
        if (!"[]".equals(string2)) {
            if (this.findChildByName(string2) == null) {
                return;
            }
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Duplicate property or field node '");
            stringBuilder.append(string2);
            stringBuilder.append("'");
            throw new XMPException(stringBuilder.toString(), 203);
        }
    }

    private void assertQualifierNotExisting(String string2) {
        if (!"[]".equals(string2)) {
            if (this.findQualifierByName(string2) == null) {
                return;
            }
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Duplicate '");
            stringBuilder.append(string2);
            stringBuilder.append("' qualifier");
            throw new XMPException(stringBuilder.toString(), 203);
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private void dumpNode(StringBuffer var1_1, boolean var2_2, int var3_3, int var4_4) {
        block13 : {
            block11 : {
                block12 : {
                    var6_5 = 0;
                    for (var5_6 = 0; var5_6 < var3_3; ++var5_6) {
                        var1_1.append('\t');
                    }
                    if (this.parent == null) break block11;
                    if (!this.getOptions().isQualifier()) break block12;
                    var1_1.append('?');
                    ** GOTO lbl-1000
                }
                if (this.getParent().getOptions().isArray()) {
                    var1_1.append('[');
                    var1_1.append(var4_4);
                    var1_1.append(']');
                } else lbl-1000: // 2 sources:
                {
                    var1_1.append(this.name);
                }
                break block13;
            }
            var1_1.append("ROOT NODE");
            if (this.name != null && this.name.length() > 0) {
                var1_1.append(" (");
                var1_1.append(this.name);
                var1_1.append(')');
            }
        }
        if (this.value != null && this.value.length() > 0) {
            var1_1.append(" = \"");
            var1_1.append(this.value);
            var1_1.append('\"');
        }
        if (this.getOptions().containsOneOf(-1)) {
            var1_1.append("\t(");
            var1_1.append(this.getOptions().toString());
            var1_1.append(" : ");
            var1_1.append(this.getOptions().getOptionsString());
            var1_1.append(')');
        }
        var1_1.append('\n');
        if (var2_2 && this.hasQualifier()) {
            var7_7 = this.getQualifier().toArray(new XMPNode[this.getQualifierLength()]);
            for (var4_4 = 0; var7_7.length > var4_4 && ("xml:lang".equals(var7_7[var4_4].getName()) || "rdf:type".equals(var7_7[var4_4].getName())); ++var4_4) {
            }
            Arrays.sort(var7_7, var4_4, var7_7.length);
            var4_4 = 0;
            while (var4_4 < var7_7.length) {
                var8_8 = var7_7[var4_4];
                XMPNode.super.dumpNode(var1_1, var2_2, var3_3 + 2, ++var4_4);
            }
        }
        if (var2_2 == false) return;
        if (this.hasChildren() == false) return;
        var7_7 = this.getChildren().toArray(new XMPNode[this.getChildrenLength()]);
        var4_4 = var6_5;
        if (!this.getOptions().isArray()) {
            Arrays.sort(var7_7);
            var4_4 = var6_5;
        }
        while (var4_4 < var7_7.length) {
            var8_8 = var7_7[var4_4];
            XMPNode.super.dumpNode(var1_1, var2_2, var3_3 + 1, ++var4_4);
        }
    }

    private XMPNode find(List object, String string2) {
        if (object != null) {
            object = object.iterator();
            while (object.hasNext()) {
                XMPNode xMPNode = (XMPNode)object.next();
                if (!xMPNode.getName().equals(string2)) continue;
                return xMPNode;
            }
        }
        return null;
    }

    private List getChildren() {
        if (this.children == null) {
            this.children = new ArrayList(0);
        }
        return this.children;
    }

    private List getQualifier() {
        if (this.qualifier == null) {
            this.qualifier = new ArrayList(0);
        }
        return this.qualifier;
    }

    private boolean isLanguageNode() {
        return "xml:lang".equals(this.name);
    }

    private boolean isTypeNode() {
        return "rdf:type".equals(this.name);
    }

    public void addChild(int n2, XMPNode xMPNode) {
        this.assertChildNotExisting(xMPNode.getName());
        xMPNode.setParent(this);
        this.getChildren().add(n2 - 1, xMPNode);
    }

    public void addChild(XMPNode xMPNode) {
        this.assertChildNotExisting(xMPNode.getName());
        xMPNode.setParent(this);
        this.getChildren().add(xMPNode);
    }

    public void addQualifier(XMPNode xMPNode) {
        RuntimeException runtimeException;
        super("d2j fail translate: java.lang.RuntimeException: can not merge Z and I\n\tat com.googlecode.dex2jar.ir.TypeClass.merge(TypeClass.java:100)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeRef.updateTypeClass(TypeTransformer.java:174)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.copyTypes(TypeTransformer.java:296)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.fixTypes(TypeTransformer.java:226)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer$TypeAnalyze.analyze(TypeTransformer.java:207)\n\tat com.googlecode.dex2jar.ir.ts.TypeTransformer.transform(TypeTransformer.java:44)\n\tat com.googlecode.d2j.dex.Dex2jar$2.optimize(Dex2jar.java:162)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertCode(Dex2Asm.java:414)\n\tat com.googlecode.d2j.dex.ExDex2Asm.convertCode(ExDex2Asm.java:42)\n\tat com.googlecode.d2j.dex.Dex2jar$2.convertCode(Dex2jar.java:128)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertMethod(Dex2Asm.java:509)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertClass(Dex2Asm.java:406)\n\tat com.googlecode.d2j.dex.Dex2Asm.convertDex(Dex2Asm.java:422)\n\tat com.googlecode.d2j.dex.Dex2jar.doTranslate(Dex2jar.java:172)\n\tat com.googlecode.d2j.dex.Dex2jar.to(Dex2jar.java:272)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.doCommandLine(Dex2jarCmd.java:108)\n\tat com.googlecode.dex2jar.tools.BaseCmd.doMain(BaseCmd.java:288)\n\tat com.googlecode.dex2jar.tools.Dex2jarCmd.main(Dex2jarCmd.java:32)\n");
        throw runtimeException;
    }

    protected void cleanupChildren() {
        if (this.children.isEmpty()) {
            this.children = null;
        }
    }

    public void clear() {
        this.options = null;
        this.name = null;
        this.value = null;
        this.children = null;
        this.qualifier = null;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    public Object clone() {
        Object object;
        block2 : {
            try {
                object = new PropertyOptions(this.getOptions().getOptions());
                break block2;
            }
            catch (XMPException xMPException) {}
            object = new PropertyOptions();
        }
        object = new XMPNode(this.name, this.value, (PropertyOptions)object);
        this.cloneSubtree((XMPNode)object);
        return object;
    }

    public void cloneSubtree(XMPNode xMPNode) {
        try {
            Iterator iterator = this.iterateChildren();
            while (iterator.hasNext()) {
                xMPNode.addChild((XMPNode)((XMPNode)iterator.next()).clone());
            }
            iterator = this.iterateQualifier();
            while (iterator.hasNext()) {
                xMPNode.addQualifier((XMPNode)((XMPNode)iterator.next()).clone());
            }
            return;
        }
        catch (XMPException xMPException) {
            return;
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    public int compareTo(Object object) {
        String string2;
        if (this.getOptions().isSchemaNode()) {
            String string3 = this.value;
            string2 = ((XMPNode)object).getValue();
            object = string3;
            do {
                return object.compareTo(string2);
                break;
            } while (true);
        }
        string2 = this.name;
        String string4 = ((XMPNode)object).getName();
        object = string2;
        string2 = string4;
        return object.compareTo(string2);
    }

    public String dumpNode(boolean bl2) {
        StringBuffer stringBuffer = new StringBuffer(512);
        this.dumpNode(stringBuffer, bl2, 0, 0);
        return stringBuffer.toString();
    }

    public XMPNode findChildByName(String string2) {
        return this.find(this.getChildren(), string2);
    }

    public XMPNode findQualifierByName(String string2) {
        return this.find(this.qualifier, string2);
    }

    public XMPNode getChild(int n2) {
        return (XMPNode)this.getChildren().get(n2 - 1);
    }

    public int getChildrenLength() {
        if (this.children != null) {
            return this.children.size();
        }
        return 0;
    }

    public boolean getHasAliases() {
        return this.hasAliases;
    }

    public boolean getHasValueChild() {
        return this.hasValueChild;
    }

    public String getName() {
        return this.name;
    }

    public PropertyOptions getOptions() {
        if (this.options == null) {
            this.options = new PropertyOptions();
        }
        return this.options;
    }

    public XMPNode getParent() {
        return this.parent;
    }

    public XMPNode getQualifier(int n2) {
        return (XMPNode)this.getQualifier().get(n2 - 1);
    }

    public int getQualifierLength() {
        if (this.qualifier != null) {
            return this.qualifier.size();
        }
        return 0;
    }

    public List getUnmodifiableChildren() {
        return Collections.unmodifiableList(new ArrayList(this.getChildren()));
    }

    public String getValue() {
        return this.value;
    }

    public boolean hasChildren() {
        if (this.children != null && this.children.size() > 0) {
            return true;
        }
        return false;
    }

    public boolean hasQualifier() {
        if (this.qualifier != null && this.qualifier.size() > 0) {
            return true;
        }
        return false;
    }

    public boolean isAlias() {
        return this.alias;
    }

    public boolean isImplicit() {
        return this.implicit;
    }

    public Iterator iterateChildren() {
        if (this.children != null) {
            return this.getChildren().iterator();
        }
        return Collections.EMPTY_LIST.listIterator();
    }

    public Iterator iterateQualifier() {
        if (this.qualifier != null) {
            return new Iterator(this.getQualifier().iterator()){
                final /* synthetic */ Iterator val$it;
                {
                    this.val$it = iterator;
                }

                @Override
                public boolean hasNext() {
                    return this.val$it.hasNext();
                }

                public Object next() {
                    return this.val$it.next();
                }

                @Override
                public void remove() {
                    throw new UnsupportedOperationException("remove() is not allowed due to the internal contraints");
                }
            };
        }
        return Collections.EMPTY_LIST.iterator();
    }

    public void removeChild(int n2) {
        this.getChildren().remove(n2 - 1);
        this.cleanupChildren();
    }

    public void removeChild(XMPNode xMPNode) {
        this.getChildren().remove(xMPNode);
        this.cleanupChildren();
    }

    public void removeChildren() {
        this.children = null;
    }

    public void removeQualifier(XMPNode xMPNode) {
        PropertyOptions propertyOptions = this.getOptions();
        if (xMPNode.isLanguageNode()) {
            propertyOptions.setHasLanguage(false);
        } else if (xMPNode.isTypeNode()) {
            propertyOptions.setHasType(false);
        }
        this.getQualifier().remove(xMPNode);
        if (this.qualifier.isEmpty()) {
            propertyOptions.setHasQualifiers(false);
            this.qualifier = null;
        }
    }

    public void removeQualifiers() {
        PropertyOptions propertyOptions = this.getOptions();
        propertyOptions.setHasQualifiers(false);
        propertyOptions.setHasLanguage(false);
        propertyOptions.setHasType(false);
        this.qualifier = null;
    }

    public void replaceChild(int n2, XMPNode xMPNode) {
        xMPNode.setParent(this);
        this.getChildren().set(n2 - 1, xMPNode);
    }

    public void setAlias(boolean bl2) {
        this.alias = bl2;
    }

    public void setHasAliases(boolean bl2) {
        this.hasAliases = bl2;
    }

    public void setHasValueChild(boolean bl2) {
        this.hasValueChild = bl2;
    }

    public void setImplicit(boolean bl2) {
        this.implicit = bl2;
    }

    public void setName(String string2) {
        this.name = string2;
    }

    public void setOptions(PropertyOptions propertyOptions) {
        this.options = propertyOptions;
    }

    protected void setParent(XMPNode xMPNode) {
        this.parent = xMPNode;
    }

    public void setValue(String string2) {
        this.value = string2;
    }

    public void sort() {
        Object object;
        if (this.hasQualifier()) {
            int n2;
            object = this.getQualifier().toArray(new XMPNode[this.getQualifierLength()]);
            int n3 = 0;
            for (n2 = 0; ((Object)object).length > n2 && ("xml:lang".equals(object[n2].getName()) || "rdf:type".equals(object[n2].getName())); ++n2) {
                object[n2].sort();
            }
            Arrays.sort((Object[])object, n2, ((Object)object).length);
            ListIterator<Object> listIterator = this.qualifier.listIterator();
            for (n2 = n3; n2 < ((Object)object).length; ++n2) {
                listIterator.next();
                listIterator.set(object[n2]);
                object[n2].sort();
            }
        }
        if (this.hasChildren()) {
            if (!this.getOptions().isArray()) {
                Collections.sort(this.children);
            }
            object = this.iterateChildren();
            while (object.hasNext()) {
                ((XMPNode)object.next()).sort();
            }
        }
    }

}

