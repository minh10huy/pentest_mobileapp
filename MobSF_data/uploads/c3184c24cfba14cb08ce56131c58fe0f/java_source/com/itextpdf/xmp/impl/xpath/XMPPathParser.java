/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl.xpath;

import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.impl.Utils;
import com.itextpdf.xmp.impl.xpath.PathPosition;
import com.itextpdf.xmp.impl.xpath.XMPPath;
import com.itextpdf.xmp.impl.xpath.XMPPathSegment;
import com.itextpdf.xmp.options.AliasOptions;
import com.itextpdf.xmp.properties.XMPAliasInfo;

public final class XMPPathParser {
    private XMPPathParser() {
    }

    /*
     * Enabled aggressive block sorting
     */
    public static XMPPath expandXPath(String object, String string2) {
        if (object == null || string2 == null) {
            throw new XMPException("Parameter must not be null", 4);
        }
        XMPPath xMPPath = new XMPPath();
        PathPosition pathPosition = new PathPosition();
        pathPosition.path = string2;
        XMPPathParser.parseRootNode((String)object, pathPosition, xMPPath);
        do {
            block14 : {
                block13 : {
                    StringBuilder stringBuilder;
                    block12 : {
                        if (pathPosition.stepEnd >= string2.length()) {
                            return xMPPath;
                        }
                        pathPosition.stepBegin = pathPosition.stepEnd;
                        XMPPathParser.skipPathDelimiter(string2, pathPosition);
                        pathPosition.stepEnd = pathPosition.stepBegin;
                        object = string2.charAt(pathPosition.stepBegin) != '[' ? XMPPathParser.parseStructSegment(pathPosition) : XMPPathParser.parseIndexSegment(pathPosition);
                        if (object.getKind() != 1) break block12;
                        if (object.getName().charAt(0) == '@') {
                            stringBuilder = new StringBuilder();
                            stringBuilder.append("?");
                            stringBuilder.append(object.getName().substring(1));
                            object.setName(stringBuilder.toString());
                            if (!"?xml:lang".equals(object.getName())) {
                                throw new XMPException("Only xml:lang allowed with '@'", 102);
                            }
                        }
                        if (object.getName().charAt(0) == '?') {
                            ++pathPosition.nameStart;
                            object.setKind(2);
                        }
                        break block13;
                    }
                    if (object.getKind() != 6) break block14;
                    if (object.getName().charAt(1) == '@') {
                        stringBuilder = new StringBuilder();
                        stringBuilder.append("[?");
                        stringBuilder.append(object.getName().substring(2));
                        object.setName(stringBuilder.toString());
                        if (!object.getName().startsWith("[?xml:lang=")) {
                            throw new XMPException("Only xml:lang allowed with '@'", 102);
                        }
                    }
                    if (object.getName().charAt(1) != '?') break block14;
                    ++pathPosition.nameStart;
                    object.setKind(5);
                }
                XMPPathParser.verifyQualName(pathPosition.path.substring(pathPosition.nameStart, pathPosition.nameEnd));
            }
            xMPPath.add((XMPPathSegment)object);
        } while (true);
    }

    private static XMPPathSegment parseIndexSegment(PathPosition pathPosition) {
        block10 : {
            block13 : {
                XMPPathSegment xMPPathSegment;
                block9 : {
                    block11 : {
                        block12 : {
                            block8 : {
                                ++pathPosition.stepEnd;
                                if ('0' > pathPosition.path.charAt(pathPosition.stepEnd) || pathPosition.path.charAt(pathPosition.stepEnd) > '9') break block8;
                                while (pathPosition.stepEnd < pathPosition.path.length() && '0' <= pathPosition.path.charAt(pathPosition.stepEnd) && pathPosition.path.charAt(pathPosition.stepEnd) <= '9') {
                                    ++pathPosition.stepEnd;
                                }
                                xMPPathSegment = new XMPPathSegment(null, 3);
                                break block9;
                            }
                            while (pathPosition.stepEnd < pathPosition.path.length() && pathPosition.path.charAt(pathPosition.stepEnd) != ']' && pathPosition.path.charAt(pathPosition.stepEnd) != '=') {
                                ++pathPosition.stepEnd;
                            }
                            if (pathPosition.stepEnd >= pathPosition.path.length()) break block10;
                            if (pathPosition.path.charAt(pathPosition.stepEnd) != ']') break block11;
                            if (!"[last()".equals(pathPosition.path.substring(pathPosition.stepBegin, pathPosition.stepEnd))) break block12;
                            xMPPathSegment = new XMPPathSegment(null, 4);
                            break block9;
                        }
                        throw new XMPException("Invalid non-numeric array index", 102);
                    }
                    pathPosition.nameStart = pathPosition.stepBegin + 1;
                    pathPosition.nameEnd = pathPosition.stepEnd++;
                    char c2 = pathPosition.path.charAt(pathPosition.stepEnd);
                    if (c2 != '\'' && c2 != '\"') {
                        throw new XMPException("Invalid quote in array selector", 102);
                    }
                    do {
                        ++pathPosition.stepEnd;
                        if (pathPosition.stepEnd >= pathPosition.path.length()) break;
                        if (pathPosition.path.charAt(pathPosition.stepEnd) != c2) continue;
                        if (pathPosition.stepEnd + 1 >= pathPosition.path.length() || pathPosition.path.charAt(pathPosition.stepEnd + 1) != c2) break;
                        ++pathPosition.stepEnd;
                    } while (true);
                    if (pathPosition.stepEnd >= pathPosition.path.length()) break block13;
                    ++pathPosition.stepEnd;
                    xMPPathSegment = new XMPPathSegment(null, 6);
                }
                if (pathPosition.stepEnd < pathPosition.path.length() && pathPosition.path.charAt(pathPosition.stepEnd) == ']') {
                    ++pathPosition.stepEnd;
                    xMPPathSegment.setName(pathPosition.path.substring(pathPosition.stepBegin, pathPosition.stepEnd));
                    return xMPPathSegment;
                }
                throw new XMPException("Missing ']' for array index", 102);
            }
            throw new XMPException("No terminating quote for array selector", 102);
        }
        throw new XMPException("Missing ']' or '=' for array index", 102);
    }

    /*
     * Enabled aggressive block sorting
     */
    private static void parseRootNode(String object, PathPosition object2, XMPPath xMPPath) {
        while (object2.stepEnd < object2.path.length() && "/[*".indexOf(object2.path.charAt(object2.stepEnd)) < 0) {
            ++object2.stepEnd;
        }
        if (object2.stepEnd == object2.stepBegin) {
            throw new XMPException("Empty initial XMPPath step", 102);
        }
        String string2 = XMPPathParser.verifyXPathRoot((String)object, object2.path.substring(object2.stepBegin, object2.stepEnd));
        object2 = XMPMetaFactory.getSchemaRegistry().findAlias(string2);
        if (object2 == null) {
            xMPPath.add(new XMPPathSegment((String)object, Integer.MIN_VALUE));
            object = new XMPPathSegment(string2, 1);
        } else {
            xMPPath.add(new XMPPathSegment(object2.getNamespace(), Integer.MIN_VALUE));
            object = new XMPPathSegment(XMPPathParser.verifyXPathRoot(object2.getNamespace(), object2.getPropName()), 1);
            object.setAlias(true);
            object.setAliasForm(object2.getAliasForm().getOptions());
            xMPPath.add((XMPPathSegment)object);
            if (object2.getAliasForm().isArrayAltText()) {
                object = new XMPPathSegment("[?xml:lang='x-default']", 5);
            } else {
                if (!object2.getAliasForm().isArray()) {
                    return;
                }
                object = new XMPPathSegment("[1]", 3);
            }
            object.setAlias(true);
            object.setAliasForm(object2.getAliasForm().getOptions());
        }
        xMPPath.add((XMPPathSegment)object);
    }

    private static XMPPathSegment parseStructSegment(PathPosition pathPosition) {
        pathPosition.nameStart = pathPosition.stepBegin;
        while (pathPosition.stepEnd < pathPosition.path.length() && "/[*".indexOf(pathPosition.path.charAt(pathPosition.stepEnd)) < 0) {
            ++pathPosition.stepEnd;
        }
        pathPosition.nameEnd = pathPosition.stepEnd;
        if (pathPosition.stepEnd != pathPosition.stepBegin) {
            return new XMPPathSegment(pathPosition.path.substring(pathPosition.stepBegin, pathPosition.stepEnd), 1);
        }
        throw new XMPException("Empty XMPPath segment", 102);
    }

    private static void skipPathDelimiter(String string2, PathPosition pathPosition) {
        if (string2.charAt(pathPosition.stepBegin) == '/') {
            ++pathPosition.stepBegin;
            if (pathPosition.stepBegin >= string2.length()) {
                throw new XMPException("Empty XMPPath segment", 102);
            }
        }
        if (string2.charAt(pathPosition.stepBegin) == '*') {
            ++pathPosition.stepBegin;
            if (pathPosition.stepBegin < string2.length() && string2.charAt(pathPosition.stepBegin) == '[') {
                return;
            }
            throw new XMPException("Missing '[' after '*'", 102);
        }
    }

    private static void verifyQualName(String string2) {
        int n2 = string2.indexOf(58);
        if (n2 > 0 && Utils.isXMLNameNS(string2 = string2.substring(0, n2))) {
            if (XMPMetaFactory.getSchemaRegistry().getNamespaceURI(string2) != null) {
                return;
            }
            throw new XMPException("Unknown namespace prefix for qualified name", 102);
        }
        throw new XMPException("Ill-formed qualified name", 102);
    }

    private static void verifySimpleXMLName(String string2) {
        if (Utils.isXMLName(string2)) {
            return;
        }
        throw new XMPException("Bad XML name", 102);
    }

    private static String verifyXPathRoot(String charSequence, String string2) {
        if (charSequence != null && charSequence.length() != 0) {
            if (string2.charAt(0) != '?' && string2.charAt(0) != '@') {
                if (string2.indexOf(47) < 0 && string2.indexOf(91) < 0) {
                    String string3 = XMPMetaFactory.getSchemaRegistry().getNamespacePrefix((String)charSequence);
                    if (string3 != null) {
                        int n2 = string2.indexOf(58);
                        if (n2 < 0) {
                            XMPPathParser.verifySimpleXMLName(string2);
                            charSequence = new StringBuilder();
                            charSequence.append(string3);
                            charSequence.append(string2);
                            return charSequence.toString();
                        }
                        XMPPathParser.verifySimpleXMLName(string2.substring(0, n2));
                        XMPPathParser.verifySimpleXMLName(string2.substring(n2));
                        string3 = string2.substring(0, n2 + 1);
                        charSequence = XMPMetaFactory.getSchemaRegistry().getNamespacePrefix((String)charSequence);
                        if (charSequence != null) {
                            if (string3.equals(charSequence)) {
                                return string2;
                            }
                            throw new XMPException("Schema namespace URI and prefix mismatch", 101);
                        }
                        throw new XMPException("Unknown schema namespace prefix", 101);
                    }
                    throw new XMPException("Unregistered schema namespace URI", 101);
                }
                throw new XMPException("Top level name must be simple", 102);
            }
            throw new XMPException("Top level name must not be a qualifier", 102);
        }
        throw new XMPException("Schema namespace URI is required", 101);
    }
}

