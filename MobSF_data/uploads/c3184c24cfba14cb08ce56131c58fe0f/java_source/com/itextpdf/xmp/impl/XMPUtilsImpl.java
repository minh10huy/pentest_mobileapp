/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl;

import com.itextpdf.xmp.XMPConst;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.impl.ParameterAsserts;
import com.itextpdf.xmp.impl.Utils;
import com.itextpdf.xmp.impl.XMPMetaImpl;
import com.itextpdf.xmp.impl.XMPNode;
import com.itextpdf.xmp.impl.XMPNodeUtils;
import com.itextpdf.xmp.impl.xpath.XMPPath;
import com.itextpdf.xmp.impl.xpath.XMPPathParser;
import com.itextpdf.xmp.impl.xpath.XMPPathSegment;
import com.itextpdf.xmp.options.PropertyOptions;
import com.itextpdf.xmp.properties.XMPAliasInfo;
import java.util.Iterator;

public class XMPUtilsImpl
implements XMPConst {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    private static final String COMMAS = ",\uff0c\uff64\ufe50\ufe51\u3001\u060c\u055d";
    private static final String CONTROLS = "\u2028\u2029";
    private static final String QUOTES = "\"\u00ab\u00bb\u301d\u301e\u301f\u2015\u2039\u203a";
    private static final String SEMICOLA = ";\uff1b\ufe54\u061b\u037e";
    private static final String SPACES = " \u3000\u303f";
    private static final int UCK_COMMA = 2;
    private static final int UCK_CONTROL = 5;
    private static final int UCK_NORMAL = 0;
    private static final int UCK_QUOTE = 4;
    private static final int UCK_SEMICOLON = 3;
    private static final int UCK_SPACE = 1;

    private XMPUtilsImpl() {
    }

    public static void appendProperties(XMPMeta object, XMPMeta xMPMeta, boolean bl2, boolean bl3, boolean bl4) {
        ParameterAsserts.assertImplementation((XMPMeta)object);
        ParameterAsserts.assertImplementation(xMPMeta);
        object = (XMPMetaImpl)object;
        xMPMeta = (XMPMetaImpl)xMPMeta;
        Iterator iterator = object.getRoot().iterateChildren();
        while (iterator.hasNext()) {
            XMPNode xMPNode = (XMPNode)iterator.next();
            object = XMPNodeUtils.findSchemaNode(xMPMeta.getRoot(), xMPNode.getName(), false);
            boolean bl5 = true;
            if (object == null) {
                object = new XMPNode(xMPNode.getName(), xMPNode.getValue(), new PropertyOptions().setSchemaNode(true));
                xMPMeta.getRoot().addChild((XMPNode)object);
            } else {
                bl5 = false;
            }
            Iterator iterator2 = xMPNode.iterateChildren();
            while (iterator2.hasNext()) {
                XMPNode xMPNode2 = (XMPNode)iterator2.next();
                if (!bl2 && Utils.isInternalProperty(xMPNode.getName(), xMPNode2.getName())) continue;
                XMPUtilsImpl.appendSubtree((XMPMetaImpl)xMPMeta, xMPNode2, (XMPNode)object, bl3, bl4);
            }
            if (object.hasChildren() || !bl5 && !bl4) continue;
            xMPMeta.getRoot().removeChild((XMPNode)object);
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    private static void appendSubtree(XMPMetaImpl object, XMPNode object2, XMPNode xMPNode, boolean bl2, boolean bl3) {
        int n2;
        XMPNode xMPNode2;
        block19 : {
            block18 : {
                xMPNode2 = XMPNodeUtils.findChildNode(xMPNode, object2.getName(), false);
                n2 = bl3 && (object2.getOptions().isSimple() ? object2.getValue() == null || object2.getValue().length() == 0 : !object2.hasChildren()) ? 1 : 0;
                if (bl3 && n2 != 0) {
                    if (xMPNode2 == null) return;
                    {
                        xMPNode.removeChild(xMPNode2);
                        return;
                    }
                }
                if (xMPNode2 == null) break block18;
                if (!bl2) break block19;
                object.setNode(xMPNode2, object2.getValue(), object2.getOptions(), true);
                xMPNode.removeChild(xMPNode2);
            }
            xMPNode.addChild((XMPNode)object2.clone());
            return;
        }
        Object object3 = object2.getOptions();
        if (object3 != xMPNode2.getOptions()) {
            return;
        }
        if (object3.isStruct()) {
            object2 = object2.iterateChildren();
            while (object2.hasNext()) {
                XMPUtilsImpl.appendSubtree((XMPMetaImpl)object, (XMPNode)object2.next(), xMPNode2, bl2, bl3);
                if (!bl3 || xMPNode2.hasChildren()) continue;
                xMPNode.removeChild(xMPNode2);
            }
            return;
        }
        if (!object3.isArrayAltText()) {
            if (!object3.isArray()) return;
            object2 = object2.iterateChildren();
            object = xMPNode2;
        } else {
            object = object2.iterateChildren();
            while (object.hasNext()) {
                object2 = (XMPNode)object.next();
                if (!object2.hasQualifier() || !"xml:lang".equals(object2.getQualifier(1).getName())) continue;
                n2 = XMPNodeUtils.lookupLanguageItem(xMPNode2, object2.getQualifier(1).getValue());
                if (bl3 && (object2.getValue() == null || object2.getValue().length() == 0)) {
                    if (n2 == -1) continue;
                    xMPNode2.removeChild(n2);
                    if (xMPNode2.hasChildren()) continue;
                    xMPNode.removeChild(xMPNode2);
                    continue;
                }
                if (n2 != -1) continue;
                if ("x-default".equals(object2.getQualifier(1).getValue()) && xMPNode2.hasChildren()) {
                    object3 = new XMPNode(object2.getName(), object2.getValue(), object2.getOptions());
                    object2.cloneSubtree((XMPNode)object3);
                    xMPNode2.addChild(1, (XMPNode)object3);
                    continue;
                }
                object2.cloneSubtree(xMPNode2);
            }
            return;
        }
        while (object2.hasNext()) {
            xMPNode2 = (XMPNode)object2.next();
            object3 = object.iterateChildren();
            n2 = 0;
            while (object3.hasNext()) {
                if (!XMPUtilsImpl.itemValuesMatch(xMPNode2, (XMPNode)object3.next())) continue;
                n2 = 1;
            }
            object = (XMPNode)xMPNode2.clone();
            xMPNode.addChild((XMPNode)object);
        }
    }

    private static String applyQuotes(String charSequence, char c2, char c3, boolean bl2) {
        int n2;
        String string2 = charSequence;
        if (charSequence == null) {
            string2 = "";
        }
        int n3 = 0;
        for (n2 = 0; n2 < string2.length(); ++n2) {
            int n4 = XMPUtilsImpl.classifyCharacter(string2.charAt(n2));
            if (n2 == 0 && n4 == 4) break;
            if (n4 == 1) {
                if (n3 != 0) break;
                n3 = 1;
                continue;
            }
            if (n4 == 3 || n4 == 5 || n4 == 2 && !bl2) break;
            n3 = 0;
        }
        charSequence = string2;
        if (n2 < string2.length()) {
            charSequence = new StringBuffer(string2.length() + 2);
            for (n3 = 0; n3 <= n2 && XMPUtilsImpl.classifyCharacter(string2.charAt(n2)) != 4; ++n3) {
            }
            charSequence.append(c2);
            charSequence.append(string2.substring(0, n3));
            while (n3 < string2.length()) {
                charSequence.append(string2.charAt(n3));
                if (XMPUtilsImpl.classifyCharacter(string2.charAt(n3)) == 4 && XMPUtilsImpl.isSurroundingQuote(string2.charAt(n3), c2, c3)) {
                    charSequence.append(string2.charAt(n3));
                }
                ++n3;
            }
            charSequence.append(c3);
            charSequence = charSequence.toString();
        }
        return charSequence;
    }

    public static String catenateArrayItems(XMPMeta object, String object2, String object3, String string2, String string3, boolean bl2) {
        String string4;
        block13 : {
            block12 : {
                block11 : {
                    block10 : {
                        ParameterAsserts.assertSchemaNS((String)object2);
                        ParameterAsserts.assertArrayName((String)object3);
                        ParameterAsserts.assertImplementation((XMPMeta)object);
                        if (string2 == null) break block10;
                        string4 = string2;
                        if (string2.length() != 0) break block11;
                    }
                    string4 = "; ";
                }
                if (string3 == null) break block12;
                string2 = string3;
                if (string3.length() != 0) break block13;
            }
            string2 = "\"";
        }
        object = (XMPMetaImpl)object;
        object2 = XMPPathParser.expandXPath((String)object2, (String)object3);
        object2 = XMPNodeUtils.findNode(object.getRoot(), (XMPPath)object2, false, null);
        if (object2 == null) {
            return "";
        }
        if (object2.getOptions().isArray() && !object2.getOptions().isArrayAlternate()) {
            XMPUtilsImpl.checkSeparator(string4);
            char c2 = string2.charAt(0);
            char c3 = XMPUtilsImpl.checkQuotes(string2, c2);
            object = new StringBuffer();
            object2 = object2.iterateChildren();
            while (object2.hasNext()) {
                object3 = (XMPNode)object2.next();
                if (!object3.getOptions().isCompositeProperty()) {
                    object.append(XMPUtilsImpl.applyQuotes(object3.getValue(), c2, c3, bl2));
                    if (!object2.hasNext()) continue;
                    object.append(string4);
                    continue;
                }
                throw new XMPException("Array items must be simple", 4);
            }
            return object.toString();
        }
        throw new XMPException("Named property must be non-alternate array", 4);
    }

    private static char checkQuotes(String string2, char c2) {
        block4 : {
            block7 : {
                char c3;
                block6 : {
                    block5 : {
                        if (XMPUtilsImpl.classifyCharacter(c2) != 4) break block4;
                        if (string2.length() != 1) break block5;
                        c3 = c2;
                        break block6;
                    }
                    c3 = string2.charAt(1);
                    if (XMPUtilsImpl.classifyCharacter(c3) != 4) break block7;
                }
                if (c3 == XMPUtilsImpl.getClosingQuote(c2)) {
                    return c3;
                }
                throw new XMPException("Mismatched quote pair", 4);
            }
            throw new XMPException("Invalid quoting character", 4);
        }
        throw new XMPException("Invalid quoting character", 4);
    }

    private static void checkSeparator(String string2) {
        boolean bl2 = false;
        for (int i2 = 0; i2 < string2.length(); ++i2) {
            int n2 = XMPUtilsImpl.classifyCharacter(string2.charAt(i2));
            if (n2 == 3) {
                if (!bl2) {
                    bl2 = true;
                    continue;
                }
                throw new XMPException("Separator can have only one semicolon", 4);
            }
            if (n2 == 1) {
                continue;
            }
            throw new XMPException("Separator can have only spaces and one semicolon", 4);
        }
        if (bl2) {
            return;
        }
        throw new XMPException("Separator must have one semicolon", 4);
    }

    private static int classifyCharacter(char c2) {
        if (SPACES.indexOf(c2) < 0 && ('\u2000' > c2 || c2 > '\u200b')) {
            if (COMMAS.indexOf(c2) >= 0) {
                return 2;
            }
            if (SEMICOLA.indexOf(c2) >= 0) {
                return 3;
            }
            if (!(QUOTES.indexOf(c2) >= 0 || '\u3008' <= c2 && c2 <= '\u300f' || '\u2018' <= c2 && c2 <= '\u201f')) {
                if (c2 >= ' ' && CONTROLS.indexOf(c2) < 0) {
                    return 0;
                }
                return 5;
            }
            return 4;
        }
        return 1;
    }

    private static char getClosingQuote(char c2) {
        switch (c2) {
            default: {
                return '\u0000';
            }
            case '\u301d': {
                return '\u301f';
            }
            case '\u300e': {
                return '\u300f';
            }
            case '\u300c': {
                return '\u300d';
            }
            case '\u300a': {
                return '\u300b';
            }
            case '\u3008': {
                return '\u3009';
            }
            case '\u203a': {
                return '\u2039';
            }
            case '\u2039': {
                return '\u203a';
            }
            case '\u201e': {
                return '\u201f';
            }
            case '\u201c': {
                return '\u201d';
            }
            case '\u201a': {
                return '\u201b';
            }
            case '\u2018': {
                return '\u2019';
            }
            case '\u2015': {
                return '\u2015';
            }
            case '\u00bb': {
                return '\u00ab';
            }
            case '\u00ab': {
                return '\u00bb';
            }
            case '\"': 
        }
        return '\"';
    }

    private static boolean isClosingingQuote(char c2, char c3, char c4) {
        if (c2 != c4 && (c3 != '\u301d' || c2 != '\u301e') && c2 != '\u301f') {
            return false;
        }
        return true;
    }

    private static boolean isSurroundingQuote(char c2, char c3, char c4) {
        if (c2 != c3 && !XMPUtilsImpl.isClosingingQuote(c2, c3, c4)) {
            return false;
        }
        return true;
    }

    private static boolean itemValuesMatch(XMPNode object, XMPNode xMPNode) {
        Object object2 = object.getOptions();
        if (object2.equals(xMPNode.getOptions())) {
            return false;
        }
        if (object2.getOptions() == 0) {
            if (!object.getValue().equals(xMPNode.getValue())) {
                return false;
            }
            if (object.getOptions().getHasLanguage() != xMPNode.getOptions().getHasLanguage()) {
                return false;
            }
            if (object.getOptions().getHasLanguage() && !object.getQualifier(1).getValue().equals(xMPNode.getQualifier(1).getValue())) {
                return false;
            }
        } else if (object2.isStruct()) {
            if (object.getChildrenLength() != xMPNode.getChildrenLength()) {
                return false;
            }
            object = object.iterateChildren();
            while (object.hasNext()) {
                object2 = (XMPNode)object.next();
                XMPNode xMPNode2 = XMPNodeUtils.findChildNode(xMPNode, object2.getName(), false);
                if (xMPNode2 != null && XMPUtilsImpl.itemValuesMatch((XMPNode)object2, xMPNode2)) continue;
                return false;
            }
        } else {
            object = object.iterateChildren();
            while (object.hasNext()) {
                boolean bl2;
                block12 : {
                    object2 = (XMPNode)object.next();
                    Iterator iterator = xMPNode.iterateChildren();
                    while (iterator.hasNext()) {
                        if (!XMPUtilsImpl.itemValuesMatch((XMPNode)object2, (XMPNode)iterator.next())) continue;
                        bl2 = true;
                        break block12;
                    }
                    bl2 = false;
                }
                if (bl2) continue;
                return false;
            }
        }
        return true;
    }

    public static void removeProperties(XMPMeta object, String object2, String object3, boolean bl2, boolean bl3) {
        block7 : {
            block8 : {
                block5 : {
                    block6 : {
                        ParameterAsserts.assertImplementation((XMPMeta)object);
                        object = (XMPMetaImpl)object;
                        if (object3 == null || object3.length() <= 0) break block5;
                        if (object2 == null || object2.length() == 0) break block6;
                        object2 = XMPPathParser.expandXPath((String)object2, (String)object3);
                        if ((object = XMPNodeUtils.findNode(object.getRoot(), (XMPPath)object2, false, null)) != null && (bl2 || !Utils.isInternalProperty(object2.getSegment(0).getName(), object2.getSegment(1).getName()))) {
                            object2 = object.getParent();
                            object2.removeChild((XMPNode)object);
                            if (object2.getOptions().isSchemaNode() && !object2.hasChildren()) {
                                object2.getParent().removeChild((XMPNode)object2);
                                return;
                            }
                        }
                        break block7;
                    }
                    throw new XMPException("Property name requires schema namespace", 4);
                }
                if (object2 == null || object2.length() <= 0) break block8;
                object3 = XMPNodeUtils.findSchemaNode(object.getRoot(), (String)object2, false);
                if (object3 != null && XMPUtilsImpl.removeSchemaChildren((XMPNode)object3, bl2)) {
                    object.getRoot().removeChild((XMPNode)object3);
                }
                if (!bl3) break block7;
                object2 = XMPMetaFactory.getSchemaRegistry().findAliases((String)object2);
                for (int i2 = 0; i2 < ((XMPAliasInfo[])object2).length; ++i2) {
                    object3 = object2[i2];
                    object3 = XMPPathParser.expandXPath(object3.getNamespace(), object3.getPropName());
                    object3 = XMPNodeUtils.findNode(object.getRoot(), (XMPPath)object3, false, null);
                    if (object3 == null) continue;
                    object3.getParent().removeChild((XMPNode)object3);
                }
                break block7;
            }
            object = object.getRoot().iterateChildren();
            while (object.hasNext()) {
                if (!XMPUtilsImpl.removeSchemaChildren((XMPNode)object.next(), bl2)) continue;
                object.remove();
            }
        }
    }

    private static boolean removeSchemaChildren(XMPNode xMPNode, boolean bl2) {
        Iterator iterator = xMPNode.iterateChildren();
        while (iterator.hasNext()) {
            XMPNode xMPNode2 = (XMPNode)iterator.next();
            if (!bl2 && Utils.isInternalProperty(xMPNode.getName(), xMPNode2.getName())) continue;
            iterator.remove();
        }
        return xMPNode.hasChildren() ^ true;
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    public static void separateArrayItems(XMPMeta var0, String var1_1, String var2_2, String var3_3, PropertyOptions var4_4, boolean var5_5) {
        ParameterAsserts.assertSchemaNS((String)var1_1);
        ParameterAsserts.assertArrayName((String)var2_2);
        if (var3_3 == null) throw new XMPException("Parameter must not be null", 4);
        ParameterAsserts.assertImplementation((XMPMeta)var0);
        var2_2 = XMPUtilsImpl.separateFindCreateArray((String)var1_1, (String)var2_2, var4_4, (XMPMetaImpl)var0);
        var15_6 = var3_3.length();
        var12_7 = 0;
        var13_8 = 0;
        var7_9 = '\u0000';
        while (var12_7 < var15_6) {
            block20 : {
                block19 : {
                    block21 : {
                        var10_13 = var13_8;
                        var6_10 = var7_9;
                        for (var11_14 = var12_7; var11_14 < var15_6; ++var11_14) {
                            var7_9 = var3_3.charAt(var11_14);
                            var12_7 = XMPUtilsImpl.classifyCharacter(var7_9);
                            var6_10 = var7_9;
                            var10_13 = var12_7;
                            if (var12_7 == 0) break;
                            if (var12_7 == 4) {
                                var6_10 = var7_9;
                                var10_13 = var12_7;
                                break;
                            }
                            var6_10 = var7_9;
                            var10_13 = var12_7;
                        }
                        if (var11_14 >= var15_6) {
                            return;
                        }
                        var14_15 = 1;
                        if (var10_13 == 4) break block21;
                        var12_7 = var10_13;
                        for (var10_13 = var11_14; var10_13 < var15_6; ++var10_13) {
                            var7_9 = var3_3.charAt(var10_13);
                            var13_8 = XMPUtilsImpl.classifyCharacter(var7_9);
                            var6_10 = var7_9;
                            if (var13_8 != 0) {
                                var6_10 = var7_9;
                                if (var13_8 != 4) {
                                    if (var13_8 == 2 && var5_5) {
                                        var6_10 = var7_9;
                                    } else {
                                        if (var13_8 != 1) {
                                            var12_7 = var13_8;
                                            var6_10 = var7_9;
                                            break;
                                        }
                                        var16_16 = var10_13 + 1;
                                        var12_7 = var13_8;
                                        var6_10 = var7_9;
                                        if (var16_16 >= var15_6) break;
                                        var7_9 = var3_3.charAt(var16_16);
                                        var16_16 = XMPUtilsImpl.classifyCharacter(var7_9);
                                        var6_10 = var7_9;
                                        if (var16_16 != 0) {
                                            var6_10 = var7_9;
                                            if (var16_16 != 4) {
                                                var12_7 = var13_8;
                                                var6_10 = var7_9;
                                                if (var16_16 != 2) break;
                                                var12_7 = var13_8;
                                                var6_10 = var7_9;
                                                if (!var5_5) break;
                                                var6_10 = var7_9;
                                            }
                                        }
                                    }
                                }
                            }
                            var12_7 = var13_8;
                        }
                        var0 = var3_3.substring(var11_14, var10_13);
                        var11_14 = var12_7;
                        break block19;
                    }
                    var8_11 = XMPUtilsImpl.getClosingQuote(var6_10);
                    var12_7 = var11_14 + 1;
                    var0 = "";
                    var7_9 = var6_10;
                    var11_14 = var10_13;
                    for (var10_13 = var12_7; var10_13 < var15_6; ++var10_13) {
                        var7_9 = var3_3.charAt(var10_13);
                        var11_14 = XMPUtilsImpl.classifyCharacter(var7_9);
                        if (var11_14 != 4 || !XMPUtilsImpl.isSurroundingQuote(var7_9, var6_10, var8_11)) ** GOTO lbl97
                        var12_7 = var10_13 + 1;
                        if (var12_7 < var15_6) {
                            var9_12 = var3_3.charAt(var12_7);
                            XMPUtilsImpl.classifyCharacter(var9_12);
                            var13_8 = var9_12;
                        } else {
                            var13_8 = 59;
                        }
                        if (var7_9 == var13_8) {
                            var1_1 = new StringBuilder();
                            var1_1.append((String)var0);
                            var1_1.append(var7_9);
                            var0 = var1_1.toString();
                            var10_13 = var12_7;
                            continue;
                        }
                        if (!XMPUtilsImpl.isClosingingQuote(var7_9, var6_10, var8_11)) {
                            var1_1 = new StringBuilder();
                        } else {
                            var6_10 = var7_9;
                            var10_13 = var12_7;
                            break block19;
lbl97: // 1 sources:
                            var1_1 = new StringBuilder();
                        }
                        var1_1.append((String)var0);
                        var1_1.append(var7_9);
                        var0 = var1_1.toString();
                    }
                    var6_10 = var7_9;
                }
                for (var12_7 = var14_15; var12_7 <= var2_2.getChildrenLength(); ++var12_7) {
                    if (!var0.equals(var2_2.getChild(var12_7).getValue())) continue;
                    var14_15 = var12_7;
                    break block20;
                }
                var14_15 = -1;
            }
            var7_9 = var6_10;
            var12_7 = var10_13;
            var13_8 = var11_14;
            if (var14_15 >= 0) continue;
            var2_2.addChild(new XMPNode("[]", (String)var0, null));
            var7_9 = var6_10;
            var12_7 = var10_13;
            var13_8 = var11_14;
        }
    }

    private static XMPNode separateFindCreateArray(String object, String object2, PropertyOptions propertyOptions, XMPMetaImpl xMPMetaImpl) {
        if ((propertyOptions = XMPNodeUtils.verifySetOptions(propertyOptions, null)).isOnlyArrayOptions()) {
            object2 = XMPPathParser.expandXPath((String)object, (String)object2);
            object = XMPNodeUtils.findNode(xMPMetaImpl.getRoot(), (XMPPath)object2, false, null);
            if (object != null) {
                object2 = object.getOptions();
                if (object2.isArray() && !object2.isArrayAlternate()) {
                    if (!propertyOptions.equalArrayTypes((PropertyOptions)object2)) {
                        return object;
                    }
                    throw new XMPException("Mismatch of specified and existing array form", 102);
                }
                throw new XMPException("Named property must be non-alternate array", 102);
            }
            object = XMPNodeUtils.findNode(xMPMetaImpl.getRoot(), (XMPPath)object2, true, propertyOptions.setArray(true));
            if (object != null) {
                return object;
            }
            throw new XMPException("Failed to create named array", 102);
        }
        throw new XMPException("Options can only provide array form", 103);
    }
}

