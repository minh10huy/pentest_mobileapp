/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl;

import com.itextpdf.xmp.XMPConst;
import com.itextpdf.xmp.XMPDateTime;
import com.itextpdf.xmp.XMPDateTimeFactory;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.XMPUtils;
import com.itextpdf.xmp.impl.Utils;
import com.itextpdf.xmp.impl.XMPNode;
import com.itextpdf.xmp.impl.xpath.XMPPath;
import com.itextpdf.xmp.impl.xpath.XMPPathSegment;
import com.itextpdf.xmp.options.PropertyOptions;
import java.util.GregorianCalendar;
import java.util.Iterator;

public class XMPNodeUtils
implements XMPConst {
    static final /* synthetic */ boolean $assertionsDisabled = false;
    static final int CLT_FIRST_ITEM = 5;
    static final int CLT_MULTIPLE_GENERIC = 3;
    static final int CLT_NO_VALUES = 0;
    static final int CLT_SINGLE_GENERIC = 2;
    static final int CLT_SPECIFIC_MATCH = 1;
    static final int CLT_XDEFAULT = 4;

    private XMPNodeUtils() {
    }

    static void appendLangItem(XMPNode xMPNode, String object, String object2) {
        object2 = new XMPNode("[]", (String)object2, null);
        object = new XMPNode("xml:lang", (String)object, null);
        object2.addQualifier((XMPNode)object);
        if (!"x-default".equals(object.getValue())) {
            xMPNode.addChild((XMPNode)object2);
            return;
        }
        xMPNode.addChild(1, (XMPNode)object2);
    }

    static Object[] chooseLocalizedText(XMPNode xMPNode, String string2, String string3) {
        if (xMPNode.getOptions().isArrayAltText()) {
            if (!xMPNode.hasChildren()) {
                return new Object[]{new Integer(0), null};
            }
            Iterator iterator = xMPNode.iterateChildren();
            Object object = null;
            XMPNode xMPNode2 = object;
            int n2 = 0;
            while (iterator.hasNext()) {
                XMPNode xMPNode3 = (XMPNode)iterator.next();
                if (!xMPNode3.getOptions().isCompositeProperty()) {
                    if (xMPNode3.hasQualifier() && "xml:lang".equals(xMPNode3.getQualifier(1).getName())) {
                        Object object2 = xMPNode3.getQualifier(1).getValue();
                        if (string3.equals(object2)) {
                            return new Object[]{new Integer(1), xMPNode3};
                        }
                        if (string2 != null && object2.startsWith(string2)) {
                            object2 = object;
                            if (object == null) {
                                object2 = xMPNode3;
                            }
                            ++n2;
                            object = object2;
                            continue;
                        }
                        if (!"x-default".equals(object2)) continue;
                        xMPNode2 = xMPNode3;
                        continue;
                    }
                    throw new XMPException("Alt-text array item has no language qualifier", 102);
                }
                throw new XMPException("Alt-text array item is not simple", 102);
            }
            if (n2 == 1) {
                return new Object[]{new Integer(2), object};
            }
            if (n2 > 1) {
                return new Object[]{new Integer(3), object};
            }
            if (xMPNode2 != null) {
                return new Object[]{new Integer(4), xMPNode2};
            }
            return new Object[]{new Integer(5), xMPNode.getChild(1)};
        }
        throw new XMPException("Localized text array is not alt-text", 102);
    }

    static void deleteNode(XMPNode xMPNode) {
        XMPNode xMPNode2 = xMPNode.getParent();
        if (xMPNode.getOptions().isQualifier()) {
            xMPNode2.removeQualifier(xMPNode);
        } else {
            xMPNode2.removeChild(xMPNode);
        }
        if (!xMPNode2.hasChildren() && xMPNode2.getOptions().isSchemaNode()) {
            xMPNode2.getParent().removeChild(xMPNode2);
        }
    }

    static void detectAltText(XMPNode xMPNode) {
        if (xMPNode.getOptions().isArrayAlternate() && xMPNode.hasChildren()) {
            boolean bl2;
            block3 : {
                boolean bl3 = false;
                Iterator iterator = xMPNode.iterateChildren();
                do {
                    bl2 = bl3;
                    if (!iterator.hasNext()) break block3;
                } while (!((XMPNode)iterator.next()).getOptions().getHasLanguage());
                bl2 = true;
            }
            if (bl2) {
                xMPNode.getOptions().setArrayAltText(true);
                XMPNodeUtils.normalizeLangArray(xMPNode);
            }
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    static XMPNode findChildNode(XMPNode xMPNode, String string2, boolean bl2) {
        XMPNode xMPNode2;
        if (!xMPNode.getOptions().isSchemaNode() && !xMPNode.getOptions().isStruct()) {
            if (!xMPNode.isImplicit()) throw new XMPException("Named children only allowed for schemas and structs", 102);
            if (xMPNode.getOptions().isArray()) throw new XMPException("Named children not allowed for arrays", 102);
            if (bl2) {
                xMPNode.getOptions().setStruct(true);
            }
        }
        XMPNode xMPNode3 = xMPNode2 = xMPNode.findChildByName(string2);
        if (xMPNode2 != null) return xMPNode3;
        xMPNode3 = xMPNode2;
        if (!bl2) return xMPNode3;
        xMPNode3 = new XMPNode(string2, new PropertyOptions());
        xMPNode3.setImplicit(true);
        xMPNode.addChild(xMPNode3);
        return xMPNode3;
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private static int findIndexedItem(XMPNode xMPNode, String object, boolean bl2) {
        block4 : {
            int n2;
            try {
                n2 = Integer.parseInt(object.substring(1, object.length() - 1));
                if (n2 < 1) break block4;
            }
            catch (NumberFormatException numberFormatException) {
                throw new XMPException("Array index not digits.", 102);
            }
            if (!bl2 || n2 != xMPNode.getChildrenLength() + 1) return n2;
            object = new XMPNode("[]", null);
            object.setImplicit(true);
            xMPNode.addChild((XMPNode)object);
            return n2;
        }
        throw new XMPException("Array index must be larger than zero", 102);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    static XMPNode findNode(XMPNode xMPNode, XMPPath xMPPath, boolean bl2, PropertyOptions propertyOptions) {
        XMPNode xMPNode2;
        if (xMPPath == null || xMPPath.size() == 0) throw new XMPException("Empty XMPPath", 102);
        {
            xMPNode2 = XMPNodeUtils.findSchemaNode(xMPNode, xMPPath.getSegment(0).getName(), bl2);
            if (xMPNode2 == null) {
                return null;
            }
            if (xMPNode2.isImplicit()) {
                xMPNode2.setImplicit(false);
                xMPNode = xMPNode2;
            } else {
                xMPNode = null;
            }
        }
        try {
            for (int i2 = 1; i2 < xMPPath.size(); ++i2) {
                if ((xMPNode2 = XMPNodeUtils.followXPathStep(xMPNode2, xMPPath.getSegment(i2), bl2)) == null) {
                    if (!bl2) return null;
                    {
                        XMPNodeUtils.deleteNode(xMPNode);
                        return null;
                    }
                }
                XMPNode xMPNode3 = xMPNode;
                if (xMPNode2.isImplicit()) {
                    xMPNode2.setImplicit(false);
                    if (i2 == 1 && xMPPath.getSegment(i2).isAlias() && xMPPath.getSegment(i2).getAliasForm() != 0) {
                        xMPNode2.getOptions().setOption(xMPPath.getSegment(i2).getAliasForm(), true);
                    } else if (i2 < xMPPath.size() - 1 && xMPPath.getSegment(i2).getKind() == 1 && !xMPNode2.getOptions().isCompositeProperty()) {
                        xMPNode2.getOptions().setStruct(true);
                    }
                    xMPNode3 = xMPNode;
                    if (xMPNode == null) {
                        xMPNode3 = xMPNode2;
                    }
                }
                xMPNode = xMPNode3;
            }
            if (xMPNode == null) return xMPNode2;
            {
                xMPNode2.getOptions().mergeWith(propertyOptions);
                xMPNode2.setOptions(xMPNode2.getOptions());
            }
            return xMPNode2;
        }
        catch (XMPException xMPException) {
            if (xMPNode == null) throw xMPException;
            {
                XMPNodeUtils.deleteNode(xMPNode);
            }
            throw xMPException;
        }
    }

    private static XMPNode findQualifierNode(XMPNode xMPNode, String string2, boolean bl2) {
        XMPNode xMPNode2;
        XMPNode xMPNode3 = xMPNode2 = xMPNode.findQualifierByName(string2);
        if (xMPNode2 == null) {
            xMPNode3 = xMPNode2;
            if (bl2) {
                xMPNode3 = new XMPNode(string2, null);
                xMPNode3.setImplicit(true);
                xMPNode.addQualifier(xMPNode3);
            }
        }
        return xMPNode3;
    }

    static XMPNode findSchemaNode(XMPNode xMPNode, String string2, String string3, boolean bl2) {
        XMPNode xMPNode2 = xMPNode.findChildByName(string2);
        Object object = xMPNode2;
        if (xMPNode2 == null) {
            object = xMPNode2;
            if (bl2) {
                xMPNode2 = new XMPNode(string2, new PropertyOptions().setSchemaNode(true));
                xMPNode2.setImplicit(true);
                String string4 = XMPMetaFactory.getSchemaRegistry().getNamespacePrefix(string2);
                object = string4;
                if (string4 == null) {
                    if (string3 != null && string3.length() != 0) {
                        object = XMPMetaFactory.getSchemaRegistry().registerNamespace(string2, string3);
                    } else {
                        throw new XMPException("Unregistered schema namespace URI", 101);
                    }
                }
                xMPNode2.setValue((String)object);
                xMPNode.addChild(xMPNode2);
                object = xMPNode2;
            }
        }
        return object;
    }

    static XMPNode findSchemaNode(XMPNode xMPNode, String string2, boolean bl2) {
        return XMPNodeUtils.findSchemaNode(xMPNode, string2, null, bl2);
    }

    private static XMPNode followXPathStep(XMPNode xMPNode, XMPPathSegment arrstring, boolean bl2) {
        block6 : {
            block11 : {
                int n2;
                block8 : {
                    block10 : {
                        block9 : {
                            block7 : {
                                n2 = arrstring.getKind();
                                if (n2 == 1) {
                                    return XMPNodeUtils.findChildNode(xMPNode, arrstring.getName(), bl2);
                                }
                                if (n2 == 2) {
                                    return XMPNodeUtils.findQualifierNode(xMPNode, arrstring.getName().substring(1), bl2);
                                }
                                if (!xMPNode.getOptions().isArray()) break block6;
                                if (n2 != 3) break block7;
                                n2 = XMPNodeUtils.findIndexedItem(xMPNode, arrstring.getName(), bl2);
                                break block8;
                            }
                            if (n2 != 4) break block9;
                            n2 = xMPNode.getChildrenLength();
                            break block8;
                        }
                        if (n2 != 6) break block10;
                        arrstring = Utils.splitNameAndValue(arrstring.getName());
                        n2 = XMPNodeUtils.lookupFieldSelector(xMPNode, arrstring[0], arrstring[1]);
                        break block8;
                    }
                    if (n2 != 5) break block11;
                    String[] arrstring2 = Utils.splitNameAndValue(arrstring.getName());
                    n2 = XMPNodeUtils.lookupQualSelector(xMPNode, arrstring2[0], arrstring2[1], arrstring.getAliasForm());
                }
                if (1 <= n2 && n2 <= xMPNode.getChildrenLength()) {
                    return xMPNode.getChild(n2);
                }
                return null;
            }
            throw new XMPException("Unknown array indexing step in FollowXPathStep", 9);
        }
        throw new XMPException("Indexing applied to non-array", 102);
    }

    private static int lookupFieldSelector(XMPNode xMPNode, String string2, String string3) {
        int n2 = -1;
        for (int i2 = 1; i2 <= xMPNode.getChildrenLength() && n2 < 0; ++i2) {
            XMPNode xMPNode2 = xMPNode.getChild(i2);
            if (xMPNode2.getOptions().isStruct()) {
                int n3;
                int n4 = 1;
                do {
                    n3 = n2;
                    if (n4 > xMPNode2.getChildrenLength()) break;
                    XMPNode xMPNode3 = xMPNode2.getChild(n4);
                    if (string2.equals(xMPNode3.getName()) && string3.equals(xMPNode3.getValue())) {
                        n3 = i2;
                        break;
                    }
                    ++n4;
                } while (true);
                n2 = n3;
                continue;
            }
            throw new XMPException("Field selector must be used on array of struct", 102);
        }
        return n2;
    }

    static int lookupLanguageItem(XMPNode xMPNode, String string2) {
        if (xMPNode.getOptions().isArray()) {
            for (int i2 = 1; i2 <= xMPNode.getChildrenLength(); ++i2) {
                XMPNode xMPNode2 = xMPNode.getChild(i2);
                if (!xMPNode2.hasQualifier() || !"xml:lang".equals(xMPNode2.getQualifier(1).getName()) || !string2.equals(xMPNode2.getQualifier(1).getValue())) continue;
                return i2;
            }
            return -1;
        }
        throw new XMPException("Language item must be used on array", 102);
    }

    private static int lookupQualSelector(XMPNode xMPNode, String object, String string2, int n2) {
        int n3;
        boolean bl2 = "xml:lang".equals(object);
        if (bl2) {
            n3 = XMPNodeUtils.lookupLanguageItem(xMPNode, Utils.normalizeLangValue(string2));
            if (n3 < 0 && (n2 & 4096) > 0) {
                object = new XMPNode("[]", null);
                object.addQualifier(new XMPNode("xml:lang", "x-default", null));
                xMPNode.addChild(1, (XMPNode)object);
                return 1;
            }
            return n3;
        }
        for (n3 = 1; n3 < xMPNode.getChildrenLength(); ++n3) {
            Iterator iterator = xMPNode.getChild(n3).iterateQualifier();
            while (iterator.hasNext()) {
                XMPNode xMPNode2 = (XMPNode)iterator.next();
                if (!object.equals(xMPNode2.getName()) || !string2.equals(xMPNode2.getValue())) continue;
                return n3;
            }
        }
        return -1;
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    static void normalizeLangArray(XMPNode xMPNode) {
        XMPNode xMPNode2;
        int n2;
        block5 : {
            if (!xMPNode.getOptions().isArrayAltText()) {
                return;
            }
            n2 = 2;
            while (n2 <= xMPNode.getChildrenLength()) {
                xMPNode2 = xMPNode.getChild(n2);
                if (xMPNode2.hasQualifier() && "x-default".equals(xMPNode2.getQualifier(1).getValue())) {
                    xMPNode.removeChild(n2);
                    xMPNode.addChild(1, xMPNode2);
                    break block5;
                }
                ++n2;
            }
            return;
            catch (XMPException xMPException) {}
        }
        if (n2 != 2) return;
        xMPNode.getChild(2).setValue(xMPNode2.getValue());
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    static String serializeNodeValue(Object var0) {
        block4 : {
            block8 : {
                block7 : {
                    block6 : {
                        block5 : {
                            block3 : {
                                var1_1 = null;
                                if (var0 == null) {
                                    return var1_1;
                                }
                                if (!(var0 instanceof Boolean)) break block3;
                                var0 = XMPUtils.convertFromBoolean((Boolean)var0);
                                break block4;
                            }
                            if (!(var0 instanceof Integer)) break block5;
                            var0 = XMPUtils.convertFromInteger((Integer)var0);
                            break block4;
                        }
                        if (!(var0 instanceof Long)) break block6;
                        var0 = XMPUtils.convertFromLong((Long)var0);
                        break block4;
                    }
                    if (!(var0 instanceof Double)) break block7;
                    var0 = XMPUtils.convertFromDouble((Double)var0);
                    break block4;
                }
                if (!(var0 instanceof XMPDateTime)) break block8;
                var0 = (XMPDateTime)var0;
                ** GOTO lbl26
            }
            if (var0 instanceof GregorianCalendar) {
                var0 = XMPDateTimeFactory.createFromCalendar((GregorianCalendar)var0);
lbl26: // 2 sources:
                var0 = XMPUtils.convertFromDate((XMPDateTime)var0);
            } else {
                var0 = var0 instanceof byte[] != false ? XMPUtils.encodeBase64((byte[])var0) : var0.toString();
            }
        }
        if (var0 == null) return var1_1;
        return Utils.removeControlChars((String)var0);
    }

    static void setNodeValue(XMPNode xMPNode, Object object) {
        String string2 = XMPNodeUtils.serializeNodeValue(object);
        object = string2;
        if (xMPNode.getOptions().isQualifier()) {
            object = !"xml:lang".equals(xMPNode.getName()) ? string2 : Utils.normalizeLangValue(string2);
        }
        xMPNode.setValue((String)object);
    }

    static PropertyOptions verifySetOptions(PropertyOptions propertyOptions, Object object) {
        PropertyOptions propertyOptions2 = propertyOptions;
        if (propertyOptions == null) {
            propertyOptions2 = new PropertyOptions();
        }
        if (propertyOptions2.isArrayAltText()) {
            propertyOptions2.setArrayAlternate(true);
        }
        if (propertyOptions2.isArrayAlternate()) {
            propertyOptions2.setArrayOrdered(true);
        }
        if (propertyOptions2.isArrayOrdered()) {
            propertyOptions2.setArray(true);
        }
        if (propertyOptions2.isCompositeProperty() && object != null && object.toString().length() > 0) {
            throw new XMPException("Structs and arrays can't have values", 103);
        }
        propertyOptions2.assertConsistency(propertyOptions2.getOptions());
        return propertyOptions2;
    }
}

