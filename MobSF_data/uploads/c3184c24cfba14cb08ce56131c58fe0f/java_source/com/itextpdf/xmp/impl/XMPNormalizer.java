/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.impl;

import com.itextpdf.xmp.XMPDateTime;
import com.itextpdf.xmp.XMPException;
import com.itextpdf.xmp.XMPMeta;
import com.itextpdf.xmp.XMPMetaFactory;
import com.itextpdf.xmp.XMPUtils;
import com.itextpdf.xmp.impl.Utils;
import com.itextpdf.xmp.impl.XMPDateTimeImpl;
import com.itextpdf.xmp.impl.XMPMetaImpl;
import com.itextpdf.xmp.impl.XMPNode;
import com.itextpdf.xmp.impl.XMPNodeUtils;
import com.itextpdf.xmp.impl.xpath.XMPPathParser;
import com.itextpdf.xmp.options.AliasOptions;
import com.itextpdf.xmp.options.ParseOptions;
import com.itextpdf.xmp.options.PropertyOptions;
import com.itextpdf.xmp.properties.XMPAliasInfo;
import java.util.Calendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

public class XMPNormalizer {
    private static Map dcArrayForms;

    static {
        XMPNormalizer.initDCArrays();
    }

    private XMPNormalizer() {
    }

    private static void compareAliasedSubtrees(XMPNode object, XMPNode object2, boolean bl2) {
        if (object.getValue().equals(object2.getValue()) && object.getChildrenLength() == object2.getChildrenLength()) {
            if (!(bl2 || object.getName().equals(object2.getName()) && object.getOptions().equals(object2.getOptions()) && object.getQualifierLength() == object2.getQualifierLength())) {
                throw new XMPException("Mismatch between alias and base nodes", 203);
            }
            Iterator iterator = object.iterateChildren();
            Iterator iterator2 = object2.iterateChildren();
            while (iterator.hasNext() && iterator2.hasNext()) {
                XMPNormalizer.compareAliasedSubtrees((XMPNode)iterator.next(), (XMPNode)iterator2.next(), false);
            }
            object = object.iterateQualifier();
            object2 = object2.iterateQualifier();
            while (object.hasNext() && object2.hasNext()) {
                XMPNormalizer.compareAliasedSubtrees((XMPNode)object.next(), (XMPNode)object2.next(), false);
            }
            return;
        }
        throw new XMPException("Mismatch between alias and base nodes", 203);
    }

    private static void deleteEmptySchemas(XMPNode object) {
        object = object.iterateChildren();
        while (object.hasNext()) {
            if (((XMPNode)object.next()).hasChildren()) continue;
            object.remove();
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private static void fixGPSTimeStamp(XMPNode comparable) {
        XMPNode xMPNode = XMPNodeUtils.findChildNode((XMPNode)comparable, "exif:GPSTimeStamp", false);
        if (xMPNode == null) {
            return;
        }
        try {
            XMPDateTime xMPDateTime = XMPUtils.convertToDate(xMPNode.getValue());
            if (xMPDateTime.getYear() == 0 && xMPDateTime.getMonth() == 0) {
                if (xMPDateTime.getDay() != 0) {
                    return;
                }
                XMPNode xMPNode2 = XMPNodeUtils.findChildNode((XMPNode)comparable, "exif:DateTimeOriginal", false);
                Comparable comparable2 = xMPNode2;
                if (xMPNode2 == null) {
                    comparable2 = XMPNodeUtils.findChildNode((XMPNode)comparable, "exif:DateTimeDigitized", false);
                }
                comparable = XMPUtils.convertToDate(comparable2.getValue());
                comparable2 = xMPDateTime.getCalendar();
                comparable2.set(1, comparable.getYear());
                comparable2.set(2, comparable.getMonth());
                comparable2.set(5, comparable.getDay());
                xMPNode.setValue(XMPUtils.convertFromDate(new XMPDateTimeImpl((Calendar)comparable2)));
            }
            return;
        }
        catch (XMPException xMPException) {
            return;
        }
    }

    private static void initDCArrays() {
        dcArrayForms = new HashMap();
        PropertyOptions propertyOptions = new PropertyOptions();
        propertyOptions.setArray(true);
        dcArrayForms.put("dc:contributor", propertyOptions);
        dcArrayForms.put("dc:language", propertyOptions);
        dcArrayForms.put("dc:publisher", propertyOptions);
        dcArrayForms.put("dc:relation", propertyOptions);
        dcArrayForms.put("dc:subject", propertyOptions);
        dcArrayForms.put("dc:type", propertyOptions);
        propertyOptions = new PropertyOptions();
        propertyOptions.setArray(true);
        propertyOptions.setArrayOrdered(true);
        dcArrayForms.put("dc:creator", propertyOptions);
        dcArrayForms.put("dc:date", propertyOptions);
        propertyOptions = new PropertyOptions();
        propertyOptions.setArray(true);
        propertyOptions.setArrayOrdered(true);
        propertyOptions.setArrayAlternate(true);
        propertyOptions.setArrayAltText(true);
        dcArrayForms.put("dc:description", propertyOptions);
        dcArrayForms.put("dc:rights", propertyOptions);
        dcArrayForms.put("dc:title", propertyOptions);
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private static void migrateAudioCopyright(XMPMeta object, XMPNode xMPNode) {
        try {
            block8 : {
                Object object2;
                String string2;
                block6 : {
                    block9 : {
                        int n2;
                        block7 : {
                            int n3;
                            object2 = XMPNodeUtils.findSchemaNode(((XMPMetaImpl)object).getRoot(), "http://purl.org/dc/elements/1.1/", true);
                            string2 = xMPNode.getValue();
                            object2 = XMPNodeUtils.findChildNode((XMPNode)object2, "dc:rights", false);
                            if (object2 == null || !object2.hasChildren()) break block6;
                            n2 = n3 = XMPNodeUtils.lookupLanguageItem((XMPNode)object2, "x-default");
                            if (n3 < 0) {
                                object.setLocalizedText("http://purl.org/dc/elements/1.1/", "rights", "", "x-default", object2.getChild(1).getValue(), null);
                                n2 = XMPNodeUtils.lookupLanguageItem((XMPNode)object2, "x-default");
                            }
                            object2 = object2.getChild(n2);
                            object = object2.getValue();
                            n2 = object.indexOf("\n\n");
                            if (n2 >= 0) break block7;
                            if (string2.equals(object)) break block8;
                            StringBuilder stringBuilder = new StringBuilder();
                            stringBuilder.append((String)object);
                            stringBuilder.append("\n\n");
                            stringBuilder.append(string2);
                            object = stringBuilder.toString();
                            break block9;
                        }
                        if (object.substring(n2 += 2).equals(string2)) break block8;
                        StringBuilder stringBuilder = new StringBuilder();
                        stringBuilder.append(object.substring(0, n2));
                        stringBuilder.append(string2);
                        object = stringBuilder.toString();
                    }
                    object2.setValue((String)object);
                    break block8;
                }
                object2 = new StringBuilder();
                object2.append("\n\n");
                object2.append(string2);
                object.setLocalizedText("http://purl.org/dc/elements/1.1/", "rights", "", "x-default", object2.toString(), null);
            }
            xMPNode.getParent().removeChild(xMPNode);
            return;
        }
        catch (XMPException xMPException) {
            return;
        }
    }

    /*
     * Unable to fully structure code
     * Enabled aggressive block sorting
     * Lifted jumps to return sites
     */
    private static void moveExplicitAliases(XMPNode var0, ParseOptions var1_1) {
        if (!var0.getHasAliases()) {
            return;
        }
        var0.setHasAliases(false);
        var3_2 = var1_1.getStrictAliasing();
        var4_3 = var0.getUnmodifiableChildren().iterator();
        while (var4_3.hasNext() != false) {
            var5_5 = (XMPNode)var4_3.next();
            if (!var5_5.getHasAliases()) continue;
            var6_6 = var5_5.iterateChildren();
            while (var6_6.hasNext()) {
                var7_7 = (XMPNode)var6_6.next();
                if (!var7_7.isAlias()) continue;
                var7_7.setAlias(false);
                var8_8 = XMPMetaFactory.getSchemaRegistry().findAlias(var7_7.getName());
                if (var8_8 == null) continue;
                var9_9 = var8_8.getNamespace();
                var1_1 = null;
                var9_9 = XMPNodeUtils.findSchemaNode(var0, (String)var9_9, null, true);
                var9_9.setImplicit(false);
                var10_10 = new StringBuilder();
                var10_10.append(var8_8.getPrefix());
                var10_10.append(var8_8.getPropName());
                var10_10 = XMPNodeUtils.findChildNode((XMPNode)var9_9, var10_10.toString(), false);
                if (var10_10 != null) ** GOTO lbl39
                if (var8_8.getAliasForm().isSimple()) {
                    var1_1 = new StringBuilder();
                    var1_1.append(var8_8.getPrefix());
                    var1_1.append(var8_8.getPropName());
                    var7_7.setName(var1_1.toString());
                    var9_9.addChild(var7_7);
                } else {
                    var1_1 = new StringBuilder();
                    var1_1.append(var8_8.getPrefix());
                    var1_1.append(var8_8.getPropName());
                    var1_1 = new XMPNode(var1_1.toString(), var8_8.getAliasForm().toPropertyOptions());
                    var9_9.addChild((XMPNode)var1_1);
                    XMPNormalizer.transplantArrayItemAlias(var6_6, var7_7, (XMPNode)var1_1);
                    continue;
lbl39: // 1 sources:
                    if (var8_8.getAliasForm().isSimple()) {
                        if (var3_2) {
                            XMPNormalizer.compareAliasedSubtrees(var7_7, (XMPNode)var10_10, true);
                        }
                    } else {
                        if (var8_8.getAliasForm().isArrayAltText()) {
                            var2_4 = XMPNodeUtils.lookupLanguageItem((XMPNode)var10_10, "x-default");
                            if (var2_4 != -1) {
                                var1_1 = var10_10.getChild(var2_4);
                            }
                        } else if (var10_10.hasChildren()) {
                            var1_1 = var10_10.getChild(1);
                        }
                        if (var1_1 == null) {
                            XMPNormalizer.transplantArrayItemAlias(var6_6, var7_7, (XMPNode)var10_10);
                            continue;
                        }
                        if (var3_2) {
                            XMPNormalizer.compareAliasedSubtrees(var7_7, (XMPNode)var1_1, true);
                        }
                    }
                }
                var6_6.remove();
            }
            var5_5.setHasAliases(false);
        }
    }

    private static void normalizeDCArrays(XMPNode xMPNode) {
        for (int i2 = 1; i2 <= xMPNode.getChildrenLength(); ++i2) {
            XMPNode xMPNode2 = xMPNode.getChild(i2);
            PropertyOptions propertyOptions = (PropertyOptions)dcArrayForms.get(xMPNode2.getName());
            if (propertyOptions == null) continue;
            if (xMPNode2.getOptions().isSimple()) {
                XMPNode xMPNode3 = new XMPNode(xMPNode2.getName(), propertyOptions);
                xMPNode2.setName("[]");
                xMPNode3.addChild(xMPNode2);
                xMPNode.replaceChild(i2, xMPNode3);
                if (!propertyOptions.isArrayAltText() || xMPNode2.getOptions().getHasLanguage()) continue;
                xMPNode2.addQualifier(new XMPNode("xml:lang", "x-default", null));
                continue;
            }
            xMPNode2.getOptions().setOption(7680, false);
            xMPNode2.getOptions().mergeWith(propertyOptions);
            if (!propertyOptions.isArrayAltText()) continue;
            XMPNormalizer.repairAltText(xMPNode2);
        }
    }

    static XMPMeta process(XMPMetaImpl xMPMetaImpl, ParseOptions parseOptions) {
        XMPNode xMPNode = xMPMetaImpl.getRoot();
        XMPNormalizer.touchUpDataModel(xMPMetaImpl);
        XMPNormalizer.moveExplicitAliases(xMPNode, parseOptions);
        XMPNormalizer.tweakOldXMP(xMPNode);
        XMPNormalizer.deleteEmptySchemas(xMPNode);
        return xMPMetaImpl;
    }

    /*
     * Enabled aggressive block sorting
     */
    private static void repairAltText(XMPNode object) {
        block5 : {
            if (object == null) break block5;
            if (!object.getOptions().isArray()) {
                return;
            }
            object.getOptions().setArrayOrdered(true).setArrayAlternate(true).setArrayAltText(true);
            object = object.iterateChildren();
            while (object.hasNext()) {
                XMPNode xMPNode;
                block7 : {
                    block6 : {
                        xMPNode = (XMPNode)object.next();
                        if (xMPNode.getOptions().isCompositeProperty()) break block6;
                        if (xMPNode.getOptions().getHasLanguage()) continue;
                        String string2 = xMPNode.getValue();
                        if (string2 != null && string2.length() != 0) break block7;
                    }
                    object.remove();
                    continue;
                }
                xMPNode.addQualifier(new XMPNode("xml:lang", "x-repair", null));
            }
        }
    }

    /*
     * Enabled aggressive block sorting
     */
    private static void touchUpDataModel(XMPMetaImpl xMPMetaImpl) {
        XMPNodeUtils.findSchemaNode(xMPMetaImpl.getRoot(), "http://purl.org/dc/elements/1.1/", true);
        Iterator iterator = xMPMetaImpl.getRoot().iterateChildren();
        while (iterator.hasNext()) {
            XMPNode xMPNode = (XMPNode)iterator.next();
            if ("http://purl.org/dc/elements/1.1/".equals(xMPNode.getName())) {
                XMPNormalizer.normalizeDCArrays(xMPNode);
                continue;
            }
            if ("http://ns.adobe.com/exif/1.0/".equals(xMPNode.getName())) {
                XMPNormalizer.fixGPSTimeStamp(xMPNode);
                if ((xMPNode = XMPNodeUtils.findChildNode(xMPNode, "exif:UserComment", false)) == null) continue;
            } else {
                if ("http://ns.adobe.com/xmp/1.0/DynamicMedia/".equals(xMPNode.getName())) {
                    if ((xMPNode = XMPNodeUtils.findChildNode(xMPNode, "xmpDM:copyright", false)) == null) continue;
                    XMPNormalizer.migrateAudioCopyright(xMPMetaImpl, xMPNode);
                    continue;
                }
                if (!"http://ns.adobe.com/xap/1.0/rights/".equals(xMPNode.getName()) || (xMPNode = XMPNodeUtils.findChildNode(xMPNode, "xmpRights:UsageTerms", false)) == null) continue;
            }
            XMPNormalizer.repairAltText(xMPNode);
        }
        return;
    }

    private static void transplantArrayItemAlias(Iterator iterator, XMPNode xMPNode, XMPNode xMPNode2) {
        if (xMPNode2.getOptions().isArrayAltText()) {
            if (!xMPNode.getOptions().getHasLanguage()) {
                xMPNode.addQualifier(new XMPNode("xml:lang", "x-default", null));
            } else {
                throw new XMPException("Alias to x-default already has a language qualifier", 203);
            }
        }
        iterator.remove();
        xMPNode.setName("[]");
        xMPNode2.addChild(xMPNode);
    }

    private static void tweakOldXMP(XMPNode xMPNode) {
        if (xMPNode.getName() != null && xMPNode.getName().length() >= 36) {
            Object object = xMPNode.getName().toLowerCase();
            String string2 = object;
            if (object.startsWith("uuid:")) {
                string2 = object.substring(5);
            }
            if (Utils.checkUUIDFormat(string2)) {
                object = XMPNodeUtils.findNode(xMPNode, XMPPathParser.expandXPath("http://ns.adobe.com/xap/1.0/mm/", "InstanceID"), true, null);
                if (object != null) {
                    object.setOptions(null);
                    StringBuilder stringBuilder = new StringBuilder();
                    stringBuilder.append("uuid:");
                    stringBuilder.append(string2);
                    object.setValue(stringBuilder.toString());
                    object.removeChildren();
                    object.removeQualifiers();
                    xMPNode.setName(null);
                    return;
                }
                throw new XMPException("Failure creating xmpMM:InstanceID", 9);
            }
        }
    }
}

