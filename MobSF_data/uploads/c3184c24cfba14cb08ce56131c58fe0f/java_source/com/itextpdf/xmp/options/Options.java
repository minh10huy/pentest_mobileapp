/*
 * Decompiled with CFR 0_132.
 */
package com.itextpdf.xmp.options;

import com.itextpdf.xmp.XMPException;
import java.util.HashMap;
import java.util.Map;

public abstract class Options {
    private Map optionNames = null;
    private int options = 0;

    public Options() {
    }

    public Options(int n2) {
        this.assertOptionsValid(n2);
        this.setOptions(n2);
    }

    private void assertOptionsValid(int n2) {
        int n3 = this.getValidOptions() & n2;
        if (n3 == 0) {
            this.assertConsistency(n2);
            return;
        }
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("The option bit(s) 0x");
        stringBuilder.append(Integer.toHexString(n3));
        stringBuilder.append(" are invalid!");
        throw new XMPException(stringBuilder.toString(), 103);
    }

    private String getOptionName(int n2) {
        String string2;
        Map map = this.procureOptionNames();
        Integer n3 = new Integer(n2);
        String string3 = string2 = (String)map.get(n3);
        if (string2 == null) {
            string3 = this.defineOptionName(n2);
            if (string3 != null) {
                map.put(n3, string3);
                return string3;
            }
            string3 = "<option name not defined>";
        }
        return string3;
    }

    private Map procureOptionNames() {
        if (this.optionNames == null) {
            this.optionNames = new HashMap();
        }
        return this.optionNames;
    }

    protected void assertConsistency(int n2) {
    }

    public void clear() {
        this.options = 0;
    }

    public boolean containsAllOptions(int n2) {
        if ((this.getOptions() & n2) == n2) {
            return true;
        }
        return false;
    }

    public boolean containsOneOf(int n2) {
        if ((n2 & this.getOptions()) != 0) {
            return true;
        }
        return false;
    }

    protected abstract String defineOptionName(int var1);

    public boolean equals(Object object) {
        if (this.getOptions() == ((Options)object).getOptions()) {
            return true;
        }
        return false;
    }

    protected boolean getOption(int n2) {
        if ((n2 & this.options) != 0) {
            return true;
        }
        return false;
    }

    public int getOptions() {
        return this.options;
    }

    public String getOptionsString() {
        if (this.options != 0) {
            StringBuffer stringBuffer = new StringBuffer();
            int n2 = this.options;
            while (n2 != 0) {
                int n3 = n2 - 1 & n2;
                stringBuffer.append(this.getOptionName(n2 ^ n3));
                if (n3 != 0) {
                    stringBuffer.append(" | ");
                }
                n2 = n3;
            }
            return stringBuffer.toString();
        }
        return "<none>";
    }

    protected abstract int getValidOptions();

    public int hashCode() {
        return this.getOptions();
    }

    public boolean isExactly(int n2) {
        if (this.getOptions() == n2) {
            return true;
        }
        return false;
    }

    public void setOption(int n2, boolean bl2) {
        n2 = bl2 ? (n2 |= this.options) : (n2 &= this.options);
        this.options = n2;
    }

    public void setOptions(int n2) {
        this.assertOptionsValid(n2);
        this.options = n2;
    }

    public String toString() {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("0x");
        stringBuilder.append(Integer.toHexString(this.options));
        return stringBuilder.toString();
    }
}

