/*
 * Decompiled with CFR 0_132.
 */
package c.a.a.d;

import c.a.a.c.a;
import c.a.a.g.e;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.io.RandomAccessFile;

public class d
extends OutputStream {
    private RandomAccessFile a;
    private long b;
    private File c;
    private File d;
    private int e;
    private long f;

    public d(File file) {
        this(file, -1L);
    }

    public d(File file, long l2) {
        if (l2 >= 0L && l2 < 65536L) {
            throw new a("split length less than minimum allowed split length of 65536 Bytes");
        }
        this.a = new RandomAccessFile(file, "rw");
        this.b = l2;
        this.d = file;
        this.c = file;
        this.e = 0;
        this.f = 0L;
    }

    private boolean a(byte[] arrby) {
        if (arrby != null) {
            if (arrby.length < 4) {
                return false;
            }
            int n2 = c.a.a.g.d.d(arrby, 0);
            arrby = e.a();
            if (arrby != null && arrby.length > 0) {
                int n3 = 0;
                do {
                    if (n3 >= arrby.length) {
                        return false;
                    }
                    if (arrby[n3] != 134695760L && arrby[n3] == (long)n2) {
                        return true;
                    }
                    ++n3;
                } while (true);
            }
        }
        return false;
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private void e() {
        try {
            Object object;
            String string2 = e.d(this.d.getName());
            CharSequence charSequence = this.c.getAbsolutePath();
            if (this.d.getParent() == null) {
                object = "";
            } else {
                object = new StringBuffer(String.valueOf(this.d.getParent()));
                object.append(System.getProperty("file.separator"));
                object = object.toString();
            }
            if (this.e < 9) {
                object = new StringBuffer(String.valueOf(object));
                object.append(string2);
                object.append(".z0");
                object.append(this.e + 1);
                object = new File(object.toString());
            } else {
                object = new StringBuffer(String.valueOf(object));
                object.append(string2);
                object.append(".z");
                object.append(this.e + 1);
                object = new File(object.toString());
            }
            this.a.close();
            if (object.exists()) {
                charSequence = new StringBuffer("split file: ");
                charSequence.append(object.getName());
                charSequence.append(" already exists in the current directory, cannot rename this file");
                throw new IOException(charSequence.toString());
            }
            if (this.c.renameTo((File)object)) {
                this.c = new File((String)charSequence);
                this.a = new RandomAccessFile(this.c, "rw");
                ++this.e;
                return;
            }
            throw new IOException("cannot rename newly created split file");
        }
        catch (a a2) {
            throw new IOException(a2.getMessage());
        }
    }

    public long a() {
        return this.a.getFilePointer();
    }

    public void a(long l2) {
        this.a.seek(l2);
    }

    public boolean a(int n2) {
        if (n2 >= 0) {
            if (!this.b(n2)) {
                try {
                    this.e();
                    this.f = 0L;
                    return true;
                }
                catch (IOException iOException) {
                    throw new a(iOException);
                }
            }
            return false;
        }
        throw new a("negative buffersize for checkBuffSizeAndStartNextSplitFile");
    }

    public boolean b() {
        if (this.b != -1L) {
            return true;
        }
        return false;
    }

    public boolean b(int n2) {
        if (n2 >= 0) {
            if (this.b >= 65536L) {
                if (this.f + (long)n2 <= this.b) {
                    return true;
                }
                return false;
            }
            return true;
        }
        throw new a("negative buffersize for isBuffSizeFitForCurrSplitFile");
    }

    public long c() {
        return this.b;
    }

    @Override
    public void close() {
        if (this.a != null) {
            this.a.close();
        }
    }

    public int d() {
        return this.e;
    }

    @Override
    public void flush() {
    }

    @Override
    public void write(int n2) {
        this.write(new byte[]{(byte)n2}, 0, 1);
    }

    @Override
    public void write(byte[] arrby) {
        this.write(arrby, 0, arrby.length);
    }

    /*
     * Enabled aggressive block sorting
     */
    @Override
    public void write(byte[] arrby, int n2, int n3) {
        long l2;
        if (n3 <= 0) {
            return;
        }
        if (this.b != -1L) {
            if (this.b < 65536L) {
                throw new IOException("split length less than minimum allowed split length of 65536 Bytes");
            }
            if (this.f >= this.b) {
                this.e();
                this.a.write(arrby, n2, n3);
                l2 = n3;
            } else {
                long l3 = this.f;
                l2 = n3;
                if (l3 + l2 > this.b) {
                    if (this.a(arrby)) {
                        this.e();
                        this.a.write(arrby, n2, n3);
                    } else {
                        this.a.write(arrby, n2, (int)(this.b - this.f));
                        this.e();
                        this.a.write(arrby, n2 + (int)(this.b - this.f), (int)(l2 - (this.b - this.f)));
                        l2 -= this.b - this.f;
                    }
                    this.f = l2;
                    return;
                }
                this.a.write(arrby, n2, n3);
                l2 = this.f + l2;
            }
        } else {
            this.a.write(arrby, n2, n3);
            l2 = this.f + (long)n3;
        }
        this.f = l2;
    }
}

