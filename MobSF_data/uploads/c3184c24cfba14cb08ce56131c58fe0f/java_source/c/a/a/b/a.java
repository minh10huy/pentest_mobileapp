/*
 * Decompiled with CFR 0_132.
 */
package c.a.a.b;

import c.a.a.b.a.c;
import c.a.a.b.b;
import c.a.a.g.d;
import java.util.Random;

public class a
implements b {
    private char[] a;
    private int b;
    private c.a.a.b.b.a c;
    private c.a.a.b.a.a d;
    private int e;
    private int f;
    private int g;
    private final int h = 2;
    private byte[] i;
    private byte[] j;
    private byte[] k;
    private byte[] l;
    private boolean m;
    private int n = 1;
    private int o = 0;
    private byte[] p;
    private byte[] q;

    public a(char[] arrc, int n2) {
        if (arrc != null && arrc.length != 0) {
            if (n2 != 1 && n2 != 3) {
                throw new c.a.a.c.a("Invalid key strength in AES encrypter constructor");
            }
            this.a = arrc;
            this.b = n2;
            this.m = false;
            this.q = new byte[16];
            this.p = new byte[16];
            this.d();
            return;
        }
        throw new c.a.a.c.a("input password is empty or null in AES encrypter constructor");
    }

    private static byte[] a(int n2) {
        if (n2 != 8 && n2 != 16) {
            throw new c.a.a.c.a("invalid salt size, cannot generate salt");
        }
        int n3 = 0;
        int n4 = n2 == 8 ? 2 : 0;
        if (n2 == 16) {
            n4 = 4;
        }
        byte[] arrby = new byte[n2];
        n2 = n3;
        while (n2 < n4) {
            n3 = new Random().nextInt();
            int n5 = n2 * 4;
            arrby[n5 + 0] = (byte)(n3 >> 24);
            arrby[n5 + 1] = (byte)(n3 >> 16);
            arrby[n5 + 2] = (byte)(n3 >> 8);
            arrby[n5 + 3] = (byte)n3;
            ++n2;
        }
        return arrby;
    }

    private byte[] a(byte[] arrby, char[] arrc) {
        try {
            arrby = new c.a.a.b.a.b(new c("HmacSHA1", "ISO-8859-1", arrby, 1000)).a(arrc, this.e + this.f + 2);
            return arrby;
        }
        catch (Exception exception) {
            throw new c.a.a.c.a(exception);
        }
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private void d() {
        int n2 = this.b;
        if (n2 != 1) {
            if (n2 != 3) throw new c.a.a.c.a("invalid aes key strength, cannot determine key sizes");
            this.e = 32;
            this.f = 32;
            this.g = 16;
        } else {
            this.e = 16;
            this.f = 16;
            this.g = 8;
        }
        this.l = a.a(this.g);
        byte[] arrby = this.a(this.l, this.a);
        if (arrby == null || arrby.length != this.e + this.f + 2) throw new c.a.a.c.a("invalid key generated, cannot decrypt file");
        this.i = new byte[this.e];
        this.j = new byte[this.f];
        this.k = new byte[2];
        System.arraycopy(arrby, 0, this.i, 0, this.e);
        System.arraycopy(arrby, this.e, this.j, 0, this.f);
        System.arraycopy(arrby, this.e + this.f, this.k, 0, 2);
        this.c = new c.a.a.b.b.a(this.i);
        this.d = new c.a.a.b.a.a("HmacSHA1");
        this.d.b(this.j);
    }

    @Override
    public int a(byte[] arrby, int n2, int n3) {
        if (!this.m) {
            if (n3 % 16 != 0) {
                this.m = true;
            }
            int n4 = n2;
            block0 : do {
                int n5;
                if (n4 >= (n5 = n2 + n3)) {
                    return n3;
                }
                int n6 = n4 + 16;
                n5 = n6 <= n5 ? 16 : (n5 -= n4);
                this.o = n5;
                d.b(this.p, this.n, 16);
                this.c.a(this.p, this.q);
                n5 = 0;
                do {
                    if (n5 >= this.o) {
                        this.d.a(arrby, n4, this.o);
                        ++this.n;
                        n4 = n6;
                        continue block0;
                    }
                    int n7 = n4 + n5;
                    arrby[n7] = (byte)(arrby[n7] ^ this.q[n5]);
                    ++n5;
                } while (true);
                break;
            } while (true);
        }
        throw new c.a.a.c.a("AES Encrypter is in finished state (A non 16 byte block has already been passed to encrypter)");
    }

    public byte[] a() {
        byte[] arrby = this.d.a();
        byte[] arrby2 = new byte[10];
        System.arraycopy(arrby, 0, arrby2, 0, 10);
        return arrby2;
    }

    public byte[] b() {
        return this.k;
    }

    public byte[] c() {
        return this.l;
    }
}

