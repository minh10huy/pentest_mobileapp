/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.content.Context
 *  android.content.SharedPreferences
 *  android.content.SharedPreferences$Editor
 *  android.os.Build
 *  android.os.Build$VERSION
 *  android.util.Log
 */
package android.support.e;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Build;
import android.support.e.c;
import android.util.Log;
import java.io.BufferedOutputStream;
import java.io.Closeable;
import java.io.File;
import java.io.FileFilter;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;
import java.io.Serializable;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

final class b
implements Closeable {
    private final File a;
    private final long b;
    private final File c;
    private final RandomAccessFile d;
    private final FileChannel e;
    private final FileLock f;

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    b(File file, File serializable) {
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append("MultiDexExtractor(");
        stringBuilder.append(file.getPath());
        stringBuilder.append(", ");
        stringBuilder.append(serializable.getPath());
        stringBuilder.append(")");
        Log.i((String)"MultiDex", (String)stringBuilder.toString());
        this.a = file;
        this.c = serializable;
        this.b = b.b(file);
        file = new File((File)serializable, "MultiDex.lock");
        this.d = new RandomAccessFile(file, "rw");
        this.e = this.d.getChannel();
        serializable = new StringBuilder();
        serializable.append("Blocking on lock ");
        serializable.append(file.getPath());
        Log.i((String)"MultiDex", (String)serializable.toString());
        this.f = this.e.lock();
        try {
            serializable = new StringBuilder();
            serializable.append(file.getPath());
            serializable.append(" locked");
            Log.i((String)"MultiDex", (String)serializable.toString());
            return;
            catch (IOException | Error | RuntimeException throwable) {
                b.a(this.e);
                throw throwable;
            }
        }
        catch (IOException | Error | RuntimeException throwable2) {
            b.a(this.d);
            throw throwable2;
        }
    }

    private static long a(File file) {
        long l2;
        long l3 = l2 = file.lastModified();
        if (l2 == -1L) {
            l3 = l2 - 1L;
        }
        return l3;
    }

    private static SharedPreferences a(Context context) {
        int n2 = Build.VERSION.SDK_INT < 11 ? 0 : 4;
        return context.getSharedPreferences("multidex.version", n2);
    }

    /*
     * Exception decompiling
     */
    private List<a> a() {
        // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
        // org.benf.cfr.reader.util.ConfusedCFRException: Tried to end blocks [0[TRYBLOCK]], but top level block is 10[UNCONDITIONALDOLOOP]
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.processEndingBlocks(Op04StructuredStatement.java:416)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op04StructuredStatement.buildNestedBlocks(Op04StructuredStatement.java:468)
        // org.benf.cfr.reader.bytecode.analysis.opgraph.Op03SimpleStatement.createInitialStructuredBlock(Op03SimpleStatement.java:2960)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:818)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
        // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
        // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
        // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
        // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
        // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
        // org.benf.cfr.reader.Main.doJar(Main.java:141)
        // org.benf.cfr.reader.Main.main(Main.java:242)
        throw new IllegalStateException("Decompilation failed");
    }

    private List<a> a(Context object, String string2) {
        Log.i((String)"MultiDex", (String)"loading existing secondary dex files");
        CharSequence charSequence = new StringBuilder();
        charSequence.append(this.a.getName());
        charSequence.append(".classes");
        charSequence = charSequence.toString();
        object = b.a((Context)object);
        Serializable serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append("dex.number");
        int n2 = object.getInt(serializable.toString(), 1);
        serializable = new ArrayList(n2 - 1);
        for (int i2 = 2; i2 <= n2; ++i2) {
            Object object2 = new StringBuilder();
            object2.append((String)charSequence);
            object2.append(i2);
            object2.append(".zip");
            object2 = object2.toString();
            object2 = new a(this.c, (String)object2);
            if (object2.isFile()) {
                object2.a = b.b((File)object2);
                StringBuilder stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append("dex.crc.");
                stringBuilder.append(i2);
                long l2 = object.getLong(stringBuilder.toString(), -1L);
                stringBuilder = new StringBuilder();
                stringBuilder.append(string2);
                stringBuilder.append("dex.time.");
                stringBuilder.append(i2);
                long l3 = object.getLong(stringBuilder.toString(), -1L);
                long l4 = object2.lastModified();
                if (l3 == l4 && l2 == object2.a) {
                    serializable.add(object2);
                    continue;
                }
                object = new StringBuilder();
                object.append("Invalid extracted dex: ");
                object.append(object2);
                object.append(" (key \"");
                object.append(string2);
                object.append("\"), expected modification time: ");
                object.append(l3);
                object.append(", modification time: ");
                object.append(l4);
                object.append(", expected crc: ");
                object.append(l2);
                object.append(", file crc: ");
                object.append(object2.a);
                throw new IOException(object.toString());
            }
            object = new StringBuilder();
            object.append("Missing extracted secondary dex file '");
            object.append(object2.getPath());
            object.append("'");
            throw new IOException(object.toString());
        }
        return serializable;
    }

    private static void a(Context context, String string2, long l2, long l3, List<a> object) {
        context = b.a(context).edit();
        Serializable serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append("timestamp");
        context.putLong(serializable.toString(), l2);
        serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append("crc");
        context.putLong(serializable.toString(), l3);
        serializable = new StringBuilder();
        serializable.append(string2);
        serializable.append("dex.number");
        context.putInt(serializable.toString(), object.size() + 1);
        object = object.iterator();
        int n2 = 2;
        while (object.hasNext()) {
            serializable = (a)object.next();
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append(string2);
            stringBuilder.append("dex.crc.");
            stringBuilder.append(n2);
            context.putLong(stringBuilder.toString(), serializable.a);
            stringBuilder = new StringBuilder();
            stringBuilder.append(string2);
            stringBuilder.append("dex.time.");
            stringBuilder.append(n2);
            context.putLong(stringBuilder.toString(), serializable.lastModified());
            ++n2;
        }
        context.commit();
    }

    private static void a(Closeable closeable) {
        try {
            closeable.close();
            return;
        }
        catch (IOException iOException) {
            Log.w((String)"MultiDex", (String)"Failed to close resource", (Throwable)iOException);
            return;
        }
    }

    /*
     * Loose catch block
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     * Lifted jumps to return sites
     */
    private static void a(ZipFile closeable, ZipEntry object, File file, String object2) {
        int n2;
        closeable = closeable.getInputStream((ZipEntry)object);
        Object object3 = new StringBuilder();
        object3.append("tmp-");
        object3.append((String)object2);
        object2 = File.createTempFile(object3.toString(), ".zip", file.getParentFile());
        object3 = new StringBuilder();
        object3.append("Extracting ");
        object3.append(object2.getPath());
        Log.i((String)"MultiDex", (String)object3.toString());
        object3 = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream((File)object2)));
        ZipEntry zipEntry = new ZipEntry("classes.dex");
        zipEntry.setTime(object.getTime());
        object3.putNextEntry(zipEntry);
        object = new byte[16384];
        while ((n2 = closeable.read((byte[])object)) != -1) {
            object3.write((byte[])object, 0, n2);
        }
        object3.closeEntry();
        {
            catch (Throwable throwable) {
                object3.close();
                throw throwable;
            }
        }
        try {
            object3.close();
            if (object2.setReadOnly()) {
                object = new StringBuilder();
                object.append("Renaming to ");
                object.append(file.getPath());
                Log.i((String)"MultiDex", (String)object.toString());
                boolean bl2 = object2.renameTo(file);
                if (bl2) {
                    return;
                }
                object = new StringBuilder();
                object.append("Failed to rename \"");
                object.append(object2.getAbsolutePath());
                object.append("\" to \"");
                object.append(file.getAbsolutePath());
                object.append("\"");
                throw new IOException(object.toString());
            }
            object = new StringBuilder();
            object.append("Failed to mark readonly \"");
            object.append(object2.getAbsolutePath());
            object.append("\" (tmp of \"");
            object.append(file.getAbsolutePath());
            object.append("\")");
            throw new IOException(object.toString());
        }
        catch (Throwable throwable) {
            throw throwable;
        }
        finally {
            b.a(closeable);
            object2.delete();
        }
    }

    private static boolean a(Context context, File serializable, long l2, String string2) {
        context = b.a(context);
        StringBuilder stringBuilder = new StringBuilder();
        stringBuilder.append(string2);
        stringBuilder.append("timestamp");
        if (context.getLong(stringBuilder.toString(), -1L) == b.a((File)serializable)) {
            serializable = new StringBuilder();
            serializable.append(string2);
            serializable.append("crc");
            if (context.getLong(serializable.toString(), -1L) == l2) {
                return false;
            }
        }
        return true;
    }

    private static long b(File file) {
        long l2;
        long l3 = l2 = c.a(file);
        if (l2 == -1L) {
            l3 = l2 - 1L;
        }
        return l3;
    }

    private void b() {
        Object object = this.c.listFiles(new FileFilter(){

            @Override
            public boolean accept(File file) {
                return file.getName().equals("MultiDex.lock") ^ true;
            }
        });
        if (object == null) {
            object = new StringBuilder();
            object.append("Failed to list secondary dex dir content (");
            object.append(this.c.getPath());
            object.append(").");
            Log.w((String)"MultiDex", (String)object.toString());
            return;
        }
        for (Object object2 : object) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("Trying to delete old file ");
            stringBuilder.append(object2.getPath());
            stringBuilder.append(" of size ");
            stringBuilder.append(object2.length());
            Log.i((String)"MultiDex", (String)stringBuilder.toString());
            if (!object2.delete()) {
                stringBuilder = new StringBuilder();
                stringBuilder.append("Failed to delete old file ");
                stringBuilder.append(object2.getPath());
                Log.w((String)"MultiDex", (String)stringBuilder.toString());
                continue;
            }
            stringBuilder = new StringBuilder();
            stringBuilder.append("Deleted old file ");
            stringBuilder.append(object2.getPath());
            Log.i((String)"MultiDex", (String)stringBuilder.toString());
        }
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    List<? extends File> a(Context object, String charSequence, boolean bl2) {
        Object object2 = new StringBuilder();
        object2.append("MultiDexExtractor.load(");
        object2.append(this.a.getPath());
        object2.append(", ");
        object2.append(bl2);
        object2.append(", ");
        object2.append((String)charSequence);
        object2.append(")");
        Log.i((String)"MultiDex", (String)object2.toString());
        if (!this.f.isValid()) {
            throw new IllegalStateException("MultiDexExtractor was closed");
        }
        if (!bl2 && !b.a((Context)object, this.a, this.b, (String)charSequence)) {
            try {
                object2 = this.a((Context)object, (String)charSequence);
                object = object2;
            }
            catch (IOException iOException) {
                Log.w((String)"MultiDex", (String)"Failed to reload existing extracted secondary dex files, falling back to fresh extraction", (Throwable)iOException);
                List<a> list = this.a();
                b.a((Context)object, (String)charSequence, b.a(this.a), this.b, list);
                object = list;
            }
        } else {
            object2 = bl2 ? "Forced extraction must be performed." : "Detected that extraction must be performed.";
            Log.i((String)"MultiDex", (String)object2);
            object2 = this.a();
            b.a((Context)object, (String)charSequence, b.a(this.a), this.b, object2);
            object = object2;
        }
        charSequence = new StringBuilder();
        charSequence.append("load found ");
        charSequence.append(object.size());
        charSequence.append(" secondary dex files");
        Log.i((String)"MultiDex", (String)charSequence.toString());
        return object;
    }

    @Override
    public void close() {
        this.f.release();
        this.e.close();
        this.d.close();
    }

    private static class a
    extends File {
        public long a = -1L;

        public a(File file, String string2) {
            super(file, string2);
        }
    }

}

