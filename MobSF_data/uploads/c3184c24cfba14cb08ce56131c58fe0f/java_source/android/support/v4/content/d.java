/*
 * Decompiled with CFR 0_132.
 * 
 * Could not load the following classes:
 *  android.os.Binder
 *  android.os.Handler
 *  android.os.Looper
 *  android.os.Message
 *  android.os.Process
 *  android.util.Log
 */
package android.support.v4.content;

import android.os.Binder;
import android.os.Handler;
import android.os.Looper;
import android.os.Message;
import android.os.Process;
import android.util.Log;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.Callable;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

abstract class d<Params, Progress, Result> {
    private static final ThreadFactory a = new ThreadFactory(){
        private final AtomicInteger a = new AtomicInteger(1);

        @Override
        public Thread newThread(Runnable runnable) {
            StringBuilder stringBuilder = new StringBuilder();
            stringBuilder.append("ModernAsyncTask #");
            stringBuilder.append(this.a.getAndIncrement());
            return new Thread(runnable, stringBuilder.toString());
        }
    };
    private static final BlockingQueue<Runnable> b = new LinkedBlockingQueue<Runnable>(10);
    public static final Executor c;
    private static b d;
    private static volatile Executor e;
    private final d<Params, Result> f = new d<Params, Result>(){

        /*
         * WARNING - Removed back jump from a try to a catch block - possible behaviour change.
         * Loose catch block
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         * Lifted jumps to return sites
         */
        @Override
        public Result call() {
            Throwable throwable2;
            Throwable throwable;
            block7 : {
                Throwable throwable3;
                block8 : {
                    d.this.j.set(true);
                    throwable3 = null;
                    throwable2 = throwable = null;
                    Process.setThreadPriority((int)10);
                    throwable2 = throwable;
                    throwable = d.this.a((Params[])this.b);
                    try {
                        Binder.flushPendingCommands();
                        d.this.d(throwable);
                    }
                    catch (Throwable throwable4) {
                        throwable2 = throwable;
                        throwable = throwable4;
                        break block7;
                    }
                    catch (Throwable throwable5) {
                        break block8;
                    }
                    return (Result)throwable;
                    catch (Throwable throwable6) {
                        break block7;
                    }
                    catch (Throwable throwable7) {
                        throwable = throwable3;
                        throwable3 = throwable7;
                    }
                }
                throwable2 = throwable;
                {
                    d.this.i.set(true);
                    throwable2 = throwable;
                    throw throwable3;
                }
            }
            d.this.d(throwable2);
            throw throwable;
        }
    };
    private final FutureTask<Result> g = new FutureTask<Result>(this.f){

        /*
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         */
        @Override
        protected void done() {
            try {
                Object v2 = this.get();
                d.this.c(v2);
                return;
            }
            catch (Throwable throwable) {
                throw new RuntimeException("An error occurred while executing doInBackground()", throwable);
            }
            catch (ExecutionException executionException) {
                throw new RuntimeException("An error occurred while executing doInBackground()", executionException.getCause());
            }
            catch (InterruptedException interruptedException) {
                Log.w((String)"AsyncTask", (Throwable)interruptedException);
                return;
            }
            catch (CancellationException cancellationException) {}
            d.this.c(null);
        }
    };
    private volatile c h = c.a;
    private final AtomicBoolean i = new AtomicBoolean();
    private final AtomicBoolean j = new AtomicBoolean();

    static {
        e = c = new ThreadPoolExecutor(5, 128, 1L, TimeUnit.SECONDS, b, a);
    }

    d() {
    }

    /*
     * Enabled aggressive block sorting
     * Enabled unnecessary exception pruning
     * Enabled aggressive exception aggregation
     */
    private static Handler d() {
        synchronized (d.class) {
            if (d != null) return d;
            d = new b();
            return d;
        }
    }

    public final /* varargs */ d<Params, Progress, Result> a(Executor executor, Params ... arrParams) {
        if (this.h != c.a) {
            switch (.a[this.h.ordinal()]) {
                default: {
                    throw new IllegalStateException("We should never reach this state");
                }
                case 2: {
                    throw new IllegalStateException("Cannot execute task: the task has already been executed (a task can be executed only once)");
                }
                case 1: 
            }
            throw new IllegalStateException("Cannot execute task: the task is already running.");
        }
        this.h = c.b;
        this.a();
        this.f.b = arrParams;
        executor.execute(this.g);
        return this;
    }

    protected /* varargs */ abstract Result a(Params ... var1);

    protected void a() {
    }

    protected void a(Result Result) {
    }

    public final boolean a(boolean bl2) {
        this.i.set(true);
        return this.g.cancel(bl2);
    }

    protected void b() {
    }

    protected void b(Result Result) {
        this.b();
    }

    protected /* varargs */ void b(Progress ... arrProgress) {
    }

    void c(Result Result) {
        if (!this.j.get()) {
            this.d(Result);
        }
    }

    public final boolean c() {
        return this.i.get();
    }

    Result d(Result Result) {
        d.d().obtainMessage(1, new a<Object>(this, Result)).sendToTarget();
        return Result;
    }

    void e(Result Result) {
        if (this.c()) {
            this.b(Result);
        } else {
            this.a(Result);
        }
        this.h = c.c;
    }

    private static class a<Data> {
        final d a;
        final Data[] b;

        /* varargs */ a(d d2, Data ... arrData) {
            this.a = d2;
            this.b = arrData;
        }
    }

    private static class b
    extends Handler {
        b() {
            super(Looper.getMainLooper());
        }

        public void handleMessage(Message message) {
            a a2 = (a)message.obj;
            switch (message.what) {
                default: {
                    return;
                }
                case 2: {
                    a2.a.b((Progress[])a2.b);
                    return;
                }
                case 1: 
            }
            a2.a.e(a2.b[0]);
        }
    }

    public static enum c {
        a,
        b,
        c;
        

        private c() {
        }
    }

    private static abstract class d<Params, Result>
    implements Callable<Result> {
        Params[] b;

        d() {
        }
    }

}

