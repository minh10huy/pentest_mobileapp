/*
 * Decompiled with CFR 0_132.
 */
package android.arch.lifecycle;

import android.arch.lifecycle.c;
import android.arch.lifecycle.e;
import android.arch.lifecycle.l;
import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

class a {
    static a a = new a();
    private final Map<Class, a> b = new HashMap<Class, a>();
    private final Map<Class, Boolean> c = new HashMap<Class, Boolean>();

    a() {
    }

    /*
     * Enabled force condition propagation
     * Lifted jumps to return sites
     */
    private a a(Class class_, Method[] object) {
        int n2;
        void var2_4;
        Object object2 = class_.getSuperclass();
        HashMap<b, c.a> hashMap = new HashMap<b, c.a>();
        if (object2 != null && (object2 = this.b((Class)object2)) != null) {
            hashMap.putAll(object2.b);
        }
        object2 = class_.getInterfaces();
        int n3 = ((Class<?>[])object2).length;
        for (n2 = 0; n2 < n3; ++n2) {
            for (Map.Entry<b, c.a> entry : this.b(object2[n2]).b.entrySet()) {
                this.a(hashMap, entry.getKey(), entry.getValue(), class_);
            }
        }
        if (object == null) {
            Method[] arrmethod = this.c(class_);
        }
        int n4 = ((void)var2_4).length;
        boolean bl2 = false;
        for (n3 = 0; n3 < n4; ++n3) {
            object2 = var2_4[n3];
            l l2 = object2.getAnnotation(l.class);
            if (l2 == null) continue;
            Class<?>[] arrclass = object2.getParameterTypes();
            if (arrclass.length > 0) {
                if (!arrclass[0].isAssignableFrom(e.class)) throw new IllegalArgumentException("invalid parameter type. Must be one and instanceof LifecycleOwner");
                n2 = 1;
            } else {
                n2 = 0;
            }
            c.a a2 = l2.a();
            if (arrclass.length > 1) {
                if (!arrclass[1].isAssignableFrom(c.a.class)) throw new IllegalArgumentException("invalid parameter type. second arg must be an event");
                if (a2 != c.a.ON_ANY) throw new IllegalArgumentException("Second arg is supported only for ON_ANY value");
                n2 = 2;
            }
            if (arrclass.length > 2) throw new IllegalArgumentException("cannot have more than 2 params");
            this.a(hashMap, new b(n2, (Method)object2), a2, class_);
            bl2 = true;
        }
        a a3 = new a(hashMap);
        this.b.put(class_, a3);
        this.c.put(class_, bl2);
        return a3;
    }

    private void a(Map<b, c.a> object, b object2, c.a a2, Class class_) {
        c.a a3 = object.get(object2);
        if (a3 != null && a2 != a3) {
            object = object2.b;
            object2 = new StringBuilder();
            object2.append("Method ");
            object2.append(object.getName());
            object2.append(" in ");
            object2.append(class_.getName());
            object2.append(" already declared with different @OnLifecycleEvent value: previous");
            object2.append(" value ");
            object2.append((Object)a3);
            object2.append(", new value ");
            object2.append((Object)a2);
            throw new IllegalArgumentException(object2.toString());
        }
        if (a3 == null) {
            object.put((b)object2, (c.a)a2);
        }
    }

    private Method[] c(Class arrmethod) {
        try {
            arrmethod = arrmethod.getDeclaredMethods();
            return arrmethod;
        }
        catch (NoClassDefFoundError noClassDefFoundError) {
            throw new IllegalArgumentException("The observer class has some methods that use newer APIs which are not available in the current OS version. Lifecycles cannot access even other methods so you should make sure that your observer classes only access framework classes that are available in your min API level OR use lifecycle:compiler annotation processor.", noClassDefFoundError);
        }
    }

    boolean a(Class class_) {
        if (this.c.containsKey(class_)) {
            return this.c.get(class_);
        }
        Method[] arrmethod = this.c(class_);
        int n2 = arrmethod.length;
        for (int i2 = 0; i2 < n2; ++i2) {
            if (arrmethod[i2].getAnnotation(l.class) == null) continue;
            this.a(class_, arrmethod);
            return true;
        }
        this.c.put(class_, false);
        return false;
    }

    a b(Class class_) {
        a a2 = this.b.get(class_);
        if (a2 != null) {
            return a2;
        }
        return this.a(class_, null);
    }

    static class a {
        final Map<c.a, List<b>> a;
        final Map<b, c.a> b;

        a(Map<b, c.a> arrayList) {
            this.b = arrayList;
            this.a = new HashMap<c.a, List<b>>();
            for (Map.Entry<b, c.a> entry : arrayList.entrySet()) {
                c.a a2 = entry.getValue();
                List<b> list = this.a.get((Object)a2);
                arrayList = list;
                if (list == null) {
                    arrayList = new ArrayList<b>();
                    this.a.put(a2, arrayList);
                }
                arrayList.add(entry.getKey());
            }
        }

        private static void a(List<b> list, e e2, c.a a2, Object object) {
            if (list != null) {
                for (int i2 = list.size() - 1; i2 >= 0; --i2) {
                    list.get(i2).a(e2, a2, object);
                }
            }
        }

        void a(e e2, c.a a2, Object object) {
            a.a(this.a.get((Object)a2), e2, a2, object);
            a.a(this.a.get((Object)c.a.ON_ANY), e2, a2, object);
        }
    }

    static class b {
        final int a;
        final Method b;

        b(int n2, Method method) {
            this.a = n2;
            this.b = method;
            this.b.setAccessible(true);
        }

        /*
         * Exception decompiling
         */
        void a(e var1_1, c.a var2_4, Object var3_5) {
            // This method has failed to decompile.  When submitting a bug report, please provide this stack trace, and (if you hold appropriate legal rights) the relevant class file.
            // org.benf.cfr.reader.util.ConfusedCFRException: Extractable last case doesn't follow previous
            // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.examineSwitchContiguity(SwitchReplacer.java:486)
            // org.benf.cfr.reader.bytecode.analysis.opgraph.op3rewriters.SwitchReplacer.replaceRawSwitches(SwitchReplacer.java:65)
            // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisInner(CodeAnalyser.java:416)
            // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysisOrWrapFail(CodeAnalyser.java:196)
            // org.benf.cfr.reader.bytecode.CodeAnalyser.getAnalysis(CodeAnalyser.java:141)
            // org.benf.cfr.reader.entities.attributes.AttributeCode.analyse(AttributeCode.java:95)
            // org.benf.cfr.reader.entities.Method.analyse(Method.java:372)
            // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:867)
            // org.benf.cfr.reader.entities.ClassFile.analyseInnerClassesPass1(ClassFile.java:749)
            // org.benf.cfr.reader.entities.ClassFile.analyseMid(ClassFile.java:847)
            // org.benf.cfr.reader.entities.ClassFile.analyseTop(ClassFile.java:768)
            // org.benf.cfr.reader.Main.doJar(Main.java:141)
            // org.benf.cfr.reader.Main.main(Main.java:242)
            throw new IllegalStateException("Decompilation failed");
        }

        public boolean equals(Object object) {
            if (this == object) {
                return true;
            }
            if (object != null) {
                if (this.getClass() != object.getClass()) {
                    return false;
                }
                object = (b)object;
                if (this.a == object.a && this.b.getName().equals(object.b.getName())) {
                    return true;
                }
                return false;
            }
            return false;
        }

        public int hashCode() {
            return this.a * 31 + this.b.getName().hashCode();
        }
    }

}

