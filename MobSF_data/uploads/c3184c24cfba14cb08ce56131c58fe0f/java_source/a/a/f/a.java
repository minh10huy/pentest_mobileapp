/*
 * Decompiled with CFR 0_132.
 */
package a.a.f;

import a.a.b;
import a.a.c;
import a.a.c.f;
import a.a.d;
import a.a.e;
import a.a.g;
import a.a.h;
import a.a.i;
import java.util.concurrent.Callable;

public final class a {
    static volatile a.a.d.d<? super Throwable> a;
    static volatile a.a.d.e<? super Runnable, ? extends Runnable> b;
    static volatile a.a.d.e<? super Callable<h>, ? extends h> c;
    static volatile a.a.d.e<? super Callable<h>, ? extends h> d;
    static volatile a.a.d.e<? super Callable<h>, ? extends h> e;
    static volatile a.a.d.e<? super Callable<h>, ? extends h> f;
    static volatile a.a.d.e<? super h, ? extends h> g;
    static volatile a.a.d.e<? super h, ? extends h> h;
    static volatile a.a.d.e<? super c, ? extends c> i;
    static volatile a.a.d.e<? super e, ? extends e> j;
    static volatile a.a.d.e<? super d, ? extends d> k;
    static volatile a.a.d.e<? super i, ? extends i> l;
    static volatile a.a.d.e<? super b, ? extends b> m;
    static volatile a.a.d.b<? super e, ? super g, ? extends g> n;

    public static b a(b b2) {
        a.a.d.e<? super b, ? extends b> e2 = m;
        b b3 = b2;
        if (e2 != null) {
            b3 = a.a(e2, b2);
        }
        return b3;
    }

    public static <T> c<T> a(c<T> c2) {
        a.a.d.e<? super c, ? extends c> e2 = i;
        c c3 = c2;
        if (e2 != null) {
            c3 = a.a(e2, c2);
        }
        return c3;
    }

    public static <T> d<T> a(d<T> d2) {
        a.a.d.e<? super d, ? extends d> e2 = k;
        d d3 = d2;
        if (e2 != null) {
            d3 = a.a(e2, d2);
        }
        return d3;
    }

    public static <T> e<T> a(e<T> e2) {
        a.a.d.e<? super e, ? extends e> e3 = j;
        e e4 = e2;
        if (e3 != null) {
            e4 = a.a(e3, e2);
        }
        return e4;
    }

    public static <T> g<? super T> a(e<T> e2, g<? super T> g2) {
        a.a.d.b<? super e, ? super g, ? extends g> b2 = n;
        if (b2 != null) {
            return a.a(b2, e2, g2);
        }
        return g2;
    }

    static h a(a.a.d.e<? super Callable<h>, ? extends h> e2, Callable<h> callable) {
        return a.a.e.b.b.a(a.a(e2, callable), "Scheduler Callable result can't be null");
    }

    public static h a(h h2) {
        a.a.d.e<? super h, ? extends h> e2 = g;
        if (e2 == null) {
            return h2;
        }
        return a.a(e2, h2);
    }

    public static h a(Callable<h> callable) {
        a.a.e.b.b.a(callable, "Scheduler Callable can't be null");
        a.a.d.e<? super Callable<h>, ? extends h> e2 = c;
        if (e2 == null) {
            return a.e(callable);
        }
        return a.a(e2, callable);
    }

    public static <T> i<T> a(i<T> i2) {
        a.a.d.e<? super i, ? extends i> e2 = l;
        i i3 = i2;
        if (e2 != null) {
            i3 = a.a(e2, i2);
        }
        return i3;
    }

    static <T, U, R> R a(a.a.d.b<T, U, R> b2, T t2, U u2) {
        try {
            b2 = b2.a(t2, u2);
        }
        catch (Throwable throwable) {
            throw a.a.e.h.a.a(throwable);
        }
        return (R)b2;
    }

    static <T, R> R a(a.a.d.e<T, R> e2, T t2) {
        try {
            e2 = e2.a(t2);
        }
        catch (Throwable throwable) {
            throw a.a.e.h.a.a(throwable);
        }
        return (R)e2;
    }

    public static Runnable a(Runnable runnable) {
        a.a.e.b.b.a(runnable, "run is null");
        a.a.d.e<? super Runnable, ? extends Runnable> e2 = b;
        if (e2 == null) {
            return runnable;
        }
        return a.a(e2, runnable);
    }

    public static void a(Throwable throwable) {
        Throwable throwable2;
        a.a.d.d<? super Throwable> d2 = a;
        if (throwable == null) {
            throwable2 = new NullPointerException("onError called with null. Null values are generally not allowed in 2.x operators and sources.");
        } else {
            throwable2 = throwable;
            if (!a.b(throwable)) {
                throwable2 = new f(throwable);
            }
        }
        if (d2 != null) {
            try {
                d2.a(throwable2);
                return;
            }
            catch (Throwable throwable3) {
                throwable3.printStackTrace();
                a.c(throwable3);
            }
        }
        throwable2.printStackTrace();
        a.c(throwable2);
    }

    public static h b(h h2) {
        a.a.d.e<? super h, ? extends h> e2 = h;
        if (e2 == null) {
            return h2;
        }
        return a.a(e2, h2);
    }

    public static h b(Callable<h> callable) {
        a.a.e.b.b.a(callable, "Scheduler Callable can't be null");
        a.a.d.e<? super Callable<h>, ? extends h> e2 = e;
        if (e2 == null) {
            return a.e(callable);
        }
        return a.a(e2, callable);
    }

    static boolean b(Throwable throwable) {
        if (throwable instanceof a.a.c.d) {
            return true;
        }
        if (throwable instanceof a.a.c.c) {
            return true;
        }
        if (throwable instanceof IllegalStateException) {
            return true;
        }
        if (throwable instanceof NullPointerException) {
            return true;
        }
        if (throwable instanceof IllegalArgumentException) {
            return true;
        }
        if (throwable instanceof a.a.c.a) {
            return true;
        }
        return false;
    }

    public static h c(Callable<h> callable) {
        a.a.e.b.b.a(callable, "Scheduler Callable can't be null");
        a.a.d.e<? super Callable<h>, ? extends h> e2 = f;
        if (e2 == null) {
            return a.e(callable);
        }
        return a.a(e2, callable);
    }

    static void c(Throwable throwable) {
        Thread thread = Thread.currentThread();
        thread.getUncaughtExceptionHandler().uncaughtException(thread, throwable);
    }

    public static h d(Callable<h> callable) {
        a.a.e.b.b.a(callable, "Scheduler Callable can't be null");
        a.a.d.e<? super Callable<h>, ? extends h> e2 = d;
        if (e2 == null) {
            return a.e(callable);
        }
        return a.a(e2, callable);
    }

    static h e(Callable<h> object) {
        try {
            object = a.a.e.b.b.a(object.call(), "Scheduler Callable result can't be null");
            return object;
        }
        catch (Throwable throwable) {
            throw a.a.e.h.a.a(throwable);
        }
    }
}

