/*
 * Decompiled with CFR 0_132.
 */
package a.a.e.g;

import a.a.e.g.f;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

public final class i {
    public static final boolean a;
    public static final int b;
    static final AtomicReference<ScheduledExecutorService> c;
    static final Map<ScheduledThreadPoolExecutor, Object> d;

    static {
        c = new AtomicReference();
        d = new ConcurrentHashMap<ScheduledThreadPoolExecutor, Object>();
        Properties properties = System.getProperties();
        a a2 = new a();
        a2.a(properties);
        a = a2.a;
        b = a2.b;
        i.a();
    }

    public static ScheduledExecutorService a(ThreadFactory object) {
        object = Executors.newScheduledThreadPool(1, (ThreadFactory)object);
        i.a(a, (ScheduledExecutorService)object);
        return object;
    }

    public static void a() {
        i.a(a);
    }

    static void a(boolean bl2) {
        if (bl2) {
            do {
                ScheduledExecutorService scheduledExecutorService;
                if ((scheduledExecutorService = c.get()) != null) {
                    return;
                }
                ScheduledExecutorService scheduledExecutorService2 = Executors.newScheduledThreadPool(1, new f("RxSchedulerPurge"));
                if (c.compareAndSet(scheduledExecutorService, scheduledExecutorService2)) {
                    scheduledExecutorService2.scheduleAtFixedRate(new b(), b, b, TimeUnit.SECONDS);
                    return;
                }
                scheduledExecutorService2.shutdownNow();
            } while (true);
        }
    }

    static void a(boolean bl2, ScheduledExecutorService scheduledExecutorService) {
        if (bl2 && scheduledExecutorService instanceof ScheduledThreadPoolExecutor) {
            ScheduledThreadPoolExecutor scheduledThreadPoolExecutor = (ScheduledThreadPoolExecutor)scheduledExecutorService;
            d.put(scheduledThreadPoolExecutor, scheduledExecutorService);
        }
    }

    static final class a {
        boolean a;
        int b;

        a() {
        }

        /*
         * Enabled aggressive block sorting
         * Enabled unnecessary exception pruning
         * Enabled aggressive exception aggregation
         */
        void a(Properties properties) {
            this.a = properties.containsKey("rx2.purge-enabled") ? Boolean.parseBoolean(properties.getProperty("rx2.purge-enabled")) : true;
            if (this.a && properties.containsKey("rx2.purge-period-seconds")) {
                try {
                    this.b = Integer.parseInt(properties.getProperty("rx2.purge-period-seconds"));
                    return;
                }
                catch (NumberFormatException numberFormatException) {}
            }
            this.b = 1;
        }
    }

    static final class b
    implements Runnable {
        b() {
        }

        @Override
        public void run() {
            for (ScheduledThreadPoolExecutor scheduledThreadPoolExecutor : new ArrayList<ScheduledThreadPoolExecutor>(i.d.keySet())) {
                if (scheduledThreadPoolExecutor.isShutdown()) {
                    i.d.remove(scheduledThreadPoolExecutor);
                    continue;
                }
                scheduledThreadPoolExecutor.purge();
            }
        }
    }

}

